class <Module>
{
}

namespace Microsoft
{
    namespace CodeAnalysis
    {
        class EmbeddedAttribute : System.Attribute
        {
            /*0x1ec2fa4*/ EmbeddedAttribute();
        }
    }
}

namespace System
{
    namespace Runtime
    {
        namespace CompilerServices
        {
            class IsUnmanagedAttribute : System.Attribute
            {
                /*0x1ec2fac*/ IsUnmanagedAttribute();
            }
        }
    }
}

class Interop
{
    static /*0x1ec2fb4*/ void ThrowExceptionForIoErrno(Interop.ErrorInfo errorInfo, string path, bool isDirectory, System.Func<Interop.ErrorInfo, Interop.ErrorInfo> errorRewriter);
    static /*0x1ec3504*/ void CheckIo(Interop.Error error, string path, bool isDirectory, System.Func<Interop.ErrorInfo, Interop.ErrorInfo> errorRewriter);
    static /*0x1ec3524*/ long CheckIo(long result, string path, bool isDirectory, System.Func<Interop.ErrorInfo, Interop.ErrorInfo> errorRewriter);
    static /*0x1ec3604*/ int CheckIo(int result, string path, bool isDirectory, System.Func<Interop.ErrorInfo, Interop.ErrorInfo> errorRewriter);
    static /*0x1ec3624*/ nint CheckIo(nint result, string path, bool isDirectory, System.Func<Interop.ErrorInfo, Interop.ErrorInfo> errorRewriter);
    static TSafeHandle CheckIo<TSafeHandle>(TSafeHandle handle, string path, bool isDirectory, System.Func<Interop.ErrorInfo, Interop.ErrorInfo> errorRewriter);
    static /*0x1ec300c*/ System.Exception GetExceptionForIoErrno(Interop.ErrorInfo errorInfo, string path, bool isDirectory);
    static /*0x1ec36dc*/ System.Exception GetIOException(Interop.ErrorInfo errorInfo);
    static bool CallStringMethod<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.Text.StringBuilder, Interop.Globalization.ResultCode> interopCall, TArg1 arg1, TArg2 arg2, TArg3 arg3, ref string result);
    static /*0x1ec3838*/ void GetRandomBytes(byte* buffer, int length);

    enum Error
    {
        SUCCESS = 0,
        E2BIG = 65537,
        EACCES = 65538,
        EADDRINUSE = 65539,
        EADDRNOTAVAIL = 65540,
        EAFNOSUPPORT = 65541,
        EAGAIN = 65542,
        EALREADY = 65543,
        EBADF = 65544,
        EBADMSG = 65545,
        EBUSY = 65546,
        ECANCELED = 65547,
        ECHILD = 65548,
        ECONNABORTED = 65549,
        ECONNREFUSED = 65550,
        ECONNRESET = 65551,
        EDEADLK = 65552,
        EDESTADDRREQ = 65553,
        EDOM = 65554,
        EDQUOT = 65555,
        EEXIST = 65556,
        EFAULT = 65557,
        EFBIG = 65558,
        EHOSTUNREACH = 65559,
        EIDRM = 65560,
        EILSEQ = 65561,
        EINPROGRESS = 65562,
        EINTR = 65563,
        EINVAL = 65564,
        EIO = 65565,
        EISCONN = 65566,
        EISDIR = 65567,
        ELOOP = 65568,
        EMFILE = 65569,
        EMLINK = 65570,
        EMSGSIZE = 65571,
        EMULTIHOP = 65572,
        ENAMETOOLONG = 65573,
        ENETDOWN = 65574,
        ENETRESET = 65575,
        ENETUNREACH = 65576,
        ENFILE = 65577,
        ENOBUFS = 65578,
        ENODEV = 65580,
        ENOENT = 65581,
        ENOEXEC = 65582,
        ENOLCK = 65583,
        ENOLINK = 65584,
        ENOMEM = 65585,
        ENOMSG = 65586,
        ENOPROTOOPT = 65587,
        ENOSPC = 65588,
        ENOSYS = 65591,
        ENOTCONN = 65592,
        ENOTDIR = 65593,
        ENOTEMPTY = 65594,
        ENOTSOCK = 65596,
        ENOTSUP = 65597,
        ENOTTY = 65598,
        ENXIO = 65599,
        EOVERFLOW = 65600,
        EPERM = 65602,
        EPIPE = 65603,
        EPROTO = 65604,
        EPROTONOSUPPORT = 65605,
        EPROTOTYPE = 65606,
        ERANGE = 65607,
        EROFS = 65608,
        ESPIPE = 65609,
        ESRCH = 65610,
        ESTALE = 65611,
        ETIMEDOUT = 65613,
        ETXTBSY = 65614,
        EXDEV = 65615,
        ESOCKTNOSUPPORT = 65630,
        EPFNOSUPPORT = 65632,
        ESHUTDOWN = 65644,
        EHOSTDOWN = 65648,
        ENODATA = 65649,
        EOPNOTSUPP = 65597,
        EWOULDBLOCK = 65542,
    }

    struct ErrorInfo
    {
        /*0x10*/ Interop.Error _error;
        /*0x14*/ int _rawErrno;

        /*0x1ec38a0*/ ErrorInfo(int errno);
        /*0x1ec390c*/ ErrorInfo(Interop.Error error);
        /*0x1ec3918*/ Interop.Error get_Error();
        /*0x1ec3768*/ int get_RawErrno();
        /*0x1ec37d4*/ string GetErrorMessage();
        /*0x1ec3a98*/ string ToString();
    }

    class Sys
    {
        static /*0x0*/ bool CanSetHiddenFlag;

        static /*0x1ec456c*/ Sys();
        static /*0x1ec359c*/ Interop.ErrorInfo GetLastErrorInfo();
        static /*0x1ec399c*/ string StrError(int platformErrno);
        static /*0x1ec3908*/ Interop.Error ConvertErrorPlatformToPal(int platformErrno);
        static /*0x1ec3920*/ int ConvertErrorPalToPlatform(Interop.Error error);
        static /*0x1ec3b6c*/ byte* StrErrorR(int platformErrno, byte* buffer, int bufferSize);
        static /*0x1ec389c*/ void GetNonCryptographicallySecureRandomBytes(byte* buffer, int length);
        static /*0x1ec3b70*/ nint OpenDir(string path);
        static /*0x1ec3ba4*/ int GetReadDirRBufferSize();
        static /*0x1ec3ba8*/ int ReadDirR(nint dir, byte* buffer, int bufferSize, ref Interop.Sys.DirectoryEntry outputEntry);
        static /*0x1ec3bac*/ int CloseDir(nint dir);
        static /*0x1ec3bc8*/ int ReadLink(string path, byte[] buffer, int bufferSize);
        static /*0x1ec3c14*/ string ReadLink(string path);
        static /*0x1ec3e2c*/ int Stat(string path, ref Interop.Sys.FileStatus output);
        static /*0x1ec3e68*/ int LStat(string path, ref Interop.Sys.FileStatus output);
        static /*0x1ec3ea4*/ int Symlink(string target, string linkPath);
        static /*0x1ec3f5c*/ int ChMod(string path, int mode);
        static /*0x1ec3f98*/ int CopyFile(Microsoft.Win32.SafeHandles.SafeFileHandle source, Microsoft.Win32.SafeHandles.SafeFileHandle destination);
        static /*0x1ec404c*/ uint GetEGid();
        static /*0x1ec4050*/ uint GetEUid();
        static /*0x1ec4054*/ int LChflags(string path, uint flags);
        static /*0x1ec40f4*/ int LChflagsCanSetHiddenFlag();
        static /*0x1ec40f8*/ int Link(string source, string link);
        static /*0x1ec414c*/ int MkDir(string path, int mode);
        static /*0x1ec4188*/ int Rename(string oldPath, string newPath);
        static /*0x1ec41dc*/ int RmDir(string path);
        static /*0x1ec4210*/ int Stat(ref byte path, ref Interop.Sys.FileStatus output);
        static /*0x1ec422c*/ int Stat(System.ReadOnlySpan<char> path, ref Interop.Sys.FileStatus output);
        static /*0x1ec4384*/ int LStat(ref byte path, ref Interop.Sys.FileStatus output);
        static /*0x1ec43a0*/ int LStat(System.ReadOnlySpan<char> path, ref Interop.Sys.FileStatus output);
        static /*0x1ec44f8*/ int UTimes(string path, ref Interop.Sys.TimeValPair times);
        static /*0x1ec4534*/ int Unlink(string pathname);
        static /*0x1ec4568*/ int DoubleToString(double value, byte* format, byte* buffer, int bufferLength);

        enum NodeType
        {
            DT_UNKNOWN = 0,
            DT_FIFO = 1,
            DT_CHR = 2,
            DT_DIR = 4,
            DT_BLK = 6,
            DT_REG = 8,
            DT_LNK = 10,
            DT_SOCK = 12,
            DT_WHT = 14,
        }

        struct DirectoryEntry
        {
            /*0x10*/ byte* Name;
            /*0x18*/ int NameLength;
            /*0x1c*/ Interop.Sys.NodeType InodeType;

            /*0x1ec45c0*/ System.ReadOnlySpan<char> GetName(System.Span<char> buffer);
        }

        struct FileStatus
        {
            /*0x10*/ Interop.Sys.FileStatusFlags Flags;
            /*0x14*/ int Mode;
            /*0x18*/ uint Uid;
            /*0x1c*/ uint Gid;
            /*0x20*/ long Size;
            /*0x28*/ long ATime;
            /*0x30*/ long ATimeNsec;
            /*0x38*/ long MTime;
            /*0x40*/ long MTimeNsec;
            /*0x48*/ long CTime;
            /*0x50*/ long CTimeNsec;
            /*0x58*/ long BirthTime;
            /*0x60*/ long BirthTimeNsec;
            /*0x68*/ long Dev;
            /*0x70*/ long Ino;
            /*0x78*/ uint UserFlags;
        }

        enum FileStatusFlags
        {
            None = 0,
            HasBirthTime = 1,
        }

        enum Permissions
        {
            Mask = 511,
            S_IRWXU = 448,
            S_IRUSR = 256,
            S_IWUSR = 128,
            S_IXUSR = 64,
            S_IRWXG = 56,
            S_IRGRP = 32,
            S_IWGRP = 16,
            S_IXGRP = 8,
            S_IRWXO = 7,
            S_IROTH = 4,
            S_IWOTH = 2,
            S_IXOTH = 1,
        }

        struct TimeValPair
        {
            /*0x10*/ long ASec;
            /*0x18*/ long AUSec;
            /*0x20*/ long MSec;
            /*0x28*/ long MUSec;
        }
    }

    class Globalization
    {
        enum ResultCode
        {
            Success = 0,
            UnknownError = 1,
            InsufficentBuffer = 2,
            OutOfMemory = 3,
        }
    }
}

class InteropErrorExtensions
{
    static /*0x1ec351c*/ Interop.ErrorInfo Info(Interop.Error error);
}

class AssemblyRef
{
    static string SystemConfiguration = "System.Configuration, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string System = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
    static string EcmaPublicKey = "b77a5c561934e089";
    static string FrameworkPublicKeyFull = "0024000004800000940000000602000000240000525341310004000001000100B5FC90E7027F67871E773A8FDE8938C81DD402BA65B9201D60593E96C492651E889CC13F1415EBB53FAC1131AE0BD333C5EE6021672D9718EA31A8AEBD0DA0072F25D87DBA6FC90FFD598ED4DA35E44C398C454307E8E33B8426143DAEC9F596836F97C8F74750E5975C64E2189F45DEF46B2A2B1247ADC3652BF5C308055DA9";
    static string FrameworkPublicKeyFull2 = "00240000048000009400000006020000002400005253413100040000010001008D56C76F9E8649383049F383C44BE0EC204181822A6C31CF5EB7EF486944D032188EA1D3920763712CCB12D75FB77E9811149E6148E5D32FBAAB37611C1878DDC19E20EF135D0CB2CFF2BFEC3D115810C3D9069638FE4BE215DBF795861920E5AB6F7DB2E2CEEF136AC23D5DD2BF031700AEC232F6C6B1C785B4305C123B37AB";
    static string MicrosoftPublicKey = "b03f5f7f11d50a3a";
    static string MicrosoftJScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string MicrosoftVSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string SystemData = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
    static string SystemDesign = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string SystemDrawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string SystemWeb = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string SystemWebExtensions = "System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
    static string SystemWindowsForms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
}

class Consts
{
    static string MonoCorlibVersion = "1A5E0066-58DC-428A-B21C-0AD6CDAE2789";
    static string MonoVersion = "6.13.0.0";
    static string MonoCompany = "Mono development team";
    static string MonoProduct = "Mono Common Language Infrastructure";
    static string MonoCopyright = "(c) Various Mono authors";
    static string FxVersion = "4.0.0.0";
    static string FxFileVersion = "4.0.30319.17020";
    static string EnvironmentVersion = "4.0.30319.17020";
    static string VsVersion = "0.0.0.0";
    static string VsFileVersion = "11.0.0.0";
    static string PublicKeyToken = "b77a5c561934e089";
    static string AssemblyI18N = "I18N, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";
    static string AssemblyMicrosoft_JScript = "Microsoft.JScript, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblyMicrosoft_VisualStudio = "Microsoft.VisualStudio, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblyMicrosoft_VisualStudio_Web = "Microsoft.VisualStudio.Web, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblyMicrosoft_VSDesigner = "Microsoft.VSDesigner, Version=0.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblyMono_Http = "Mono.Http, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";
    static string AssemblyMono_Posix = "Mono.Posix, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";
    static string AssemblyMono_Security = "Mono.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";
    static string AssemblyMono_Messaging_RabbitMQ = "Mono.Messaging.RabbitMQ, Version=4.0.0.0, Culture=neutral, PublicKeyToken=0738eb9f132ed756";
    static string AssemblyCorlib = "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
    static string AssemblySystem = "System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
    static string AssemblySystem_Data = "System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
    static string AssemblySystem_Design = "System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblySystem_DirectoryServices = "System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblySystem_Drawing = "System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblySystem_Drawing_Design = "System.Drawing.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblySystem_Messaging = "System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblySystem_Security = "System.Security, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblySystem_ServiceProcess = "System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblySystem_Web = "System.Web, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
    static string AssemblySystem_Windows_Forms = "System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
    static string AssemblySystem_2_0 = "System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
    static string AssemblySystemCore_3_5 = "System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
    static string AssemblySystem_Core = "System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
    static string WindowsBase_3_0 = "WindowsBase, Version=3.0.0.0, PublicKeyToken=31bf3856ad364e35";
    static string AssemblyWindowsBase = "WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
    static string AssemblyPresentationCore_3_5 = "PresentationCore, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
    static string AssemblyPresentationCore_4_0 = "PresentationCore, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
    static string AssemblyPresentationFramework_3_5 = "PresentationFramework, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35";
    static string AssemblySystemServiceModel_3_0 = "System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
}

class Locale
{
    static /*0x1ec472c*/ string GetText(string msg);
    static /*0x1ec4730*/ string GetText(string fmt, object[] args);
    /*0x1ec4724*/ Locale();
}

class SR
{
    static string RTL = "RTL_False";
    static string ContinueButtonText = "Continue";
    static string DebugMessageTruncated = "{0}...
<truncated>";
    static string DebugAssertTitleShort = "Assertion Failed";
    static string DebugAssertTitle = "Assertion Failed: Cancel=Debug, OK=Continue";
    static string NotSupported = "This operation is not supported.";
    static string DebugLaunchFailed = "Cannot launch the debugger.  Make sure that a Microsoft (R) .NET Framework debugger is properly installed.";
    static string DebugLaunchFailedTitle = "Microsoft .NET Framework Debug Launch Failure";
    static string ObjectDisposed = "Object {0} has been disposed and can no longer be used.";
    static string ExceptionOccurred = "An exception occurred writing trace output to log file '{0}'. {1}";
    static string MustAddListener = "Only TraceListeners can be added to a TraceListenerCollection.";
    static string ToStringNull = "(null)";
    static string EnumConverterInvalidValue = "The value '{0}' is not a valid value for the enum '{1}'.";
    static string ConvertFromException = "{0} cannot convert from {1}.";
    static string ConvertToException = "'{0}' is unable to convert '{1}' to '{2}'.";
    static string ConvertInvalidPrimitive = "{0} is not a valid value for {1}.";
    static string ErrorMissingPropertyAccessors = "Accessor methods for the {0} property are missing.";
    static string ErrorInvalidPropertyType = "Invalid type for the {0} property.";
    static string ErrorMissingEventAccessors = "Accessor methods for the {0} event are missing.";
    static string ErrorInvalidEventHandler = "Invalid event handler for the {0} event.";
    static string ErrorInvalidEventType = "Invalid type for the {0} event.";
    static string InvalidMemberName = "Invalid member name.";
    static string ErrorBadExtenderType = "The {0} extender provider is not compatible with the {1} type.";
    static string NullableConverterBadCtorArg = "The specified type is not a nullable type.";
    static string TypeDescriptorExpectedElementType = "Expected types in the collection to be of type {0}.";
    static string TypeDescriptorSameAssociation = "Cannot create an association when the primary and secondary objects are the same.";
    static string TypeDescriptorAlreadyAssociated = "The primary and secondary objects are already associated with each other.";
    static string TypeDescriptorProviderError = "The type description provider {0} has returned null from {1} which is illegal.";
    static string TypeDescriptorUnsupportedRemoteObject = "The object {0} is being remoted by a proxy that does not support interface discovery.  This type of remoted object is not supported.";
    static string TypeDescriptorArgsCountMismatch = "The number of elements in the Type and Object arrays must match.";
    static string ErrorCreateSystemEvents = "Failed to create system events window thread.";
    static string ErrorCreateTimer = "Cannot create timer.";
    static string ErrorKillTimer = "Cannot end timer.";
    static string ErrorSystemEventsNotSupported = "System event notifications are not supported under the current context. Server processes, for example, may not support global system event notifications.";
    static string ErrorGetTempPath = "Cannot get temporary file name";
    static string CHECKOUTCanceled = "The checkout was canceled by the user.";
    static string ErrorInvalidServiceInstance = "The service instance must derive from or implement {0}.";
    static string ErrorServiceExists = "The service {0} already exists in the service container.";
    static string Argument_InvalidNumberStyles = "An undefined NumberStyles value is being used.";
    static string Argument_InvalidHexStyle = "With the AllowHexSpecifier bit set in the enum bit field, the only other valid bits that can be combined into the enum value must be a subset of those in HexNumber.";
    static string Argument_ByteArrayLengthMustBeAMultipleOf4 = "The Byte[] length must be a multiple of 4.";
    static string Argument_InvalidCharactersInString = "The string contained an invalid character.";
    static string Argument_ParsedStringWasInvalid = "The parsed string was invalid.";
    static string Argument_MustBeBigInt = "The parameter must be a BigInteger.";
    static string Format_InvalidFormatSpecifier = "Format specifier was invalid.";
    static string Format_TooLarge = "The value is too large to be represented by this format specifier.";
    static string ArgumentOutOfRange_MustBeLessThanUInt32MaxValue = "The value must be less than UInt32.MaxValue (2^32).";
    static string ArgumentOutOfRange_MustBeNonNeg = "The number must be greater than or equal to zero.";
    static string NotSupported_NumberStyle = "The NumberStyle option is not supported.";
    static string Overflow_BigIntInfinity = "BigInteger cannot represent infinity.";
    static string Overflow_NotANumber = "The value is not a number.";
    static string Overflow_ParseBigInteger = "The value could not be parsed.";
    static string Overflow_Int32 = "Value was either too large or too small for an Int32.";
    static string Overflow_Int64 = "Value was either too large or too small for an Int64.";
    static string Overflow_UInt32 = "Value was either too large or too small for a UInt32.";
    static string Overflow_UInt64 = "Value was either too large or too small for a UInt64.";
    static string Overflow_Decimal = "Value was either too large or too small for a Decimal.";
    static string Argument_FrameworkNameTooShort = "FrameworkName cannot have less than two components or more than three components.";
    static string Argument_FrameworkNameInvalid = "FrameworkName is invalid.";
    static string Argument_FrameworkNameInvalidVersion = "FrameworkName version component is invalid.";
    static string Argument_FrameworkNameMissingVersion = "FrameworkName version component is missing.";
    static string ArgumentNull_Key = "Key cannot be null.";
    static string Argument_InvalidValue = "Argument {0} should be larger than {1}.";
    static string Arg_MultiRank = "Multi dimension array is not supported on this operation.";
    static string Barrier_ctor_ArgumentOutOfRange = "The participantCount argument must be non-negative and less than or equal to 32767.";
    static string Barrier_AddParticipants_NonPositive_ArgumentOutOfRange = "The participantCount argument must be a positive value.";
    static string Barrier_AddParticipants_Overflow_ArgumentOutOfRange = "Adding participantCount participants would result in the number of participants exceeding the maximum number allowed.";
    static string Barrier_InvalidOperation_CalledFromPHA = "This method may not be called from within the postPhaseAction.";
    static string Barrier_RemoveParticipants_NonPositive_ArgumentOutOfRange = "The participantCount argument must be a positive value.";
    static string Barrier_RemoveParticipants_ArgumentOutOfRange = "The participantCount argument must be less than or equal the number of participants.";
    static string Barrier_RemoveParticipants_InvalidOperation = "The participantCount argument is greater than the number of participants that haven't yet arrived at the barrier in this phase.";
    static string Barrier_SignalAndWait_ArgumentOutOfRange = "The specified timeout must represent a value between -1 and Int32.MaxValue, inclusive.";
    static string Barrier_SignalAndWait_InvalidOperation_ZeroTotal = "The barrier has no registered participants.";
    static string Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded = "The number of threads using the barrier exceeded the total number of registered participants.";
    static string Barrier_Dispose = "The barrier has been disposed.";
    static string BarrierPostPhaseException = "The postPhaseAction failed with an exception.";
    static string UriTypeConverter_ConvertFrom_CannotConvert = "{0} cannot convert from {1}.";
    static string UriTypeConverter_ConvertTo_CannotConvert = "{0} cannot convert {1} to {2}.";
    static string ISupportInitializeDescr = "Specifies support for transacted initialization.";
    static string CantModifyListSortDescriptionCollection = "Once a ListSortDescriptionCollection has been created it can't be modified.";
    static string Argument_NullComment = "The 'Comment' property of the CodeCommentStatement '{0}' cannot be null.";
    static string InvalidPrimitiveType = "Invalid Primitive Type: {0}. Consider using CodeObjectCreateExpression.";
    static string Cannot_Specify_Both_Compiler_Path_And_Version = "Cannot specify both the '{0}' and '{1}' CodeDom provider options to choose a compiler. Please remove one of them.";
    static string CodeGenOutputWriter = "The output writer for code generation and the writer supplied don't match and cannot be used. This is generally caused by a bad implementation of a CodeGenerator derived class.";
    static string CodeGenReentrance = "This code generation API cannot be called while the generator is being used to generate something else.";
    static string InvalidLanguageIdentifier = "The identifier:"{0}" on the property:"{1}" of type:"{2}" is not a valid language-independent identifier name. Check to see if CodeGenerator.IsValidLanguageIndependentIdentifier allows the identifier name.";
    static string InvalidTypeName = "The type name:"{0}" on the property:"{1}" of type:"{2}" is not a valid language-independent type name.";
    static string Empty_attribute = "The '{0}' attribute cannot be an empty string.";
    static string Invalid_nonnegative_integer_attribute = "The '{0}' attribute must be a non-negative integer.";
    static string CodeDomProvider_NotDefined = "There is no CodeDom provider defined for the language.";
    static string Language_Names_Cannot_Be_Empty = "You need to specify a non-empty String for a language name in the CodeDom configuration section.";
    static string Extension_Names_Cannot_Be_Empty_Or_Non_Period_Based = "An extension name in the CodeDom configuration section must be a non-empty string which starts with a period.";
    static string Unable_To_Locate_Type = "The CodeDom provider type "{0}" could not be located.";
    static string NotSupported_CodeDomAPI = "This CodeDomProvider does not support this method.";
    static string ArityDoesntMatch = "The total arity specified in '{0}' does not match the number of TypeArguments supplied.  There were '{1}' TypeArguments supplied.";
    static string PartialTrustErrorTextReplacement = "<The original value of this property potentially contains file system information and has been suppressed.>";
    static string PartialTrustIllegalProvider = "When used in partial trust, langID must be C#, VB, J#, or JScript, and the language provider must be in the global assembly cache.";
    static string IllegalAssemblyReference = "Assembly references cannot begin with '-', or contain a '/' or '\'.";
    static string NullOrEmpty_Value_in_Property = "The '{0}' property cannot contain null or empty strings.";
    static string AutoGen_Comment_Line1 = "auto-generated>";
    static string AutoGen_Comment_Line2 = "This code was generated by a tool.";
    static string AutoGen_Comment_Line3 = "Runtime Version:";
    static string AutoGen_Comment_Line4 = "Changes to this file may cause incorrect behavior and will be lost if";
    static string AutoGen_Comment_Line5 = "the code is regenerated.";
    static string CantContainNullEntries = "Array '{0}' cannot contain null entries.";
    static string InvalidPathCharsInChecksum = "The CodeChecksumPragma file name '{0}' contains invalid path characters.";
    static string InvalidRegion = "The region directive '{0}' contains invalid characters.  RegionText cannot contain any new line characters.";
    static string Provider_does_not_support_options = "This CodeDomProvider type does not have a constructor that takes providerOptions - "{0}"";
    static string MetaExtenderName = "{0} on {1}";
    static string InvalidEnumArgument = "The value of argument '{0}' ({1}) is invalid for Enum type '{2}'.";
    static string InvalidArgument = "'{1}' is not a valid value for '{0}'.";
    static string InvalidNullArgument = "Null is not a valid value for {0}.";
    static string LicExceptionTypeOnly = "A valid license cannot be granted for the type {0}. Contact the manufacturer of the component for more information.";
    static string LicExceptionTypeAndInstance = "An instance of type '{1}' was being created, and a valid license could not be granted for the type '{0}'. Please,  contact the manufacturer of the component for more information.";
    static string LicMgrContextCannotBeChanged = "The CurrentContext property of the LicenseManager is currently locked and cannot be changed.";
    static string LicMgrAlreadyLocked = "The CurrentContext property of the LicenseManager is already locked by another user.";
    static string LicMgrDifferentUser = "The CurrentContext property of the LicenseManager can only be unlocked with the same contextUser.";
    static string InvalidElementType = "Element type {0} is not supported.";
    static string InvalidIdentifier = "Identifier '{0}' is not valid.";
    static string ExecFailedToCreate = "Failed to create file {0}.";
    static string ExecTimeout = "Timed out waiting for a program to execute. The command being executed was {0}.";
    static string ExecBadreturn = "An invalid return code was encountered waiting for a program to execute. The command being executed was {0}.";
    static string ExecCantGetRetCode = "Unable to get the return code for a program being executed. The command that was being executed was '{0}'.";
    static string ExecCantExec = "Cannot execute a program. The command being executed was {0}.";
    static string ExecCantRevert = "Cannot execute a program. Impersonation failed.";
    static string CompilerNotFound = "Compiler executable file {0} cannot be found.";
    static string DuplicateFileName = "The file name '{0}' was already in the collection.";
    static string CollectionReadOnly = "Collection is read-only.";
    static string BitVectorFull = "Bit vector is full.";
    static string ArrayConverterText = "{0} Array";
    static string CollectionConverterText = "(Collection)";
    static string MultilineStringConverterText = "(Text)";
    static string CultureInfoConverterDefaultCultureString = "(Default)";
    static string CultureInfoConverterInvalidCulture = "The {0} culture cannot be converted to a CultureInfo object on this computer.";
    static string InvalidPrimitive = "The text {0} is not a valid {1}.";
    static string TimerInvalidInterval = "'{0}' is not a valid value for 'Interval'. 'Interval' must be greater than {1}.";
    static string TraceSwitchLevelTooHigh = "Attempted to set {0} to a value that is too high.  Setting level to TraceLevel.Verbose";
    static string TraceSwitchLevelTooLow = "Attempted to set {0} to a value that is too low.  Setting level to TraceLevel.Off";
    static string TraceSwitchInvalidLevel = "The Level must be set to a value in the enumeration TraceLevel.";
    static string TraceListenerIndentSize = "The IndentSize property must be non-negative.";
    static string TraceListenerFail = "Fail:";
    static string TraceAsTraceSource = "Trace";
    static string InvalidLowBoundArgument = "'{1}' is not a valid value for '{0}'. '{0}' must be greater than {2}.";
    static string DuplicateComponentName = "Duplicate component name '{0}'.  Component names must be unique and case-insensitive.";
    static string NotImplemented = "{0}: Not implemented";
    static string OutOfMemory = "Could not allocate needed memory.";
    static string EOF = "End of data stream encountered.";
    static string IOError = "Unknown input/output failure.";
    static string BadChar = "Unexpected Character: '{0}'.";
    static string toStringNone = "(none)";
    static string toStringUnknown = "(unknown)";
    static string InvalidEnum = "{0} is not a valid {1} value.";
    static string IndexOutOfRange = "Index {0} is out of range.";
    static string ErrorPropertyAccessorException = "Property accessor '{0}' on object '{1}' threw the following exception:'{2}'";
    static string InvalidOperation = "Invalid operation.";
    static string EmptyStack = "Stack has no items in it.";
    static string PerformanceCounterDesc = "Represents a Windows performance counter component.";
    static string PCCategoryName = "Category name of the performance counter object.";
    static string PCCounterName = "Counter name of the performance counter object.";
    static string PCInstanceName = "Instance name of the performance counter object.";
    static string PCMachineName = "Specifies the machine from where to read the performance data.";
    static string PCInstanceLifetime = "Specifies the lifetime of the instance.";
    static string PropertyCategoryAction = "Action";
    static string PropertyCategoryAppearance = "Appearance";
    static string PropertyCategoryAsynchronous = "Asynchronous";
    static string PropertyCategoryBehavior = "Behavior";
    static string PropertyCategoryData = "Data";
    static string PropertyCategoryDDE = "DDE";
    static string PropertyCategoryDesign = "Design";
    static string PropertyCategoryDragDrop = "Drag Drop";
    static string PropertyCategoryFocus = "Focus";
    static string PropertyCategoryFont = "Font";
    static string PropertyCategoryFormat = "Format";
    static string PropertyCategoryKey = "Key";
    static string PropertyCategoryList = "List";
    static string PropertyCategoryLayout = "Layout";
    static string PropertyCategoryDefault = "Misc";
    static string PropertyCategoryMouse = "Mouse";
    static string PropertyCategoryPosition = "Position";
    static string PropertyCategoryText = "Text";
    static string PropertyCategoryScale = "Scale";
    static string PropertyCategoryWindowStyle = "Window Style";
    static string PropertyCategoryConfig = "Configurations";
    static string ArgumentNull_ArrayWithNullElements = "The array cannot contain null elements.";
    static string OnlyAllowedOnce = "This operation is only allowed once per object.";
    static string BeginIndexNotNegative = "Start index cannot be less than 0 or greater than input length.";
    static string LengthNotNegative = "Length cannot be less than 0 or exceed input length.";
    static string UnimplementedState = "Unimplemented state.";
    static string UnexpectedOpcode = "Unexpected opcode in regular expression generation: {0}.";
    static string NoResultOnFailed = "Result cannot be called on a failed Match.";
    static string UnterminatedBracket = "Unterminated [] set.";
    static string TooManyParens = "Too many )'s.";
    static string NestedQuantify = "Nested quantifier {0}.";
    static string QuantifyAfterNothing = "Quantifier {x,y} following nothing.";
    static string InternalError = "Internal error in ScanRegex.";
    static string IllegalRange = "Illegal {x,y} with x > y.";
    static string NotEnoughParens = "Not enough )'s.";
    static string BadClassInCharRange = "Cannot include class \{0} in character range.";
    static string ReversedCharRange = "[x-y] range in reverse order.";
    static string UndefinedReference = "(?({0}) ) reference to undefined group.";
    static string MalformedReference = "(?({0}) ) malformed.";
    static string UnrecognizedGrouping = "Unrecognized grouping construct.";
    static string UnterminatedComment = "Unterminated (?#...) comment.";
    static string IllegalEndEscape = "Illegal \ at end of pattern.";
    static string MalformedNameRef = "Malformed \k<...> named back reference.";
    static string UndefinedBackref = "Reference to undefined group number {0}.";
    static string UndefinedNameRef = "Reference to undefined group name {0}.";
    static string TooFewHex = "Insufficient hexadecimal digits.";
    static string MissingControl = "Missing control character.";
    static string UnrecognizedControl = "Unrecognized control character.";
    static string UnrecognizedEscape = "Unrecognized escape sequence \{0}.";
    static string IllegalCondition = "Illegal conditional (?(...)) expression.";
    static string TooManyAlternates = "Too many | in (?()|).";
    static string MakeException = "parsing "{0}" - {1}";
    static string IncompleteSlashP = "Incomplete \p{X} character escape.";
    static string MalformedSlashP = "Malformed \p{X} character escape.";
    static string InvalidGroupName = "Invalid group name: Group names must begin with a word character.";
    static string CapnumNotZero = "Capture number cannot be zero.";
    static string AlternationCantCapture = "Alternation conditions do not capture and cannot be named.";
    static string AlternationCantHaveComment = "Alternation conditions cannot be comments.";
    static string CaptureGroupOutOfRange = "Capture group numbers must be less than or equal to Int32.MaxValue.";
    static string SubtractionMustBeLast = "A subtraction must be the last element in a character class.";
    static string UnknownProperty = "Unknown property '{0}'.";
    static string ReplacementError = "Replacement pattern error.";
    static string CountTooSmall = "Count cannot be less than -1.";
    static string EnumNotStarted = "Enumeration has either not started or has already finished.";
    static string Arg_InvalidArrayType = "Target array type is not compatible with the type of items in the collection.";
    static string RegexMatchTimeoutException_Occurred = "The RegEx engine has timed out while trying to match a pattern to an input string. This can occur for many reasons, including very large inputs or excessive backtracking caused by nested quantifiers, back-references and other factors.";
    static string IllegalDefaultRegexMatchTimeoutInAppDomain = "AppDomain data '{0}' contains an invalid value or object for specifying a default matching timeout for System.Text.RegularExpressions.Regex.";
    static string FileObject_AlreadyOpen = "The file is already open.  Call Close before trying to open the FileObject again.";
    static string FileObject_Closed = "The FileObject is currently closed.  Try opening it.";
    static string FileObject_NotWhileWriting = "File information cannot be queried while open for writing.";
    static string FileObject_FileDoesNotExist = "File information cannot be queried if the file does not exist.";
    static string FileObject_MustBeClosed = "This operation can only be done when the FileObject is closed.";
    static string FileObject_MustBeFileName = "You must specify a file name, not a relative or absolute path.";
    static string FileObject_InvalidInternalState = "FileObject's open mode wasn't set to a valid value.  This FileObject is corrupt.";
    static string FileObject_PathNotSet = "The path has not been set, or is an empty string.  Please ensure you specify some path.";
    static string FileObject_Reading = "The file is currently open for reading.  Close the file and reopen it before attempting this.";
    static string FileObject_Writing = "The file is currently open for writing.  Close the file and reopen it before attempting this.";
    static string FileObject_InvalidEnumeration = "Enumerator is positioned before the first line or after the last line of the file.";
    static string FileObject_NoReset = "Reset is not supported on a FileLineEnumerator.";
    static string DirectoryObject_MustBeDirName = "You must specify a directory name, not a relative or absolute path.";
    static string DirectoryObjectPathDescr = "The fully qualified, or relative path to the directory you wish to read from. E.g., "c:\temp".";
    static string FileObjectDetectEncodingDescr = "Determines whether the file will be parsed to see if it has a byte order mark indicating its encoding.  If it does, this will be used rather than the current specified encoding.";
    static string FileObjectEncodingDescr = "The encoding to use when reading the file. UTF-8 is the default.";
    static string FileObjectPathDescr = "The fully qualified, or relative path to the file you wish to read from. E.g., "myfile.txt".";
    static string Arg_EnumIllegalVal = "Illegal enum value: {0}.";
    static string Arg_OutOfRange_NeedNonNegNum = "Non-negative number required.";
    static string Argument_InvalidPermissionState = "Invalid permission state.";
    static string Argument_InvalidOidValue = "The OID value was invalid.";
    static string Argument_WrongType = "Operation on type '{0}' attempted with target of incorrect type.";
    static string Arg_EmptyOrNullString = "String cannot be empty or null.";
    static string Arg_EmptyOrNullArray = "Array cannot be empty or null.";
    static string Argument_InvalidClassAttribute = "The value of "class" attribute is invalid.";
    static string Argument_InvalidNameType = "The value of "nameType" is invalid.";
    static string InvalidOperation_DuplicateItemNotAllowed = "Duplicate items are not allowed in the collection.";
    static string Cryptography_Asn_MismatchedOidInCollection = "The AsnEncodedData object does not have the same OID for the collection.";
    static string Cryptography_Cms_Envelope_Empty_Content = "Cannot create CMS enveloped for empty content.";
    static string Cryptography_Cms_Invalid_Recipient_Info_Type = "The recipient info type {0} is not valid.";
    static string Cryptography_Cms_Invalid_Subject_Identifier_Type = "The subject identifier type {0} is not valid.";
    static string Cryptography_Cms_Invalid_Subject_Identifier_Type_Value_Mismatch = "The subject identifier type {0} does not match the value data type {1}.";
    static string Cryptography_Cms_Key_Agree_Date_Not_Available = "The Date property is not available for none KID key agree recipient.";
    static string Cryptography_Cms_Key_Agree_Other_Key_Attribute_Not_Available = "The OtherKeyAttribute property is not available for none KID key agree recipient.";
    static string Cryptography_Cms_MessageNotSigned = "The CMS message is not signed.";
    static string Cryptography_Cms_MessageNotSignedByNoSignature = "The CMS message is not signed by NoSignature.";
    static string Cryptography_Cms_MessageNotEncrypted = "The CMS message is not encrypted.";
    static string Cryptography_Cms_Not_Supported = "The Cryptographic Message Standard (CMS) is not supported on this platform.";
    static string Cryptography_Cms_RecipientCertificateNotFound = "The recipient certificate is not specified.";
    static string Cryptography_Cms_Sign_Empty_Content = "Cannot create CMS signature for empty content.";
    static string Cryptography_Cms_Sign_No_Signature_First_Signer = "CmsSigner has to be the first signer with NoSignature.";
    static string Cryptography_DpApi_InvalidMemoryLength = "The length of the data should be a multiple of 16 bytes.";
    static string Cryptography_InvalidHandle = "{0} is an invalid handle.";
    static string Cryptography_InvalidContextHandle = "The chain context handle is invalid.";
    static string Cryptography_InvalidStoreHandle = "The store handle is invalid.";
    static string Cryptography_Oid_InvalidValue = "The OID value is invalid.";
    static string Cryptography_Pkcs9_ExplicitAddNotAllowed = "The PKCS 9 attribute cannot be explicitly added to the collection.";
    static string Cryptography_Pkcs9_InvalidOid = "The OID does not represent a valid PKCS 9 attribute.";
    static string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed = "Cannot add multiple PKCS 9 signing time attributes.";
    static string Cryptography_Pkcs9_AttributeMismatch = "The parameter should be a PKCS 9 attribute.";
    static string Cryptography_X509_AddFailed = "Adding certificate with index '{0}' failed.";
    static string Cryptography_X509_BadEncoding = "Input data cannot be coded as a valid certificate.";
    static string Cryptography_X509_ExportFailed = "The certificate export operation failed.";
    static string Cryptography_X509_ExtensionMismatch = "The parameter should be an X509Extension.";
    static string Cryptography_X509_InvalidFindType = "Invalid find type.";
    static string Cryptography_X509_InvalidFindValue = "Invalid find value.";
    static string Cryptography_X509_InvalidEncodingFormat = "Invalid encoding format.";
    static string Cryptography_X509_InvalidContentType = "Invalid content type.";
    static string Cryptography_X509_KeyMismatch = "The public key of the certificate does not match the value specified.";
    static string Cryptography_X509_RemoveFailed = "Removing certificate with index '{0}' failed.";
    static string Cryptography_X509_StoreNotOpen = "The X509 certificate store has not been opened.";
    static string Environment_NotInteractive = "The current session is not interactive.";
    static string NotSupported_InvalidKeyImpl = "Only asymmetric keys that implement ICspAsymmetricAlgorithm are supported.";
    static string NotSupported_KeyAlgorithm = "The certificate key algorithm is not supported.";
    static string NotSupported_PlatformRequiresNT = "This operation is only supported on Windows 2000, Windows XP, and higher.";
    static string NotSupported_UnreadableStream = "Stream does not support reading.";
    static string Security_InvalidValue = "The {0} value was invalid.";
    static string Unknown_Error = "Unknown error.";
    static string security_ServiceNameCollection_EmptyServiceName = "A service name must not be null or empty.";
    static string security_ExtendedProtectionPolicy_UseDifferentConstructorForNever = "To construct a policy with PolicyEnforcement.Never, the single-parameter constructor must be used.";
    static string security_ExtendedProtectionPolicy_NoEmptyServiceNameCollection = "The ServiceNameCollection must contain at least one service name.";
    static string security_ExtendedProtection_NoOSSupport = "This operation requires OS support for extended protection.";
    static string net_nonClsCompliantException = "A non-CLS Compliant Exception (i.e. an object that does not derive from System.Exception) was thrown.";
    static string net_illegalConfigWith = "The '{0}' attribute cannot appear when '{1}' is present.";
    static string net_illegalConfigWithout = "The '{0}' attribute can only appear when '{1}' is present.";
    static string net_resubmitcanceled = "An error occurred on an automatic resubmission of the request.";
    static string net_redirect_perm = "WebPermission demand failed for redirect URI.";
    static string net_resubmitprotofailed = "Cannot handle redirect from HTTP/HTTPS protocols to other dissimilar ones.";
    static string net_invalidversion = "This protocol version is not supported.";
    static string net_toolong = "The size of {0} is too long. It cannot be longer than {1} characters.";
    static string net_connclosed = "The underlying connection was closed: {0}.";
    static string net_mutualauthfailed = "The requirement for mutual authentication was not met by the remote server.";
    static string net_invasync = "Cannot block a call on this socket while an earlier asynchronous call is in progress.";
    static string net_inasync = "An asynchronous call is already in progress. It must be completed or canceled before you can call this method.";
    static string net_mustbeuri = "The {0} parameter must represent a valid Uri (see inner exception).";
    static string net_format_shexp = "The shell expression '{0}' could not be parsed because it is formatted incorrectly.";
    static string net_cannot_load_proxy_helper = "Failed to load the proxy script runtime environment from the Microsoft.JScript assembly.";
    static string net_io_no_0timeouts = "NetworkStream does not support a 0 millisecond timeout, use a value greater than zero for the timeout instead.";
    static string net_tooManyRedirections = "Too many automatic redirections were attempted.";
    static string net_authmodulenotregistered = "The supplied authentication module is not registered.";
    static string net_authschemenotregistered = "There is no registered module for this authentication scheme.";
    static string net_proxyschemenotsupported = "The ServicePointManager does not support proxies with the {0} scheme.";
    static string net_maxsrvpoints = "The maximum number of service points was exceeded.";
    static string net_notconnected = "The operation is not allowed on non-connected sockets.";
    static string net_notstream = "The operation is not allowed on non-stream oriented sockets.";
    static string net_nocontentlengthonget = "Content-Length or Chunked Encoding cannot be set for an operation that does not write data.";
    static string net_contentlengthmissing = "When performing a write operation with AllowWriteStreamBuffering set to false, you must either set ContentLength to a non-negative number or set SendChunked to true.";
    static string net_nonhttpproxynotallowed = "The URI scheme for the supplied IWebProxy has the illegal value '{0}'. Only 'http' is supported.";
    static string net_need_writebuffering = "This request requires buffering data to succeed.";
    static string net_nodefaultcreds = "Default credentials cannot be supplied for the {0} authentication scheme.";
    static string net_stopped = "Not listening. You must call the Start() method before calling this method.";
    static string net_udpconnected = "Cannot send packets to an arbitrary host while connected.";
    static string net_no_concurrent_io_allowed = "The stream does not support concurrent IO read or write operations.";
    static string net_needmorethreads = "There were not enough free threads in the ThreadPool to complete the operation.";
    static string net_MethodNotSupportedException = "This method is not supported by this class.";
    static string net_ProtocolNotSupportedException = "The '{0}' protocol is not supported by this class.";
    static string net_SelectModeNotSupportedException = "The '{0}' select mode is not supported by this class.";
    static string net_InvalidSocketHandle = "The socket handle is not valid.";
    static string net_InvalidAddressFamily = "The AddressFamily {0} is not valid for the {1} end point, use {2} instead.";
    static string net_InvalidEndPointAddressFamily = "The supplied EndPoint of AddressFamily {0} is not valid for this Socket, use {1} instead.";
    static string net_InvalidSocketAddressSize = "The supplied {0} is an invalid size for the {1} end point.";
    static string net_invalidAddressList = "None of the discovered or specified addresses match the socket address family.";
    static string net_invalidPingBufferSize = "The buffer length must not exceed 65500 bytes.";
    static string net_cant_perform_during_shutdown = "This operation cannot be performed while the AppDomain is shutting down.";
    static string net_cant_create_environment = "Unable to create another web proxy script environment at this time.";
    static string net_protocol_invalid_family = "'{0}' Client can only accept InterNetwork or InterNetworkV6 addresses.";
    static string net_protocol_invalid_multicast_family = "Multicast family is not the same as the family of the '{0}' Client.";
    static string net_empty_osinstalltype = "The Registry value '{0}' was either empty or not a string type.";
    static string net_unknown_osinstalltype = "Unknown Windows installation type '{0}'.";
    static string net_cant_determine_osinstalltype = "Can't determine OS installation type: Can't read key '{0}'. Exception message: {1}";
    static string net_osinstalltype = "Current OS installation type is '{0}'.";
    static string net_entire_body_not_written = "You must write ContentLength bytes to the request stream before calling [Begin]GetResponse.";
    static string net_must_provide_request_body = "You must provide a request body if you set ContentLength>0 or SendChunked==true.  Do this by calling [Begin]GetRequestStream before [Begin]GetResponse.";
    static string net_sockets_zerolist = "The parameter {0} must contain one or more elements.";
    static string net_sockets_blocking = "The operation is not allowed on a non-blocking Socket.";
    static string net_sockets_useblocking = "Use the Blocking property to change the status of the Socket.";
    static string net_sockets_select = "The operation is not allowed on objects of type {0}. Use only objects of type {1}.";
    static string net_sockets_toolarge_select = "The {0} list contains too many items; a maximum of {1} is allowed.";
    static string net_sockets_empty_select = "All lists are either null or empty.";
    static string net_sockets_mustbind = "You must call the Bind method before performing this operation.";
    static string net_sockets_mustlisten = "You must call the Listen method before performing this operation.";
    static string net_sockets_mustnotlisten = "You may not perform this operation after calling the Listen method.";
    static string net_sockets_mustnotbebound = "The socket must not be bound or connected.";
    static string net_sockets_namedmustnotbebound = "{0}: The socket must not be bound or connected.";
    static string net_sockets_invalid_socketinformation = "The specified value for the socket information is invalid.";
    static string net_sockets_invalid_ipaddress_length = "The number of specified IP addresses has to be greater than 0.";
    static string net_sockets_invalid_optionValue = "The specified value is not a valid '{0}'.";
    static string net_sockets_invalid_optionValue_all = "The specified value is not valid.";
    static string net_sockets_invalid_dnsendpoint = "The parameter {0} must not be of type DnsEndPoint.";
    static string net_sockets_disconnectedConnect = "Once the socket has been disconnected, you can only reconnect again asynchronously, and only to a different EndPoint.  BeginConnect must be called on a thread that won't exit until the operation has been completed.";
    static string net_sockets_disconnectedAccept = "Once the socket has been disconnected, you can only accept again asynchronously.  BeginAccept must be called on a thread that won't exit until the operation has been completed.";
    static string net_tcplistener_mustbestopped = "The TcpListener must not be listening before performing this operation.";
    static string net_sockets_no_duplicate_async = "BeginConnect cannot be called while another asynchronous operation is in progress on the same Socket.";
    static string net_socketopinprogress = "An asynchronous socket operation is already in progress using this SocketAsyncEventArgs instance.";
    static string net_buffercounttoosmall = "The Buffer space specified by the Count property is insufficient for the AcceptAsync method.";
    static string net_multibuffernotsupported = "Multiple buffers cannot be used with this method.";
    static string net_ambiguousbuffers = "Buffer and BufferList properties cannot both be non-null.";
    static string net_sockets_ipv6only = "This operation is only valid for IPv6 Sockets.";
    static string net_perfcounter_initialized_success = "System.Net performance counters initialization completed successful.";
    static string net_perfcounter_initialized_error = "System.Net performance counters initialization completed with errors. See System.Net trace file for more information.";
    static string net_perfcounter_nocategory = "Performance counter category '{0}' doesn't exist. No System.Net performance counter values available.";
    static string net_perfcounter_initialization_started = "System.Net performance counter initialization started.";
    static string net_perfcounter_cant_queue_workitem = "Can't queue counter initialization logic on a thread pool thread. System.Net performance counters will not be available.";
    static string net_config_proxy = "Error creating the Web Proxy specified in the 'system.net/defaultProxy' configuration section.";
    static string net_config_proxy_module_not_public = "The specified proxy module type is not public.";
    static string net_config_authenticationmodules = "Error creating the modules specified in the 'system.net/authenticationModules' configuration section.";
    static string net_config_webrequestmodules = "Error creating the modules specified in the 'system.net/webRequestModules' configuration section.";
    static string net_config_requestcaching = "Error creating the Web Request caching policy specified in the 'system.net/requestCaching' configuration section.";
    static string net_config_section_permission = "Insufficient permissions for setting the configuration section '{0}'.";
    static string net_config_element_permission = "Insufficient permissions for setting the configuration element '{0}'.";
    static string net_config_property_permission = "Insufficient permissions for setting the configuration property '{0}'.";
    static string net_WebResponseParseError_InvalidHeaderName = "Header name is invalid";
    static string net_WebResponseParseError_InvalidContentLength = "'Content-Length' header value is invalid";
    static string net_WebResponseParseError_IncompleteHeaderLine = "Invalid header name";
    static string net_WebResponseParseError_CrLfError = "CR must be followed by LF";
    static string net_WebResponseParseError_InvalidChunkFormat = "Response chunk format is invalid";
    static string net_WebResponseParseError_UnexpectedServerResponse = "Unexpected server response received";
    static string net_webstatus_Success = "Status success";
    static string net_webstatus_ReceiveFailure = "An unexpected error occurred on a receive";
    static string net_webstatus_SendFailure = "An unexpected error occurred on a send";
    static string net_webstatus_PipelineFailure = "A pipeline failure occurred";
    static string net_webstatus_RequestCanceled = "The request was canceled";
    static string net_webstatus_ConnectionClosed = "The connection was closed unexpectedly";
    static string net_webstatus_TrustFailure = "Could not establish trust relationship for the SSL/TLS secure channel";
    static string net_webstatus_SecureChannelFailure = "Could not create SSL/TLS secure channel";
    static string net_webstatus_ServerProtocolViolation = "The server committed a protocol violation";
    static string net_webstatus_KeepAliveFailure = "A connection that was expected to be kept alive was closed by the server";
    static string net_webstatus_ProxyNameResolutionFailure = "The proxy name could not be resolved";
    static string net_webstatus_MessageLengthLimitExceeded = "The message length limit was exceeded";
    static string net_webstatus_CacheEntryNotFound = "The request cache-only policy does not allow a network request and the response is not found in cache";
    static string net_webstatus_RequestProhibitedByCachePolicy = "The request could not be satisfied using a cache-only policy";
    static string net_webstatus_RequestProhibitedByProxy = "The IWebProxy object associated with the request did not allow the request to proceed";
    static string net_httpstatuscode_NoContent = "No Content";
    static string net_httpstatuscode_NonAuthoritativeInformation = "Non Authoritative Information";
    static string net_httpstatuscode_ResetContent = "Reset Content";
    static string net_httpstatuscode_PartialContent = "Partial Content";
    static string net_httpstatuscode_MultipleChoices = "Multiple Choices Redirect";
    static string net_httpstatuscode_Ambiguous = "Ambiguous Redirect";
    static string net_httpstatuscode_MovedPermanently = "Moved Permanently Redirect";
    static string net_httpstatuscode_Moved = "Moved Redirect";
    static string net_httpstatuscode_Found = "Found Redirect";
    static string net_httpstatuscode_Redirect = "Redirect";
    static string net_httpstatuscode_SeeOther = "See Other";
    static string net_httpstatuscode_RedirectMethod = "Redirect Method";
    static string net_httpstatuscode_NotModified = "Not Modified";
    static string net_httpstatuscode_UseProxy = "Use Proxy Redirect";
    static string net_httpstatuscode_TemporaryRedirect = "Temporary Redirect";
    static string net_httpstatuscode_RedirectKeepVerb = "Redirect Keep Verb";
    static string net_httpstatuscode_BadRequest = "Bad Request";
    static string net_httpstatuscode_Unauthorized = "Unauthorized";
    static string net_httpstatuscode_PaymentRequired = "Payment Required";
    static string net_httpstatuscode_Forbidden = "Forbidden";
    static string net_httpstatuscode_NotFound = "Not Found";
    static string net_httpstatuscode_MethodNotAllowed = "Method Not Allowed";
    static string net_httpstatuscode_NotAcceptable = "Not Acceptable";
    static string net_httpstatuscode_ProxyAuthenticationRequired = "Proxy Authentication Required";
    static string net_httpstatuscode_RequestTimeout = "Request Timeout";
    static string net_httpstatuscode_Conflict = "Conflict";
    static string net_httpstatuscode_Gone = "Gone";
    static string net_httpstatuscode_LengthRequired = "Length Required";
    static string net_httpstatuscode_InternalServerError = "Internal Server Error";
    static string net_httpstatuscode_NotImplemented = "Not Implemented";
    static string net_httpstatuscode_BadGateway = "Bad Gateway";
    static string net_httpstatuscode_ServiceUnavailable = "Server Unavailable";
    static string net_httpstatuscode_GatewayTimeout = "Gateway Timeout";
    static string net_httpstatuscode_HttpVersionNotSupported = "Http Version Not Supported";
    static string net_emptystringset = "This property cannot be set to an empty string.";
    static string net_emptystringcall = "The parameter '{0}' cannot be an empty string.";
    static string net_headers_req = "This collection holds response headers and cannot contain the specified request header.";
    static string net_headers_rsp = "This collection holds request headers and cannot contain the specified response header.";
    static string net_headers_toolong = "Header values cannot be longer than {0} characters.";
    static string net_WebHeaderInvalidNonAsciiChars = "Specified value has invalid non-ASCII characters.";
    static string net_WebHeaderMissingColon = "Specified value does not have a ':' separator.";
    static string net_headerrestrict = "The '{0}' header must be modified using the appropriate property or method.";
    static string net_io_completionportwasbound = "The socket has already been bound to an io completion port.";
    static string net_io_writefailure = "Unable to write data to the transport connection: {0}.";
    static string net_io_readfailure = "Unable to read data from the transport connection: {0}.";
    static string net_io_connectionclosed = "The connection was closed";
    static string net_io_transportfailure = "Unable to create a transport connection.";
    static string net_io_internal_bind = "Internal Error: A socket handle could not be bound to a completion port.";
    static string net_io_invalidnestedcall = "The {0} method cannot be called when another {1} operation is pending.";
    static string net_io_must_be_rw_stream = "The stream has to be read/write.";
    static string net_io_header_id = "Found a wrong header field {0} read = {1}, expected = {2}.";
    static string net_io_out_range = "The byte count must not exceed {0} bytes for this stream type.";
    static string net_io_encrypt = "The encryption operation failed, see inner exception.";
    static string net_io_decrypt = "The decryption operation failed, see inner exception.";
    static string net_io_read = "The read operation failed, see inner exception.";
    static string net_io_write = "The write operation failed, see inner exception.";
    static string net_io_eof = "Received an unexpected EOF or 0 bytes from the transport stream.";
    static string net_io_async_result = "The parameter: {0} is not valid. Use the object returned from corresponding Begin async call.";
    static string net_tls_version = "The SSL version is not supported.";
    static string net_perm_target = "Cannot cast target permission type.";
    static string net_perm_both_regex = "Cannot subset Regex. Only support if both patterns are identical.";
    static string net_perm_none = "There are no permissions to check.";
    static string net_perm_attrib_count = "The value for '{0}' must be specified.";
    static string net_perm_invalid_val = "The parameter value '{0}={1}' is invalid.";
    static string net_perm_attrib_multi = "The permission '{0}={1}' cannot be added. Add a separate Attribute statement.";
    static string net_perm_epname = "The argument value '{0}' is invalid for creating a SocketPermission object.";
    static string net_perm_invalid_val_in_element = "The '{0}' element contains one or more invalid values.";
    static string net_invalid_ip_addr = "IPv4 address 0.0.0.0 and IPv6 address ::0 are unspecified addresses that cannot be used as a target address.";
    static string dns_bad_ip_address = "An invalid IP address was specified.";
    static string net_bad_mac_address = "An invalid physical address was specified.";
    static string net_ping = "An exception occurred during a Ping request.";
    static string net_bad_ip_address_prefix = "An invalid IP address prefix was specified.";
    static string net_max_ip_address_list_length_exceeded = "Too many addresses to sort. The maximum number of addresses allowed are {0}.";
    static string net_ipv4_not_installed = "IPv4 is not installed.";
    static string net_ipv6_not_installed = "IPv6 is not installed.";
    static string net_webclient = "An exception occurred during a WebClient request.";
    static string net_webclient_ContentType = "The Content-Type header cannot be changed from its default value for this request.";
    static string net_webclient_Multipart = "The Content-Type header cannot be set to a multipart type for this request.";
    static string net_webclient_no_concurrent_io_allowed = "WebClient does not support concurrent I/O operations.";
    static string net_webclient_invalid_baseaddress = "The specified value is not a valid base address.";
    static string net_container_add_cookie = "An error occurred when adding a cookie to the container.";
    static string net_cookie_invalid = "Invalid contents for cookie = '{0}'.";
    static string net_cookie_size = "The value size of the cookie is '{0}'. This exceeds the configured maximum size, which is '{1}'.";
    static string net_cookie_parse_header = "An error occurred when parsing the Cookie header for Uri '{0}'.";
    static string net_cookie_attribute = "The '{0}'='{1}' part of the cookie is invalid.";
    static string net_cookie_format = "Cookie format error.";
    static string net_cookie_capacity_range = "'{0}' has to be greater than '{1}' and less than '{2}'.";
    static string net_set_token = "Failed to impersonate a thread doing authentication of a Web Request.";
    static string net_revert_token = "Failed to revert the thread token after authenticating a Web Request.";
    static string net_ssl_io_async_context = "Async context creation failed.";
    static string net_ssl_io_encrypt = "The encryption operation failed, see inner exception.";
    static string net_ssl_io_decrypt = "The decryption operation failed, see inner exception.";
    static string net_ssl_io_context_expired = "The security context has expired.";
    static string net_ssl_io_handshake_start = "The handshake failed. The remote side has dropped the stream.";
    static string net_ssl_io_handshake = "The handshake failed, see inner exception.";
    static string net_ssl_io_frame = "The handshake failed due to an unexpected packet format.";
    static string net_ssl_io_corrupted = "The stream is corrupted due to an invalid SSL version number in the SSL protocol header.";
    static string net_ssl_io_cert_validation = "The remote certificate is invalid according to the validation procedure.";
    static string net_ssl_io_invalid_end_call = "{0} can only be called once for each asynchronous operation.";
    static string net_ssl_io_invalid_begin_call = "{0} cannot be called when another {1} operation is pending.";
    static string net_ssl_io_no_server_cert = "The server mode SSL must use a certificate with the associated private key.";
    static string net_auth_bad_client_creds = "The server has rejected the client credentials.";
    static string net_auth_bad_client_creds_or_target_mismatch = "Either the target name is incorrect or the server has rejected the client credentials.";
    static string net_auth_context_expectation = "A security requirement was not fulfilled during authentication. Required: {0}, negotiated: {1}.";
    static string net_auth_context_expectation_remote = "A remote side security requirement was not fulfilled during authentication. Try increasing the ProtectionLevel and/or ImpersonationLevel.";
    static string net_auth_supported_impl_levels = "The supported values are Identification, Impersonation or Delegation.";
    static string net_auth_no_anonymous_support = "The TokenImpersonationLevel.Anonymous level is not supported for authentication.";
    static string net_auth_reauth = "This operation is not allowed on a security context that has already been authenticated.";
    static string net_auth_noauth = "This operation is only allowed using a successfully authenticated context.";
    static string net_auth_client_server = "Once authentication is attempted as the client or server, additional authentication attempts must use the same client or server role.";
    static string net_auth_noencryption = "This authenticated context does not support data encryption.";
    static string net_auth_SSPI = "Authentication failed, see inner exception.";
    static string net_auth_failure = "Authentication failed, see inner exception.";
    static string net_auth_eof = "Authentication failed because the remote party has closed the transport stream.";
    static string net_auth_alert = "Authentication failed on the remote side (the stream might still be available for additional authentication attempts).";
    static string net_auth_ignored_reauth = "Re-authentication failed because the remote party continued to encrypt more than {0} bytes before answering re-authentication.";
    static string net_auth_empty_read = "Protocol error: cannot proceed with SSPI handshake because an empty blob was received.";
    static string net_auth_must_specify_extended_protection_scheme = "An extended protection policy must specify either a custom channel binding or a custom service name collection.";
    static string net_frame_size = "Received an invalid authentication frame. The message size is limited to {0} bytes, attempted to read {1} bytes.";
    static string net_frame_read_io = "Received incomplete authentication message. Remote party has probably closed the connection.";
    static string net_frame_read_size = "Cannot determine the frame size or a corrupted frame was received.";
    static string net_frame_max_size = "The payload size is limited to {0}, attempted set it to {1}.";
    static string net_jscript_load = "The proxy JScript file threw an exception while being initialized: {0}.";
    static string net_proxy_not_gmt = "The specified value is not a valid GMT time.";
    static string net_proxy_invalid_dayofweek = "The specified value is not a valid day of the week.";
    static string net_proxy_invalid_url_format = "The system proxy settings contain an invalid proxy server setting: '{0}'.";
    static string net_param_not_string = "Argument must be a string instead of {0}.";
    static string net_value_cannot_be_negative = "The specified value cannot be negative.";
    static string net_invalid_offset = "Value of offset cannot be negative or greater than the length of the buffer.";
    static string net_offset_plus_count = "Sum of offset and count cannot be greater than the length of the buffer.";
    static string net_cannot_be_false = "The specified value cannot be false.";
    static string net_cache_shadowstream_not_writable = "Shadow stream must be writable.";
    static string net_cache_validator_fail = "The validation method {0}() returned a failure for this request.";
    static string net_cache_access_denied = "For this RequestCache object, {0} access is denied.";
    static string net_cache_validator_result = "The validation method {0}() returned the unexpected status: {1}.";
    static string net_cache_retrieve_failure = "Cache retrieve failed: {0}.";
    static string net_cache_not_supported_body = "The cached response is not supported for a request with a content body.";
    static string net_cache_not_supported_command = "The cached response is not supported for a request with the specified request method.";
    static string net_cache_not_accept_response = "The cache protocol refused the server response. To allow automatic request retrying, set request.AllowAutoRedirect to true.";
    static string net_cache_method_failed = "The request (Method = {0}) cannot be served from the cache and will fail because of the effective CachePolicy: {1}.";
    static string net_cache_key_failed = "The request failed because no cache entry (CacheKey = {0}) was found and the effective CachePolicy is {1}.";
    static string net_cache_no_stream = "The cache protocol returned a cached response but the cache entry is invalid because it has a null stream. (Cache Key = {0}).";
    static string net_cache_unsupported_partial_stream = "A partial content stream does not support this operation or some method argument is out of range.";
    static string net_cache_not_configured = "No cache protocol is available for this request.";
    static string net_cache_non_seekable_stream_not_supported = "The transport stream instance passed in the RangeStream constructor is not seekable and therefore is not supported.";
    static string net_invalid_cast = "Invalid cast from {0} to {1}.";
    static string net_collection_readonly = "The collection is read-only.";
    static string net_not_ipermission = "Specified value does not contain 'IPermission' as its tag.";
    static string net_no_classname = "Specified value does not contain a 'class' attribute.";
    static string net_no_typename = "The value class attribute is not valid.";
    static string net_servicePointAddressNotSupportedInHostMode = "This property is not supported for protocols that do not use URI.";
    static string net_Websockets_WebSocketBaseFaulted = "An exception caused the WebSocket to enter the Aborted state. Please see the InnerException, if present, for more details.";
    static string net_WebSockets_Generic = "An internal WebSocket error occurred. Please see the innerException, if present, for more details.";
    static string net_WebSockets_NotAWebSocket_Generic = "A WebSocket operation was called on a request or response that is not a WebSocket.";
    static string net_WebSockets_UnsupportedWebSocketVersion_Generic = "Unsupported WebSocket version.";
    static string net_WebSockets_HeaderError_Generic = "The WebSocket request or response contained unsupported header(s).";
    static string net_WebSockets_UnsupportedProtocol_Generic = "The WebSocket request or response operation was called with unsupported protocol(s).";
    static string net_WebSockets_ClientSecWebSocketProtocolsBlank = "The WebSocket client sent a blank '{0}' header; this is not allowed by the WebSocket protocol specification. The client should omit the header if the client is not negotiating any sub-protocols.";
    static string net_WebSockets_InvalidState_Generic = "The WebSocket instance cannot be used for communication because it has been transitioned into an invalid state.";
    static string net_WebSockets_InvalidMessageType_Generic = "The received  message type is invalid after calling {0}. {0} should only be used if no more data is expected from the remote endpoint. Use '{1}' instead to keep being able to receive data but close the output channel.";
    static string net_WebSockets_ConnectionClosedPrematurely_Generic = "The remote party closed the WebSocket connection without completing the close handshake.";
    static string net_WebSockets_Scheme = "Only Uris starting with 'ws://' or 'wss://' are supported.";
    static string net_WebSockets_AlreadyStarted = "The WebSocket has already been started.";
    static string net_WebSockets_Connect101Expected = "The server returned status code '{0}' when status code '101' was expected.";
    static string net_WebSockets_InvalidResponseHeader = "The '{0}' header value '{1}' is invalid.";
    static string net_WebSockets_NotConnected = "The WebSocket is not connected.";
    static string net_WebSockets_InvalidRegistration = "The WebSocket schemes must be registered with the HttpWebRequest class.";
    static string net_WebSockets_NoDuplicateProtocol = "Duplicate protocols are not allowed: '{0}'.";
    static string net_log_exception = "Exception in {0}::{1} - {2}.";
    static string net_log_sspi_enumerating_security_packages = "Enumerating security packages:";
    static string net_log_sspi_security_package_not_found = "Security package '{0}' was not found.";
    static string net_log_sspi_security_context_input_buffer = "{0}(In-Buffer length={1}, Out-Buffer length={2}, returned code={3}).";
    static string net_log_sspi_security_context_input_buffers = "{0}(In-Buffers count={1}, Out-Buffer length={2}, returned code={3}).";
    static string net_log_sspi_selected_cipher_suite = "{0}(Protocol={1}, Cipher={2} {3} bit strength, Hash={4} {5} bit strength, Key Exchange={6} {7} bit strength).";
    static string net_log_remote_certificate = "Remote certificate: {0}.";
    static string net_log_locating_private_key_for_certificate = "Locating the private key for the certificate: {0}.";
    static string net_log_cert_is_of_type_2 = "Certificate is of type X509Certificate2 and contains the private key.";
    static string net_log_found_cert_in_store = "Found the certificate in the {0} store.";
    static string net_log_did_not_find_cert_in_store = "Cannot find the certificate in either the LocalMachine store or the CurrentUser store.";
    static string net_log_open_store_failed = "Opening Certificate store {0} failed, exception: {1}.";
    static string net_log_got_certificate_from_delegate = "Got a certificate from the client delegate.";
    static string net_log_no_delegate_and_have_no_client_cert = "Client delegate did not provide a certificate; and there are not other user-provided certificates. Need to attempt a session restart.";
    static string net_log_no_delegate_but_have_client_cert = "Client delegate did not provide a certificate; but there are other user-provided certificates".";
    static string net_log_attempting_restart_using_cert = "Attempting to restart the session using the user-provided certificate: {0}.";
    static string net_log_no_issuers_try_all_certs = "We have user-provided certificates. The server has not specified any issuers, so try all the certificates.";
    static string net_log_server_issuers_look_for_matching_certs = "We have user-provided certificates. The server has specified {0} issuer(s). Looking for certificates that match any of the issuers.";
    static string net_log_selected_cert = "Selected certificate: {0}.";
    static string net_log_n_certs_after_filtering = "Left with {0} client certificates to choose from.";
    static string net_log_finding_matching_certs = "Trying to find a matching certificate in the certificate store.";
    static string net_log_using_cached_credential = "Using the cached credential handle.";
    static string net_log_remote_cert_user_declared_valid = "Remote certificate was verified as valid by the user.";
    static string net_log_remote_cert_user_declared_invalid = "Remote certificate was verified as invalid by the user.";
    static string net_log_remote_cert_has_no_errors = "Remote certificate has no errors.";
    static string net_log_remote_cert_has_errors = "Remote certificate has errors:";
    static string net_log_remote_cert_not_available = "The remote server did not provide a certificate.";
    static string net_log_remote_cert_name_mismatch = "Certificate name mismatch.";
    static string net_log_proxy_autodetect_script_location_parse_error = "WebProxy failed to parse the auto-detected location of a proxy script:"{0}" into a Uri.";
    static string net_log_proxy_autodetect_failed = "WebProxy failed to autodetect a Uri for a proxy script.";
    static string net_log_proxy_script_execution_error = "WebProxy caught an exception while executing the ScriptReturn script: {0}.";
    static string net_log_proxy_script_download_compile_error = "WebProxy caught an exception while  downloading/compiling the proxy script: {0}.";
    static string net_log_proxy_system_setting_update = "ScriptEngine was notified of a potential change in the system's proxy settings and will update WebProxy settings.";
    static string net_log_proxy_update_due_to_ip_config_change = "ScriptEngine was notified of a change in the IP configuration and will update WebProxy settings.";
    static string net_log_proxy_called_with_null_parameter = "{0} was called with a null '{1}' parameter.";
    static string net_log_proxy_called_with_invalid_parameter = "{0} was called with an invalid parameter.";
    static string net_log_proxy_ras_supported = "RAS supported: {0}";
    static string net_log_proxy_ras_notsupported_exception = "RAS is not supported. Can't create RasHelper instance.";
    static string net_log_proxy_winhttp_cant_open_session = "Can't open WinHttp session. Error code: {0}.";
    static string net_log_proxy_winhttp_getproxy_failed = "Can't retrieve proxy settings for Uri '{0}'. Error code: {1}.";
    static string net_log_proxy_winhttp_timeout_error = "Can't specify proxy discovery timeout. Error code: {0}.";
    static string net_log_cache_validation_failed_resubmit = "Resubmitting this request because cache cannot validate the response.";
    static string net_log_cache_refused_server_response = "Caching protocol has refused the server response. To allow automatic request retrying set request.AllowAutoRedirect=true.";
    static string net_log_cache_ftp_proxy_doesnt_support_partial = "This FTP request is configured to use a proxy through HTTP protocol. Cache revalidation and partially cached responses are not supported.";
    static string net_log_cache_ftp_method = "FTP request method={0}.";
    static string net_log_cache_ftp_supports_bin_only = "Caching is not supported for non-binary FTP request mode.";
    static string net_log_cache_replacing_entry_with_HTTP_200 = "Replacing cache entry metadata with 'HTTP/1.1 200 OK' status line to satisfy HTTP cache protocol logic.";
    static string net_log_cache_now_time = "[Now Time (UTC)] = {0}.";
    static string net_log_cache_max_age_absolute = "[MaxAge] Absolute time expiration check (sensitive to clock skew), cache Expires: {0}.";
    static string net_log_cache_age1 = "[Age1] Now - LastSynchronized = [Age1] Now - LastSynchronized = {0}, Last Synchronized: {1}.";
    static string net_log_cache_age1_date_header = "[Age1] NowTime-Date Header = {0}, Date Header: {1}.";
    static string net_log_cache_age1_last_synchronized = "[Age1] Now - LastSynchronized + AgeHeader = {0}, Last Synchronized: {1}.";
    static string net_log_cache_age1_last_synchronized_age_header = "[Age1] Now - LastSynchronized + AgeHeader = {0}, Last Synchronized: {1}, Age Header: {2}.";
    static string net_log_cache_age2 = "[Age2] AgeHeader = {0}.";
    static string net_log_cache_max_age_cache_s_max_age = "[MaxAge] Cache s_MaxAge = {0}.";
    static string net_log_cache_max_age_expires_date = "[MaxAge] Cache Expires - Date = {0}, Expires: {1}.";
    static string net_log_cache_max_age_cache_max_age = "[MaxAge] Cache MaxAge = {0}.";
    static string net_log_cache_no_max_age_use_10_percent = "[MaxAge] Cannot compute Cache MaxAge, use 10% since LastModified: {0}, LastModified: {1}.";
    static string net_log_cache_no_max_age_use_default = "[MaxAge] Cannot compute Cache MaxAge, using default RequestCacheValidator.UnspecifiedMaxAge: {0}.";
    static string net_log_cache_validator_invalid_for_policy = "This validator should not be called for policy : {0}.";
    static string net_log_cache_response_last_modified = "Response LastModified={0},  ContentLength= {1}.";
    static string net_log_cache_cache_last_modified = "Cache    LastModified={0},  ContentLength= {1}.";
    static string net_log_cache_partial_and_non_zero_content_offset = "A Cache Entry is partial and the user request has non zero ContentOffset = {0}. A restart from cache is not supported for partial cache entries.";
    static string net_log_cache_response_valid_based_on_policy = "Response is valid based on Policy = {0}.";
    static string net_log_cache_null_response_failure = "Response is null so this Request should fail.";
    static string net_log_cache_ftp_response_status = "FTP Response Status={0}, {1}.";
    static string net_log_cache_resp_valid_based_on_retry = "Accept this response as valid based on the retry count = {0}.";
    static string net_log_cache_no_update_based_on_method = "Cache is not updated based on the request Method = {0}.";
    static string net_log_cache_removed_existing_invalid_entry = "Existing entry is removed because it was found invalid.";
    static string net_log_cache_not_updated_based_on_policy = "Cache is not updated based on Policy = {0}.";
    static string net_log_cache_not_updated_because_no_response = "Cache is not updated because there is no response associated with the request.";
    static string net_log_cache_removed_existing_based_on_method = "Existing cache entry is removed based on the request Method = {0}.";
    static string net_log_cache_existing_not_removed_because_unexpected_response_status = "Existing cache entry should but cannot be removed due to unexpected response Status = ({0}) {1}.";
    static string net_log_cache_removed_existing_based_on_policy = "Existing cache entry is removed based on Policy = {0}.";
    static string net_log_cache_not_updated_based_on_ftp_response_status = "Cache is not updated based on the FTP response status. Expected = {0}, actual = {1}.";
    static string net_log_cache_update_not_supported_for_ftp_restart = "Cache update is not supported for restarted FTP responses. Restart offset = {0}.";
    static string net_log_cache_removed_entry_because_ftp_restart_response_changed = "Existing cache entry is removed since a restarted response was changed on the server, cache LastModified date = {0}, new LastModified date = {1}.";
    static string net_log_cache_last_synchronized = "The cache entry last synchronized time = {0}.";
    static string net_log_cache_suppress_update_because_synched_last_minute = "Suppressing cache update since the entry was synchronized within the last minute.";
    static string net_log_cache_updating_last_synchronized = "Updating cache entry last synchronized time = {0}.";
    static string net_log_cache_cannot_remove = "{0} Cannot Remove (throw): Key = {1}, Error = {2}.";
    static string net_log_cache_key_status = "{0}, Key = {1}, -> Status = {2}.";
    static string net_log_cache_key_remove_failed_status = "{0}, Key = {1}, Remove operation failed -> Status = {2}.";
    static string net_log_cache_usecount_file = "{0}, UseCount = {1}, File = {2}.";
    static string net_log_cache_stream = "{0}, stream = {1}.";
    static string net_log_cache_filename = "{0} -> Filename = {1}, Status = {2}.";
    static string net_log_cache_lookup_failed = "{0}, Lookup operation failed -> {1}.";
    static string net_log_cache_exception = "{0}, Exception = {1}.";
    static string net_log_cache_expected_length = "Expected length (0=none)= {0}.";
    static string net_log_cache_last_modified = "LastModified    (0=none)= {0}.";
    static string net_log_cache_expires = "Expires         (0=none)= {0}.";
    static string net_log_cache_max_stale = "MaxStale (sec)          = {0}.";
    static string net_log_cache_dumping_metadata = "...Dumping Metadata...";
    static string net_log_cache_create_failed = "Create operation failed -> {0}.";
    static string net_log_cache_set_expires = "Set Expires               ={0}.";
    static string net_log_cache_set_last_modified = "Set LastModified          ={0}.";
    static string net_log_cache_set_last_synchronized = "Set LastSynchronized      ={0}.";
    static string net_log_cache_enable_max_stale = "Enable MaxStale (sec) ={0}.";
    static string net_log_cache_disable_max_stale = "Disable MaxStale (set to 0).";
    static string net_log_cache_set_new_metadata = "Set new Metadata.";
    static string net_log_cache_dumping = "...Dumping...";
    static string net_log_cache_key = "{0}, Key = {1}.";
    static string net_log_cache_no_commit = "{0}, Nothing was written to the stream, do not commit that cache entry.";
    static string net_log_cache_error_deleting_filename = "{0}, Error deleting a Filename = {1}.";
    static string net_log_cache_update_failed = "{0}, Key = {1}, Update operation failed -> {2}.";
    static string net_log_cache_delete_failed = "{0}, Key = {1}, Delete operation failed -> {2}.";
    static string net_log_cache_commit_failed = "{0}, Key = {1}, Commit operation failed -> {2}.";
    static string net_log_cache_committed_as_partial = "{0}, Key = {1}, Committed entry as partial, not cached bytes count = {2}.";
    static string net_log_cache_max_stale_and_update_status = "{0}, MaxStale = {1}, Update Status = {2}.";
    static string net_log_cache_failing_request_with_exception = "Failing request with the WebExceptionStatus = {0}.";
    static string net_log_cache_request_method = "Request Method = {0}.";
    static string net_log_cache_http_status_parse_failure = "Cannot Parse Cache HTTP Status Line: {0}.";
    static string net_log_cache_http_status_line = "Entry Status Line = HTTP/{0} {1} {2}.";
    static string net_log_cache_cache_control = "Cache Cache-Control = {0}.";
    static string net_log_cache_invalid_http_version = "The cached version is invalid, assuming HTTP 1.0.";
    static string net_log_cache_no_http_response_header = "This Cache Entry does not carry HTTP response headers.";
    static string net_log_cache_http_header_parse_error = "Cannot parse HTTP headers in entry metadata, offending string: {0}.";
    static string net_log_cache_metadata_name_value_parse_error = "Cannot parse all strings in system metadata as "name:value", offending string: {0}.";
    static string net_log_cache_content_range_error = "Invalid format of Response Content-Range:{0}.";
    static string net_log_cache_cache_control_error = "Invalid CacheControl header = {0}.";
    static string net_log_cache_unexpected_status = "The cache protocol method {0} has returned unexpected status: {1}.";
    static string net_log_cache_object_and_exception = "{0} exception: {1}.";
    static string net_log_cache_revalidation_not_needed = "{0}, No cache entry revalidation is needed.";
    static string net_log_cache_not_updated_based_on_cache_protocol_status = "{0}, Cache is not updated based on the current cache protocol status = {1}.";
    static string net_log_cache_closing_cache_stream = "{0}: {1} Closing effective cache stream, type = {2}, cache entry key = {3}.";
    static string net_log_cache_exception_ignored = "{0}: an exception (ignored) on {1} = {2}.";
    static string net_log_cache_no_cache_entry = "{0} has requested a cache response but the entry does not exist (Stream.Null).";
    static string net_log_cache_null_cached_stream = "{0} has requested a cache response but the cached stream is null.";
    static string net_log_cache_requested_combined_but_null_cached_stream = "{0} has requested a combined response but the cached stream is null.";
    static string net_log_cache_returned_range_cache = "{0} has returned a range cache stream, Offset = {1}, Length = {2}.";
    static string net_log_cache_entry_not_found_freshness_undefined = "{0}, Cache Entry not found, freshness result = Undefined.";
    static string net_log_cache_dumping_cache_context = "...Dumping Cache Context...";
    static string net_log_cache_result = "{0}, result = {1}.";
    static string net_log_cache_uri_with_query_has_no_expiration = "Request Uri has a Query, and no explicit expiration time is provided.";
    static string net_log_cache_uri_with_query_and_cached_resp_from_http_10 = "Request Uri has a Query, and cached response is from HTTP 1.0 server.";
    static string net_log_cache_valid_as_fresh_or_because_policy = "Valid as fresh or because of Cache Policy = {0}.";
    static string net_log_cache_accept_based_on_retry_count = "Accept this response base on the retry count = {0}.";
    static string net_log_cache_date_header_older_than_cache_entry = "Response Date header value is older than that of the cache entry.";
    static string net_log_cache_server_didnt_satisfy_range = "Server did not satisfy the range: {0}.";
    static string net_log_cache_304_received_on_unconditional_request = "304 response was received on an unconditional request.";
    static string net_log_cache_304_received_on_unconditional_request_expected_200_206 = "304 response was received on an unconditional request, but expected response code is 200 or 206.";
    static string net_log_cache_last_modified_header_older_than_cache_entry = "HTTP 1.0 Response Last-Modified header value is older than that of the cache entry.";
    static string net_log_cache_freshness_outside_policy_limits = "Response freshness is not within the specified policy limits.";
    static string net_log_cache_need_to_remove_invalid_cache_entry_304 = "Need to remove an invalid cache entry with status code == 304(NotModified).";
    static string net_log_cache_resp_status = "Response Status = {0}.";
    static string net_log_cache_resp_304_or_request_head = "Response==304 or Request was HEAD, updating cache entry.";
    static string net_log_cache_dont_update_cached_headers = "Do not update Cached Headers.";
    static string net_log_cache_update_cached_headers = "Update Cached Headers.";
    static string net_log_cache_partial_resp_not_combined_with_existing_entry = "A partial response is not combined with existing cache entry, Cache Stream Size = {0}, response Range Start = {1}.";
    static string net_log_cache_request_contains_conditional_header = "User Request contains a conditional header.";
    static string net_log_cache_not_a_get_head_post = "This was Not a GET, HEAD or POST request.";
    static string net_log_cache_cannot_update_cache_if_304 = "Cannot update cache if Response status == 304 and a cache entry was not found.";
    static string net_log_cache_cannot_update_cache_with_head_resp = "Cannot update cache with HEAD response if the cache entry does not exist.";
    static string net_log_cache_http_resp_is_null = "HttpWebResponse is null.";
    static string net_log_cache_resp_cache_control_is_no_store = "Response Cache-Control = no-store.";
    static string net_log_cache_resp_cache_control_is_public = "Response Cache-Control = public.";
    static string net_log_cache_resp_cache_control_is_private = "Response Cache-Control = private, and Cache is public.";
    static string net_log_cache_resp_cache_control_is_private_plus_headers = "Response Cache-Control = private+Headers, removing those headers.";
    static string net_log_cache_resp_older_than_cache = "HttpWebResponse date is older than of the cached one.";
    static string net_log_cache_revalidation_required = "Response revalidation is always required but neither Last-Modified nor ETag header is set on the response.";
    static string net_log_cache_needs_revalidation = "Response can be cached although it will always require revalidation.";
    static string net_log_cache_resp_allows_caching = "Response explicitly allows caching = Cache-Control: {0}.";
    static string net_log_cache_auth_header_and_no_s_max_age = "Request carries Authorization Header and no s-maxage, proxy-revalidate or public directive found.";
    static string net_log_cache_post_resp_without_cache_control_or_expires = "POST Response without Cache-Control or Expires headers.";
    static string net_log_cache_valid_based_on_status_code = "Valid based on Status Code: {0}.";
    static string net_log_cache_resp_no_cache_control = "Response with no CacheControl and Status Code = {0}.";
    static string net_log_cache_age = "Cache Age = {0}, Cache MaxAge = {1}.";
    static string net_log_cache_policy_min_fresh = "Client Policy MinFresh = {0}.";
    static string net_log_cache_policy_max_age = "Client Policy MaxAge = {0}.";
    static string net_log_cache_policy_cache_sync_date = "Client Policy CacheSyncDate (UTC) = {0}, Cache LastSynchronizedUtc = {1}.";
    static string net_log_cache_policy_max_stale = "Client Policy MaxStale = {0}.";
    static string net_log_cache_control_no_cache = "Cached CacheControl = no-cache.";
    static string net_log_cache_control_no_cache_removing_some_headers = "Cached CacheControl = no-cache, Removing some headers.";
    static string net_log_cache_control_must_revalidate = "Cached CacheControl = must-revalidate and Cache is not fresh.";
    static string net_log_cache_cached_auth_header = "The cached entry has Authorization Header and cache is not fresh.";
    static string net_log_cache_cached_auth_header_no_control_directive = "The cached entry has Authorization Header and no Cache-Control directive present that would allow to use that entry.";
    static string net_log_cache_after_validation = "After Response Cache Validation.";
    static string net_log_cache_resp_status_304 = "Response status == 304 but the cache entry does not exist.";
    static string net_log_cache_head_resp_has_different_content_length = "A response resulted from a HEAD request has different Content-Length header.";
    static string net_log_cache_head_resp_has_different_content_md5 = "A response resulted from a HEAD request has different Content-MD5 header.";
    static string net_log_cache_head_resp_has_different_etag = "A response resulted from a HEAD request has different ETag header.";
    static string net_log_cache_304_head_resp_has_different_last_modified = "A 304 response resulted from a HEAD request has different Last-Modified header.";
    static string net_log_cache_existing_entry_has_to_be_discarded = "An existing cache entry has to be discarded.";
    static string net_log_cache_existing_entry_should_be_discarded = "An existing cache entry should be discarded.";
    static string net_log_cache_206_resp_non_matching_entry = "A 206 Response has been received and either ETag or Last-Modified header value does not match cache entry.";
    static string net_log_cache_206_resp_starting_position_not_adjusted = "The starting position for 206 Response is not adjusted to the end of cache entry.";
    static string net_log_cache_combined_resp_requested = "Creation of a combined response has been requested from the cache protocol.";
    static string net_log_cache_updating_headers_on_304 = "Updating headers on 304 response.";
    static string net_log_cache_suppressing_headers_update_on_304 = "Suppressing cache headers update on 304, new headers don't add anything.";
    static string net_log_cache_status_code_not_304_206 = "A Response Status Code is not 304 or 206.";
    static string net_log_cache_sxx_resp_cache_only = "A 5XX Response and Cache-Only like policy, serving from cache.";
    static string net_log_cache_sxx_resp_can_be_replaced = "A 5XX Response that can be replaced by existing cache entry.";
    static string net_log_cache_vary_header_empty = "Cache entry Vary header is empty.";
    static string net_log_cache_vary_header_contains_asterisks = "Cache entry Vary header contains '*'.";
    static string net_log_cache_no_headers_in_metadata = "No request headers are found in cached metadata to test based on the cached response Vary header.";
    static string net_log_cache_vary_header_mismatched_count = "Vary header: Request and cache header fields count does not match, header name = {0}.";
    static string net_log_cache_vary_header_mismatched_field = "Vary header: A Cache header field mismatch the request one, header name = {0}, cache field = {1}, request field = {2}.";
    static string net_log_cache_vary_header_match = "All required Request headers match based on cached Vary response header.";
    static string net_log_cache_range = "Request Range (not in Cache yet) = Range:{0}.";
    static string net_log_cache_range_invalid_format = "Invalid format of Request Range:{0}.";
    static string net_log_cache_range_not_in_cache = "Cannot serve from Cache, Range:{0}.";
    static string net_log_cache_range_in_cache = "Serving Request Range from cache, Range:{0}.";
    static string net_log_cache_partial_resp = "Serving Partial Response (206) from cache, Content-Range:{0}.";
    static string net_log_cache_range_request_range = "Range Request (user specified), Range: {0}.";
    static string net_log_cache_could_be_partial = "Could be a Partial Cached Response, Size = {0}, Response Content Length = {1}.";
    static string net_log_cache_condition_if_none_match = "Request Condition = If-None-Match:{0}.";
    static string net_log_cache_condition_if_modified_since = "Request Condition = If-Modified-Since:{0}.";
    static string net_log_cache_cannot_construct_conditional_request = "A Conditional Request cannot be constructed.";
    static string net_log_cache_cannot_construct_conditional_range_request = "A Conditional Range request cannot be constructed.";
    static string net_log_cache_entry_size_too_big = "Cached Entry Size = {0} is too big, cannot do a range request.";
    static string net_log_cache_condition_if_range = "Request Condition = If-Range:{0}.";
    static string net_log_cache_conditional_range_not_implemented_on_http_10 = "A Conditional Range request on Http <= 1.0 is not implemented.";
    static string net_log_cache_saving_request_headers = "Saving Request Headers, Vary: {0}.";
    static string net_log_cache_only_byte_range_implemented = "Ranges other than bytes are not implemented.";
    static string net_log_cache_multiple_complex_range_not_implemented = "Multiple/complexe ranges are not implemented.";
    static string net_log_digest_hash_algorithm_not_supported = "The hash algorithm is not supported by Digest authentication: {0}.";
    static string net_log_digest_qop_not_supported = "The Quality of Protection value is not supported by Digest authentication: {0}.";
    static string net_log_digest_requires_nonce = "A nonce parameter required for Digest authentication was not found or was preceded by an invalid parameter.";
    static string net_log_auth_invalid_challenge = "The challenge string is not valid for this authentication module: {0}";
    static string net_log_unknown = "unknown";
    static string net_log_operation_returned_something = "{0} returned {1}.";
    static string net_log_buffered_n_bytes = "Buffered {0} bytes.";
    static string net_log_method_equal = "Method={0}.";
    static string net_log_releasing_connection = "Releasing FTP connection#{0}.";
    static string net_log_unexpected_exception = "Unexpected exception in {0}.";
    static string net_log_server_response_error_code = "Error code {0} was received from server response.";
    static string net_log_resubmitting_request = "Resubmitting request.";
    static string net_log_retrieving_localhost_exception = "An unexpected exception while retrieving the local address list: {0}.";
    static string net_log_resolved_servicepoint_may_not_be_remote_server = "A resolved ServicePoint host could be wrongly considered as a remote server.";
    static string net_log_closed_idle = "{0}#{1} - Closed as idle.";
    static string net_log_received_status_line = "Received status line: Version={0}, StatusCode={1}, StatusDescription={2}.";
    static string net_log_sending_headers = "Sending headers
{{
{0}}}.";
    static string net_log_received_headers = "Received headers
{{
{0}}}.";
    static string net_log_shell_expression_pattern_format_warning = "ShellServices.ShellExpression.Parse() was called with a badly formatted 'pattern':{0}.";
    static string net_log_exception_in_callback = "Exception in callback: {0}.";
    static string net_log_sending_command = "Sending command [{0}]";
    static string net_log_received_response = "Received response [{0}]";
    static string net_log_socket_connected = "Created connection from {0} to {1}.";
    static string net_log_socket_accepted = "Accepted connection from {0} to {1}.";
    static string net_log_socket_not_logged_file = "Not logging data from file: {0}.";
    static string net_log_socket_connect_dnsendpoint = "Connecting to a DnsEndPoint.";
    static string MailAddressInvalidFormat = "The specified string is not in the form required for an e-mail address.";
    static string MailSubjectInvalidFormat = "The specified string is not in the form required for a subject.";
    static string MailBase64InvalidCharacter = "An invalid character was found in the Base-64 stream.";
    static string MailCollectionIsReadOnly = "The collection is read-only.";
    static string MailDateInvalidFormat = "The date is in an invalid format.";
    static string MailHeaderFieldAlreadyExists = "The specified singleton field already exists in the collection and cannot be added.";
    static string MailHeaderFieldInvalidCharacter = "An invalid character was found in the mail header: '{0}'.";
    static string MailHeaderFieldMalformedHeader = "The mail header is malformed.";
    static string MailHeaderFieldMismatchedName = "The header name does not match this property.";
    static string MailHeaderIndexOutOfBounds = "The index value is outside the bounds of the array.";
    static string MailHeaderItemAccessorOnlySingleton = "The Item property can only be used with singleton fields.";
    static string MailHeaderListHasChanged = "The underlying list has been changed and the enumeration is out of date.";
    static string MailHeaderResetCalledBeforeEOF = "The stream should have been consumed before resetting.";
    static string MailHeaderTargetArrayTooSmall = "The target array is too small to contain all the headers.";
    static string MailHeaderInvalidCID = "The ContentID cannot contain a '<' or '>' character.";
    static string MailHostNotFound = "The SMTP host was not found.";
    static string MailReaderGetContentStreamAlreadyCalled = "GetContentStream() can only be called once.";
    static string MailReaderTruncated = "Premature end of stream.";
    static string MailWriterIsInContent = "This operation cannot be performed while in content.";
    static string MailServerDoesNotSupportStartTls = "Server does not support secure connections.";
    static string MailServerResponse = "The server response was: {0}";
    static string SSPIAuthenticationOrSPNNull = "AuthenticationType and ServicePrincipalName cannot be specified as null for server's SSPI Negotiation module.";
    static string SSPIPInvokeError = "{0} failed with error {1}.";
    static string SmtpAlreadyConnected = "Already connected.";
    static string SmtpAuthenticationFailed = "Authentication failed.";
    static string SmtpAuthenticationFailedNoCreds = "Authentication failed due to lack of credentials.";
    static string SmtpDataStreamOpen = "Data stream is still open.";
    static string SmtpDefaultMimePreamble = "This is a multi-part MIME message.";
    static string SmtpDefaultSubject = "@@SOAP Application Message";
    static string SmtpInvalidResponse = "Smtp server returned an invalid response.";
    static string SmtpNotConnected = "Not connected.";
    static string SmtpSystemStatus = "System status, or system help reply.";
    static string SmtpHelpMessage = "Help message.";
    static string SmtpServiceReady = "Service ready.";
    static string SmtpServiceClosingTransmissionChannel = "Service closing transmission channel.";
    static string SmtpOK = "Completed.";
    static string SmtpUserNotLocalWillForward = "User not local; will forward to specified path.";
    static string SmtpStartMailInput = "Start mail input; end with <CRLF>.<CRLF>.";
    static string SmtpServiceNotAvailable = "Service not available, closing transmission channel.";
    static string SmtpMailboxBusy = "Mailbox unavailable.";
    static string SmtpLocalErrorInProcessing = "Error in processing.";
    static string SmtpInsufficientStorage = "Insufficient system storage.";
    static string SmtpPermissionDenied = "Client does not have permission to Send As this sender.";
    static string SmtpCommandUnrecognized = "Syntax error, command unrecognized.";
    static string SmtpSyntaxError = "Syntax error in parameters or arguments.";
    static string SmtpCommandNotImplemented = "Command not implemented.";
    static string SmtpBadCommandSequence = "Bad sequence of commands.";
    static string SmtpCommandParameterNotImplemented = "Command parameter not implemented.";
    static string SmtpMailboxUnavailable = "Mailbox unavailable.";
    static string SmtpUserNotLocalTryAlternatePath = "User not local; please try a different path.";
    static string SmtpExceededStorageAllocation = "Exceeded storage allocation.";
    static string SmtpMailboxNameNotAllowed = "Mailbox name not allowed.";
    static string SmtpTransactionFailed = "Transaction failed.";
    static string SmtpSendMailFailure = "Failure sending mail.";
    static string SmtpRecipientFailed = "Unable to send to a recipient.";
    static string SmtpRecipientRequired = "A recipient must be specified.";
    static string SmtpFromRequired = "A from address must be specified.";
    static string SmtpAllRecipientsFailed = "Unable to send to all recipients.";
    static string SmtpClientNotPermitted = "Client does not have permission to submit mail to this server.";
    static string SmtpMustIssueStartTlsFirst = "The SMTP server requires a secure connection or the client was not authenticated.";
    static string SmtpNeedAbsolutePickupDirectory = "Only absolute directories are allowed for pickup directory.";
    static string SmtpGetIisPickupDirectoryFailed = "Cannot get IIS pickup directory.";
    static string SmtpPickupDirectoryDoesnotSupportSsl = "SSL must not be enabled for pickup-directory delivery methods.";
    static string SmtpOperationInProgress = "Previous operation is still in progress.";
    static string SmtpAuthResponseInvalid = "The server returned an invalid response in the authentication handshake.";
    static string SmtpEhloResponseInvalid = "The server returned an invalid response to the EHLO command.";
    static string SmtpNonAsciiUserNotSupported = "The client or server is only configured for E-mail addresses with ASCII local-parts: {0}.";
    static string SmtpInvalidHostName = "The address has an invalid host name: {0}.";
    static string MimeTransferEncodingNotSupported = "The MIME transfer encoding '{0}' is not supported.";
    static string SeekNotSupported = "Seeking is not supported on this stream.";
    static string WriteNotSupported = "Writing is not supported on this stream.";
    static string InvalidHexDigit = "Invalid hex digit '{0}'.";
    static string InvalidSSPIContext = "The SSPI context is not valid.";
    static string InvalidSSPIContextKey = "A null session key was obtained from SSPI.";
    static string InvalidSSPINegotiationElement = "Invalid SSPI BinaryNegotiationElement.";
    static string InvalidHeaderName = "An invalid character was found in header name.";
    static string InvalidHeaderValue = "An invalid character was found in header value.";
    static string CannotGetEffectiveTimeOfSSPIContext = "Cannot get the effective time of the SSPI context.";
    static string CannotGetExpiryTimeOfSSPIContext = "Cannot get the expiry time of the SSPI context.";
    static string ReadNotSupported = "Reading is not supported on this stream.";
    static string InvalidAsyncResult = "The AsyncResult is not valid.";
    static string UnspecifiedHost = "The SMTP host was not specified.";
    static string InvalidPort = "The specified port is invalid. The port must be greater than 0.";
    static string SmtpInvalidOperationDuringSend = "This operation cannot be performed while a message is being sent.";
    static string MimePartCantResetStream = "One of the streams has already been used and can't be reset to the origin.";
    static string MediaTypeInvalid = "The specified media type is invalid.";
    static string ContentTypeInvalid = "The specified content type is invalid.";
    static string ContentDispositionInvalid = "The specified content disposition is invalid.";
    static string AttributeNotSupported = "'{0}' is not a valid configuration attribute for type '{1}'.";
    static string Cannot_remove_with_null = "Cannot remove with null name.";
    static string Config_base_elements_only = "Only elements allowed.";
    static string Config_base_no_child_nodes = "Child nodes not allowed.";
    static string Config_base_required_attribute_empty = "Required attribute '{0}' cannot be empty.";
    static string Config_base_required_attribute_missing = "Required attribute '{0}' not found.";
    static string Config_base_time_overflow = "The time span for the property '{0}' exceeds the maximum that can be stored in the configuration.";
    static string Config_base_type_must_be_configurationvalidation = "The ConfigurationValidation attribute must be derived from ConfigurationValidation.";
    static string Config_base_type_must_be_typeconverter = "The ConfigurationPropertyConverter attribute must be derived from TypeConverter.";
    static string Config_base_unknown_format = "Unknown";
    static string Config_base_unrecognized_attribute = "Unrecognized attribute '{0}'. Note that attribute names are case-sensitive.";
    static string Config_base_unrecognized_element = "Unrecognized element.";
    static string Config_invalid_boolean_attribute = "The property '{0}' must have value 'true' or 'false'.";
    static string Config_invalid_integer_attribute = "The '{0}' attribute must be set to an integer value.";
    static string Config_invalid_positive_integer_attribute = "The '{0}' attribute must be set to a positive integer value.";
    static string Config_invalid_type_attribute = "The '{0}' attribute must be set to a valid Type name.";
    static string Config_missing_required_attribute = "The '{0}' attribute must be specified on the '{1}' tag.";
    static string Config_name_value_file_section_file_invalid_root = "The root element must match the name of the section referencing the file, '{0}'";
    static string Config_provider_must_implement_type = "Provider must implement the class '{0}'.";
    static string Config_provider_name_null_or_empty = "Provider name cannot be null or empty.";
    static string Config_provider_not_found = "The provider was not found in the collection.";
    static string Config_property_name_cannot_be_empty = "Property '{0}' cannot be empty or null.";
    static string Config_section_cannot_clear_locked_section = "Cannot clear section handlers.  Section '{0}' is locked.";
    static string Config_section_record_not_found = "SectionRecord not found.";
    static string Config_source_cannot_contain_file = "The 'File' property cannot be used with the ConfigSource property.";
    static string Config_system_already_set = "The configuration system can only be set once.  Configuration system is already set";
    static string Config_unable_to_read_security_policy = "Unable to read security policy.";
    static string Config_write_xml_returned_null = "WriteXml returned null.";
    static string Cannot_clear_sections_within_group = "Server cannot clear configuration sections from within section groups.  <clear/> must be a child of <configSections>.";
    static string Cannot_exit_up_top_directory = "Cannot use a leading .. to exit above the top directory.";
    static string Could_not_create_listener = "Couldn't create listener '{0}'.";
    static string TL_InitializeData_NotSpecified = "initializeData needs to be valid for this TraceListener.";
    static string Could_not_create_type_instance = "Could not create {0}.";
    static string Could_not_find_type = "Couldn't find type for class {0}.";
    static string Could_not_get_constructor = "Couldn't find constructor for class {0}.";
    static string EmptyTypeName_NotAllowed = "switchType needs to be a valid class name. It can't be empty.";
    static string Incorrect_base_type = "The specified type, '{0}' is not derived from the appropriate base type, '{1}'.";
    static string Only_specify_one = "'switchValue' and 'switchName' cannot both be specified on source '{0}'.";
    static string Provider_Already_Initialized = "This provider instance has already been initialized.";
    static string Reference_listener_cant_have_properties = "A listener with no type name specified references the sharedListeners section and cannot have any attributes other than 'Name'.  Listener: '{0}'.";
    static string Reference_to_nonexistent_listener = "Listener '{0}' does not exist in the sharedListeners section.";
    static string SettingsPropertyNotFound = "The settings property '{0}' was not found.";
    static string SettingsPropertyReadOnly = "The settings property '{0}' is read-only.";
    static string SettingsPropertyWrongType = "The settings property '{0}' is of a non-compatible type.";
    static string Type_isnt_tracelistener = "Could not add trace listener {0} because it is not a subclass of TraceListener.";
    static string Unable_to_convert_type_from_string = "Could not find a type-converter to convert object if type '{0}' from string.";
    static string Unable_to_convert_type_to_string = "Could not find a type-converter to convert object if type '{0}' to string.";
    static string Value_must_be_numeric = "Error in trace switch '{0}': The value of a switch must be integral.";
    static string Could_not_create_from_default_value = "The property '{0}' could not be created from it's default value. Error message: {1}";
    static string Could_not_create_from_default_value_2 = "The property '{0}' could not be created from it's default value because the default value is of a different type.";
    static string InvalidDirName = "The directory name {0} is invalid.";
    static string FSW_IOError = "Error reading the {0} directory.";
    static string PatternInvalidChar = "The character '{0}' in the pattern provided is not valid.";
    static string BufferSizeTooLarge = "The specified buffer size is too large. FileSystemWatcher cannot allocate {0} bytes for the internal buffer.";
    static string FSW_ChangedFilter = "Flag to indicate which change event to monitor.";
    static string FSW_Enabled = "Flag to indicate whether this component is active or not.";
    static string FSW_Filter = "The file pattern filter.";
    static string FSW_IncludeSubdirectories = "Flag to watch subdirectories.";
    static string FSW_Path = "The path to the directory to monitor.";
    static string FSW_SynchronizingObject = "The object used to marshal the event handler calls issued as a result of a Directory change.";
    static string FSW_Changed = "Occurs when a file and/or directory change matches the filter.";
    static string FSW_Created = "Occurs when a file and/or directory creation matches the filter.";
    static string FSW_Deleted = "Occurs when a file and/or directory deletion matches the filter.";
    static string FSW_Renamed = "Occurs when a file and/or directory rename matches the filter.";
    static string FSW_BufferOverflow = "Too many changes at once in directory:{0}.";
    static string FileSystemWatcherDesc = "Monitors file system change notifications and raises events when a directory or file changes.";
    static string NotSet = "[Not Set]";
    static string TimerAutoReset = "Indicates whether the timer will be restarted when it is enabled.";
    static string TimerEnabled = "Indicates whether the timer is enabled to fire events at a defined interval.";
    static string TimerInterval = "The number of milliseconds between timer events.";
    static string TimerIntervalElapsed = "Occurs when the Interval has elapsed.";
    static string TimerSynchronizingObject = "The object used to marshal the event handler calls issued when an interval has elapsed.";
    static string MismatchedCounterTypes = "Mismatched counter types.";
    static string NoPropertyForAttribute = "Could not find a property for the attribute '{0}'.";
    static string InvalidAttributeType = "The value of attribute '{0}' could not be converted to the proper type.";
    static string Generic_ArgCantBeEmptyString = "'{0}' can not be empty string.";
    static string BadLogName = "Event log names must consist of printable characters and cannot contain \, *, ?, or spaces";
    static string InvalidProperty = "Invalid value {1} for property {0}.";
    static string CantMonitorEventLog = "Cannot monitor EntryWritten events for this EventLog. This might be because the EventLog is on a remote machine which is not a supported scenario.";
    static string InitTwice = "Cannot initialize the same object twice.";
    static string InvalidParameter = "Invalid value '{1}' for parameter '{0}'.";
    static string MissingParameter = "Must specify value for {0}.";
    static string ParameterTooLong = "The size of {0} is too big. It cannot be longer than {1} characters.";
    static string LocalSourceAlreadyExists = "Source {0} already exists on the local computer.";
    static string SourceAlreadyExists = "Source {0} already exists on the computer '{1}'.";
    static string LocalLogAlreadyExistsAsSource = "Log {0} has already been registered as a source on the local computer.";
    static string LogAlreadyExistsAsSource = "Log {0} has already been registered as a source on the computer '{1}'.";
    static string DuplicateLogName = "Only the first eight characters of a custom log name are significant, and there is already another log on the system using the first eight characters of the name given. Name given: '{0}', name of existing log: '{1}'.";
    static string RegKeyMissing = "Cannot open registry key {0}\{1}\{2} on computer '{3}'.";
    static string LocalRegKeyMissing = "Cannot open registry key {0}\{1}\{2}.";
    static string RegKeyMissingShort = "Cannot open registry key {0} on computer {1}.";
    static string InvalidParameterFormat = "Invalid format for argument {0}.";
    static string NoLogName = "Log to delete was not specified.";
    static string RegKeyNoAccess = "Cannot open registry key {0} on computer {1}. You might not have access.";
    static string MissingLog = "Cannot find Log {0} on computer '{1}'.";
    static string SourceNotRegistered = "The source '{0}' is not registered on machine '{1}', or you do not have write access to the {2} registry key.";
    static string LocalSourceNotRegistered = "Source {0} is not registered on the local computer.";
    static string CantRetrieveEntries = "Cannot retrieve all entries.";
    static string IndexOutOfBounds = "Index {0} is out of bounds.";
    static string CantReadLogEntryAt = "Cannot read log entry number {0}.  The event log may be corrupt.";
    static string MissingLogProperty = "Log property value has not been specified.";
    static string CantOpenLog = "Cannot open log {0} on machine {1}. Windows has not provided an error code.";
    static string NeedSourceToOpen = "Source property was not set before opening the event log in write mode.";
    static string NeedSourceToWrite = "Source property was not set before writing to the event log.";
    static string CantOpenLogAccess = "Cannot open log for source '{0}'. You may not have write access.";
    static string LogEntryTooLong = "Log entry string is too long. A string written to the event log cannot exceed 32766 characters.";
    static string TooManyReplacementStrings = "The maximum allowed number of replacement strings is 255.";
    static string LogSourceMismatch = "The source '{0}' is not registered in log '{1}'. (It is registered in log '{2}'.) " The Source and Log properties must be matched, or you may set Log to the empty string, and it will automatically be matched to the Source property.";
    static string NoAccountInfo = "Cannot obtain account information.";
    static string NoCurrentEntry = "No current EventLog entry available, cursor is located before the first or after the last element of the enumeration.";
    static string MessageNotFormatted = "The description for Event ID '{0}' in Source '{1}' cannot be found.  The local computer may not have the necessary registry information or message DLL files to display the message, or you may not have permission to access them.  The following information is part of the event:";
    static string EventID = "Invalid eventID value '{0}'. It must be in the range between '{1}' and '{2}'.";
    static string LogDoesNotExists = "The event log '{0}' on computer '{1}' does not exist.";
    static string InvalidCustomerLogName = "The log name: '{0}' is invalid for customer log creation.";
    static string CannotDeleteEqualSource = "The event log source '{0}' cannot be deleted, because it's equal to the log name.";
    static string RentionDaysOutOfRange = "'retentionDays' must be between 1 and 365 days.";
    static string MaximumKilobytesOutOfRange = "MaximumKilobytes must be between 64 KB and 4 GB, and must be in 64K increments.";
    static string SomeLogsInaccessible = "The source was not found, but some or all event logs could not be searched.  Inaccessible logs: {0}.";
    static string SomeLogsInaccessibleToCreate = "The source was not found, but some or all event logs could not be searched.  To create the source, you need permission to read all event logs to make sure that the new source name is unique.  Inaccessible logs: {0}.";
    static string BadConfigSwitchValue = "The config value for Switch '{0}' was invalid.";
    static string ConfigSectionsUnique = "The '{0}' section can only appear once per config file.";
    static string ConfigSectionsUniquePerSection = "The '{0}' tag can only appear once per section.";
    static string SourceListenerDoesntExist = "The listener '{0}' added to source '{1}' must have a listener with the same name defined in the main Trace listeners section.";
    static string SourceSwitchDoesntExist = "The source '{0}' must have a switch with the same name defined in the Switches section.";
    static string CategoryHelpCorrupt = "Cannot load Category Help data because an invalid index '{0}' was read from the registry.";
    static string CounterNameCorrupt = "Cannot load Counter Name data because an invalid index '{0}' was read from the registry.";
    static string CounterDataCorrupt = "Cannot load Performance Counter data because an unexpected registry key value type was read from '{0}'.";
    static string ReadOnlyCounter = "Cannot update Performance Counter, this object has been initialized as ReadOnly.";
    static string ReadOnlyRemoveInstance = "Cannot remove Performance Counter Instance, this object as been initialized as ReadOnly.";
    static string NotCustomCounter = "The requested Performance Counter is not a custom counter, it has to be initialized as ReadOnly.";
    static string CategoryNameMissing = "Failed to initialize because CategoryName is missing.";
    static string CounterNameMissing = "Failed to initialize because CounterName is missing.";
    static string InstanceNameProhibited = "Counter is single instance, instance name '{0}' is not valid for this counter category.";
    static string InstanceNameRequired = "Counter is not single instance, an instance name needs to be specified.";
    static string MissingInstance = "Instance {0} does not exist in category {1}.";
    static string PerformanceCategoryExists = "Cannot create Performance Category '{0}' because it already exists.";
    static string InvalidCounterName = "Invalid empty or null string for counter name.";
    static string DuplicateCounterName = "Cannot create Performance Category with counter name {0} because the name is a duplicate.";
    static string CantChangeCategoryRegistration = "Cannot create or delete the Performance Category '{0}' because access is denied.";
    static string CantDeleteCategory = "Cannot delete Performance Category because this category is not registered or is a system category.";
    static string MissingCategory = "Category does not exist.";
    static string MissingCategoryDetail = "Category {0} does not exist.";
    static string CantReadCategory = "Cannot read Category {0}.";
    static string MissingCounter = "Counter {0} does not exist.";
    static string CategoryNameNotSet = "Category name property has not been set.";
    static string CounterExists = "Could not locate Performance Counter with specified category name '{0}', counter name '{1}'.";
    static string CantReadCategoryIndex = "Could not Read Category Index: {0}.";
    static string CantReadCounter = "Counter '{0}' does not exist in the specified Category.";
    static string CantReadInstance = "Instance '{0}' does not exist in the specified Category.";
    static string RemoteWriting = "Cannot write to a Performance Counter in a remote machine.";
    static string CounterLayout = "The Counter layout for the Category specified is invalid, a counter of the type:  AverageCount64, AverageTimer32, CounterMultiTimer, CounterMultiTimerInverse, CounterMultiTimer100Ns, CounterMultiTimer100NsInverse, RawFraction, or SampleFraction has to be immediately followed by any of the base counter types: AverageBase, CounterMultiBase, RawBase or SampleBase.";
    static string PossibleDeadlock = "The operation couldn't be completed, potential internal deadlock.";
    static string SharedMemoryGhosted = "Cannot access shared memory, AppDomain has been unloaded.";
    static string HelpNotAvailable = "Help not available.";
    static string PerfInvalidHelp = "Invalid help string. Its length must be in the range between '{0}' and '{1}'.";
    static string PerfInvalidCounterName = "Invalid counter name. Its length must be in the range between '{0}' and '{1}'. Double quotes, control characters and leading or trailing spaces are not allowed.";
    static string PerfInvalidCategoryName = "Invalid category name. Its length must be in the range between '{0}' and '{1}'. Double quotes, control characters and leading or trailing spaces are not allowed.";
    static string MustAddCounterCreationData = "Only objects of type CounterCreationData can be added to a CounterCreationDataCollection.";
    static string RemoteCounterAdmin = "Creating or Deleting Performance Counter Categories on remote machines is not supported.";
    static string NoInstanceInformation = "The {0} category doesn't provide any instance information, no accurate data can be returned.";
    static string PerfCounterPdhError = "There was an error calculating the PerformanceCounter value (0x{0}).";
    static string MultiInstanceOnly = "Category '{0}' is marked as multi-instance.  Performance counters in this category can only be created with instance names.";
    static string SingleInstanceOnly = "Category '{0}' is marked as single-instance.  Performance counters in this category can only be created without instance names.";
    static string InstanceNameTooLong = "Instance names used for writing to custom counters must be 127 characters or less.";
    static string CategoryNameTooLong = "Category names must be 1024 characters or less.";
    static string InstanceLifetimeProcessonReadOnly = "InstanceLifetime is unused by ReadOnly counters.";
    static string InstanceLifetimeProcessforSingleInstance = "Single instance categories are only valid with the Global lifetime.";
    static string InstanceAlreadyExists = "Instance '{0}' already exists with a lifetime of Process.  It cannot be recreated or reused until it has been removed or until the process using it has exited.";
    static string CantSetLifetimeAfterInitialized = "The InstanceLifetime cannot be set after the instance has been initialized.  You must use the default constructor and set the CategoryName, InstanceName, CounterName, InstanceLifetime and ReadOnly properties manually before setting the RawValue.";
    static string ProcessLifetimeNotValidInGlobal = "PerformanceCounterInstanceLifetime.Process is not valid in the global shared memory.  If your performance counter category was created with an older version of the Framework, it uses the global shared memory.  Either use PerformanceCounterInstanceLifetime.Global, or if applications running on older versions of the Framework do not need to write to your category, delete and recreate it.";
    static string CantConvertProcessToGlobal = "An instance with a lifetime of Process can only be accessed from a PerformanceCounter with the InstanceLifetime set to PerformanceCounterInstanceLifetime.Process.";
    static string CantConvertGlobalToProcess = "An instance with a lifetime of Global can only be accessed from a PerformanceCounter with the InstanceLifetime set to PerformanceCounterInstanceLifetime.Global.";
    static string PCNotSupportedUnderAppContainer = "Writeable performance counters are not allowed when running in AppContainer.";
    static string PriorityClassNotSupported = "The AboveNormal and BelowNormal priority classes are not available on this platform.";
    static string WinNTRequired = "Feature requires Windows NT.";
    static string Win2kRequired = "Feature requires Windows 2000.";
    static string NoAssociatedProcess = "No process is associated with this object.";
    static string ProcessIdRequired = "Feature requires a process identifier.";
    static string NotSupportedRemote = "Feature is not supported for remote machines.";
    static string NoProcessInfo = "Process has exited, so the requested information is not available.";
    static string WaitTillExit = "Process must exit before requested information can be determined.";
    static string NoProcessHandle = "Process was not started by this object, so requested information cannot be determined.";
    static string MissingProccess = "Process with an Id of {0} is not running.";
    static string BadMinWorkset = "Minimum working set size is invalid. It must be less than or equal to the maximum working set size.";
    static string BadMaxWorkset = "Maximum working set size is invalid. It must be greater than or equal to the minimum working set size.";
    static string WinNTRequiredForRemote = "Operating system does not support accessing processes on remote computers. This feature requires Windows NT or later.";
    static string ProcessHasExited = "Cannot process request because the process ({0}) has exited.";
    static string ProcessHasExitedNoId = "Cannot process request because the process has exited.";
    static string ThreadExited = "The request cannot be processed because the thread ({0}) has exited.";
    static string Win2000Required = "Feature requires Windows 2000 or later.";
    static string ProcessNotFound = "Thread {0} found, but no process {1} found.";
    static string CantGetProcessId = "Cannot retrieve process identifier from the process handle.";
    static string ProcessDisabled = "Process performance counter is disabled, so the requested operation cannot be performed.";
    static string WaitReasonUnavailable = "WaitReason is only available if the ThreadState is Wait.";
    static string NotSupportedRemoteThread = "Feature is not supported for threads on remote computers.";
    static string UseShellExecuteRequiresSTA = "Current thread is not in Single Thread Apartment (STA) mode. Starting a process with UseShellExecute set to True requires the current thread be in STA mode.  Ensure that your Main function has STAThreadAttribute marked.";
    static string CantRedirectStreams = "The Process object must have the UseShellExecute property set to false in order to redirect IO streams.";
    static string CantUseEnvVars = "The Process object must have the UseShellExecute property set to false in order to use environment variables.";
    static string CantStartAsUser = "The Process object must have the UseShellExecute property set to false in order to start a process as a user.";
    static string CouldntConnectToRemoteMachine = "Couldn't connect to remote machine.";
    static string CouldntGetProcessInfos = "Couldn't get process information from performance counter.";
    static string InputIdleUnkownError = "WaitForInputIdle failed.  This could be because the process does not have a graphical interface.";
    static string FileNameMissing = "Cannot start process because a file name has not been provided.";
    static string EnvironmentBlock = "The environment block provided doesn't have the correct format.";
    static string EnumProcessModuleFailed = "Unable to enumerate the process modules.";
    static string EnumProcessModuleFailedDueToWow = "A 32 bit processes cannot access modules of a 64 bit process.";
    static string PendingAsyncOperation = "An async read operation has already been started on the stream.";
    static string NoAsyncOperation = "No async read operation is in progress on the stream.";
    static string InvalidApplication = "The specified executable is not a valid application for this OS platform.";
    static string StandardOutputEncodingNotAllowed = "StandardOutputEncoding is only supported when standard output is redirected.";
    static string StandardErrorEncodingNotAllowed = "StandardErrorEncoding is only supported when standard error is redirected.";
    static string CountersOOM = "Custom counters file view is out of memory.";
    static string MappingCorrupted = "Cannot continue the current operation, the performance counters memory mapping has been corrupted.";
    static string SetSecurityDescriptorFailed = "Cannot initialize security descriptor initialized.";
    static string CantCreateFileMapping = "Cannot create file mapping.";
    static string CantMapFileView = "Cannot map view of file.";
    static string CantGetMappingSize = "Cannot calculate the size of the file view.";
    static string CantGetStandardOut = "StandardOut has not been redirected or the process hasn't started yet.";
    static string CantGetStandardIn = "StandardIn has not been redirected.";
    static string CantGetStandardError = "StandardError has not been redirected.";
    static string CantMixSyncAsyncOperation = "Cannot mix synchronous and asynchronous operation on process stream.";
    static string NoFileMappingSize = "Cannot retrieve file mapping size while initializing configuration settings.";
    static string EnvironmentBlockTooLong = "The environment block used to start a process cannot be longer than 65535 bytes.  Your environment block is {0} bytes long.  Remove some environment variables and try again.";
    static string Arg_SecurityException = "The port name cannot start with '\'.";
    static string ArgumentNull_Array = "Array cannot be null.";
    static string ArgumentNull_Buffer = "Buffer cannot be null.";
    static string IO_UnknownError = "Unknown Error '{0}'.";
    static string NotSupported_UnwritableStream = "Stream does not support writing.";
    static string ObjectDisposed_WriterClosed = "Can not write to a closed TextWriter.";
    static string NotSupportedOS = "GetPortNames is not supported on Win9x platforms.";
    static string BaudRate = "The baud rate to use on this serial port.";
    static string DataBits = "The number of data bits per transmitted/received byte.";
    static string DiscardNull = "Whether to discard null bytes received on the port before adding to serial buffer.";
    static string DtrEnable = "Whether to enable the Data Terminal Ready (DTR) line during communications.";
    static string EncodingMonitoringDescription = "The encoding to use when reading and writing strings.";
    static string Handshake = "The handshaking protocol for flow control in data exchange, which can be None.";
    static string NewLine = "The string used by ReadLine and WriteLine to denote a new line.";
    static string Parity = "The scheme for parity checking each received byte and marking each transmitted byte.";
    static string ParityReplace = "Byte with which to replace bytes received with parity errors.";
    static string PortName = "The name of the communications port to open.";
    static string ReadBufferSize = "The size of the read buffer in bytes.  This is the maximum number of read bytes which can be buffered.";
    static string ReadTimeout = "The read timeout in Milliseconds.";
    static string ReceivedBytesThreshold = "Number of bytes required to be available before the Read event is fired.";
    static string RtsEnable = "Whether to enable the Request To Send (RTS) line during communications.";
    static string SerialPortDesc = "Represents a serial port resource.";
    static string StopBits = "The number of stop bits per transmitted/received byte.";
    static string WriteBufferSize = "The size of the write buffer in bytes.  This is the maximum number of bytes which can be queued for write.";
    static string WriteTimeout = "The write timeout in milliseconds.";
    static string SerialErrorReceived = "Raised each time when an error is received from the SerialPort.";
    static string SerialPinChanged = "Raised each time when pin is changed on the SerialPort.";
    static string SerialDataReceived = "Raised each time when data is received from the SerialPort.";
    static string CounterType = "The type of this counter.";
    static string CounterName = "The name of this counter.";
    static string CounterHelp = "Help information for this counter.";
    static string EventLogDesc = "Provides interaction with Windows event logs.";
    static string ErrorDataReceived = "User event handler to call for async IO with StandardError stream.";
    static string LogEntries = "The contents of the log.";
    static string LogLog = "Gets or sets the name of the log to read from and write to.";
    static string LogMachineName = "The name of the machine on which to read or write events.";
    static string LogMonitoring = "Indicates if the component monitors the event log for changes.";
    static string LogSynchronizingObject = "The object used to marshal the event handler calls issued as a result of an EventLog change.";
    static string LogSource = "The application name (source name) to use when writing to the event log.";
    static string LogEntryWritten = "Raised each time any application writes an entry to the event log.";
    static string LogEntryMachineName = "The machine on which this event log resides.";
    static string LogEntryData = "The binary data associated with this entry in the event log.";
    static string LogEntryIndex = "The sequence of this entry in the event log.";
    static string LogEntryCategory = "The category for this message.";
    static string LogEntryCategoryNumber = "An application-specific category number assigned to this entry.";
    static string LogEntryEventID = "The number identifying the message for this source.";
    static string LogEntryEntryType = "The type of entry - Information, Warning, etc.";
    static string LogEntryMessage = "The text of the message for this entry";
    static string LogEntrySource = "The name of the application that wrote this entry.";
    static string LogEntryReplacementStrings = "The application-supplied strings used in the message.";
    static string LogEntryResourceId = "The full number identifying the message in the event message dll.";
    static string LogEntryTimeGenerated = "The time at which the application logged this entry.";
    static string LogEntryTimeWritten = "The time at which the system logged this entry to the event log.";
    static string LogEntryUserName = "The username of the account associated with this entry by the writing application.";
    static string OutputDataReceived = "User event handler to call for async IO with StandardOutput stream.";
    static string PC_CounterHelp = "The description message for this counter.";
    static string PC_CounterType = "The counter type indicates how to interpret the value of the counter, for example an actual count or a rate of change.";
    static string PC_ReadOnly = "Indicates if the counter is read only.  Remote counters and counters not created using this component are read-only.";
    static string PC_RawValue = "Directly accesses the raw value of this counter.  The counter must have been created using this component.";
    static string ProcessAssociated = "Indicates if the process component is associated with a real process.";
    static string ProcessDesc = "Provides access to local and remote processes, enabling starting and stopping of local processes.";
    static string ProcessExitCode = "The value returned from the associated process when it terminated.";
    static string ProcessTerminated = "Indicates if the associated process has been terminated.";
    static string ProcessExitTime = "The time that the associated process exited.";
    static string ProcessHandle = "Returns the native handle for this process.   The handle is only available if the process was started using this component.";
    static string ProcessHandleCount = "The number of native handles associated with this process.";
    static string ProcessId = "The unique identifier for the process.";
    static string ProcessMachineName = "The name of the machine the running the process.";
    static string ProcessMainModule = "The main module for the associated process.";
    static string ProcessModules = "The modules that have been loaded by the associated process.";
    static string ProcessSynchronizingObject = "The object used to marshal the event handler calls issued as a result of a Process exit.";
    static string ProcessSessionId = "The identifier for the session of the process.";
    static string ProcessThreads = "The threads running in the associated process.";
    static string ProcessEnableRaisingEvents = "Whether the process component should watch for the associated process to exit, and raise the Exited event.";
    static string ProcessExited = "If the WatchForExit property is set to true, then this event is raised when the associated process exits.";
    static string ProcessFileName = "The name of the application, document or URL to start.";
    static string ProcessWorkingDirectory = "The initial working directory for the process.";
    static string ProcessBasePriority = "The base priority computed based on the priority class that all threads run relative to.";
    static string ProcessMainWindowHandle = "The handle of the main window for the process.";
    static string ProcessMainWindowTitle = "The caption of the main window for the process.";
    static string ProcessMaxWorkingSet = "The maximum amount of physical memory the process has required since it was started.";
    static string ProcessMinWorkingSet = "The minimum amount of physical memory the process has required since it was started.";
    static string ProcessNonpagedSystemMemorySize = "The number of bytes of non pageable system  memory the process is using.";
    static string ProcessPagedMemorySize = "The current amount of memory that can be paged to disk that the process is using.";
    static string ProcessPagedSystemMemorySize = "The number of bytes of pageable system memory the process is using.";
    static string ProcessPeakPagedMemorySize = "The maximum amount of memory that can be paged to disk that the process has used since it was started.";
    static string ProcessPeakWorkingSet = "The maximum amount of physical memory the process has used since it was started.";
    static string ProcessPeakVirtualMemorySize = "The maximum amount of virtual memory the process has allocated since it was started.";
    static string ProcessPriorityBoostEnabled = "Whether this process would like a priority boost when the user interacts with it.";
    static string ProcessPriorityClass = "The priority that the threads in the process run relative to.";
    static string ProcessPrivateMemorySize = "The current amount of memory that the process has allocated that cannot be shared with other processes.";
    static string ProcessPrivilegedProcessorTime = "The amount of CPU time the process spent inside the operating system core.";
    static string ProcessProcessName = "The name of the process.";
    static string ProcessProcessorAffinity = "A bit mask which represents the processors that the threads within the process are allowed to run on.";
    static string ProcessResponding = "Whether this process is currently responding.";
    static string ProcessStandardError = "Standard error stream of the process.";
    static string ProcessStandardInput = "Standard input stream of the process.";
    static string ProcessStandardOutput = "Standard output stream of the process.";
    static string ProcessStartInfo = "Specifies information used to start a process.";
    static string ProcessStartTime = "The time at which the process was started.";
    static string ProcessTotalProcessorTime = "The amount of CPU time the process has used.";
    static string ProcessUserProcessorTime = "The amount of CPU time the process spent outside the operating system core.";
    static string ProcessVirtualMemorySize = "The amount of virtual memory the process has currently allocated.";
    static string ProcessWorkingSet = "The current amount of physical memory the process is using.";
    static string ProcModModuleName = "The name of the module.";
    static string ProcModFileName = "The file name of the module.";
    static string ProcModBaseAddress = "The memory address that the module loaded at.";
    static string ProcModModuleMemorySize = "The amount of virtual memory required by the code and data in the module file.";
    static string ProcModEntryPointAddress = "The memory address of the function that runs when the module is loaded.";
    static string ProcessVerb = "The verb to apply to the document specified by the FileName property.";
    static string ProcessArguments = "Command line arguments that will be passed to the application specified by the FileName property.";
    static string ProcessErrorDialog = "Whether to show an error dialog to the user if there is an error.";
    static string ProcessWindowStyle = "How the main window should be created when the process starts.";
    static string ProcessCreateNoWindow = "Whether to start the process without creating a new window to contain it.";
    static string ProcessEnvironmentVariables = "Set of environment variables that apply to this process and child processes.";
    static string ProcessRedirectStandardInput = "Whether the process command input is read from the Process instance's StandardInput member.";
    static string ProcessRedirectStandardOutput = "Whether the process output is written to the Process instance's StandardOutput member.";
    static string ProcessRedirectStandardError = "Whether the process's error output is written to the Process instance's StandardError member.";
    static string ProcessUseShellExecute = "Whether to use the operating system shell to start the process.";
    static string ThreadBasePriority = "The current base priority of the thread.";
    static string ThreadCurrentPriority = "The current priority level of the thread.";
    static string ThreadId = "The unique identifier for the thread.";
    static string ThreadPriorityBoostEnabled = "Whether the thread would like a priority boost when the user interacts with UI associated with the thread.";
    static string ThreadPriorityLevel = "The priority level of the thread.";
    static string ThreadPrivilegedProcessorTime = "The amount of CPU time the thread spent inside the operating system core.";
    static string ThreadStartAddress = "The memory address of the function that was run when the thread started.";
    static string ThreadStartTime = "The time the thread was started.";
    static string ThreadThreadState = "The execution state of the thread.";
    static string ThreadTotalProcessorTime = "The amount of CPU time the thread has consumed since it was started.";
    static string ThreadUserProcessorTime = "The amount of CPU time the thread spent outside the operating system core.";
    static string ThreadWaitReason = "The reason the thread is waiting, if it is waiting.";
    static string VerbEditorDefault = "(Default)";
    static string AppSettingsReaderNoKey = "The key '{0}' does not exist in the appSettings configuration section.";
    static string AppSettingsReaderNoParser = "Type '{0}' does not have a Parse method.";
    static string AppSettingsReaderCantParse = "The value '{0}' was found in the appSettings configuration section for key '{1}', and this value is not a valid {2}.";
    static string AppSettingsReaderEmptyString = "(empty string)";
    static string InvalidPermissionState = "Invalid permission state.";
    static string PermissionNumberOfElements = "The number of elements on the access path must be the same as the number of tag names.";
    static string PermissionItemExists = "The item provided already exists.";
    static string PermissionItemDoesntExist = "The requested item doesn't exist.";
    static string PermissionBadParameterEnum = "Parameter must be of type enum.";
    static string PermissionInvalidLength = "Length must be greater than {0}.";
    static string PermissionTypeMismatch = "Type mismatch.";
    static string Argument_NotAPermissionElement = "'securityElement' was not a permission element.";
    static string Argument_InvalidXMLBadVersion = "Invalid Xml - can only parse elements of version one.";
    static string InvalidPermissionLevel = "Invalid permission level.";
    static string TargetNotWebBrowserPermissionLevel = "Target not WebBrowserPermissionLevel.";
    static string WebBrowserBadXml = "Bad Xml {0}";
    static string KeyedCollNeedNonNegativeNum = "Need a non negative number for capacity.";
    static string KeyedCollDuplicateKey = "Cannot add item since the item with the key already exists in the collection.";
    static string KeyedCollReferenceKeyNotFound = "The key reference with respect to which the insertion operation was to be performed was not found.";
    static string KeyedCollKeyNotFound = "Cannot find the key {0} in the collection.";
    static string KeyedCollInvalidKey = "Keys must be non-null non-empty Strings.";
    static string KeyedCollCapacityOverflow = "Capacity overflowed and went negative.  Check capacity of the collection.";
    static string OrderedDictionary_ReadOnly = "The OrderedDictionary is readonly and cannot be modified.";
    static string OrderedDictionary_SerializationMismatch = "There was an error deserializing the OrderedDictionary.  The ArrayList does not contain DictionaryEntries.";
    static string Async_ExceptionOccurred = "An exception occurred during the operation, making the result invalid.  Check InnerException for exception details.";
    static string Async_QueueingFailed = "Queuing WaitCallback failed.";
    static string Async_OperationCancelled = "Operation has been cancelled.";
    static string Async_OperationAlreadyCompleted = "This operation has already had OperationCompleted called on it and further calls are illegal.";
    static string Async_NullDelegate = "A non-null SendOrPostCallback must be supplied.";
    static string BackgroundWorker_AlreadyRunning = "BackgroundWorker is already running.";
    static string BackgroundWorker_CancellationNotSupported = "BackgroundWorker does not support cancellation.";
    static string BackgroundWorker_OperationCompleted = "Operation has already been completed.";
    static string BackgroundWorker_ProgressNotSupported = "BackgroundWorker does not support progress.";
    static string BackgroundWorker_WorkerAlreadyRunning = "This BackgroundWorker is currently busy and cannot run multiple tasks concurrently.";
    static string BackgroundWorker_WorkerDoesntReportProgress = "This BackgroundWorker states that it doesn't report progress. Modify WorkerReportsProgress to state that it does report progress.";
    static string BackgroundWorker_WorkerDoesntSupportCancellation = "This BackgroundWorker states that it doesn't support cancellation. Modify WorkerSupportsCancellation to state that it does support cancellation.";
    static string Async_ProgressChangedEventArgs_ProgressPercentage = "Percentage progress made in operation.";
    static string Async_ProgressChangedEventArgs_UserState = "User-supplied state to identify operation.";
    static string Async_AsyncEventArgs_Cancelled = "True if operation was cancelled.";
    static string Async_AsyncEventArgs_Error = "Exception that occurred during operation.  Null if no error.";
    static string Async_AsyncEventArgs_UserState = "User-supplied state to identify operation.";
    static string BackgroundWorker_CancellationPending = "Has the user attempted to cancel the operation? To be accessed from DoWork event handler.";
    static string BackgroundWorker_DoWork = "Event handler to be run on a different thread when the operation begins.";
    static string BackgroundWorker_IsBusy = "Is the worker still currently working on a background operation?";
    static string BackgroundWorker_ProgressChanged = "Raised when the worker thread indicates that some progress has been made.";
    static string BackgroundWorker_RunWorkerCompleted = "Raised when the worker has completed (either through success, failure, or cancellation).";
    static string BackgroundWorker_WorkerReportsProgress = "Whether the worker will report progress.";
    static string BackgroundWorker_WorkerSupportsCancellation = "Whether the worker supports cancellation.";
    static string BackgroundWorker_DoWorkEventArgs_Argument = "Argument passed into the worker handler from BackgroundWorker.RunWorkerAsync.";
    static string BackgroundWorker_DoWorkEventArgs_Result = "Result from the worker function.";
    static string BackgroundWorker_Desc = "Executes an operation on a separate thread.";
    static string InstanceCreationEditorDefaultText = "(New...)";
    static string PropertyTabAttributeBadPropertyTabScope = "Scope must be PropertyTabScope.Document or PropertyTabScope.Component";
    static string PropertyTabAttributeTypeLoadException = "Couldn't find type {0}";
    static string PropertyTabAttributeArrayLengthMismatch = "tabClasses must have the same number of items as tabScopes";
    static string PropertyTabAttributeParamsBothNull = "An array of tab type names or tab types must be specified";
    static string InstanceDescriptorCannotBeStatic = "Parameter cannot be static.";
    static string InstanceDescriptorMustBeStatic = "Parameter must be static.";
    static string InstanceDescriptorMustBeReadable = "Parameter must be readable.";
    static string InstanceDescriptorLengthMismatch = "Length mismatch.";
    static string ToolboxItemAttributeFailedGetType = "Failed to create ToolboxItem of type: {0}";
    static string PropertyDescriptorCollectionBadValue = "Parameter must be of type PropertyDescriptor.";
    static string PropertyDescriptorCollectionBadKey = "Parameter must be of type int or string.";
    static string AspNetHostingPermissionBadXml = "Bad Xml {0}";
    static string CorruptedGZipHeader = "The magic number in GZip header is not correct. Make sure you are passing in a GZip stream.";
    static string UnknownCompressionMode = "The compression mode specified in GZip header is unknown.";
    static string UnknownState = "Decoder is in some unknown state. This might be caused by corrupted data.";
    static string InvalidHuffmanData = "Failed to construct a huffman tree using the length array. The stream might be corrupted.";
    static string InvalidCRC = "The CRC in GZip footer does not match the CRC calculated from the decompressed data.";
    static string InvalidStreamSize = "The stream size in GZip footer does not match the real stream size.";
    static string UnknownBlockType = "Unknown block type. Stream might be corrupted.";
    static string InvalidBlockLength = "Block length does not match with its complement.";
    static string GenericInvalidData = "Found invalid data while decoding.";
    static string CannotReadFromDeflateStream = "Reading from the compression stream is not supported.";
    static string CannotWriteToDeflateStream = "Writing to the compression stream is not supported.";
    static string NotReadableStream = "The base stream is not readable.";
    static string NotWriteableStream = "The base stream is not writeable.";
    static string InvalidArgumentOffsetCount = "Offset plus count is larger than the length of target array.";
    static string InvalidBeginCall = "Only one asynchronous reader is allowed time at one time.";
    static string InvalidEndCall = "EndRead is only callable when there is one pending asynchronous reader.";
    static string StreamSizeOverflow = "The gzip stream can't contain more than 4GB data.";
    static string ZLibErrorDLLLoadError = "The underlying compression routine could not be loaded correctly.";
    static string ZLibErrorUnexpected = "The underlying compression routine returned an unexpected error code.";
    static string ZLibErrorInconsistentStream = "The stream state of the underlying compression routine is inconsistent.";
    static string ZLibErrorSteamFreedPrematurely = "The stream state of the underlying compression routine was freed prematurely.";
    static string ZLibErrorNotEnoughMemory = "The underlying compression routine could not reserve sufficient memory.";
    static string ZLibErrorIncorrectInitParameters = "The underlying compression routine received incorrect initialization parameters.";
    static string ZLibErrorVersionMismatch = "The version of the underlying compression routine does not match expected version.";
    static string InvalidOperation_HCCountOverflow = "Handle collector count overflows or underflows.";
    static string Argument_InvalidThreshold = "maximumThreshold cannot be less than initialThreshold.";
    static string Argument_SemaphoreInitialMaximum = "The initial count for the semaphore must be greater than or equal to zero and less than the maximum count.";
    static string Argument_WaitHandleNameTooLong = "The name can be no more than 260 characters in length.";
    static string WaitHandleCannotBeOpenedException_InvalidHandle = "A WaitHandle with system-wide name '{0}' cannot be created. A WaitHandle of a different type might have the same name.";
    static string ArgumentNotAPermissionElement = "Argument was not a permission Element.";
    static string ArgumentWrongType = "Argument should be of type {0}.";
    static string BadXmlVersion = "Xml version was wrong.";
    static string BinarySerializationNotSupported = "Binary serialization is current not supported by the LocalFileSettingsProvider.";
    static string BothScopeAttributes = "The setting {0} has both an ApplicationScopedSettingAttribute and a UserScopedSettingAttribute.";
    static string NoScopeAttributes = "The setting {0} does not have either an ApplicationScopedSettingAttribute or UserScopedSettingAttribute.";
    static string PositionOutOfRange = "Position cannot be less than zero.";
    static string ProviderInstantiationFailed = "Failed to instantiate provider: {0}.";
    static string ProviderTypeLoadFailed = "Failed to load provider type: {0}.";
    static string SaveAppScopedNotSupported = "Error saving {0} - The LocalFileSettingsProvider does not support saving changes to application-scoped settings.";
    static string SettingsResetFailed = "Failed to reset settings: unable to access the configuration section.";
    static string SettingsSaveFailed = "Failed to save settings: {0}";
    static string SettingsSaveFailedNoSection = "Failed to save settings: unable to access the configuration section.";
    static string StringDeserializationFailed = "Could not use String deserialization for setting: {0}.";
    static string StringSerializationFailed = "Could not use String serialization for setting: {0}.";
    static string UnknownSerializationFormat = "Unknown serialization format specified.";
    static string UnknownSeekOrigin = "Unknown SeekOrigin specified.";
    static string UnknownUserLevel = "Unknown ConfigurationUserLevel specified.";
    static string UserSettingsNotSupported = "The current configuration system does not support user-scoped settings.";
    static string XmlDeserializationFailed = "Could not use Xml deserialization for setting: {0}.";
    static string XmlSerializationFailed = "Could not use Xml serialization for setting: {0}.";
    static string MemberRelationshipService_RelationshipNotSupported = "Relationships between {0}.{1} and {2}.{3} are not supported.";
    static string MaskedTextProviderPasswordAndPromptCharError = "The PasswordChar and PromptChar values cannot be the same.";
    static string MaskedTextProviderInvalidCharError = "The specified character value is not allowed for this property.";
    static string MaskedTextProviderMaskNullOrEmpty = "The Mask value cannot be null or empty.";
    static string MaskedTextProviderMaskInvalidChar = "The specified mask contains invalid characters.";
    static string StandardOleMarshalObjectGetMarshalerFailed = "Failed to get marshaler for IID {0}.";
    static string SoundAPIBadSoundLocation = "Could not determine a universal resource identifier for the sound location.";
    static string SoundAPIFileDoesNotExist = "Please be sure a sound file exists at the specified location.";
    static string SoundAPIFormatNotSupported = "Sound API only supports playing PCM wave files.";
    static string SoundAPIInvalidWaveFile = "The file located at {0} is not a valid wave file.";
    static string SoundAPIInvalidWaveHeader = "The wave header is corrupt.";
    static string SoundAPILoadTimedOut = "The request to load the wave file in memory timed out.";
    static string SoundAPILoadTimeout = "The LoadTimeout property of a SoundPlayer cannot be negative.";
    static string SoundAPIReadError = "There was an error reading the file located at {0}. Please make sure that a valid wave file exists at the specified location.";
    static string WrongActionForCtor = "Constructor supports only the '{0}' action.";
    static string MustBeResetAddOrRemoveActionForCtor = "Constructor only supports either a Reset, Add, or Remove action.";
    static string ResetActionRequiresNullItem = "Reset action must be initialized with no changed items.";
    static string ResetActionRequiresIndexMinus1 = "Reset action must be initialized with index -1.";
    static string IndexCannotBeNegative = "Index cannot be negative.";
    static string ObservableCollectionReentrancyNotAllowed = "Cannot change ObservableCollection during a CollectionChanged event.";
    static string Arg_ArgumentOutOfRangeException = "Specified argument was out of the range of valid values.";
    static string mono_net_io_shutdown = "mono_net_io_shutdown";
    static string mono_net_io_renegotiate = "mono_net_io_renegotiate";
    static string net_ssl_io_already_shutdown = "Write operations are not allowed after the channel was shutdown.";
    static string net_log_set_socketoption_reuseport_default_on = "net_log_set_socketoption_reuseport_default_on";
    static string net_log_set_socketoption_reuseport_not_supported = "net_log_set_socketoption_reuseport_not_supported";
    static string net_log_set_socketoption_reuseport = "net_log_set_socketoption_reuseport";
    static string net_ssl_app_protocols_invalid = "The application protocol list is invalid.";
    static string net_ssl_app_protocol_invalid = "The application protocol value is invalid.";
    static string net_conflicting_options = "The '{0}' option was already set in the SslStream constructor.";
    static string Arg_NonZeroLowerBound = "The lower bound of target array must be zero.";
    static string Arg_WrongType = "The value '{0}' is not of type '{1}' and cannot be used in this generic collection.";
    static string Arg_ArrayPlusOffTooSmall = "Destination array is not long enough to copy all the items in the collection. Check array index and length.";
    static string ArgumentOutOfRange_NeedNonNegNum = "Non-negative number required.";
    static string ArgumentOutOfRange_SmallCapacity = "capacity was less than the current size.";
    static string Argument_InvalidOffLen = "Offset and length were out of bounds for the array or count is greater than the number of elements from index to the end of the source collection.";
    static string Argument_AddingDuplicate = "An item with the same key has already been added. Key: {0}";
    static string InvalidOperation_ConcurrentOperationsNotSupported = "Operations that change non-concurrent collections must have exclusive access. A concurrent update was performed on this collection and corrupted its state. The collection's state is no longer correct.";
    static string InvalidOperation_EmptyQueue = "Queue empty.";
    static string InvalidOperation_EnumOpCantHappen = "Enumeration has either not started or has already finished.";
    static string InvalidOperation_EnumFailedVersion = "Collection was modified; enumeration operation may not execute.";
    static string InvalidOperation_EmptyStack = "Stack empty.";
    static string InvalidOperation_EnumNotStarted = "Enumeration has not started. Call MoveNext.";
    static string InvalidOperation_EnumEnded = "Enumeration already finished.";
    static string NotSupported_KeyCollectionSet = "Mutating a key collection derived from a dictionary is not allowed.";
    static string NotSupported_ValueCollectionSet = "Mutating a value collection derived from a dictionary is not allowed.";
    static string Arg_ArrayLengthsDiffer = "Array lengths must be the same.";
    static string Arg_BitArrayTypeUnsupported = "Only supported array types for CopyTo on BitArrays are Boolean[], Int32[] and Byte[].";
    static string Arg_HSCapacityOverflow = "HashSet capacity is too big.";
    static string Arg_HTCapacityOverflow = "Hashtable's capacity overflowed and went negative. Check load factor, capacity and the current size of the table.";
    static string Arg_InsufficientSpace = "Insufficient space in the target location to copy the information.";
    static string Arg_RankMultiDimNotSupported = "Only single dimensional arrays are supported for the requested action.";
    static string Argument_ArrayTooLarge = "The input array length must not exceed Int32.MaxValue / {0}. Otherwise BitArray.Length would exceed Int32.MaxValue.";
    static string Argument_InvalidArrayType = "Target array type is not compatible with the type of items in the collection.";
    static string ArgumentOutOfRange_BiggerThanCollection = "Must be less than or equal to the size of the collection.";
    static string ArgumentOutOfRange_Index = "Index was out of range. Must be non-negative and less than the size of the collection.";
    static string ExternalLinkedListNode = "The LinkedList node does not belong to current LinkedList.";
    static string LinkedListEmpty = "The LinkedList is empty.";
    static string LinkedListNodeIsAttached = "The LinkedList node already belongs to a LinkedList.";
    static string NotSupported_SortedListNestedWrite = "This operation is not supported on SortedList nested types because they require modifying the original SortedList.";
    static string SortedSet_LowerValueGreaterThanUpperValue = "Must be less than or equal to upperValue.";
    static string Serialization_InvalidOnDeser = "OnDeserialization method was called while the object was not being deserialized.";
    static string Serialization_MismatchedCount = "The serialized Count information doesn't match the number of items.";
    static string Serialization_MissingKeys = "The keys for this dictionary are missing.";
    static string Serialization_MissingValues = "The values for this dictionary are missing.";
    static string Arg_KeyNotFoundWithKey = "The given key '{0}' was not present in the dictionary.";
    static string BlockingCollection_Add_ConcurrentCompleteAdd = "CompleteAdding may not be used concurrently with additions to the collection.";
    static string BlockingCollection_Add_Failed = "The underlying collection didn't accept the item.";
    static string BlockingCollection_CantAddAnyWhenCompleted = "At least one of the specified collections is marked as complete with regards to additions.";
    static string BlockingCollection_CantTakeAnyWhenAllDone = "All collections are marked as complete with regards to additions.";
    static string BlockingCollection_CantTakeWhenDone = "The collection argument is empty and has been marked as complete with regards to additions.";
    static string BlockingCollection_Completed = "The collection has been marked as complete with regards to additions.";
    static string BlockingCollection_CopyTo_IncorrectType = "The array argument is of the incorrect type.";
    static string BlockingCollection_CopyTo_MultiDim = "The array argument is multidimensional.";
    static string BlockingCollection_CopyTo_NonNegative = "The index argument must be greater than or equal zero.";
    static string Collection_CopyTo_TooManyElems = "The number of elements in the collection is greater than the available space from index to the end of the destination array.";
    static string BlockingCollection_ctor_BoundedCapacityRange = "The boundedCapacity argument must be positive.";
    static string BlockingCollection_ctor_CountMoreThanCapacity = "The collection argument contains more items than are allowed by the boundedCapacity.";
    static string BlockingCollection_Disposed = "The collection has been disposed.";
    static string BlockingCollection_Take_CollectionModified = "The underlying collection was modified from outside of the BlockingCollection<T>.";
    static string BlockingCollection_TimeoutInvalid = "The specified timeout must represent a value between -1 and {0}, inclusive.";
    static string BlockingCollection_ValidateCollectionsArray_DispElems = "The collections argument contains at least one disposed element.";
    static string BlockingCollection_ValidateCollectionsArray_LargeSize = "The collections length is greater than the supported range for 32 bit machine.";
    static string BlockingCollection_ValidateCollectionsArray_NullElems = "The collections argument contains at least one null element.";
    static string BlockingCollection_ValidateCollectionsArray_ZeroSize = "The collections argument is a zero-length array.";
    static string Common_OperationCanceled = "The operation was canceled.";
    static string ConcurrentBag_Ctor_ArgumentNullException = "The collection argument is null.";
    static string ConcurrentBag_CopyTo_ArgumentNullException = "The array argument is null.";
    static string Collection_CopyTo_ArgumentOutOfRangeException = "The index argument must be greater than or equal zero.";
    static string ConcurrentCollection_SyncRoot_NotSupported = "The SyncRoot property may not be used for the synchronization of concurrent collections.";
    static string ConcurrentDictionary_ArrayIncorrectType = "The array is multidimensional, or the type parameter for the set cannot be cast automatically to the type of the destination array.";
    static string ConcurrentDictionary_SourceContainsDuplicateKeys = "The source argument contains duplicate keys.";
    static string ConcurrentDictionary_ConcurrencyLevelMustBePositive = "The concurrencyLevel argument must be positive.";
    static string ConcurrentDictionary_CapacityMustNotBeNegative = "The capacity argument must be greater than or equal to zero.";
    static string ConcurrentDictionary_IndexIsNegative = "The index argument is less than zero.";
    static string ConcurrentDictionary_ArrayNotLargeEnough = "The index is equal to or greater than the length of the array, or the number of elements in the dictionary is greater than the available space from index to the end of the destination array.";
    static string ConcurrentDictionary_KeyAlreadyExisted = "The key already existed in the dictionary.";
    static string ConcurrentDictionary_ItemKeyIsNull = "TKey is a reference type and item.Key is null.";
    static string ConcurrentDictionary_TypeOfKeyIncorrect = "The key was of an incorrect type for this dictionary.";
    static string ConcurrentDictionary_TypeOfValueIncorrect = "The value was of an incorrect type for this dictionary.";
    static string ConcurrentStack_PushPopRange_CountOutOfRange = "The count argument must be greater than or equal to zero.";
    static string ConcurrentStack_PushPopRange_InvalidCount = "The sum of the startIndex and count arguments must be less than or equal to the collection's Count.";
    static string ConcurrentStack_PushPopRange_StartOutOfRange = "The startIndex argument must be greater than or equal to zero.";
    static string Partitioner_DynamicPartitionsNotSupported = "Dynamic partitions are not supported by this partitioner.";
    static string PartitionerStatic_CanNotCallGetEnumeratorAfterSourceHasBeenDisposed = "Can not call GetEnumerator on partitions after the source enumerable is disposed";
    static string PartitionerStatic_CurrentCalledBeforeMoveNext = "MoveNext must be called at least once before calling Current.";
    static string ConcurrentBag_Enumerator_EnumerationNotStartedOrAlreadyFinished = "Enumeration has either not started or has already finished.";
    static string Argument_AddingDuplicate__ = "Item has already been added. Key in dictionary: '{0}'  Key being added: '{1}'";
    static string Argument_ImplementIComparable = "At least one object must implement IComparable.";
    static string Arg_RemoveArgNotFound = "Cannot remove the specified item because it was not found in the specified Collection.";
    static string ArgumentNull_Dictionary = "Dictionary cannot be null.";
    static string ArgumentOutOfRange_QueueGrowFactor = "Queue grow factor must be between {0} and {1}.";
    static string Array = "{0} Array";
    static string Collection = "(Collection)";
    static string none = "(none)";
    static string Null = "(null)";
    static string Text = "(Text)";
    static string InvalidColor = "Color '{0}' is not valid.";
    static string TextParseFailedFormat = "Text "{0}" cannot be parsed. The expected text format is "{1}".";
    static string PropertyValueInvalidEntry = "IDictionary parameter contains at least one entry that is not valid. Ensure all values are consistent with the object's properties.";
    static string ArgumentException_BufferNotFromPool = "The buffer is not associated with this pool and may not be returned to it.";
    static string Arg_FileIsDirectory_Name = "The target file '{0}' is a directory, not a file.";
    static string Arg_HandleNotAsync = "Handle does not support asynchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened synchronously (that is, it was not opened for overlapped I/O).";
    static string Arg_HandleNotSync = "Handle does not support synchronous operations. The parameters to the FileStream constructor may need to be changed to indicate that the handle was opened asynchronously (that is, it was opened explicitly for overlapped I/O).";
    static string Arg_InvalidFileAttrs = "Invalid File or Directory attributes value.";
    static string Arg_InvalidHandle = "Invalid handle.";
    static string Arg_InvalidSearchPattern = "Search pattern cannot contain '..' to move up directories and can be contained only internally in file/directory names, as in 'a..b'.";
    static string Arg_Path2IsRooted = "Second path fragment must not be a drive or UNC name.";
    static string Arg_PathIsVolume = "Path must not be a drive.";
    static string ArgumentNull_FileName = "File name cannot be null.";
    static string ArgumentNull_Path = "Path cannot be null.";
    static string ArgumentOutOfRange_Enum = "Enum value was out of legal range.";
    static string ArgumentOutOfRange_FileLengthTooBig = "Specified file length was too large for the file system.";
    static string ArgumentOutOfRange_NeedPosNum = "Positive number required.";
    static string Argument_EmptyFileName = "Empty file name is not legal.";
    static string Argument_EmptyPath = "Empty path name is not legal.";
    static string Argument_FileNotResized = "The stream's length cannot be changed.";
    static string Argument_InvalidAppendMode = "Append access can be requested only in write-only mode.";
    static string Argument_InvalidFileModeAndAccessCombo = "Combining FileMode: {0} with FileAccess: {1} is invalid.";
    static string Argument_InvalidPathChars = "Illegal characters in path '{0}'.";
    static string Argument_InvalidSeekOrigin = "Invalid seek origin.";
    static string Argument_InvalidSubPath = "The directory specified, '{0}', is not a subdirectory of '{1}'.";
    static string Argument_PathEmpty = "Path cannot be the empty string or all whitespace.";
    static string IO_AlreadyExists_Name = "Cannot create '{0}' because a file or directory with the same name already exists.";
    static string IO_BindHandleFailed = "BindHandle for ThreadPool failed on this handle.";
    static string IO_CannotCreateDirectory = "The specified directory '{0}' cannot be created.";
    static string IO_EOF_ReadBeyondEOF = "Unable to read beyond the end of the stream.";
    static string IO_FileCreateAlreadyExists = "Cannot create a file when that file already exists.";
    static string IO_FileExists_Name = "The file '{0}' already exists.";
    static string IO_FileNotFound = "Unable to find the specified file.";
    static string IO_FileNotFound_FileName = "Could not find file '{0}'.";
    static string IO_FileStreamHandlePosition = "The OS handle's position is not what FileStream expected. Do not use a handle simultaneously in one FileStream and in Win32 code or another FileStream. This may cause data loss.";
    static string IO_FileTooLong2GB = "The file is too long. This operation is currently limited to supporting files less than 2 gigabytes in size.";
    static string IO_FileTooLongOrHandleNotSync = "IO operation will not work. Most likely the file will become too long or the handle was not opened to support synchronous IO operations.";
    static string IO_PathNotFound_NoPathName = "Could not find a part of the path.";
    static string IO_PathNotFound_Path = "Could not find a part of the path '{0}'.";
    static string IO_PathTooLong = "The specified file name or path is too long, or a component of the specified path is too long.";
    static string IO_SeekAppendOverwrite = "Unable seek backward to overwrite data that previously existed in a file opened in Append mode.";
    static string IO_SetLengthAppendTruncate = "Unable to truncate data that previously existed in a file opened in Append mode.";
    static string IO_SharingViolation_File = "The process cannot access the file '{0}' because it is being used by another process.";
    static string IO_SharingViolation_NoFileName = "The process cannot access the file because it is being used by another process.";
    static string IO_SourceDestMustBeDifferent = "Source and destination path must be different.";
    static string IO_SourceDestMustHaveSameRoot = "Source and destination path must have identical roots. Move will not work across volumes.";
    static string IO_SyncOpOnUIThread = "Synchronous operations should not be performed on the UI thread.  Consider wrapping this method in Task.Run.";
    static string IO_UnknownFileName = "[Unknown]";
    static string IndexOutOfRange_IORaceCondition = "Probable I/O race condition detected while copying memory. The I/O package is not thread safe by default. In multithreaded applications, a stream must be accessed in a thread-safe way, such as a thread-safe wrapper returned by TextReader's or TextWriter's Synchronized methods. This also applies to classes like StreamWriter and StreamReader.";
    static string NotSupported_UnseekableStream = "Stream does not support seeking.";
    static string ObjectDisposed_FileClosed = "Cannot access a closed file.";
    static string UnauthorizedAccess_IODenied_NoPathName = "Access to the path is denied.";
    static string UnauthorizedAccess_IODenied_Path = "Access to the path '{0}' is denied.";
    static string ObjectDisposed_StreamClosed = "Cannot access a closed Stream.";
    static string PlatformNotSupported_FileEncryption = "File encryption is not supported on this platform.";
    static string IO_PathTooLong_Path = "The path '{0}' is too long, or a component of the specified path is too long.";
    static string InvalidDirName_NotExists = "The directory name '{0}' does not exist.";
    static string EventStream_FailedToStart = "Failed to start the EventStream";
    static string IOException_INotifyInstanceSystemLimitExceeded = "The system limit on the number of inotify instances has been reached.";
    static string IOException_INotifyInstanceUserLimitExceeded_Value = "The configured user limit ({0}) on the number of inotify instances has been reached.";
    static string IOException_INotifyWatchesUserLimitExceeded_Value = "The configured user limit ({0}) on the number of inotify watches has been reached.";
    static string IOException_INotifyInstanceUserLimitExceeded = "The configured user limit on the number of inotify instances has been reached.";
    static string IOException_INotifyWatchesUserLimitExceeded = "The configured user limit on the number of inotify watches has been reached.";
    static string BaseStream_Invalid_Not_Open = "The BaseStream is only available when the port is open.";
    static string PortNameEmpty_String = "The PortName cannot be empty.";
    static string Port_not_open = "The port is closed.";
    static string Port_already_open = "The port is already open.";
    static string Cant_be_set_when_open = "'{0}' cannot be set while the port is open.";
    static string Max_Baud = "The maximum baud rate for the device is {0}.";
    static string In_Break_State = "The port is in the break state and cannot be written to.";
    static string Write_timed_out = "The write timed out.";
    static string CantSetRtsWithHandshaking = "RtsEnable cannot be accessed if Handshake is set to RequestToSend or RequestToSendXOnXOff.";
    static string NotSupportedEncoding = "SerialPort does not support encoding '{0}'.  The supported encodings include ASCIIEncoding, UTF8Encoding, UnicodeEncoding, UTF32Encoding, and most single or double byte code pages.  For a complete list please see the documentation.";
    static string Arg_InvalidSerialPort = "The given port name does not start with COM/com or does not resolve to a valid serial port.";
    static string Arg_InvalidSerialPortExtended = "The given port name is invalid.  It may be a valid port, but not a serial port.";
    static string ArgumentOutOfRange_Bounds_Lower_Upper = "Argument must be between {0} and {1}.";
    static string ArgumentOutOfRange_NeedNonNegNumRequired = "Non-negative number required.";
    static string ArgumentOutOfRange_Timeout = "The timeout must be greater than or equal to -1.";
    static string ArgumentOutOfRange_WriteTimeout = "The timeout must be either a positive number or -1.";
    static string IO_OperationAborted = "The I/O operation has been aborted because of either a thread exit or an application request.";
    static string InvalidNullEmptyArgument = "Argument {0} cannot be null or zero-length.";
    static string Arg_WrongAsyncResult = "IAsyncResult object did not come from the corresponding async method on this type.";
    static string InvalidOperation_EndReadCalledMultiple = "EndRead can only be called once for each asynchronous operation.";
    static string InvalidOperation_EndWriteCalledMultiple = "EndWrite can only be called once for each asynchronous operation.";
    static string IO_PortNotFound = "The specified port does not exist.";
    static string IO_PortNotFoundFileName = "The port '{0}' does not exist.";
    static string PlatformNotSupported_IOPorts = "System.IO.Ports is currently only supported on Windows.";
    static string PlatformNotSupported_SerialPort_GetPortNames = "Enumeration of serial port names is not supported on the current platform.";
    static string NotSupported_CannotCallEqualsOnSpan = "Equals() on Span and ReadOnlySpan is not supported. Use operator== instead.";
    static string NotSupported_CannotCallGetHashCodeOnSpan = "GetHashCode() on Span and ReadOnlySpan is not supported.";
    static string Argument_InvalidTypeWithPointersNotSupported = "Cannot use type '{0}'. Only value types without pointers or references are supported.";
    static string Argument_DestinationTooShort = "Destination is too short.";
    static string MemoryDisposed = "Memory<T> has been disposed.";
    static string OutstandingReferences = "Release all references before disposing this instance.";
    static string Argument_BadFormatSpecifier = "Format specifier was invalid.";
    static string Argument_GWithPrecisionNotSupported = "The 'G' format combined with a precision is not supported.";
    static string Argument_CannotParsePrecision = "Characters following the format symbol must be a number of {0} or less.";
    static string Argument_PrecisionTooLarge = "Precision cannot be larger than {0}.";
    static string Argument_OverlapAlignmentMismatch = "Overlapping spans have mismatching alignment.";
    static string EndPositionNotReached = "End position was not reached during enumeration.";
    static string UnexpectedSegmentType = "Unexpected segment type.";
    static string net_log_listener_delegate_exception = "Sending 500 response, AuthenticationSchemeSelectorDelegate threw an exception: {0}.";
    static string net_log_listener_unsupported_authentication_scheme = "Received a request with an unsupported authentication scheme, Authorization:{0} SupportedSchemes:{1}.";
    static string net_log_listener_unmatched_authentication_scheme = "Received a request with an unmatched or no authentication scheme. AuthenticationSchemes:{0}, Authorization:{1}.";
    static string net_io_invalidasyncresult = "The IAsyncResult object was not returned from the corresponding asynchronous method on this class.";
    static string net_io_invalidendcall = "{0} can only be called once for each asynchronous operation.";
    static string net_listener_cannot_set_custom_cbt = "Custom channel bindings are not supported.";
    static string net_listener_detach_error = "Can't detach Url group from request queue. Status code: {0}.";
    static string net_listener_scheme = "Only Uri prefixes starting with 'http://' or 'https://' are supported.";
    static string net_listener_host = "Only Uri prefixes with a valid hostname are supported.";
    static string net_listener_not_supported = "The request is not supported.";
    static string net_listener_mustcall = "Please call the {0} method before calling this method.";
    static string net_listener_slash = "Only Uri prefixes ending in '/' are allowed.";
    static string net_listener_already = "Failed to listen on prefix '{0}' because it conflicts with an existing registration on the machine.";
    static string net_log_listener_no_cbt_disabled = "No channel binding check because extended protection is disabled.";
    static string net_log_listener_no_cbt_http = "No channel binding check for requests without a secure channel.";
    static string net_log_listener_no_cbt_trustedproxy = "No channel binding check for the trusted proxy scenario.";
    static string net_log_listener_cbt = "Channel binding check enabled.";
    static string net_log_listener_no_spn_kerberos = "No explicit service name check because Kerberos authentication already validates the service name.";
    static string net_log_listener_no_spn_disabled = "No service name check because extended protection is disabled.";
    static string net_log_listener_no_spn_cbt = "No service name check because the channel binding was already checked.";
    static string net_log_listener_no_spn_whensupported = "No service name check because the client did not provide a service name and the server was configured for PolicyEnforcement.WhenSupported.";
    static string net_log_listener_no_spn_loopback = "No service name check because the authentication was from a client on the local machine.";
    static string net_log_listener_spn = "Client provided service name '{0}'.";
    static string net_log_listener_spn_passed = "Service name check succeeded.";
    static string net_log_listener_spn_failed = "Service name check failed.";
    static string net_log_listener_spn_failed_always = "Service name check failed because the client did not provide a service name and the server was configured for PolicyEnforcement.Always.";
    static string net_log_listener_spn_failed_empty = "No acceptable service names were configured!";
    static string net_log_listener_spn_failed_dump = "Dumping acceptable service names:";
    static string net_log_listener_spn_add = "Adding default service name '{0}' from prefix '{1}'.";
    static string net_log_listener_spn_not_add = "No default service name added for prefix '{0}'.";
    static string net_log_listener_spn_remove = "Removing default service name '{0}' from prefix '{1}'.";
    static string net_log_listener_spn_not_remove = "No default service name removed for prefix '{0}'.";
    static string net_listener_no_spns = "No service names could be determined from the registered prefixes. Either add prefixes from which default service names can be derived or specify an ExtendedProtectionPolicy object which contains an explicit list of service names.";
    static string net_ssp_dont_support_cbt = "The Security Service Providers don't support extended protection. Please install the latest Security Service Providers update.";
    static string net_PropertyNotImplementedException = "This property is not implemented by this class.";
    static string net_array_too_small = "The target array is too small.";
    static string net_listener_mustcompletecall = "The in-progress method {0} must be completed first.";
    static string net_listener_invalid_cbt_type = "Querying the {0} Channel Binding is not supported.";
    static string net_listener_callinprogress = "Cannot re-call {0} while a previous call is still in progress.";
    static string net_log_listener_cant_create_uri = "Can't create Uri from string '{0}://{1}{2}{3}'.";
    static string net_log_listener_cant_convert_raw_path = "Can't convert Uri path '{0}' using encoding '{1}'.";
    static string net_log_listener_cant_convert_percent_value = "Can't convert percent encoded value '{0}'.";
    static string net_log_listener_cant_convert_to_utf8 = "Can't convert string '{0}' into UTF-8 bytes: {1}";
    static string net_log_listener_cant_convert_bytes = "Can't convert bytes '{0}' into UTF-16 characters: {1}";
    static string net_invalidstatus = "The status code must be exactly three digits.";
    static string net_WebHeaderInvalidControlChars = "Specified value has invalid Control characters.";
    static string net_rspsubmitted = "This operation cannot be performed after the response has been submitted.";
    static string net_nochunkuploadonhttp10 = "Chunked encoding upload is not supported on the HTTP/1.0 protocol.";
    static string net_cookie_exists = "Cookie already exists.";
    static string net_clsmall = "The Content-Length value must be greater than or equal to zero.";
    static string net_wrongversion = "Only HTTP/1.0 and HTTP/1.1 version requests are currently supported.";
    static string net_noseek = "This stream does not support seek operations.";
    static string net_writeonlystream = "The stream does not support reading.";
    static string net_entitytoobig = "Bytes to be written to the stream exceed the Content-Length bytes size specified.";
    static string net_io_notenoughbyteswritten = "Cannot close stream until all bytes are written.";
    static string net_listener_close_urlgroup_error = "Can't close Url group. Status code: {0}.";
    static string net_WebSockets_NativeSendResponseHeaders = "An error occurred when sending the WebSocket HTTP upgrade response during the {0} operation. The HRESULT returned is '{1}'";
    static string net_WebSockets_ClientAcceptingNoProtocols = "The WebSocket client did not request any protocols, but server attempted to accept '{0}' protocol(s). ";
    static string net_WebSockets_AcceptUnsupportedProtocol = "The WebSocket client request requested '{0}' protocol(s), but server is only accepting '{1}' protocol(s).";
    static string net_WebSockets_AcceptNotAWebSocket = "The {0} operation was called on an incoming request that did not specify a '{1}: {2}' header or the {2} header not contain '{3}'. {2} specified by the client was '{4}'.";
    static string net_WebSockets_AcceptHeaderNotFound = "The {0} operation was called on an incoming WebSocket request without required '{1}' header. ";
    static string net_WebSockets_AcceptUnsupportedWebSocketVersion = "The {0} operation was called on an incoming request with WebSocket version '{1}', expected '{2}'. ";
    static string net_WebSockets_InvalidEmptySubProtocol = "Empty string is not a valid subprotocol value. Please use \"null\" to specify no value.";
    static string net_WebSockets_InvalidCharInProtocolString = "The WebSocket protocol '{0}' is invalid because it contains the invalid character '{1}'.";
    static string net_WebSockets_ReasonNotNull = "The close status description '{0}' is invalid. When using close status code '{1}' the description must be null.";
    static string net_WebSockets_InvalidCloseStatusCode = "The close status code '{0}' is reserved for system use only and cannot be specified when calling this method.";
    static string net_WebSockets_InvalidCloseStatusDescription = "The close status description '{0}' is too long. The UTF8-representation of the status description must not be longer than {1} bytes.";
    static string net_WebSockets_ArgumentOutOfRange_TooSmall = "The argument must be a value greater than {0}.";
    static string net_WebSockets_ArgumentOutOfRange_TooBig = "The value of the '{0}' parameter ({1}) must be less than or equal to {2}.";
    static string net_WebSockets_UnsupportedPlatform = "The WebSocket protocol is not supported on this platform.";
    static string net_readonlystream = "The stream does not support writing.";
    static string net_WebSockets_InvalidState_ClosedOrAborted = "The '{0}' instance cannot be used for communication because it has been transitioned into the '{1}' state.";
    static string net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync = "The WebSocket is in an invalid state for this operation. The '{0}' method has already been called before on this instance. Use '{1}' instead to keep being able to receive data but close the output channel.";
    static string net_Websockets_AlreadyOneOutstandingOperation = "There is already one outstanding '{0}' call for this WebSocket instance. ReceiveAsync and SendAsync can be called simultaneously, but at most one outstanding operation for each of them is allowed at the same time.";
    static string net_WebSockets_InvalidMessageType = "The received message type '{2}' is invalid after calling {0}. {0} should only be used if no more data is expected from the remote endpoint. Use '{1}' instead to keep being able to receive data but close the output channel.";
    static string net_WebSockets_InvalidBufferType = "The buffer type '{0}' is invalid. Valid buffer types are: '{1}', '{2}', '{3}', '{4}', '{5}'.";
    static string net_WebSockets_ArgumentOutOfRange_InternalBuffer = "The byte array must have a length of at least '{0}' bytes.  ";
    static string net_WebSockets_Argument_InvalidMessageType = "The message type '{0}' is not allowed for the '{1}' operation. Valid message types are: '{2}, {3}'. To close the WebSocket, use the '{4}' operation instead. ";
    static string net_securitypackagesupport = "The requested security package is not supported.";
    static string net_log_operation_failed_with_error = "{0} failed with error {1}.";
    static string net_MethodNotImplementedException = "This method is not implemented by this class.";
    static string event_OperationReturnedSomething = "{0} returned {1}.";
    static string net_invalid_enum = "The specified value is not valid in the '{0}' enumeration.";
    static string net_auth_message_not_encrypted = "Protocol error: A received message contains a valid signature but it was not encrypted as required by the effective Protection Level.";
    static string SSPIInvalidHandleType = "'{0}' is not a supported handle type.";
    static string net_io_operation_aborted = "I/O operation aborted: '{0}'.";
    static string net_invalid_path = "Invalid path.";
    static string net_listener_auth_errors = "Authentication errors.";
    static string net_listener_close = "Listener closed.";
    static string net_invalid_port = "Invalid port in prefix.";
    static string net_WebSockets_InvalidState = "The WebSocket is in an invalid state ('{0}') for this operation. Valid states are: '{1}'";
    static string net_unknown_prefix = "The URI prefix is not recognized.";
    static string net_reqsubmitted = "This operation cannot be performed after the request has been submitted.";
    static string net_io_timeout_use_ge_zero = "Timeout can be only be set to 'System.Threading.Timeout.Infinite' or a value >= 0.";
    static string net_writestarted = "This property cannot be set after writing has started.";
    static string net_badmethod = "Cannot set null or blank methods on request.";
    static string net_servererror = "The remote server returned an error: ({0}) {1}.";
    static string net_reqaborted = "The request was aborted: The request was canceled.";
    static string net_OperationNotSupportedException = "This operation is not supported.";
    static string net_nouploadonget = "Cannot send a content-body with this verb-type.";
    static string net_repcall = "Cannot re-call BeginGetRequestStream/BeginGetResponse while a previous call is still in progress.";
    static string net_securityprotocolnotsupported = "The requested security protocol is not supported.";
    static string net_requestaborted = "The request was aborted: {0}.";
    static string net_webstatus_Timeout = "The operation has timed out.";
    static string net_baddate = "The value of the date string in the header is invalid.";
    static string net_connarg = "Keep-Alive and Close may not be set using this property.";
    static string net_fromto = "The From parameter cannot be less than To.";
    static string net_needchunked = "TransferEncoding requires the SendChunked property to be set to true.";
    static string net_no100 = "100-Continue may not be set using this property.";
    static string net_nochunked = "Chunked encoding must be set via the SendChunked property.";
    static string net_nottoken = "The supplied string is not a valid HTTP token.";
    static string net_rangetoosmall = "The From or To parameter cannot be less than 0.";
    static string net_rangetype = "A different range specifier has already been added to this request.";
    static string net_toosmall = "The specified value must be greater than 0.";
    static string net_WebHeaderInvalidCRLFChars = "Specified value has invalid CRLF characters.";
    static string net_WebHeaderInvalidHeaderChars = "Specified value has invalid HTTP Header characters.";
    static string net_timeout = "The operation has timed out.";
    static string net_completed_result = "This operation cannot be performed on a completed asynchronous result object.";
    static string net_PropertyNotSupportedException = "This property is not supported by this class.";
    static string net_InvalidStatusCode = "The server returned a status code outside the valid range of 100-599.";
    static string net_io_timeout_use_gt_zero = "Timeout can be only be set to 'System.Threading.Timeout.Infinite' or a value > 0.";
    static string net_ftp_servererror = "The remote server returned an error: {0}.";
    static string net_ftp_active_address_different = "The data connection was made from an address that is different than the address to which the FTP connection was made.";
    static string net_ftp_invalid_method_name = "FTP Method names cannot be null or empty.";
    static string net_ftp_invalid_renameto = "The RenameTo filename cannot be null or empty.";
    static string net_ftp_invalid_response_filename = "The server returned the filename ({0}) which is not valid.";
    static string net_ftp_invalid_status_response = "The status response ({0}) is not expected in response to '{1}' command.";
    static string net_ftp_invalid_uri = "The requested URI is invalid for this FTP command.";
    static string net_ftp_no_defaultcreds = "Default credentials are not supported on an FTP request.";
    static string net_ftp_response_invalid_format = "The response string '{0}' has invalid format.";
    static string net_ftp_server_failed_passive = "The server failed the passive mode request with status response ({0}).";
    static string net_ftp_unsupported_method = "This method is not supported.";
    static string net_ftp_protocolerror = "The underlying connection was closed: The server committed a protocol violation";
    static string net_ftp_receivefailure = "The underlying connection was closed: An unexpected error occurred on a receive";
    static string net_webstatus_NameResolutionFailure = "The remote name could not be resolved";
    static string net_webstatus_ConnectFailure = "Unable to connect to the remote server";
    static string net_ftpstatuscode_ServiceNotAvailable = "Service not available, closing control connection.";
    static string net_ftpstatuscode_CantOpenData = "Can't open data connection";
    static string net_ftpstatuscode_ConnectionClosed = "Connection closed; transfer aborted";
    static string net_ftpstatuscode_ActionNotTakenFileUnavailableOrBusy = "File unavailable (e.g., file busy)";
    static string net_ftpstatuscode_ActionAbortedLocalProcessingError = "Local error in processing";
    static string net_ftpstatuscode_ActionNotTakenInsufficientSpace = "Insufficient storage space in system";
    static string net_ftpstatuscode_CommandSyntaxError = "Syntax error, command unrecognized";
    static string net_ftpstatuscode_ArgumentSyntaxError = "Syntax error in parameters or arguments";
    static string net_ftpstatuscode_CommandNotImplemented = "Command not implemented";
    static string net_ftpstatuscode_BadCommandSequence = "Bad sequence of commands";
    static string net_ftpstatuscode_NotLoggedIn = "Not logged in";
    static string net_ftpstatuscode_AccountNeeded = "Need account for storing files";
    static string net_ftpstatuscode_ActionNotTakenFileUnavailable = "File unavailable (e.g., file not found, no access)";
    static string net_ftpstatuscode_ActionAbortedUnknownPageType = "Page type unknown";
    static string net_ftpstatuscode_FileActionAborted = "Exceeded storage allocation (for current directory or data set)";
    static string net_ftpstatuscode_ActionNotTakenFilenameNotAllowed = "File name not allowed";
    static string net_invalid_host = "The specified value is not a valid Host header string.";
    static string net_sockets_connect_multiconnect_notsupported = "Sockets on this platform are invalid for use after a failed connection attempt.";
    static string net_sockets_dualmode_receivefrom_notsupported = "This platform does not support packet information for dual-mode sockets.  If packet information is not required, use Socket.Receive.  If packet information is required set Socket.DualMode to false.";
    static string net_sockets_accept_receive_notsupported = "This platform does not support receiving data with Socket.AcceptAsync.  Instead, make a separate call to Socket.ReceiveAsync.";
    static string net_sockets_duplicateandclose_notsupported = "This platform does not support Socket.DuplicateAndClose.  Instead, create a new socket.";
    static string net_sockets_transmitfileoptions_notsupported = "This platform does not support TransmitFileOptions other than TransmitFileOptions.UseDefaultWorkerThread.";
    static string ArgumentOutOfRange_PathLengthInvalid = "The path '{0}' is of an invalid length for use with domain sockets on this platform.  The length must be between 1 and {1} characters, inclusive.";
    static string net_io_readwritefailure = "Unable to transfer data on the transport connection: {0}.";
    static string PlatformNotSupported_AcceptSocket = "Accepting into an existing Socket is not supported on this platform.";
    static string PlatformNotSupported_IOControl = "Socket.IOControl handles Windows-specific control codes and is not supported on this platform.";
    static string PlatformNotSupported_IPProtectionLevel = "IP protection level cannot be controlled on this platform.";
    static string InvalidOperation_BufferNotExplicitArray = "This operation may only be performed when the buffer was set using the SetBuffer overload that accepts an array.";
    static string InvalidOperation_IncorrectToken = "The result of the operation was already consumed and may not be used again.";
    static string InvalidOperation_MultipleContinuations = "Another continuation was already registered.";
    static string net_http_httpmethod_format_error = "The format of the HTTP method is invalid.";
    static string net_http_httpmethod_notsupported_error = "The HTTP method '{0}' is not supported on this platform.";
    static string net_http_reasonphrase_format_error = "The reason phrase must not contain new-line characters.";
    static string net_http_copyto_array_too_small = "The number of elements is greater than the available space from arrayIndex to the end of the destination array.";
    static string net_http_headers_not_found = "The given header was not found.";
    static string net_http_headers_single_value_header = "Cannot add value because header '{0}' does not support multiple values.";
    static string net_http_headers_invalid_header_name = "The header name format is invalid.";
    static string net_http_headers_invalid_value = "The format of value '{0}' is invalid.";
    static string net_http_headers_not_allowed_header_name = "Misused header name. Make sure request headers are used with HttpRequestMessage, response headers with HttpResponseMessage, and content headers with HttpContent objects.";
    static string net_http_headers_invalid_host_header = "The specified value is not a valid 'Host' header string.";
    static string net_http_headers_invalid_from_header = "The specified value is not a valid 'From' header string.";
    static string net_http_headers_invalid_etag_name = "The specified value is not a valid quoted string.";
    static string net_http_headers_invalid_range = "Invalid range. At least one of the two parameters must not be null.";
    static string net_http_headers_no_newlines = "New-line characters in header values must be followed by a white-space character.";
    static string net_http_content_buffersize_exceeded = "Cannot write more bytes to the buffer than the configured maximum buffer size: {0}.";
    static string net_http_content_no_task_returned = "The async operation did not return a System.Threading.Tasks.Task object.";
    static string net_http_content_stream_already_read = "The stream was already consumed. It cannot be read again.";
    static string net_http_content_readonly_stream = "The stream does not support writing.";
    static string net_http_content_invalid_charset = "The character set provided in ContentType is invalid. Cannot read content as string using an invalid character set.";
    static string net_http_content_stream_copy_error = "Error while copying content to a stream.";
    static string net_http_argument_empty_string = "The value cannot be null or empty.";
    static string net_http_client_request_already_sent = "The request message was already sent. Cannot send the same request message multiple times.";
    static string net_http_operation_started = "This instance has already started one or more requests. Properties can only be modified before sending the first request.";
    static string net_http_client_execution_error = "An error occurred while sending the request.";
    static string net_http_client_absolute_baseaddress_required = "The base address must be an absolute URI.";
    static string net_http_client_invalid_requesturi = "An invalid request URI was provided. The request URI must either be an absolute URI or BaseAddress must be set.";
    static string net_http_client_http_baseaddress_required = "Only 'http' and 'https' schemes are allowed.";
    static string net_http_parser_invalid_base64_string = "Value '{0}' is not a valid Base64 string. Error: {1}";
    static string net_http_handler_noresponse = "Handler did not return a response message.";
    static string net_http_handler_norequest = "A request message must be provided. It cannot be null.";
    static string net_http_message_not_success_statuscode = "Response status code does not indicate success: {0} ({1}).";
    static string net_http_content_field_too_long = "The field cannot be longer than {0} characters.";
    static string net_http_log_headers_no_newlines = "Value for header '{0}' contains invalid new-line characters. Value: '{1}'.";
    static string net_http_log_headers_invalid_quality = "The 'q' value is invalid: '{0}'.";
    static string net_http_log_headers_wrong_email_format = "Value '{0}' is not a valid email address. Error: {1}";
    static string net_http_handler_not_assigned = "The inner handler has not been assigned.";
    static string net_http_invalid_enable_first = "The {0} property must be set to '{1}' to use this property.";
    static string net_http_content_buffersize_limit = "Buffering more than {0} bytes is not supported.";
    static string net_http_value_not_supported = "The value '{0}' is not supported for property '{1}'.";
    static string net_http_io_read = "The read operation failed, see inner exception.";
    static string net_http_io_read_incomplete = "Unable to read data from the transport connection. The connection was closed before all data could be read. Expected {0} bytes, read {1} bytes.";
    static string net_http_io_write = "The write operation failed, see inner exception.";
    static string net_http_chunked_not_allowed_with_empty_content = "'Transfer-Encoding: chunked' header can not be used when content object is not specified.";
    static string net_http_invalid_cookiecontainer = "When using CookieUsePolicy.UseSpecifiedCookieContainer, the CookieContainer property must not be null.";
    static string net_http_invalid_proxyusepolicy = "When using a non-null Proxy, the WindowsProxyUsePolicy property must be set to WindowsProxyUsePolicy.UseCustomProxy.";
    static string net_http_invalid_proxy = "When using WindowsProxyUsePolicy.UseCustomProxy, the Proxy property must not be null.";
    static string net_http_value_must_be_greater_than = "The specified value must be greater than {0}.";
    static string net_http_unix_invalid_credential = "The libcurl library in use ({0}) does not support different credentials for different authentication schemes.";
    static string net_http_unix_https_support_unavailable_libcurl = "The libcurl library in use ({0}) does not support HTTPS.";
    static string net_http_content_no_concurrent_reads = "The stream does not support concurrent read operations.";
    static string net_http_username_empty_string = "The username for a credential object cannot be null or empty.";
    static string net_http_no_concurrent_io_allowed = "The stream does not support concurrent I/O read or write operations.";
    static string net_http_invalid_response = "The server returned an invalid or unrecognized response.";
    static string net_http_unix_handler_disposed = "The handler was disposed of while active operations were in progress.";
    static string net_http_buffer_insufficient_length = "The buffer was not long enough.";
    static string net_http_response_headers_exceeded_length = "The HTTP response headers length exceeded the set limit of {0} bytes.";
    static string ArgumentOutOfRange_NeedNonNegativeNum = "Non-negative number required.";
    static string net_http_libcurl_callback_notsupported_sslbackend = "The handler does not support custom handling of certificates with this combination of libcurl ({0}) and its SSL backend ("{1}"). An SSL backend based on "{2}" is required. Consider using System.Net.Http.SocketsHttpHandler.";
    static string net_http_libcurl_callback_notsupported_os = "The handler does not support custom handling of certificates on this operating system. Consider using System.Net.Http.SocketsHttpHandler.";
    static string net_http_libcurl_clientcerts_notsupported_sslbackend = "The handler does not support client authentication certificates with this combination of libcurl ({0}) and its SSL backend ("{1}"). An SSL backend based on "{2}" is required. Consider using System.Net.Http.SocketsHttpHandler.";
    static string net_http_libcurl_clientcerts_notsupported_os = "The handler does not support client authentication certificates on this operating system. Consider using System.Net.Http.SocketsHttpHandler.";
    static string net_http_libcurl_revocation_notsupported_sslbackend = "The handler does not support changing revocation settings with this combination of libcurl ({0}) and its SSL backend ("{1}"). An SSL backend based on "{2}" is required. Consider using System.Net.Http.SocketsHttpHandler.";
    static string net_http_feature_requires_Windows10Version1607 = "Using this feature requires Windows 10 Version 1607.";
    static string net_http_feature_UWPClientCertSupportRequiresCertInPersonalCertificateStore = "Client certificate was not found in the personal (\"MY\") certificate store. In UWP, client certificates are only supported if they have been added to that certificate store.";
    static string net_http_invalid_proxy_scheme = "Only the 'http' scheme is allowed for proxies.";
    static string net_http_request_invalid_char_encoding = "Request headers must contain only ASCII characters.";
    static string net_http_ssl_connection_failed = "The SSL connection could not be established, see inner exception.";
    static string net_http_unsupported_chunking = "HTTP 1.0 does not support chunking.";
    static string net_http_unsupported_version = "Request HttpVersion 0.X is not supported.  Use 1.0 or above.";
    static string IO_SeekBeforeBegin = "An attempt was made to move the position before the beginning of the stream.";
    static string net_http_request_no_host = "CONNECT request must contain Host header.";
    static string net_http_winhttp_error = "Error {0} calling {1}, '{2}'.";
    static string net_http_authconnectionfailure = "Authentication failed because the connection could not be reused.";
    static string net_nego_server_not_supported = "Server implementation is not supported";
    static string net_nego_protection_level_not_supported = "Requested protection level is not supported with the gssapi implementation currently installed.";
    static string net_context_buffer_too_small = "Insufficient buffer space. Required: {0} Actual: {1}.";
    static string net_gssapi_operation_failed_detailed = "GSSAPI operation failed with error - {0} ({1}).";
    static string net_gssapi_operation_failed = "GSSAPI operation failed with status: {0} (Minor status: {1}).";
    static string net_nego_channel_binding_not_supported = "No support for channel binding on operating systems other than Windows.";
    static string net_ntlm_not_possible_default_cred = "NTLM authentication is not possible with default credentials on this platform.";
    static string net_nego_not_supported_empty_target_with_defaultcreds = "Target name should be non empty if default credentials are passed.";
    static string Arg_ElementsInSourceIsGreaterThanDestination = "Number of elements in source vector is greater than the destination array";
    static string Arg_NullArgumentNullRef = "The method was called with a null array argument.";
    static string Arg_TypeNotSupported = "Specified type is not supported";
    static string Arg_InsufficientNumberOfElements = "At least {0} element(s) are expected in the parameter "{1}".";
    static string NoMetadataTokenAvailable = "There is no metadata token available for the given member.";
    static string PlatformNotSupported_ReflectionTypeExtensions = "System.Reflection.TypeExtensions is not supported on NET Standard 1.3 or 1.5.";
    static string Argument_EmptyApplicationName = "ApplicationId cannot have an empty string for the name.";
    static string ArgumentOutOfRange_GenericPositive = "Value must be positive.";
    static string ArgumentOutOfRange_MustBePositive = "'{0}' must be greater than zero.";
    static string InvalidOperation_ComputerName = "Computer name could not be obtained.";
    static string InvalidOperation_GetVersion = "OSVersion's call to GetVersionEx failed";
    static string PersistedFiles_NoHomeDirectory = "The home directory of the current user could not be determined.";
    static string Argument_BadResourceScopeTypeBits = "Unknown value for the ResourceScope: {0}  Too many resource type bits may be set.";
    static string Argument_BadResourceScopeVisibilityBits = "Unknown value for the ResourceScope: {0}  Too many resource visibility bits may be set.";
    static string ArgumentNull_TypeRequiredByResourceScope = "The type parameter cannot be null when scoping the resource's visibility to Private or Assembly.";
    static string Argument_ResourceScopeWrongDirection = "Resource type in the ResourceScope enum is going from a more restrictive resource type to a more general one.  From: "{0}"  To: "{1}"";
    static string AppDomain_Name = "Name:";
    static string AppDomain_NoContextPolicies = "There are no context policies.";
    static string Arg_MustBeTrue = "Argument must be true.";
    static string Arg_CannotUnloadAppDomainException = "Attempt to unload the AppDomain failed.";
    static string Arg_AppDomainUnloadedException = "Attempted to access an unloaded AppDomain.";
    static string ZeroLengthString = "String cannot have zero length.";
    static string EntryPointNotFound = "Entry point not found in assembly";
    static string Arg_ContextMarshalException = "Attempted to marshal an object across a context boundary.";
    static string AppDomain_Policy_PrincipalTwice = "Default principal object cannot be set twice.";
    static string ArgumentNull_Collection = "Collection cannot be null.";
    static string ArgumentOutOfRange_ArrayListInsert = "Insertion index was out of range. Must be non-negative and less than or equal to size.";
    static string ArgumentOutOfRange_Count = "Count must be positive and count must refer to a location within the string/array/collection.";
    static string ArgumentOutOfRange_HashtableLoadFactor = "Load factor needs to be between 0.1 and 1.0.";
    static string ArgumentOutOfRange_MustBeNonNegNum = "'{0}' must be non-negative.";
    static string Arg_CannotMixComparisonInfrastructure = "The usage of IKeyComparer and IHashCodeProvider/IComparer interfaces cannot be mixed; use one or the other.";
    static string InvalidOperation_HashInsertFailed = "Hashtable insert failed. Load factor too high. The most common cause is multiple threads writing to the Hashtable simultaneously.";
    static string InvalidOperation_UnderlyingArrayListChanged = "This range in the underlying list is invalid. A possible cause is that elements were removed.";
    static string NotSupported_FixedSizeCollection = "Collection was of a fixed size.";
    static string NotSupported_RangeCollection = "The specified operation is not supported on Ranges.";
    static string NotSupported_ReadOnlyCollection = "Collection is read-only.";
    static string Serialization_KeyValueDifferentSizes = "The keys and values arrays have different sizes.";
    static string Serialization_NullKey = "One of the serialized keys is null.";
    static string NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed = "Cannot write to a BufferedStream while the read buffer is not empty if the underlying stream is not seekable. Ensure that the stream underlying this BufferedStream can seek or avoid interleaving read and write operations on this BufferedStream.";
    static string Argument_StreamNotReadable = "Stream was not readable.";
    static string Argument_StreamNotWritable = "Stream was not writable.";
    static string ObjectDisposed_ReaderClosed = "Cannot read from a closed TextReader.";
    static string ArgumentNull_Child = "Cannot have a null child.";
    static string Argument_AttributeNamesMustBeUnique = "Attribute names must be unique.";
    static string Argument_InvalidElementName = "Invalid element name '{0}'.";
    static string Argument_InvalidElementTag = "Invalid element tag '{0}'.";
    static string Argument_InvalidElementText = "Invalid element text '{0}'.";
    static string Argument_InvalidElementValue = "Invalid element value '{0}'.";
    static string Argument_InvalidFlag = "Value of flags is invalid.";
    static string PlatformNotSupported_AppDomains = "Secondary AppDomains are not supported on this platform.";
    static string PlatformNotSupported_CAS = "Code Access Security is not supported on this platform.";
    static string PlatformNotSupported_AppDomain_ResMon = "AppDomain resource monitoring is not supported on this platform.";
    static string Argument_EmptyValue = "Value cannot be empty.";
    static string PlatformNotSupported_RuntimeInformation = "RuntimeInformation is not supported for Portable Class Libraries.";
    static string Overflow_Negative_Unsigned = "Negative values do not have an unsigned representation.";
    static string Cryptography_Oid_InvalidName = "No OID value matches this name.";
    static string Cryptography_SSE_InvalidDataSize = "NoLength of the data to encrypt is invalid.";
    static string Cryptography_Der_Invalid_Encoding = "ASN1 corrupted data.";
    static string ObjectDisposed_Generic = "Cannot access a disposed object.";
    static string Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum = "ASN.1 Enumerated values only apply to enum types without the [Flags] attribute.";
    static string Cryptography_Asn_NamedBitListRequiresFlagsEnum = "Named bit list operations require an enum with the [Flags] attribute.";
    static string Cryptography_Asn_NamedBitListValueTooBig = "The encoded named bit list value is larger than the value size of the '{0}' enum.";
    static string Cryptography_Asn_UniversalValueIsFixed = "Tags with TagClass Universal must have the appropriate TagValue value for the data type being read or written.";
    static string Cryptography_Asn_UnusedBitCountRange = "Unused bit count must be between 0 and 7, inclusive.";
    static string Cryptography_AsnSerializer_AmbiguousFieldType = "Field '{0}' of type '{1}' has ambiguous type '{2}', an attribute derived from AsnTypeAttribute is required.";
    static string Cryptography_AsnSerializer_Choice_AllowNullNonNullable = "[Choice].AllowNull=true is not valid because type '{0}' cannot have a null value.";
    static string Cryptography_AsnSerializer_Choice_ConflictingTagMapping = "The tag ({0} {1}) for field '{2}' on type '{3}' already is associated in this context with field '{4}' on type '{5}'.";
    static string Cryptography_AsnSerializer_Choice_DefaultValueDisallowed = "Field '{0}' on [Choice] type '{1}' has a default value, which is not permitted.";
    static string Cryptography_AsnSerializer_Choice_NoChoiceWasMade = "An instance of [Choice] type '{0}' has no non-null fields.";
    static string Cryptography_AsnSerializer_Choice_NonNullableField = "Field '{0}' on [Choice] type '{1}' can not be assigned a null value.";
    static string Cryptography_AsnSerializer_Choice_TooManyValues = "Fields '{0}' and '{1}' on type '{2}' are both non-null when only one value is permitted.";
    static string Cryptography_AsnSerializer_Choice_TypeCycle = "Field '{0}' on [Choice] type '{1}' has introduced a type chain cycle.";
    static string Cryptography_AsnSerializer_MultipleAsnTypeAttributes = "Field '{0}' on type '{1}' has multiple attributes deriving from '{2}' when at most one is permitted.";
    static string Cryptography_AsnSerializer_NoJaggedArrays = "Type '{0}' cannot be serialized or deserialized because it is an array of arrays.";
    static string Cryptography_AsnSerializer_NoMultiDimensionalArrays = "Type '{0}' cannot be serialized or deserialized because it is a multi-dimensional array.";
    static string Cryptography_AsnSerializer_NoOpenTypes = "Type '{0}' cannot be serialized or deserialized because it is not sealed or has unbound generic parameters.";
    static string Cryptography_AsnSerializer_Optional_NonNullableField = "Field '{0}' on type '{1}' is declared [OptionalValue], but it can not be assigned a null value.";
    static string Cryptography_AsnSerializer_PopulateFriendlyNameOnString = "Field '{0}' on type '{1}' has [ObjectIdentifier].PopulateFriendlyName set to true, which is not applicable to a string.  Change the field to '{2}' or set PopulateFriendlyName to false.";
    static string Cryptography_AsnSerializer_SetValueException = "Unable to set field {0} on type {1}.";
    static string Cryptography_AsnSerializer_SpecificTagChoice = "Field '{0}' on type '{1}' has specified an implicit tag value via [ExpectedTag] for [Choice] type '{2}'. ExplicitTag must be true, or the [ExpectedTag] attribute removed.";
    static string Cryptography_AsnSerializer_UnexpectedTypeForAttribute = "Field '{0}' of type '{1}' has an effective type of '{2}' when one of ({3}) was expected.";
    static string Cryptography_AsnSerializer_UtcTimeTwoDigitYearMaxTooSmall = "Field '{0}' on type '{1}' has a [UtcTime] TwoDigitYearMax value ({2}) smaller than the minimum (99).";
    static string Cryptography_AsnSerializer_UnhandledType = "Could not determine how to serialize or deserialize type '{0}'.";
    static string Cryptography_AsnWriter_EncodeUnbalancedStack = "Encode cannot be called while a Sequence or SetOf is still open.";
    static string Cryptography_AsnWriter_PopWrongTag = "Cannot pop the requested tag as it is not currently in progress.";
    static string Cryptography_BadHashValue = "The hash value is not correct.";
    static string Cryptography_BadSignature = "Invalid signature.";
    static string Cryptography_Cms_CannotDetermineSignatureAlgorithm = "Could not determine signature algorithm for the signer certificate.";
    static string Cryptography_Cms_IncompleteCertChain = "The certificate chain is incomplete, the self-signed root authority could not be determined.";
    static string Cryptography_Cms_Invalid_Originator_Identifier_Choice = "Invalid originator identifier choice {0} found in decoded CMS.";
    static string Cryptography_Cms_InvalidMessageType = "Invalid cryptographic message type.";
    static string Cryptography_Cms_InvalidSignerHashForSignatureAlg = "SignerInfo digest algorithm '{0}' is not valid for signature algorithm '{1}'.";
    static string Cryptography_Cms_MissingAuthenticatedAttribute = "The cryptographic message does not contain an expected authenticated attribute.";
    static string Cryptography_Cms_NoCounterCounterSigner = "Only one level of counter-signatures are supported on this platform.";
    static string Cryptography_Cms_NoRecipients = "The recipients collection is empty. You must specify at least one recipient. This platform does not implement the certificate picker UI.";
    static string Cryptography_Cms_NoSignerCert = "No signer certificate was provided. This platform does not implement the certificate picker UI.";
    static string Cryptography_Cms_NoSignerAtIndex = "The signed cryptographic message does not have a signer for the specified signer index.";
    static string Cryptography_Cms_RecipientNotFound = "The enveloped-data message does not contain the specified recipient.";
    static string Cryptography_Cms_RecipientType_NotSupported = "The recipient type '{0}' is not supported for encryption or decryption on this platform.";
    static string Cryptography_Cms_SignerNotFound = "Cannot find the original signer.";
    static string Cryptography_Cms_Signing_RequiresPrivateKey = "A certificate with a private key is required.";
    static string Cryptography_Cms_TrustFailure = "Certificate trust could not be established. The first reported error is: {0}";
    static string Cryptography_Cms_UnknownAlgorithm = "Unknown algorithm '{0}'.";
    static string Cryptography_Cms_UnknownKeySpec = "Unable to determine the type of key handle from this keyspec {0}.";
    static string Cryptography_Cms_WrongKeyUsage = "The certificate is not valid for the requested usage.";
    static string Cryptography_Pkcs_InvalidSignatureParameters = "Invalid signature paramters.";
    static string Cryptography_Pkcs_PssParametersMissing = "PSS parameters were not present.";
    static string Cryptography_Pkcs_PssParametersHashMismatch = "This platform requires that the PSS hash algorithm ({0}) match the data digest algorithm ({1}).";
    static string Cryptography_Pkcs_PssParametersMgfHashMismatch = "This platform does not support the MGF hash algorithm ({0}) being different from the signature hash algorithm ({1}).";
    static string Cryptography_Pkcs_PssParametersMgfNotSupported = "Mask generation function '{0}' is not supported by this platform.";
    static string Cryptography_Pkcs_PssParametersSaltMismatch = "PSS salt size {0} is not supported by this platform with hash algorithm {1}.";
    static string Cryptography_TimestampReq_BadNonce = "The response from the timestamping server did not match the request nonce.";
    static string Cryptography_TimestampReq_BadResponse = "The response from the timestamping server was not understood.";
    static string Cryptography_TimestampReq_Failure = "The timestamping server did not grant the request. The request status is '{0}' with failure info '{1}'.";
    static string Cryptography_TimestampReq_NoCertFound = "The timestamping request required the TSA certificate in the response, but it was not found.";
    static string Cryptography_TimestampReq_UnexpectedCertFound = "The timestamping request required the TSA certificate not be included in the response, but certificates were present.";
    static string InvalidOperation_WrongOidInAsnCollection = "AsnEncodedData element in the collection has wrong Oid value: expected = '{0}', actual = '{1}'.";
    static string PlatformNotSupported_CryptographyPkcs = "System.Security.Cryptography.Pkcs is only supported on Windows platforms.";
    static string Cryptography_Invalid_IA5String = "The string contains a character not in the 7 bit ASCII character set.";
    static string Cryptography_UnknownHashAlgorithm = "'{0}' is not a known hash algorithm.";
    static string Cryptography_WriteEncodedValue_OneValueAtATime = "The input to WriteEncodedValue must represent a single encoded value with no trailing data.";
    static string Arg_CryptographyException = "Error occurred during a cryptographic operation.";
    static string Cryptography_CryptoStream_FlushFinalBlockTwice = "FlushFinalBlock() method was called twice on a CryptoStream. It can only be called once.";
    static string Cryptography_DefaultAlgorithm_NotSupported = "This platform does not allow the automatic selection of an algorithm.";
    static string Cryptography_HashNotYetFinalized = "Hash must be finalized before the hash value is retrieved.";
    static string Cryptography_InvalidFeedbackSize = "Specified feedback size is not valid for this algorithm.";
    static string Cryptography_InvalidBlockSize = "Specified block size is not valid for this algorithm.";
    static string Cryptography_InvalidCipherMode = "Specified cipher mode is not valid for this algorithm.";
    static string Cryptography_InvalidIVSize = "Specified initialization vector (IV) does not match the block size for this algorithm.";
    static string Cryptography_InvalidKeySize = "Specified key is not a valid size for this algorithm.";
    static string Cryptography_InvalidPaddingMode = "Specified padding mode is not valid for this algorithm.";
    static string HashNameMultipleSetNotSupported = "Setting the hashname after it's already been set is not supported on this platform.";
    static string CryptoConfigNotSupported = "Accessing a hash algorithm by manipulating the HashName property is not supported on this platform. Instead, you must instantiate one of the supplied subtypes (such as HMACSHA1.)";
    static string InvalidOperation_IncorrectImplementation = "The algorithm's implementation is incorrect.";
    static string Cryptography_DpApi_ProfileMayNotBeLoaded = "The data protection operation was unsuccessful. This may have been caused by not having the user profile loaded for the current thread's user context, which may be the case when the thread is impersonating.";
    static string PlatformNotSupported_CryptographyProtectedData = "Windows Data Protection API (DPAPI) is not supported on this platform.";
    static string Cryptography_Partial_Chain = "A certificate chain could not be built to a trusted root authority.";
    static string Cryptography_Xml_BadWrappedKeySize = "Bad wrapped key size.";
    static string Cryptography_Xml_CipherValueElementRequired = "A Cipher Data element should have either a CipherValue or a CipherReference element.";
    static string Cryptography_Xml_CreateHashAlgorithmFailed = "Could not create hash algorithm object.";
    static string Cryptography_Xml_CreateTransformFailed = "Could not create the XML transformation identified by the URI {0}.";
    static string Cryptography_Xml_CreatedKeyFailed = "Failed to create signing key.";
    static string Cryptography_Xml_DigestMethodRequired = "A DigestMethod must be specified on a Reference prior to generating XML.";
    static string Cryptography_Xml_DigestValueRequired = "A Reference must contain a DigestValue.";
    static string Cryptography_Xml_EnvelopedSignatureRequiresContext = "An XmlDocument context is required for enveloped transforms.";
    static string Cryptography_Xml_InvalidElement = "Malformed element {0}.";
    static string Cryptography_Xml_InvalidEncryptionProperty = "Malformed encryption property element.";
    static string Cryptography_Xml_InvalidKeySize = "The key size should be a non negative integer.";
    static string Cryptography_Xml_InvalidReference = "Malformed reference element.";
    static string Cryptography_Xml_InvalidSignatureLength = "The length of the signature with a MAC should be less than the hash output length.";
    static string Cryptography_Xml_InvalidSignatureLength2 = "The length in bits of the signature with a MAC should be a multiple of 8.";
    static string Cryptography_Xml_InvalidX509IssuerSerialNumber = "X509 issuer serial number is invalid.";
    static string Cryptography_Xml_KeyInfoRequired = "A KeyInfo element is required to check the signature.";
    static string Cryptography_Xml_KW_BadKeySize = "The length of the encrypted data in Key Wrap is either 32, 40 or 48 bytes.";
    static string Cryptography_Xml_LoadKeyFailed = "Signing key is not loaded.";
    static string Cryptography_Xml_MissingAlgorithm = "Symmetric algorithm is not specified.";
    static string Cryptography_Xml_MissingCipherData = "Cipher data is not specified.";
    static string Cryptography_Xml_MissingDecryptionKey = "Unable to retrieve the decryption key.";
    static string Cryptography_Xml_MissingEncryptionKey = "Unable to retrieve the encryption key.";
    static string Cryptography_Xml_NotSupportedCryptographicTransform = "The specified cryptographic transform is not supported.";
    static string Cryptography_Xml_ReferenceElementRequired = "At least one Reference element is required.";
    static string Cryptography_Xml_ReferenceTypeRequired = "The Reference type must be set in an EncryptedReference object.";
    static string Cryptography_Xml_SelfReferenceRequiresContext = "An XmlDocument context is required to resolve the Reference Uri {0}.";
    static string Cryptography_Xml_SignatureDescriptionNotCreated = "SignatureDescription could not be created for the signature algorithm supplied.";
    static string Cryptography_Xml_SignatureMethodKeyMismatch = "The key does not fit the SignatureMethod.";
    static string Cryptography_Xml_SignatureMethodRequired = "A signature method is required.";
    static string Cryptography_Xml_SignatureValueRequired = "Signature requires a SignatureValue.";
    static string Cryptography_Xml_SignedInfoRequired = "Signature requires a SignedInfo.";
    static string Cryptography_Xml_TransformIncorrectInputType = "The input type was invalid for this transform.";
    static string Cryptography_Xml_IncorrectObjectType = "Type of input object is invalid.";
    static string Cryptography_Xml_UnknownTransform = "Unknown transform has been encountered.";
    static string Cryptography_Xml_UriNotResolved = "Unable to resolve Uri {0}.";
    static string Cryptography_Xml_UriNotSupported = " The specified Uri is not supported.";
    static string Cryptography_Xml_UriRequired = "A Uri attribute is required for a CipherReference element.";
    static string Cryptography_Xml_XrmlMissingContext = "Null Context property encountered.";
    static string Cryptography_Xml_XrmlMissingIRelDecryptor = "IRelDecryptor is required.";
    static string Cryptography_Xml_XrmlMissingIssuer = "Issuer node is required.";
    static string Cryptography_Xml_XrmlMissingLicence = "License node is required.";
    static string Cryptography_Xml_XrmlUnableToDecryptGrant = "Unable to decrypt grant content.";
    static string Log_ActualHashValue = "Actual hash value: {0}";
    static string Log_BeginCanonicalization = "Beginning canonicalization using "{0}" ({1}).";
    static string Log_BeginSignatureComputation = "Beginning signature computation.";
    static string Log_BeginSignatureVerification = "Beginning signature verification.";
    static string Log_BuildX509Chain = "Building and verifying the X509 chain for certificate {0}.";
    static string Log_CanonicalizationSettings = "Canonicalization transform is using resolver {0} and base URI "{1}".";
    static string Log_CanonicalizedOutput = "Output of canonicalization transform: {0}";
    static string Log_CertificateChain = "Certificate chain:";
    static string Log_CheckSignatureFormat = "Checking signature format using format validator "[{0}] {1}.{2}".";
    static string Log_CheckSignedInfo = "Checking signature on SignedInfo with id "{0}".";
    static string Log_FormatValidationSuccessful = "Signature format validation was successful.";
    static string Log_FormatValidationNotSuccessful = "Signature format validation failed.";
    static string Log_KeyUsages = "Found key usages "{0}" in extension {1} on certificate {2}.";
    static string Log_NoNamespacesPropagated = "No namespaces are being propagated.";
    static string Log_PropagatingNamespace = "Propagating namespace {0}="{1}".";
    static string Log_RawSignatureValue = "Raw signature: {0}";
    static string Log_ReferenceHash = "Reference {0} hashed with "{1}" ({2}) has hash value {3}, expected hash value {4}.";
    static string Log_RevocationMode = "Revocation mode for chain building: {0}.";
    static string Log_RevocationFlag = "Revocation flag for chain building: {0}.";
    static string Log_SigningAsymmetric = "Calculating signature with key {0} using signature description {1}, hash algorithm {2}, and asymmetric signature formatter {3}.";
    static string Log_SigningHmac = "Calculating signature using keyed hash algorithm {0}.";
    static string Log_SigningReference = "Hashing reference {0}, Uri "{1}", Id "{2}", Type "{3}" with hash algorithm "{4}" ({5}).";
    static string Log_TransformedReferenceContents = "Transformed reference contents: {0}";
    static string Log_UnsafeCanonicalizationMethod = "Canonicalization method "{0}" is not on the safe list. Safe canonicalization methods are: {1}.";
    static string Log_UrlTimeout = "URL retrieval timeout for chain building: {0}.";
    static string Log_VerificationFailed = "Verification failed checking {0}.";
    static string Log_VerificationFailed_References = "references";
    static string Log_VerificationFailed_SignedInfo = "SignedInfo";
    static string Log_VerificationFailed_X509Chain = "X509 chain verification";
    static string Log_VerificationFailed_X509KeyUsage = "X509 key usage verification";
    static string Log_VerificationFlag = "Verification flags for chain building: {0}.";
    static string Log_VerificationTime = "Verification time for chain building: {0}.";
    static string Log_VerificationWithKeySuccessful = "Verification with key {0} was successful.";
    static string Log_VerificationWithKeyNotSuccessful = "Verification with key {0} was not successful.";
    static string Log_VerifyReference = "Processing reference {0}, Uri "{1}", Id "{2}", Type "{3}".";
    static string Log_VerifySignedInfoAsymmetric = "Verifying SignedInfo using key {0}, signature description {1}, hash algorithm {2}, and asymmetric signature deformatter {3}.";
    static string Log_VerifySignedInfoHmac = "Verifying SignedInfo using keyed hash algorithm {0}.";
    static string Log_X509ChainError = "Error building X509 chain: {0}: {1}.";
    static string Log_XmlContext = "Using context: {0}";
    static string Log_SignedXmlRecursionLimit = "Signed xml recursion limit hit while trying to decrypt the key. Reference {0} hashed with "{1}" and ({2}).";
    static string Log_UnsafeTransformMethod = "Transform method "{0}" is not on the safe list. Safe transform methods are: {1}.";
    static string Arg_InvalidType = "Invalid type.";
    static string Chain_NoPolicyMatch = "The certificate has invalid policy.";
    static string Cryptography_BadHashSize_ForAlgorithm = "The provided value of {0} bytes does not match the expected size of {1} bytes for the algorithm ({2}).";
    static string Cryptography_Cert_AlreadyHasPrivateKey = "The certificate already has an associated private key.";
    static string Cryptography_CertReq_AlgorithmMustMatch = "The issuer certificate public key algorithm ({0}) does not match the value for this certificate request ({1}), use the X509SignatureGenerator overload.";
    static string Cryptography_CertReq_BasicConstraintsRequired = "The issuer certificate does not have a Basic Constraints extension.";
    static string Cryptography_CertReq_DatesReversed = "The provided notBefore value is later than the notAfter value.";
    static string Cryptography_CertReq_DateTooOld = "The value predates 1950 and has no defined encoding.";
    static string Cryptography_CertReq_DuplicateExtension = "An X509Extension with OID '{0}' has already been specified.";
    static string Cryptography_CertReq_IssuerBasicConstraintsInvalid = "The issuer certificate does not have an appropriate value for the Basic Constraints extension.";
    static string Cryptography_CertReq_IssuerKeyUsageInvalid = "The issuer certificate's Key Usage extension is present but does not contain the KeyCertSign flag.";
    static string Cryptography_CertReq_IssuerRequiresPrivateKey = "The provided issuer certificate does not have an associated private key.";
    static string Cryptography_CertReq_NotAfterNotNested = "The requested notAfter value ({0}) is later than issuerCertificate.NotAfter ({1}).";
    static string Cryptography_CertReq_NotBeforeNotNested = "The requested notBefore value ({0}) is earlier than issuerCertificate.NotBefore ({1}).";
    static string Cryptography_CertReq_NoKeyProvided = "This method cannot be used since no signing key was provided via a constructor, use an overload accepting an X509SignatureGenerator instead.";
    static string Cryptography_CertReq_RSAPaddingRequired = "The issuer certificate uses an RSA key but no RSASignaturePadding was provided to a constructor. If one cannot be provided, use the X509SignatureGenerator overload.";
    static string Cryptography_CSP_NoPrivateKey = "Object contains only the public half of a key pair. A private key must also be provided.";
    static string Cryptography_CurveNotSupported = "The specified curve '{0}' or its parameters are not valid for this platform.";
    static string Cryptography_ECC_NamedCurvesOnly = "Only named curves are supported on this platform.";
    static string Cryptography_Encryption_MessageTooLong = "The message exceeds the maximum allowable length for the chosen options ({0}).";
    static string Cryptography_HashAlgorithmNameNullOrEmpty = "The hash algorithm name cannot be null or empty.";
    static string Cryptography_InvalidOID = "Object identifier (OID) is unknown.";
    static string Cryptography_InvalidPublicKey_Object = "The provided PublicKey object is invalid, valid Oid and EncodedKeyValue property values are required.";
    static string Cryptography_InvalidRsaParameters = "The specified RSA parameters are not valid; both Exponent and Modulus are required fields.";
    static string Cryptography_KeyTooSmall = "The key is too small for the requested operation.";
    static string Cryptography_OAEP_Decryption_Failed = "Error occurred while decoding OAEP padding.";
    static string Cryptography_OpenInvalidHandle = "Cannot open an invalid handle.";
    static string Cryptography_PrivateKey_DoesNotMatch = "The provided key does not match the public key for this certificate.";
    static string Cryptography_PrivateKey_WrongAlgorithm = "The provided key does not match the public key algorithm for this certificate.";
    static string Cryptography_RSA_DecryptWrongSize = "The length of the data to decrypt is not valid for the size of this key.";
    static string Cryptography_SignHash_WrongSize = "The provided hash value is not the expected size for the specified hash algorithm.";
    static string Cryptography_Unix_X509_DisallowedStoreNotEmpty = "The Disallowed store is not supported on this platform, but already has data. All files under '{0}' must be removed.";
    static string Cryptography_Unix_X509_MachineStoresReadOnly = "Unix LocalMachine X509Stores are read-only for all users.";
    static string Cryptography_Unix_X509_MachineStoresRootOnly = "Unix LocalMachine X509Store is limited to the Root and CertificateAuthority stores.";
    static string Cryptography_Unix_X509_NoDisallowedStore = "The Disallowed store is not supported on this platform.";
    static string Cryptography_Unix_X509_PropertyNotSettable = "The {0} value cannot be set on Unix.";
    static string Cryptography_UnknownKeyAlgorithm = "'{0}' is not a known key algorithm.";
    static string Cryptography_Unix_X509_SerializedExport = "X509ContentType.SerializedCert and X509ContentType.SerializedStore are not supported on Unix.";
    static string Cryptography_Unmapped_System_Typed_Error = "The system cryptographic library returned error '{0}' of type '{1}'";
    static string Cryptography_X509_InvalidFlagCombination = "The flags '{0}' may not be specified together.";
    static string Cryptography_X509_PKCS7_NoSigner = "Cannot find the original signer.";
    static string Cryptography_X509_StoreAddFailure = "The X509 certificate could not be added to the store.";
    static string Cryptography_X509_StoreNoFileAvailable = "The X509 certificate could not be added to the store because all candidate file names were in use.";
    static string Cryptography_X509_StoreNotFound = "The specified X509 certificate store does not exist.";
    static string Cryptography_X509_StoreReadOnly = "The X509 certificate store is read-only.";
    static string Cryptography_X509_StoreCannotCreate = "The platform does not have a definition for an X509 certificate store named '{0}' with a StoreLocation of '{1}', and does not support creating it.";
    static string NotSupported_ECDsa_Csp = "CryptoApi ECDsa keys are not supported.";
    static string NotSupported_Export_MultiplePrivateCerts = "Only one certificate with a private key can be exported in a single PFX.";
    static string NotSupported_LegacyBasicConstraints = "The X509 Basic Constraints extension with OID 2.5.29.10 is not supported.";
    static string NotSupported_ImmutableX509Certificate = "X509Certificate is immutable on this platform. Use the equivalent constructor instead.";
    static string Security_AccessDenied = "Access is denied.";
    static string Cryptography_FileStatusError = "Unable to get file status.";
    static string Cryptography_InvalidDirectoryPermissions = "Invalid directory permissions. The directory '{0}' must be readable, writable and executable by the owner.";
    static string Cryptography_OwnerNotCurrentUser = "The owner of '{0}' is not the current user.";
    static string Cryptography_InvalidFilePermissions = "Invalid file permissions. The file '{0}' must readable and writable by the current owner and by no one else, and the permissions could not be changed to meet that criteria.";
    static string Cryptography_Invalid_X500Name = "The string contains an invalid X500 name attribute key, oid, value or delimiter.";
    static string Cryptography_X509_NoEphemeralPfx = "This platform does not support loading with EphemeralKeySet. Remove the flag to allow keys to be temporarily created on disk.";
    static string Cryptography_X509Store_WouldModifyUserTrust = "Removing the requested certificate would modify user trust settings, and has been denied.";
    static string Cryptography_X509Store_WouldModifyAdminTrust = "Removing the requested certificate would modify admin trust settings, and has been denied.";
    static string Cryptography_DSA_KeyGenNotSupported = "DSA keys can be imported, but new key generation is not supported on this platform.";
    static string Cryptography_InvalidDsaParameters_MissingFields = "The specified DSA parameters are not valid; P, Q, G and Y are all required.";
    static string Cryptography_InvalidDsaParameters_MismatchedPGY = "The specified DSA parameters are not valid; P, G and Y must be the same length (the key size).";
    static string Cryptography_InvalidDsaParameters_MismatchedQX = "The specified DSA parameters are not valid; Q and X (if present) must be the same length.";
    static string Cryptography_InvalidDsaParameters_MismatchedPJ = "The specified DSA parameters are not valid; J (if present) must be shorter than P.";
    static string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey = "The specified DSA parameters are not valid; Seed, if present, must be 20 bytes long for keys shorter than 1024 bits.";
    static string Cryptography_InvalidDsaParameters_QRestriction_ShortKey = "The specified DSA parameters are not valid; Q must be 20 bytes long for keys shorter than 1024 bits.";
    static string Cryptography_InvalidDsaParameters_QRestriction_LargeKey = "The specified DSA parameters are not valid; Q's length must be one of 20, 32 or 64 bytes.";
    static string InvalidEmptyArgument = "Argument {0} cannot be zero-length.";
    static string PlatformNotSupported_CompileToAssembly = "This platform does not support writing compiled regular expressions to an assembly.";
    static string Parallel_Invoke_ActionNull = "One of the actions was null.";
    static string Parallel_ForEach_OrderedPartitionerKeysNotNormalized = "This method requires the use of an OrderedPartitioner with the KeysNormalized property set to true.";
    static string Parallel_ForEach_PartitionerNotDynamic = "The Partitioner used here must support dynamic partitioning.";
    static string Parallel_ForEach_PartitionerReturnedNull = "The Partitioner used here returned a null partitioner source.";
    static string Parallel_ForEach_NullEnumerator = "The Partitioner source returned a null enumerator.";
    static string ParallelState_Break_InvalidOperationException_BreakAfterStop = "Break was called after Stop was called.";
    static string ParallelState_Stop_InvalidOperationException_StopAfterBreak = "Stop was called after Break was called.";
    static string ParallelState_NotSupportedException_UnsupportedMethod = "This method is not supported.";
    static string ArgumentOutOfRange_InvalidThreshold = "The specified threshold for creating dictionary is out of range.";
    static string Argument_ItemNotExist = "The specified item does not exist in this KeyedCollection.";
    static string AmbiguousImplementationException_NullMessage = "Ambiguous implementation found.";
    static string Arg_AccessException = "Cannot access member.";
    static string Arg_AccessViolationException = "Attempted to read or write protected memory. This is often an indication that other memory is corrupt.";
    static string Arg_ApplicationException = "Error in the application.";
    static string Arg_ArgumentException = "Value does not fall within the expected range.";
    static string Arg_ArithmeticException = "Overflow or underflow in the arithmetic operation.";
    static string Arg_ArrayTypeMismatchException = "Attempted to access an element as a type incompatible with the array.";
    static string Arg_ArrayZeroError = "Array must not be of length zero.";
    static string Arg_BadImageFormatException = "Format of the executable (.exe) or library (.dll) is invalid.";
    static string Arg_BogusIComparer = "Unable to sort because the IComparer.Compare() method returns inconsistent results. Either a value does not compare equal to itself, or one value repeatedly compared to another value yields different results. IComparer: '{0}'.";
    static string Arg_CannotBeNaN = "TimeSpan does not accept floating point Not-a-Number values.";
    static string Arg_CannotHaveNegativeValue = "String cannot contain a minus sign if the base is not 10.";
    static string Arg_CopyNonBlittableArray = "Arrays must contain only blittable data in order to be copied to unmanaged memory.";
    static string Arg_CopyOutOfRange = "Requested range extends past the end of the array.";
    static string Arg_DataMisalignedException = "A datatype misalignment was detected in a load or store instruction.";
    static string Arg_DateTimeRange = "Combination of arguments to the DateTime constructor is out of the legal range.";
    static string Arg_DirectoryNotFoundException = "Attempted to access a path that is not on the disk.";
    static string Arg_DecBitCtor = "Decimal byte array constructor requires an array of length four containing valid decimal bytes.";
    static string Arg_DivideByZero = "Attempted to divide by zero.";
    static string Arg_DlgtNullInst = "Delegate to an instance method cannot have null 'this'.";
    static string Arg_DlgtTypeMis = "Delegates must be of the same type.";
    static string Arg_DuplicateWaitObjectException = "Duplicate objects in argument.";
    static string Arg_EHClauseNotFilter = "This ExceptionHandlingClause is not a filter.";
    static string Arg_EnumAndObjectMustBeSameType = "Object must be the same type as the enum. The type passed in was '{0}'; the enum type was '{1}'.";
    static string Arg_EntryPointNotFoundException = "Entry point was not found.";
    static string Arg_EntryPointNotFoundExceptionParameterized = "Unable to find an entry point named '{0}' in DLL '{1}'.";
    static string Arg_ExecutionEngineException = "Internal error in the runtime.";
    static string Arg_ExternalException = "External component has thrown an exception.";
    static string Arg_FieldAccessException = "Attempted to access a field that is not accessible by the caller.";
    static string Arg_FormatException = "One of the identified items was in an invalid format.";
    static string Arg_GuidArrayCtor = "Byte array for GUID must be exactly {0} bytes long.";
    static string Arg_HexStyleNotSupported = "The number style AllowHexSpecifier is not supported on floating point data types.";
    static string Arg_IndexOutOfRangeException = "Index was outside the bounds of the array.";
    static string Arg_InsufficientExecutionStackException = "Insufficient stack to continue executing the program safely. This can happen from having too many functions on the call stack or function on the stack using too much stack space.";
    static string Arg_InvalidBase = "Invalid Base.";
    static string Arg_InvalidCastException = "Specified cast is not valid.";
    static string Arg_InvalidHexStyle = "With the AllowHexSpecifier bit set in the enum bit field, the only other valid bits that can be combined into the enum value must be a subset of those in HexNumber.";
    static string Arg_InvalidOperationException = "Operation is not valid due to the current state of the object.";
    static string Arg_OleAutDateInvalid = " Not a legal OleAut date.";
    static string Arg_OleAutDateScale = "OleAut date did not convert to a DateTime correctly.";
    static string Arg_InvalidRuntimeTypeHandle = "Invalid RuntimeTypeHandle.";
    static string Arg_IOException = "I/O error occurred.";
    static string Arg_KeyNotFound = "The given key was not present in the dictionary.";
    static string Arg_LongerThanSrcString = "Source string was not long enough. Check sourceIndex and count.";
    static string Arg_LowerBoundsMustMatch = "The arrays' lower bounds must be identical.";
    static string Arg_MissingFieldException = "Attempted to access a non-existing field.";
    static string Arg_MethodAccessException = "Attempt to access the method failed.";
    static string Arg_MissingMemberException = "Attempted to access a missing member.";
    static string Arg_MissingMethodException = "Attempted to access a missing method.";
    static string Arg_MulticastNotSupportedException = "Attempted to add multiple callbacks to a delegate that does not support multicast.";
    static string Arg_MustBeBoolean = "Object must be of type Boolean.";
    static string Arg_MustBeByte = "Object must be of type Byte.";
    static string Arg_MustBeChar = "Object must be of type Char.";
    static string Arg_MustBeDateTime = "Object must be of type DateTime.";
    static string Arg_MustBeDateTimeOffset = "Object must be of type DateTimeOffset.";
    static string Arg_MustBeDecimal = "Object must be of type Decimal.";
    static string Arg_MustBeDouble = "Object must be of type Double.";
    static string Arg_MustBeEnum = "Type provided must be an Enum.";
    static string Arg_MustBeGuid = "Object must be of type GUID.";
    static string Arg_MustBeInt16 = "Object must be of type Int16.";
    static string Arg_MustBeInt32 = "Object must be of type Int32.";
    static string Arg_MustBeInt64 = "Object must be of type Int64.";
    static string Arg_MustBePrimArray = "Object must be an array of primitives.";
    static string Arg_MustBeSByte = "Object must be of type SByte.";
    static string Arg_MustBeSingle = "Object must be of type Single.";
    static string Arg_MustBeStatic = "Method must be a static method.";
    static string Arg_MustBeString = "Object must be of type String.";
    static string Arg_MustBeStringPtrNotAtom = "The pointer passed in as a String must not be in the bottom 64K of the process's address space.";
    static string Arg_MustBeTimeSpan = "Object must be of type TimeSpan.";
    static string Arg_MustBeUInt16 = "Object must be of type UInt16.";
    static string Arg_MustBeUInt32 = "Object must be of type UInt32.";
    static string Arg_MustBeUInt64 = "Object must be of type UInt64.";
    static string Arg_MustBeVersion = "Object must be of type Version.";
    static string Arg_NeedAtLeast1Rank = "Must provide at least one rank.";
    static string Arg_Need2DArray = "Array was not a two-dimensional array.";
    static string Arg_Need3DArray = "Array was not a three-dimensional array.";
    static string Arg_NegativeArgCount = "Argument count must not be negative.";
    static string Arg_NotFiniteNumberException = "Arg_NotFiniteNumberException = Number encountered was not a finite quantity.";
    static string Arg_NotGenericParameter = "Method may only be called on a Type for which Type.IsGenericParameter is true.";
    static string Arg_NotImplementedException = "The method or operation is not implemented.";
    static string Arg_NotSupportedException = "Specified method is not supported.";
    static string Arg_NotSupportedNonZeroLowerBound = "Arrays with non-zero lower bounds are not supported.";
    static string Arg_NullReferenceException = "Object reference not set to an instance of an object.";
    static string Arg_ObjObjEx = "Object of type '{0}' cannot be converted to type '{1}'.";
    static string Arg_OverflowException = "Arithmetic operation resulted in an overflow.";
    static string Arg_OutOfMemoryException = "Insufficient memory to continue the execution of the program.";
    static string Arg_PlatformNotSupported = "Operation is not supported on this platform.";
    static string Arg_ParamName_Name = "Parameter name: {0}";
    static string Arg_PathEmpty = "The path is empty.";
    static string Arg_PathIllegalUNC_Path = "The UNC path '{0}' should be of the form \\\\server\\share.";
    static string Arg_RankException = "Attempted to operate on an array with the incorrect number of dimensions.";
    static string Arg_RankIndices = "Indices length does not match the array rank.";
    static string Arg_RanksAndBounds = "Number of lengths and lowerBounds must match.";
    static string Arg_RegGetOverflowBug = "RegistryKey.GetValue does not allow a String that has a length greater than Int32.MaxValue.";
    static string Arg_RegKeyNotFound = "The specified registry key does not exist.";
    static string Arg_RegInvalidKeyName = "Registry key name must start with a valid base key name.";
    static string Arg_StackOverflowException = "Operation caused a stack overflow.";
    static string Arg_SynchronizationLockException = "Object synchronization method was called from an unsynchronized block of code.";
    static string Arg_SystemException = "System error.";
    static string Arg_TargetInvocationException = "Exception has been thrown by the target of an invocation.";
    static string Arg_TargetParameterCountException = "Number of parameters specified does not match the expected number.";
    static string Arg_DefaultValueMissingException = "Missing parameter does not have a default value.";
    static string Arg_ThreadStartException = "Thread failed to start.";
    static string Arg_ThreadStateException = "Thread was in an invalid state for the operation being executed.";
    static string Arg_TimeoutException = "The operation has timed out.";
    static string Arg_TypeAccessException = "Attempt to access the type failed.";
    static string Arg_TypeLoadException = "Failure has occurred while loading a type.";
    static string Arg_UnauthorizedAccessException = "Attempted to perform an unauthorized operation.";
    static string Arg_VersionString = "Version string portion was too short or too long.";
    static string Argument_AbsolutePathRequired = "Absolute path information is required.";
    static string Argument_AdjustmentRulesNoNulls = "The AdjustmentRule array cannot contain null elements.";
    static string Argument_AdjustmentRulesOutOfOrder = "The elements of the AdjustmentRule array must be in chronological order and must not overlap.";
    static string Argument_CodepageNotSupported = "{0} is not a supported code page.";
    static string Argument_CompareOptionOrdinal = "CompareOption.Ordinal cannot be used with other options.";
    static string Argument_ConflictingDateTimeRoundtripStyles = "The DateTimeStyles value RoundtripKind cannot be used with the values AssumeLocal, AssumeUniversal or AdjustToUniversal.";
    static string Argument_ConflictingDateTimeStyles = "The DateTimeStyles values AssumeLocal and AssumeUniversal cannot be used together.";
    static string Argument_ConversionOverflow = "Conversion buffer overflow.";
    static string Argument_ConvertMismatch = "The conversion could not be completed because the supplied DateTime did not have the Kind property set correctly.  For example, when the Kind property is DateTimeKind.Local, the source time zone must be TimeZoneInfo.Local.";
    static string Argument_CultureInvalidIdentifier = "{0} is an invalid culture identifier.";
    static string Argument_CultureIetfNotSupported = "Culture IETF Name {0} is not a recognized IETF name.";
    static string Argument_CultureIsNeutral = "Culture ID {0} (0x{0:X4}) is a neutral culture; a region cannot be created from it.";
    static string Argument_CultureNotSupported = "Culture is not supported.";
    static string Argument_CustomCultureCannotBePassedByNumber = "Customized cultures cannot be passed by LCID, only by name.";
    static string Argument_DateTimeBadBinaryData = "The binary data must result in a DateTime with ticks between DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks.";
    static string Argument_DateTimeHasTicks = "The supplied DateTime must have the Year, Month, and Day properties set to 1.  The time cannot be specified more precisely than whole milliseconds.";
    static string Argument_DateTimeHasTimeOfDay = "The supplied DateTime includes a TimeOfDay setting.   This is not supported.";
    static string Argument_DateTimeIsInvalid = "The supplied DateTime represents an invalid time.  For example, when the clock is adjusted forward, any time in the period that is skipped is invalid.";
    static string Argument_DateTimeIsNotAmbiguous = "The supplied DateTime is not in an ambiguous time range.";
    static string Argument_DateTimeKindMustBeUnspecified = "The supplied DateTime must have the Kind property set to DateTimeKind.Unspecified.";
    static string Argument_DateTimeKindMustBeUnspecifiedOrUtc = "The supplied DateTime must have the Kind property set to DateTimeKind.Unspecified or DateTimeKind.Utc.";
    static string Argument_DateTimeOffsetInvalidDateTimeStyles = "The DateTimeStyles value 'NoCurrentDateDefault' is not allowed when parsing DateTimeOffset.";
    static string Argument_DateTimeOffsetIsNotAmbiguous = "The supplied DateTimeOffset is not in an ambiguous time range.";
    static string Argument_EmptyDecString = "Decimal separator cannot be the empty string.";
    static string Argument_EmptyName = "Empty name is not legal.";
    static string Argument_EmptyWaithandleArray = "Waithandle array may not be empty.";
    static string Argument_EncoderFallbackNotEmpty = "Must complete Convert() operation or call Encoder.Reset() before calling GetBytes() or GetByteCount(). Encoder '{0}' fallback '{1}'.";
    static string Argument_EncodingConversionOverflowBytes = "The output byte buffer is too small to contain the encoded data, encoding '{0}' fallback '{1}'.";
    static string Argument_EncodingConversionOverflowChars = "The output char buffer is too small to contain the decoded characters, encoding '{0}' fallback '{1}'.";
    static string Argument_EncodingNotSupported = "'{0}' is not a supported encoding name. For information on defining a custom encoding, see the documentation for the Encoding.RegisterProvider method.";
    static string Argument_EnumTypeDoesNotMatch = "The argument type, '{0}', is not the same as the enum type '{1}'.";
    static string Argument_FallbackBufferNotEmpty = "Cannot change fallback when buffer is not empty. Previous Convert() call left data in the fallback buffer.";
    static string Argument_InvalidArgumentForComparison = "Type of argument is not compatible with the generic comparer.";
    static string Argument_InvalidArrayLength = "Length of the array must be {0}.";
    static string Argument_InvalidCalendar = "Not a valid calendar for the given culture.";
    static string Argument_InvalidCharSequence = "Invalid Unicode code point found at index {0}.";
    static string Argument_InvalidCharSequenceNoIndex = "String contains invalid Unicode code points.";
    static string Argument_InvalidCodePageBytesIndex = "Unable to translate bytes {0} at index {1} from specified code page to Unicode.";
    static string Argument_InvalidCodePageConversionIndex = "Unable to translate Unicode character \\u{0:X4} at index {1} to specified code page.";
    static string Argument_InvalidCultureName = "Culture name '{0}' is not supported.";
    static string Argument_InvalidDateTimeKind = "Invalid DateTimeKind value.";
    static string Argument_InvalidDateTimeStyles = "An undefined DateTimeStyles value is being used.";
    static string Argument_InvalidDigitSubstitution = "The DigitSubstitution property must be of a valid member of the DigitShapes enumeration. Valid entries include Context, NativeNational or None.";
    static string Argument_InvalidEnumValue = "The value '{0}' is not valid for this usage of the type {1}.";
    static string Argument_InvalidGroupSize = "Every element in the value array should be between one and nine, except for the last element, which can be zero.";
    static string Argument_InvalidHighSurrogate = "Found a high surrogate char without a following low surrogate at index: {0}. The input may not be in this encoding, or may not contain valid Unicode (UTF-16) characters.";
    static string Argument_InvalidId = "The specified ID parameter '{0}' is not supported.";
    static string Argument_InvalidLowSurrogate = "Found a low surrogate char without a preceding high surrogate at index: {0}. The input may not be in this encoding, or may not contain valid Unicode (UTF-16) characters.";
    static string Argument_InvalidNativeDigitCount = "The NativeDigits array must contain exactly ten members.";
    static string Argument_InvalidNativeDigitValue = "Each member of the NativeDigits array must be a single text element (one or more UTF16 code points) with a Unicode Nd (Number, Decimal Digit) property indicating it is a digit.";
    static string Argument_InvalidNeutralRegionName = "The region name {0} should not correspond to neutral culture; a specific culture name is required.";
    static string Argument_InvalidNormalizationForm = "Invalid normalization form.";
    static string Argument_InvalidREG_TZI_FORMAT = "The REG_TZI_FORMAT structure is corrupt.";
    static string Argument_InvalidResourceCultureName = "The given culture name '{0}' cannot be used to locate a resource file. Resource filenames must consist of only letters, numbers, hyphens or underscores.";
    static string Argument_InvalidSerializedString = "The specified serialized string '{0}' is not supported.";
    static string Argument_InvalidTimeSpanStyles = "An undefined TimeSpanStyles value is being used.";
    static string Argument_MustBeFalse = "Argument must be initialized to false";
    static string Argument_MustBeRuntimeType = "Type must be a runtime Type object.";
    static string Argument_NoEra = "No Era was supplied.";
    static string Argument_NoRegionInvariantCulture = "There is no region associated with the Invariant Culture (Culture ID: 0x7F).";
    static string Argument_NotIsomorphic = "Object contains non-primitive or non-blittable data.";
    static string Argument_OffsetLocalMismatch = "The UTC Offset of the local dateTime parameter does not match the offset argument.";
    static string Argument_OffsetPrecision = "Offset must be specified in whole minutes.";
    static string Argument_OffsetOutOfRange = "Offset must be within plus or minus 14 hours.";
    static string Argument_OffsetUtcMismatch = "The UTC Offset for Utc DateTime instances must be 0.";
    static string Argument_OneOfCulturesNotSupported = "Culture name {0} or {1} is not supported.";
    static string Argument_OnlyMscorlib = "Only mscorlib's assembly is valid.";
    static string Argument_OutOfOrderDateTimes = "The DateStart property must come before the DateEnd property.";
    static string ArgumentOutOfRange_HugeArrayNotSupported = "Arrays larger than 2GB are not supported.";
    static string ArgumentOutOfRange_Length = "The specified length exceeds maximum capacity of SecureString.";
    static string ArgumentOutOfRange_LengthTooLarge = "The specified length exceeds the maximum value of {0}.";
    static string ArgumentOutOfRange_NeedValidId = "The ID parameter must be in the range {0} through {1}.";
    static string Argument_InvalidTypeName = "The name of the type is invalid.";
    static string Argument_PathFormatNotSupported_Path = "The format of the path '{0}' is not supported.";
    static string Argument_RecursiveFallback = "Recursive fallback not allowed for character \\u{0:X4}.";
    static string Argument_RecursiveFallbackBytes = "Recursive fallback not allowed for bytes {0}.";
    static string Argument_ResultCalendarRange = "The result is out of the supported range for this calendar. The result should be between {0} (Gregorian date) and {1} (Gregorian date), inclusive.";
    static string Argument_TimeSpanHasSeconds = "The TimeSpan parameter cannot be specified more precisely than whole minutes.";
    static string Argument_TimeZoneNotFound = "The time zone ID '{0}' was not found on the local computer.";
    static string Argument_TimeZoneInfoBadTZif = "The tzfile does not begin with the magic characters 'TZif'.  Please verify that the file is not corrupt.";
    static string Argument_TimeZoneInfoInvalidTZif = "The TZif data structure is corrupt.";
    static string Argument_ToExclusiveLessThanFromExclusive = "fromInclusive must be less than or equal to toExclusive.";
    static string Argument_TransitionTimesAreIdentical = "The DaylightTransitionStart property must not equal the DaylightTransitionEnd property.";
    static string Argument_UTCOutOfRange = "The UTC time represented when the offset is applied must be between year 0 and 10,000.";
    static string ArgumentException_OtherNotArrayOfCorrectLength = "Object is not a array with the same number of elements as the array to compare it to.";
    static string ArgumentException_TupleIncorrectType = "Argument must be of type {0}.";
    static string ArgumentException_TupleLastArgumentNotATuple = "The last element of an eight element tuple must be a Tuple.";
    static string ArgumentException_ValueTupleIncorrectType = "Argument must be of type {0}.";
    static string ArgumentException_ValueTupleLastArgumentNotAValueTuple = "The last element of an eight element ValueTuple must be a ValueTuple.";
    static string ArgumentNull_ArrayElement = "At least one element in the specified array was null.";
    static string ArgumentNull_ArrayValue = "Found a null value within an array.";
    static string ArgumentNull_Generic = "Value cannot be null.";
    static string ArgumentNull_Obj = "Object cannot be null.";
    static string ArgumentNull_String = "String reference not set to an instance of a String.";
    static string ArgumentNull_Type = "Type cannot be null.";
    static string ArgumentNull_Waithandles = "The waitHandles parameter cannot be null.";
    static string ArgumentOutOfRange_AddValue = "Value to add was out of range.";
    static string ArgumentOutOfRange_ActualValue = "Actual value was {0}.";
    static string ArgumentOutOfRange_BadYearMonthDay = "Year, Month, and Day parameters describe an un-representable DateTime.";
    static string ArgumentOutOfRange_BadHourMinuteSecond = "Hour, Minute, and Second parameters describe an un-representable DateTime.";
    static string ArgumentOutOfRange_CalendarRange = "Specified time is not supported in this calendar. It should be between {0} (Gregorian date) and {1} (Gregorian date), inclusive.";
    static string ArgumentOutOfRange_Capacity = "Capacity exceeds maximum capacity.";
    static string ArgumentOutOfRange_DateArithmetic = "The added or subtracted value results in an un-representable DateTime.";
    static string ArgumentOutOfRange_DateTimeBadMonths = "Months value must be between +/-120000.";
    static string ArgumentOutOfRange_DateTimeBadTicks = "Ticks must be between DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks.";
    static string ArgumentOutOfRange_DateTimeBadYears = "Years value must be between +/-10000.";
    static string ArgumentOutOfRange_Day = "Day must be between 1 and {0} for month {1}.";
    static string ArgumentOutOfRange_DayOfWeek = "The DayOfWeek enumeration must be in the range 0 through 6.";
    static string ArgumentOutOfRange_DayParam = "The Day parameter must be in the range 1 through 31.";
    static string ArgumentOutOfRange_DecimalRound = "Decimal can only round to between 0 and 28 digits of precision.";
    static string ArgumentOutOfRange_DecimalScale = "Decimal's scale value must be between 0 and 28, inclusive.";
    static string ArgumentOutOfRange_EndIndexStartIndex = "endIndex cannot be greater than startIndex.";
    static string ArgumentOutOfRange_Era = "Time value was out of era range.";
    static string ArgumentOutOfRange_FileTimeInvalid = "Not a valid Win32 FileTime.";
    static string ArgumentOutOfRange_GetByteCountOverflow = "Too many characters. The resulting number of bytes is larger than what can be returned as an int.";
    static string ArgumentOutOfRange_GetCharCountOverflow = "Too many bytes. The resulting number of chars is larger than what can be returned as an int.";
    static string ArgumentOutOfRange_IndexCount = "Index and count must refer to a location within the string.";
    static string ArgumentOutOfRange_IndexCountBuffer = "Index and count must refer to a location within the buffer.";
    static string ArgumentOutOfRange_IndexLength = "Index and length must refer to a location within the string.";
    static string ArgumentOutOfRange_IndexString = "Index was out of range. Must be non-negative and less than the length of the string.";
    static string ArgumentOutOfRange_InvalidEraValue = "Era value was not valid.";
    static string ArgumentOutOfRange_InvalidHighSurrogate = "A valid high surrogate character is between 0xd800 and 0xdbff, inclusive.";
    static string ArgumentOutOfRange_InvalidLowSurrogate = "A valid low surrogate character is between 0xdc00 and 0xdfff, inclusive.";
    static string ArgumentOutOfRange_InvalidUTF32 = "A valid UTF32 value is between 0x000000 and 0x10ffff, inclusive, and should not include surrogate codepoint values (0x00d800 ~ 0x00dfff).";
    static string ArgumentOutOfRange_LengthGreaterThanCapacity = "The length cannot be greater than the capacity.";
    static string ArgumentOutOfRange_ListInsert = "Index must be within the bounds of the List.";
    static string ArgumentOutOfRange_ListItem = "Index was out of range. Must be non-negative and less than the size of the list.";
    static string ArgumentOutOfRange_ListRemoveAt = "Index was out of range. Must be non-negative and less than the size of the list.";
    static string ArgumentOutOfRange_Month = "Month must be between one and twelve.";
    static string ArgumentOutOfRange_MonthParam = "The Month parameter must be in the range 1 through 12.";
    static string ArgumentOutOfRange_MustBeNonNegInt32 = "Value must be non-negative and less than or equal to Int32.MaxValue.";
    static string ArgumentOutOfRange_NeedNonNegOrNegative1 = "Number must be either non-negative and less than or equal to Int32.MaxValue or -1.";
    static string ArgumentOutOfRange_NegativeCapacity = "Capacity must be positive.";
    static string ArgumentOutOfRange_NegativeCount = "Count cannot be less than zero.";
    static string ArgumentOutOfRange_NegativeLength = "Length cannot be less than zero.";
    static string ArgumentOutOfRange_NoGCLohSizeGreaterTotalSize = "lohSize can't be greater than totalSize";
    static string ArgumentOutOfRange_OffsetLength = "Offset and length must refer to a position in the string.";
    static string ArgumentOutOfRange_OffsetOut = "Either offset did not refer to a position in the string, or there is an insufficient length of destination character array.";
    static string ArgumentOutOfRange_PartialWCHAR = "Pointer startIndex and length do not refer to a valid string.";
    static string ArgumentOutOfRange_Range = "Valid values are between {0} and {1}, inclusive.";
    static string ArgumentOutOfRange_RoundingDigits = "Rounding digits must be between 0 and 15, inclusive.";
    static string ArgumentOutOfRange_SmallMaxCapacity = "MaxCapacity must be one or greater.";
    static string ArgumentOutOfRange_StartIndex = "StartIndex cannot be less than zero.";
    static string ArgumentOutOfRange_StartIndexLargerThanLength = "startIndex cannot be larger than length of string.";
    static string ArgumentOutOfRange_StartIndexLessThanLength = "startIndex must be less than length of string.";
    static string ArgumentOutOfRange_UtcOffset = "The TimeSpan parameter must be within plus or minus 14.0 hours.";
    static string ArgumentOutOfRange_UtcOffsetAndDaylightDelta = "The sum of the BaseUtcOffset and DaylightDelta properties must within plus or minus 14.0 hours.";
    static string ArgumentOutOfRange_Version = "Version's parameters must be greater than or equal to zero.";
    static string ArgumentOutOfRange_Week = "The Week parameter must be in the range 1 through 5.";
    static string ArgumentOutOfRange_Year = "Year must be between 1 and 9999.";
    static string Arithmetic_NaN = "Function does not accept floating point Not-a-Number values.";
    static string ArrayTypeMismatch_CantAssignType = "Source array type cannot be assigned to destination array type.";
    static string BadImageFormatException_CouldNotLoadFileOrAssembly = "Could not load file or assembly '{0}'. An attempt was made to load a program with an incorrect format.";
    static string CollectionCorrupted = "A prior operation on this collection was interrupted by an exception. Collection's state is no longer trusted.";
    static string Exception_EndOfInnerExceptionStack = "--- End of inner exception stack trace ---";
    static string Exception_WasThrown = "Exception of type '{0}' was thrown.";
    static string Format_BadBase64Char = "The input is not a valid Base-64 string as it contains a non-base 64 character, more than two padding characters, or an illegal character among the padding characters.";
    static string Format_BadBase64CharArrayLength = "Invalid length for a Base-64 char array or string.";
    static string Format_BadBoolean = "String was not recognized as a valid Boolean.";
    static string Format_BadFormatSpecifier = "Format specifier '{0}' was invalid.";
    static string Format_NoFormatSpecifier = "No format specifiers were provided.";
    static string Format_BadQuote = "Cannot find a matching quote character for the character '{0}'.";
    static string Format_EmptyInputString = "Input string was either empty or contained only whitespace.";
    static string Format_GuidHexPrefix = "Expected hex 0x in '{0}'.";
    static string Format_GuidInvLen = "Guid should contain 32 digits with 4 dashes (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).";
    static string Format_GuidInvalidChar = "Guid string should only contain hexadecimal characters.";
    static string Format_GuidBrace = "Expected {0xdddddddd, etc}.";
    static string Format_GuidComma = "Could not find a comma, or the length between the previous token and the comma was zero (i.e., '0x,'etc.).";
    static string Format_GuidBraceAfterLastNumber = "Could not find a brace, or the length between the previous token and the brace was zero (i.e., '0x,'etc.).";
    static string Format_GuidDashes = "Dashes are in the wrong position for GUID parsing.";
    static string Format_GuidEndBrace = "Could not find the ending brace.";
    static string Format_ExtraJunkAtEnd = "Additional non-parsable characters are at the end of the string.";
    static string Format_GuidUnrecognized = "Unrecognized Guid format.";
    static string Format_IndexOutOfRange = "Index (zero based) must be greater than or equal to zero and less than the size of the argument list.";
    static string Format_InvalidGuidFormatSpecification = "Format String can be only 'D', 'd', 'N', 'n', 'P', 'p', 'B', 'b', 'X' or 'x'.";
    static string Format_InvalidString = "Input string was not in a correct format.";
    static string Format_NeedSingleChar = "String must be exactly one character long.";
    static string Format_NoParsibleDigits = "Could not find any recognizable digits.";
    static string Format_BadTimeSpan = "String was not recognized as a valid TimeSpan.";
    static string InsufficientMemory_MemFailPoint = "Insufficient available memory to meet the expected demands of an operation at this time.  Please try again later.";
    static string InsufficientMemory_MemFailPoint_TooBig = "Insufficient memory to meet the expected demands of an operation, and this system is likely to never satisfy this request.  If this is a 32 bit system, consider booting in 3 GB mode.";
    static string InsufficientMemory_MemFailPoint_VAFrag = "Insufficient available memory to meet the expected demands of an operation at this time, possibly due to virtual address space fragmentation.  Please try again later.";
    static string InvalidCast_CannotCastNullToValueType = "Null object cannot be converted to a value type.";
    static string InvalidCast_DownCastArrayElement = "At least one element in the source array could not be cast down to the destination array type.";
    static string InvalidCast_FromTo = "Invalid cast from '{0}' to '{1}'.";
    static string InvalidCast_IConvertible = "Object must implement IConvertible.";
    static string InvalidCast_StoreArrayElement = "Object cannot be stored in an array of this type.";
    static string InvalidOperation_Calling = "WinRT Interop has already been initialized and cannot be initialized again.";
    static string InvalidOperation_DateTimeParsing = "Internal Error in DateTime and Calendar operations.";
    static string InvalidOperation_HandleIsNotInitialized = "Handle is not initialized.";
    static string InvalidOperation_IComparerFailed = "Failed to compare two elements in the array.";
    static string InvalidOperation_NoValue = "Nullable object must have a value.";
    static string InvalidOperation_NullArray = "The underlying array is null.";
    static string InvalidOperation_Overlapped_Pack = "Cannot pack a packed Overlapped again.";
    static string InvalidOperation_ReadOnly = "Instance is read-only.";
    static string InvalidOperation_ThreadWrongThreadStart = "The thread was created with a ThreadStart delegate that does not accept a parameter.";
    static string InvalidOperation_UnknownEnumType = "Unknown enum type.";
    static string InvalidOperation_WriteOnce = "This property has already been set and cannot be modified.";
    static string InvalidOperation_ArrayCreateInstance_NotARuntimeType = "Array.CreateInstance() can only accept Type objects created by the runtime.";
    static string InvalidOperation_TooEarly = "Internal Error: This operation cannot be invoked in an eager class constructor.";
    static string InvalidOperation_NullContext = "Cannot call Set on a null context";
    static string InvalidOperation_CannotUseAFCOtherThread = "AsyncFlowControl object must be used on the thread where it was created.";
    static string InvalidOperation_CannotRestoreUnsupressedFlow = "Cannot restore context flow when it is not suppressed.";
    static string InvalidOperation_CannotSupressFlowMultipleTimes = "Context flow is already suppressed.";
    static string InvalidOperation_CannotUseAFCMultiple = "AsyncFlowControl object can be used only once to call Undo().";
    static string InvalidOperation_AsyncFlowCtrlCtxMismatch = "AsyncFlowControl objects can be used to restore flow only on a Context that had its flow suppressed.";
    static string InvalidOperation_AsyncIOInProgress = "The stream is currently in use by a previous operation on the stream.";
    static string InvalidProgram_Default = "Common Language Runtime detected an invalid program.";
    static string InvalidProgram_Specific = "Common Language Runtime detected an invalid program. The body of method '{0}' is invalid.";
    static string InvalidProgram_Vararg = "Method '{0}' has a variable argument list. Variable argument lists are not supported in .NET Core.";
    static string InvalidProgram_CallVirtFinalize = "Object.Finalize() can not be called directly. It is only callable by the runtime.";
    static string InvalidProgram_NativeCallable = "NativeCallable method cannot be called from managed code.";
    static string InvalidTimeZone_InvalidRegistryData = "The time zone ID '{0}' was found on the local computer, but the registry information was corrupt.";
    static string InvalidTimeZone_InvalidFileData = "The time zone ID '{0}' was found on the local computer, but the file at '{1}' was corrupt.";
    static string InvalidTimeZone_InvalidJulianDay = "Invalid Julian day in POSIX strings.";
    static string InvalidTimeZone_NJulianDayNotSupported = "Julian n day in POSIX strings is not supported.";
    static string InvalidTimeZone_NoTTInfoStructures = "There are no ttinfo structures in the tzfile.  At least one ttinfo structure is required in order to construct a TimeZoneInfo object.";
    static string InvalidTimeZone_UnparseablePosixMDateString = "'{0}' is not a valid POSIX-TZ-environment-variable MDate rule.  A valid rule has the format 'Mm.w.d'.";
    static string IO_DriveNotFound_Drive = "Could not find the drive '{0}'. The drive might not be ready or might not be mapped.";
    static string IO_FileName_Name = "File name: '{0}'";
    static string IO_FileLoad = "Could not load the specified file.";
    static string IO_FileLoad_FileName = "Could not load the file '{0}'.";
    static string Lazy_CreateValue_NoParameterlessCtorForT = "The lazily-initialized type does not have a public, parameterless constructor.";
    static string Lazy_ctor_ModeInvalid = "The mode argument specifies an invalid value.";
    static string Lazy_StaticInit_InvalidOperation = "ValueFactory returned null.";
    static string Lazy_ToString_ValueNotCreated = "Value is not created.";
    static string Lazy_Value_RecursiveCallsToValue = "ValueFactory attempted to access the Value property of this instance.";
    static string MissingConstructor_Name = "Constructor on type '{0}' not found.";
    static string MustUseCCRewrite = "An assembly (probably '{1}') must be rewritten using the code contracts binary rewriter (CCRewrite) because it is calling Contract.{0} and the CONTRACTS_FULL symbol is defined.  Remove any explicit definitions of the CONTRACTS_FULL symbol from your project and rebuild.  CCRewrite can be downloaded from http://go.microsoft.com/fwlink/?LinkID=169180. \r\nAfter the rewriter is installed, it can be enabled in Visual Studio from the project's Properties page on the Code Contracts pane.  Ensure that 'Perform Runtime Contract Checking' is enabled, which will define CONTRACTS_FULL.";
    static string NotSupported_MaxWaitHandles = "The number of WaitHandles must be less than or equal to 64.";
    static string NotSupported_NoCodepageData = "No data is available for encoding {0}. For information on defining a custom encoding, see the documentation for the Encoding.RegisterProvider method.";
    static string NotSupported_StringComparison = "The string comparison type passed in is currently not supported.";
    static string NotSupported_VoidArray = "Arrays of System.Void are not supported.";
    static string NotSupported_ByRefLike = "Cannot create boxed ByRef-like values.";
    static string NotSupported_Type = "Type is not supported.";
    static string NotSupported_WaitAllSTAThread = "WaitAll for multiple handles on a STA thread is not supported.";
    static string ObjectDisposed_ObjectName_Name = "Object name: '{0}'.";
    static string Overflow_Byte = "Value was either too large or too small for an unsigned byte.";
    static string Overflow_Char = "Value was either too large or too small for a character.";
    static string Overflow_Double = "Value was either too large or too small for a Double.";
    static string Overflow_TimeSpanElementTooLarge = "The TimeSpan could not be parsed because at least one of the numeric components is out of range or contains too many digits.";
    static string Overflow_Duration = "The duration cannot be returned for TimeSpan.MinValue because the absolute value of TimeSpan.MinValue exceeds the value of TimeSpan.MaxValue.";
    static string Overflow_Int16 = "Value was either too large or too small for an Int16.";
    static string Overflow_NegateTwosCompNum = "Negating the minimum value of a twos complement number is invalid.";
    static string Overflow_NegativeUnsigned = "The string was being parsed as an unsigned number and could not have a negative sign.";
    static string Overflow_SByte = "Value was either too large or too small for a signed byte.";
    static string Overflow_Single = "Value was either too large or too small for a Single.";
    static string Overflow_TimeSpanTooLong = "TimeSpan overflowed because the duration is too long.";
    static string Overflow_UInt16 = "Value was either too large or too small for a UInt16.";
    static string Rank_MultiDimNotSupported = "Only single dimension arrays are supported here.";
    static string RuntimeWrappedException = "An object that does not derive from System.Exception has been wrapped in a RuntimeWrappedException.";
    static string SpinWait_SpinUntil_ArgumentNull = "The condition argument is null.";
    static string Serialization_CorruptField = "The value of the field '{0}' is invalid.  The serialized data is corrupt.";
    static string Serialization_InvalidData = "An error occurred while deserializing the object.  The serialized data is corrupt.";
    static string Serialization_InvalidEscapeSequence = "The serialized data contained an invalid escape sequence '\\{0}'.";
    static string Serialization_InvalidType = "Only system-provided types can be passed to the GetUninitializedObject method. '{0}' is not a valid instance of a type.";
    static string SpinWait_SpinUntil_TimeoutWrong = "The timeout must represent a value between -1 and Int32.MaxValue, inclusive.";
    static string Threading_AbandonedMutexException = "The wait completed due to an abandoned mutex.";
    static string Threading_SemaphoreFullException = "Adding the specified count to the semaphore would cause it to exceed its maximum count.";
    static string Threading_ThreadInterrupted = "Thread was interrupted from a waiting state.";
    static string Threading_WaitHandleCannotBeOpenedException = "No handle of the given name exists.";
    static string Threading_WaitHandleCannotBeOpenedException_InvalidHandle = "A WaitHandle with system-wide name '{0}' cannot be created. A WaitHandle of a different type might have the same name.";
    static string TimeZoneNotFound_MissingData = "The time zone ID '{0}' was not found on the local computer.";
    static string TypeInitialization_Default = "Type constructor threw an exception.";
    static string TypeInitialization_Type = "The type initializer for '{0}' threw an exception.";
    static string TypeInitialization_Type_NoTypeAvailable = "A type initializer threw an exception. To determine which type, inspect the InnerException's StackTrace property.";
    static string Verification_Exception = "Operation could destabilize the runtime.";
    static string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType = "Enum underlying type and the object must be same type or object. Type passed in was '{0}'; the enum underlying type was '{1}'.";
    static string Format_InvalidEnumFormatSpecification = "Format String can be only 'G', 'g', 'X', 'x', 'F', 'f', 'D' or 'd'.";
    static string Arg_MustBeEnumBaseTypeOrEnum = "The value passed in must be an enum base or an underlying type for an enum, such as an Int32.";
    static string Arg_EnumUnderlyingTypeAndObjectMustBeSameType = "Enum underlying type and the object must be same type or object must be a String. Type passed in was '{0}'; the enum underlying type was '{1}'.";
    static string Arg_MustBeType = "Type must be a type provided by the runtime.";
    static string Arg_MustContainEnumInfo = "Must specify valid information for parsing in the string.";
    static string Arg_EnumValueNotFound = "Requested value '{0}' was not found.";
    static string Argument_StringZeroLength = "String cannot be of zero length.";
    static string Argument_StringFirstCharIsZero = "The first char in the string is the null character.";
    static string Argument_LongEnvVarValue = "Environment variable name or value is too long.";
    static string Argument_IllegalEnvVarName = "Environment variable name cannot contain equal character.";
    static string AssumptionFailed = "Assumption failed.";
    static string AssumptionFailed_Cnd = "Assumption failed: {0}";
    static string AssertionFailed = "Assertion failed.";
    static string AssertionFailed_Cnd = "Assertion failed: {0}";
    static string PreconditionFailed = "Precondition failed.";
    static string PreconditionFailed_Cnd = "Precondition failed: {0}";
    static string PostconditionFailed = "Postcondition failed.";
    static string PostconditionFailed_Cnd = "Postcondition failed: {0}";
    static string PostconditionOnExceptionFailed = "Postcondition failed after throwing an exception.";
    static string PostconditionOnExceptionFailed_Cnd = "Postcondition failed after throwing an exception: {0}";
    static string InvariantFailed = "Invariant failed.";
    static string InvariantFailed_Cnd = "Invariant failed: {0}";
    static string MissingEncodingNameResource = "Could not find a resource entry for the encoding codepage '{0} - {1}'";
    static string Globalization_cp_1200 = "Unicode";
    static string Globalization_cp_1201 = "Unicode (Big-Endian)";
    static string Globalization_cp_12000 = "Unicode (UTF-32)";
    static string Globalization_cp_12001 = "Unicode (UTF-32 Big-Endian)";
    static string Globalization_cp_20127 = "US-ASCII";
    static string Globalization_cp_28591 = "Western European (ISO)";
    static string Globalization_cp_65000 = "Unicode (UTF-7)";
    static string Globalization_cp_65001 = "Unicode (UTF-8)";
    static string DebugAssertBanner = "---- DEBUG ASSERTION FAILED ----";
    static string DebugAssertLongMessage = "---- Assert Long Message ----";
    static string DebugAssertShortMessage = "---- Assert Short Message ----";
    static string InvalidCast_Empty = "Object cannot be cast to Empty.";
    static string Arg_UnknownTypeCode = "Unknown TypeCode value.";
    static string Format_BadDatePattern = "Could not determine the order of year, month, and date from '{0}'.";
    static string Format_BadDateTime = "String '{0}' was not recognized as a valid DateTime.";
    static string Format_BadDateTimeCalendar = "The DateTime represented by the string '{0}' is not supported in calendar '{1}'.";
    static string Format_BadDayOfWeek = "String '{0}' was not recognized as a valid DateTime because the day of week was incorrect.";
    static string Format_DateOutOfRange = "The DateTime represented by the string '{0}' is out of range.";
    static string Format_MissingIncompleteDate = "There must be at least a partial date with a year present in the input string '{0}'.";
    static string Format_OffsetOutOfRange = "The time zone offset of string '{0}' must be within plus or minus 14 hours.";
    static string Format_RepeatDateTimePattern = "DateTime pattern '{0}' appears more than once with different values.";
    static string Format_UnknownDateTimeWord = "The string '{0}' was not recognized as a valid DateTime. There is an unknown word starting at index '{1}'.";
    static string Format_UTCOutOfRange = "The UTC representation of the date '{0}' falls outside the year range 1-9999.";
    static string RFLCT_Ambiguous = "Ambiguous match found.";
    static string AggregateException_ctor_DefaultMessage = "One or more errors occurred.";
    static string AggregateException_ctor_InnerExceptionNull = "An element of innerExceptions was null.";
    static string AggregateException_DeserializationFailure = "The serialization stream contains no inner exceptions.";
    static string AggregateException_InnerException = "(Inner Exception #{0}) ";
    static string ArgumentOutOfRange_TimeoutTooLarge = "Time-out interval must be less than 2^32-2.";
    static string ArgumentOutOfRange_PeriodTooLarge = "Period must be less than 2^32-2.";
    static string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent = "The current SynchronizationContext may not be used as a TaskScheduler.";
    static string TaskScheduler_ExecuteTask_WrongTaskScheduler = "ExecuteTask may not be called for a task which was previously queued to a different TaskScheduler.";
    static string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline = "The TryExecuteTaskInline call to the underlying scheduler succeeded, but the task body was not invoked.";
    static string TaskSchedulerException_ctor_DefaultMessage = "An exception was thrown by a TaskScheduler.";
    static string Task_MultiTaskContinuation_FireOptions = "It is invalid to exclude specific continuation kinds for continuations off of multiple tasks.";
    static string Task_ContinueWith_ESandLR = "The specified TaskContinuationOptions combined LongRunning and ExecuteSynchronously.  Synchronous continuations should not be long running.";
    static string Task_MultiTaskContinuation_EmptyTaskList = "The tasks argument contains no tasks.";
    static string Task_MultiTaskContinuation_NullTask = "The tasks argument included a null value.";
    static string Task_FromAsync_PreferFairness = "It is invalid to specify TaskCreationOptions.PreferFairness in calls to FromAsync.";
    static string Task_FromAsync_LongRunning = "It is invalid to specify TaskCreationOptions.LongRunning in calls to FromAsync.";
    static string AsyncMethodBuilder_InstanceNotInitialized = "The builder was not properly initialized.";
    static string TaskT_TransitionToFinal_AlreadyCompleted = "An attempt was made to transition a task to a final state when it had already completed.";
    static string TaskT_DebuggerNoResult = "{Not yet computed}";
    static string OperationCanceled = "The operation was canceled.";
    static string CancellationToken_CreateLinkedToken_TokensIsEmpty = "No tokens were supplied.";
    static string CancellationTokenSource_Disposed = "The CancellationTokenSource has been disposed.";
    static string CancellationToken_SourceDisposed = "The CancellationTokenSource associated with this CancellationToken has been disposed.";
    static string TaskExceptionHolder_UnknownExceptionType = "(Internal)Expected an Exception or an IEnumerable<Exception>";
    static string TaskExceptionHolder_UnhandledException = "A Task's exception(s) were not observed either by Waiting on the Task or accessing its Exception property. As a result, the unobserved exception was rethrown by the finalizer thread.";
    static string Task_Delay_InvalidMillisecondsDelay = "The value needs to be either -1 (signifying an infinite timeout), 0 or a positive integer.";
    static string Task_Delay_InvalidDelay = "The value needs to translate in milliseconds to -1 (signifying an infinite timeout), 0 or a positive integer less than or equal to Int32.MaxValue.";
    static string Task_Dispose_NotCompleted = "A task may only be disposed if it is in a completion state (RanToCompletion, Faulted or Canceled).";
    static string Task_WaitMulti_NullTask = "The tasks array included at least one null element.";
    static string Task_ContinueWith_NotOnAnything = "The specified TaskContinuationOptions excluded all continuation kinds.";
    static string Task_RunSynchronously_AlreadyStarted = "RunSynchronously may not be called on a task that was already started.";
    static string Task_ThrowIfDisposed = "The task has been disposed.";
    static string Task_RunSynchronously_TaskCompleted = "RunSynchronously may not be called on a task that has already completed.";
    static string Task_RunSynchronously_Promise = "RunSynchronously may not be called on a task not bound to a delegate, such as the task returned from an asynchronous method.";
    static string Task_RunSynchronously_Continuation = "RunSynchronously may not be called on a continuation task.";
    static string Task_Start_AlreadyStarted = "Start may not be called on a task that was already started.";
    static string Task_Start_ContinuationTask = "Start may not be called on a continuation task.";
    static string Task_Start_Promise = "Start may not be called on a promise-style task.";
    static string Task_Start_TaskCompleted = "Start may not be called on a task that has completed.";
    static string TaskCanceledException_ctor_DefaultMessage = "A task was canceled.";
    static string TaskCompletionSourceT_TrySetException_NoExceptions = "The exceptions collection was empty.";
    static string TaskCompletionSourceT_TrySetException_NullException = "The exceptions collection included at least one null element.";
    static string Argument_MinMaxValue = "'{0}' cannot be greater than {1}.";
    static string ExecutionContext_ExceptionInAsyncLocalNotification = "An exception was not handled in an AsyncLocal<T> notification callback.";
    static string InvalidOperation_WrongAsyncResultOrEndCalledMultiple = "Either the IAsyncResult object did not come from the corresponding async method on this type, or the End method was called multiple times with the same IAsyncResult.";
    static string SpinLock_IsHeldByCurrentThread = "Thread tracking is disabled.";
    static string SpinLock_TryEnter_LockRecursionException = "The calling thread already holds the lock.";
    static string SpinLock_Exit_SynchronizationLockException = "The calling thread does not hold the lock.";
    static string SpinLock_TryReliableEnter_ArgumentException = "The tookLock argument must be set to false before calling this method.";
    static string SpinLock_TryEnter_ArgumentOutOfRange = "The timeout must be a value between -1 and Int32.MaxValue, inclusive.";
    static string ManualResetEventSlim_Disposed = "The event has been disposed.";
    static string ManualResetEventSlim_ctor_SpinCountOutOfRange = "The spinCount argument must be in the range 0 to {0}, inclusive.";
    static string ManualResetEventSlim_ctor_TooManyWaiters = "There are too many threads currently waiting on the event. A maximum of {0} waiting threads are supported.";
    static string InvalidOperation_SendNotSupportedOnWindowsRTSynchronizationContext = "Send is not supported in the Windows Runtime SynchronizationContext";
    static string SemaphoreSlim_Disposed = "The semaphore has been disposed.";
    static string SemaphoreSlim_Release_CountWrong = "The releaseCount argument must be greater than zero.";
    static string SemaphoreSlim_Wait_TimeoutWrong = "The timeout must represent a value between -1 and Int32.MaxValue, inclusive.";
    static string SemaphoreSlim_ctor_MaxCountWrong = "The maximumCount argument must be a positive number. If a maximum is not required, use the constructor without a maxCount parameter.";
    static string SemaphoreSlim_ctor_InitialCountWrong = "The initialCount argument must be non-negative and less than or equal to the maximumCount.";
    static string ThreadLocal_ValuesNotAvailable = "The ThreadLocal object is not tracking values. To use the Values property, use a ThreadLocal constructor that accepts the trackAllValues parameter and set the parameter to true.";
    static string ThreadLocal_Value_RecursiveCallsToValue = "ValueFactory attempted to access the Value property of this instance.";
    static string ThreadLocal_Disposed = "The ThreadLocal object has been disposed.";
    static string LockRecursionException_WriteAfterReadNotAllowed = "Write lock may not be acquired with read lock held. This pattern is prone to deadlocks. Please ensure that read locks are released before taking a write lock. If an upgrade is necessary, use an upgrade lock in place of the read lock.";
    static string LockRecursionException_RecursiveWriteNotAllowed = "Recursive write lock acquisitions not allowed in this mode.";
    static string LockRecursionException_ReadAfterWriteNotAllowed = "A read lock may not be acquired with the write lock held in this mode.";
    static string LockRecursionException_RecursiveUpgradeNotAllowed = "Recursive upgradeable lock acquisitions not allowed in this mode.";
    static string LockRecursionException_RecursiveReadNotAllowed = "Recursive read lock acquisitions not allowed in this mode.";
    static string SynchronizationLockException_IncorrectDispose = "The lock is being disposed while still being used. It either is being held by a thread and/or has active waiters waiting to acquire the lock.";
    static string SynchronizationLockException_MisMatchedWrite = "The write lock is being released without being held.";
    static string LockRecursionException_UpgradeAfterReadNotAllowed = "Upgradeable lock may not be acquired with read lock held.";
    static string LockRecursionException_UpgradeAfterWriteNotAllowed = "Upgradeable lock may not be acquired with write lock held in this mode. Acquiring Upgradeable lock gives the ability to read along with an option to upgrade to a writer.";
    static string SynchronizationLockException_MisMatchedUpgrade = "The upgradeable lock is being released without being held.";
    static string SynchronizationLockException_MisMatchedRead = "The read lock is being released without being held.";
    static string InvalidOperation_TimeoutsNotSupported = "Timeouts are not supported on this stream.";
    static string NotSupported_SubclassOverride = "Derived classes must provide an implementation.";
    static string InvalidOperation_NoPublicRemoveMethod = "Cannot remove the event handler since no public remove method exists for the event.";
    static string InvalidOperation_NoPublicAddMethod = "Cannot add the event handler since no public add method exists for the event.";
    static string SerializationException = "Serialization error.";
    static string Serialization_NotFound = "Member '{0}' was not found.";
    static string Serialization_OptionalFieldVersionValue = "Version value must be positive.";
    static string Serialization_SameNameTwice = "Cannot add the same member twice to a SerializationInfo object.";
    static string NotSupported_AbstractNonCLS = "This non-CLS method is not implemented.";
    static string NotSupported_NoTypeInfo = "Cannot resolve {0} to a TypeInfo object.";
    static string Arg_CustomAttributeFormatException = "Binary format of the specified custom attribute was invalid.";
    static string Argument_InvalidMemberForNamedArgument = "The member must be either a field or a property.";
    static string Arg_InvalidFilterCriteriaException = "Specified filter criteria was invalid.";
    static string Arg_ParmArraySize = "Must specify one or more parameters.";
    static string Arg_MustBePointer = "Type must be a Pointer.";
    static string Argument_InvalidEnum = "The Enum type should contain one and only one instance field.";
    static string Argument_MustHaveAttributeBaseClass = "Type passed in must be derived from System.Attribute or System.Attribute itself.";
    static string InvalidFilterCriteriaException_CritString = "A String must be provided for the filter criteria.";
    static string InvalidFilterCriteriaException_CritInt = "An Int32 must be provided for the filter criteria.";
    static string InvalidOperation_NotSupportedOnWinRTEvent = "Adding or removing event handlers dynamically is not supported on WinRT events.";
    static string PlatformNotSupported_ReflectionOnly = "ReflectionOnly loading is not supported on this platform.";
    static string PlatformNotSupported_OSXFileLocking = "Locking/unlocking file regions is not supported on this platform. Use FileShare on the entire file instead.";
    static string PlatformNotSupported_ReflectionEmit = "Dynamic code generation is not supported on this platform.";
    static string MissingMember_Name = "Member '{0}' not found.";
    static string MissingMethod_Name = "Method '{0}' not found.";
    static string MissingField_Name = "Field '{0}' not found.";
    static string Format_StringZeroLength = "String cannot have zero length.";
    static string Security_CannotReadFileData = "The time zone ID '{0}' was found on the local computer, but the application does not have permission to read the file.";
    static string Security_CannotReadRegistryData = "The time zone ID '{0}' was found on the local computer, but the application does not have permission to read the registry information.";
    static string Security_InvalidAssemblyPublicKey = "Invalid assembly public key.";
    static string Security_RegistryPermission = "Requested registry access is not allowed.";
    static string ClassLoad_General = "Could not load type '{0}' from assembly '{1}'.";
    static string ClassLoad_RankTooLarge = "'{0}' from assembly '{1}' has too many dimensions.";
    static string ClassLoad_ExplicitGeneric = "Could not load type '{0}' from assembly '{1}' because generic types cannot have explicit layout.";
    static string ClassLoad_BadFormat = "Could not load type '{0}' from assembly '{1}' because the format is invalid.";
    static string ClassLoad_ValueClassTooLarge = "Array of type '{0}' from assembly '{1}' cannot be created because base value type is too large.";
    static string ClassLoad_ExplicitLayout = "Could not load type '{0}' from assembly '{1}' because it contains an object field at offset '{2}' that is incorrectly aligned or overlapped by a non-object field.";
    static string EE_MissingMethod = "Method not found: '{0}'.";
    static string EE_MissingField = "Field not found: '{0}'.";
    static string UnauthorizedAccess_RegistryKeyGeneric_Key = "Access to the registry key '{0}' is denied.";
    static string UnknownError_Num = "Unknown error '{0}'.";
    static string Argument_NeedStructWithNoRefs = "The specified Type must be a struct containing no references.";
    static string ArgumentOutOfRange_AddressSpace = "The number of bytes cannot exceed the virtual address space on a 32 bit machine.";
    static string ArgumentOutOfRange_UIntPtrMax = "The length of the buffer must be less than the maximum UIntPtr value for your platform.";
    static string Arg_BufferTooSmall = "Not enough space available in the buffer.";
    static string InvalidOperation_MustCallInitialize = "You must call Initialize on this object instance before using it.";
    static string Argument_InvalidSafeBufferOffLen = "Offset and length were greater than the size of the SafeBuffer.";
    static string Argument_NotEnoughBytesToRead = "There are not enough bytes remaining in the accessor to read at this position.";
    static string Argument_NotEnoughBytesToWrite = "There are not enough bytes remaining in the accessor to write at this position.";
    static string Argument_OffsetAndCapacityOutOfBounds = "Offset and capacity were greater than the size of the view.";
    static string ArgumentOutOfRange_UnmanagedMemStreamLength = "UnmanagedMemoryStream length must be non-negative and less than 2^63 - 1 - baseAddress.";
    static string Argument_UnmanagedMemAccessorWrapAround = "The UnmanagedMemoryAccessor capacity and offset would wrap around the high end of the address space.";
    static string ArgumentOutOfRange_StreamLength = "Stream length must be non-negative and less than 2^31 - 1 - origin.";
    static string ArgumentOutOfRange_UnmanagedMemStreamWrapAround = "The UnmanagedMemoryStream capacity would wrap around the high end of the address space.";
    static string InvalidOperation_CalledTwice = "The method cannot be called twice on the same instance.";
    static string IO_FixedCapacity = "Unable to expand length of this stream beyond its capacity.";
    static string IO_StreamTooLong = "Stream was too long.";
    static string Arg_BadDecimal = "Read an invalid decimal value from the buffer.";
    static string NotSupported_Reading = "Accessor does not support reading.";
    static string NotSupported_UmsSafeBuffer = "This operation is not supported for an UnmanagedMemoryStream created from a SafeBuffer.";
    static string NotSupported_Writing = "Accessor does not support writing.";
    static string IndexOutOfRange_UMSPosition = "Unmanaged memory stream position was beyond the capacity of the stream.";
    static string ObjectDisposed_ViewAccessorClosed = "Cannot access a closed accessor.";
    static string ArgumentOutOfRange_PositionLessThanCapacityRequired = "The position may not be greater or equal to the capacity of the accessor.";
    static string Arg_EndOfStreamException = "Attempted to read past the end of the stream.";
    static string Argument_InvalidHandle = "'handle' has been disposed or is an invalid handle.";
    static string Argument_AlreadyBoundOrSyncHandle = "'handle' has already been bound to the thread pool, or was not opened for asynchronous I/O.";
    static string Argument_PreAllocatedAlreadyAllocated = "'preAllocated' is already in use.";
    static string Argument_NativeOverlappedAlreadyFree = "'overlapped' has already been freed.";
    static string Argument_NativeOverlappedWrongBoundHandle = "'overlapped' was not allocated by this ThreadPoolBoundHandle instance.";
    static string NotSupported_FileStreamOnNonFiles = "FileStream was asked to open a device that was not a file. For support for devices like 'com1:' or 'lpt1:', call CreateFile, then use the FileStream constructors that take an OS handle as an IntPtr.";
    static string Arg_ResourceFileUnsupportedVersion = "The ResourceReader class does not know how to read this version of .resources files.";
    static string Resources_StreamNotValid = "Stream is not a valid resource file.";
    static string BadImageFormat_ResourcesHeaderCorrupted = "Corrupt .resources file. Unable to read resources from this file because of invalid header information. Try regenerating the .resources file.";
    static string BadImageFormat_NegativeStringLength = "Corrupt .resources file. String length must be non-negative.";
    static string BadImageFormat_ResourcesNameInvalidOffset = "Corrupt .resources file. The Invalid offset into name section is .";
    static string BadImageFormat_TypeMismatch = "Corrupt .resources file.  The specified type doesn't match the available data in the stream.";
    static string BadImageFormat_ResourceNameCorrupted_NameIndex = "Corrupt .resources file. The resource name for name index that extends past the end of the stream is ";
    static string BadImageFormat_ResourcesDataInvalidOffset = "Corrupt .resources file. Invalid offset  into data section is ";
    static string Format_Bad7BitInt32 = "Too many bytes in what should have been a 7 bit encoded Int32.";
    static string BadImageFormat_InvalidType = "Corrupt .resources file.  The specified type doesn't exist.";
    static string ResourceReaderIsClosed = "ResourceReader is closed.";
    static string Arg_MissingManifestResourceException = "Unable to find manifest resource.";
    static string UnauthorizedAccess_MemStreamBuffer = "MemoryStream's internal buffer cannot be accessed.";
    static string NotSupported_MemStreamNotExpandable = "Memory stream is not expandable.";
    static string ArgumentNull_Stream = "Stream cannot be null.";
    static string IO_InvalidStringLen_Len = "BinaryReader encountered an invalid string length of {0} characters.";
    static string ArgumentOutOfRange_BinaryReaderFillBuffer = "The number of bytes requested does not fit into BinaryReader's internal buffer.";
    static string Serialization_InsufficientDeserializationState = "Insufficient state to deserialize the object. Missing field '{0}'.";
    static string NotSupported_UnitySerHolder = "The UnitySerializationHolder object is designed to transmit information about other types and is not serializable itself.";
    static string Serialization_UnableToFindModule = "The given module {0} cannot be found within the assembly {1}.";
    static string Argument_InvalidUnity = "Invalid Unity type.";
    static string InvalidOperation_InvalidHandle = "The handle is invalid.";
    static string PlatformNotSupported_NamedSynchronizationPrimitives = "The named version of this synchronization primitive is not supported on this platform.";
    static string Overflow_MutexReacquireCount = "The current thread attempted to reacquire a mutex that has reached its maximum acquire count.";
    static string Serialization_InsufficientState = "Insufficient state to return the real object.";
    static string Serialization_UnknownMember = "Cannot get the member '{0}'.";
    static string Serialization_NullSignature = "The method signature cannot be null.";
    static string Serialization_MemberTypeNotRecognized = "Unknown member type.";
    static string Serialization_BadParameterInfo = "Non existent ParameterInfo. Position bigger than member's parameters length.";
    static string Serialization_NoParameterInfo = "Serialized member does not have a ParameterInfo.";
    static string ArgumentNull_Assembly = "Assembly cannot be null.";
    static string Arg_InvalidNeutralResourcesLanguage_Asm_Culture = "The NeutralResourcesLanguageAttribute on the assembly "{0}" specifies an invalid culture name: "{1}".";
    static string Arg_InvalidNeutralResourcesLanguage_FallbackLoc = "The NeutralResourcesLanguageAttribute specifies an invalid or unrecognized ultimate resource fallback location: "{0}".";
    static string Arg_InvalidSatelliteContract_Asm_Ver = "Satellite contract version attribute on the assembly '{0}' specifies an invalid version: {1}.";
    static string Arg_ResMgrNotResSet = "Type parameter must refer to a subclass of ResourceSet.";
    static string BadImageFormat_ResourceNameCorrupted = "Corrupt .resources file. A resource name extends past the end of the stream.";
    static string BadImageFormat_ResourcesNameTooLong = "Corrupt .resources file. Resource name extends past the end of the file.";
    static string InvalidOperation_ResMgrBadResSet_Type = "'{0}': ResourceSet derived classes must provide a constructor that takes a String file name and a constructor that takes a Stream.";
    static string InvalidOperation_ResourceNotStream_Name = "Resource '{0}' was not a Stream - call GetObject instead.";
    static string MissingManifestResource_MultipleBlobs = "A case-insensitive lookup for resource file "{0}" in assembly "{1}" found multiple entries. Remove the duplicates or specify the exact case.";
    static string MissingManifestResource_NoNeutralAsm = "Could not find any resources appropriate for the specified culture or the neutral culture.  Make sure "{0}" was correctly embedded or linked into assembly "{1}" at compile time, or that all the satellite assemblies required are loadable and fully signed.";
    static string MissingManifestResource_NoNeutralDisk = "Could not find any resources appropriate for the specified culture (or the neutral culture) on disk.";
    static string MissingManifestResource_NoPRIresources = "Unable to open Package Resource Index.";
    static string MissingManifestResource_ResWFileNotLoaded = "Unable to load resources for resource file "{0}" in package "{1}".";
    static string MissingSatelliteAssembly_Culture_Name = "The satellite assembly named "{1}" for fallback culture "{0}" either could not be found or could not be loaded. This is generally a setup problem. Please consider reinstalling or repairing the application.";
    static string MissingSatelliteAssembly_Default = "Resource lookup fell back to the ultimate fallback resources in a satellite assembly, but that satellite either was not found or could not be loaded. Please consider reinstalling or repairing the application.";
    static string NotSupported_ObsoleteResourcesFile = "Found an obsolete .resources file in assembly '{0}'. Rebuild that .resources file then rebuild that assembly.";
    static string NotSupported_ResourceObjectSerialization = "Cannot read resources that depend on serialization.";
    static string ObjectDisposed_ResourceSet = "Cannot access a closed resource set.";
    static string Arg_ResourceNameNotExist = "The specified resource name "{0}" does not exist in the resource file.";
    static string BadImageFormat_ResourceDataLengthInvalid = "Corrupt .resources file.  The specified data length '{0}' is not a valid position in the stream.";
    static string BadImageFormat_ResourcesIndexTooLong = "Corrupt .resources file. String for name index '{0}' extends past the end of the file.";
    static string InvalidOperation_ResourceNotString_Name = "Resource '{0}' was not a String - call GetObject instead.";
    static string InvalidOperation_ResourceNotString_Type = "Resource was of type '{0}' instead of String - call GetObject instead.";
    static string NotSupported_WrongResourceReader_Type = "This .resources file should not be read with this reader. The resource reader type is "{0}".";
    static string Arg_MustBeDelegate = "Type must derive from Delegate.";
    static string NotSupported_GlobalMethodSerialization = "Serialization of global methods (including implicit serialization via the use of asynchronous delegates) is not supported.";
    static string NotSupported_DelegateSerHolderSerial = "DelegateSerializationHolder objects are designed to represent a delegate during serialization and are not serializable themselves.";
    static string DelegateSer_InsufficientMetadata = "The delegate cannot be serialized properly due to missing metadata for the target method.";
    static string Argument_NoUninitializedStrings = "Uninitialized Strings cannot be created.";
    static string ArgumentOutOfRangeException_NoGCRegionSizeTooLarge = "totalSize is too large. For more information about setting the maximum size, see \"Latency Modes\" in http://go.microsoft.com/fwlink/?LinkId=522706.";
    static string InvalidOperationException_AlreadyInNoGCRegion = "The NoGCRegion mode was already in progress.";
    static string InvalidOperationException_NoGCRegionAllocationExceeded = "Allocated memory exceeds specified memory for NoGCRegion mode.";
    static string InvalidOperationException_NoGCRegionInduced = "Garbage collection was induced in NoGCRegion mode.";
    static string InvalidOperationException_NoGCRegionNotInProgress = "NoGCRegion mode must be set.";
    static string InvalidOperationException_SetLatencyModeNoGC = "The NoGCRegion mode is in progress. End it and then set a different mode.";
    static string InvalidOperation_NotWithConcurrentGC = "This API is not available when the concurrent GC is enabled.";
    static string ThreadState_AlreadyStarted = "Thread is running or terminated; it cannot restart.";
    static string ThreadState_Dead_Priority = "Thread is dead; priority cannot be accessed.";
    static string ThreadState_Dead_State = "Thread is dead; state cannot be accessed.";
    static string ThreadState_NotStarted = "Thread has not been started.";
    static string ThreadState_SetPriorityFailed = "Unable to set thread priority.";
    static string Serialization_InvalidFieldState = "Object fields may not be properly initialized.";
    static string Acc_CreateAbst = "Cannot create an abstract class.";
    static string Acc_CreateGeneric = "Cannot create a type for which Type.ContainsGenericParameters is true.";
    static string NotSupported_ManagedActivation = "Cannot create uninitialized instances of types requiring managed activation.";
    static string PlatformNotSupported_ResourceManager_ResWFileUnsupportedMethod = "ResourceManager method '{0}' is not supported when reading from .resw resource files.";
    static string PlatformNotSupported_ResourceManager_ResWFileUnsupportedProperty = "ResourceManager property '{0}' is not supported when reading from .resw resource files.";
    static string Serialization_NonSerType = "Type '{0}' in Assembly '{1}' is not marked as serializable.";
    static string InvalidCast_DBNull = "Object cannot be cast to DBNull.";
    static string NotSupported_NYI = "This feature is not currently implemented.";
    static string Delegate_GarbageCollected = "The corresponding delegate has been garbage collected. Please make sure the delegate is still referenced by managed code when you are using the marshalled native function pointer.";
    static string Arg_AmbiguousMatchException = "Ambiguous match found.";
    static string NotSupported_ChangeType = "ChangeType operation is not supported.";
    static string Arg_EmptyArray = "Array may not be empty.";
    static string MissingMember = "Member not found.";
    static string MissingField = "Field not found.";
    static string InvalidCast_FromDBNull = "Object cannot be cast from DBNull to other types.";
    static string NotSupported_DBNullSerial = "Only one DBNull instance may exist, and calls to DBNull deserialization methods are not allowed.";
    static string Serialization_StringBuilderCapacity = "The serialized Capacity property of StringBuilder must be positive, less than or equal to MaxCapacity and greater than or equal to the String length.";
    static string Serialization_StringBuilderMaxCapacity = "The serialized MaxCapacity property of StringBuilder must be positive and greater than or equal to the String length.";
    static string PlatformNotSupported_Remoting = "Remoting is not supported on this platform.";
    static string PlatformNotSupported_StrongNameSigning = "Strong-name signing is not supported on this platform.";
    static string Serialization_MissingDateTimeData = "Invalid serialized DateTime data. Unable to find 'ticks' or 'dateData'.";
    static string Serialization_DateTimeTicksOutOfRange = "Invalid serialized DateTime data. Ticks must be between DateTime.MinValue.Ticks and DateTime.MaxValue.Ticks.";
    static string FeatureRemoved_Message = "Code to support feature '{0}' was removed during publishing. If this is in error, update the project configuration to not disable feature '{0}'.";
    static string Arg_InvalidANSIString = "The ANSI string passed in could not be converted from the default ANSI code page to Unicode.";
    static string PlatformNotSupported_ArgIterator = "ArgIterator is not supported on this platform.";
    static string Arg_TypeUnloadedException = "Type had been unloaded.";
    static string Overflow_Currency = "Value was either too large or too small for a Currency.";
    static string PlatformNotSupported_SecureBinarySerialization = "Secure binary serialization is not supported on this platform.";
    static string Serialization_InvalidPtrValue = "An IntPtr or UIntPtr with an eight byte value cannot be deserialized on a machine with a four byte word size.";
    static string EventSource_AbstractMustNotDeclareEventMethods = "Abstract event source must not declare event methods ({0} with ID {1}).";
    static string EventSource_AbstractMustNotDeclareKTOC = "Abstract event source must not declare {0} nested type.";
    static string EventSource_AddScalarOutOfRange = "Getting out of bounds during scalar addition.";
    static string EventSource_BadHexDigit = "Bad Hexidecimal digit "{0}".";
    static string EventSource_ChannelTypeDoesNotMatchEventChannelValue = "Channel {0} does not match event channel value {1}.";
    static string EventSource_DataDescriptorsOutOfRange = "Data descriptors are out of range.";
    static string EventSource_DuplicateStringKey = "Multiple definitions for string "{0}".";
    static string EventSource_EnumKindMismatch = "The type of {0} is not expected in {1}.";
    static string EventSource_EvenHexDigits = "Must have an even number of Hexidecimal digits.";
    static string EventSource_EventChannelOutOfRange = "Channel {0} has a value of {1} which is outside the legal range (16-254).";
    static string EventSource_EventIdReused = "Event {0} has ID {1} which is already in use.";
    static string EventSource_EventMustHaveTaskIfNonDefaultOpcode = "Event {0} (with ID {1}) has a non-default opcode but not a task.";
    static string EventSource_EventMustNotBeExplicitImplementation = "Event method {0} (with ID {1}) is an explicit interface method implementation. Re-write method as implicit implementation.";
    static string EventSource_EventNameDoesNotEqualTaskPlusOpcode = "Event {0} (with ID {1}) has a name that is not the concatenation of its task name and opcode.";
    static string EventSource_EventNameReused = "Event name {0} used more than once.  If you wish to overload a method, the overloaded method should have a NonEvent attribute.";
    static string EventSource_EventParametersMismatch = "Event {0} was called with {1} argument(s), but it is defined with {2} parameter(s).";
    static string EventSource_EventSourceGuidInUse = "An instance of EventSource with Guid {0} already exists.";
    static string EventSource_EventTooBig = "The payload for a single event is too large.";
    static string EventSource_EventWithAdminChannelMustHaveMessage = "Event {0} specifies an Admin channel {1}. It must specify a Message property.";
    static string EventSource_IllegalKeywordsValue = "Keyword {0} has a value of {1} which is outside the legal range (0-0x0000080000000000).";
    static string EventSource_IllegalOpcodeValue = "Opcode {0} has a value of {1} which is outside the legal range (11-238).";
    static string EventSource_IllegalTaskValue = "Task {0} has a value of {1} which is outside the legal range (1-65535).";
    static string EventSource_IllegalValue = "Illegal value "{0}" (prefix strings with @ to indicate a literal string).";
    static string EventSource_IncorrentlyAuthoredTypeInfo = "Incorrectly-authored TypeInfo - a type should be serialized as one field or as one group";
    static string EventSource_InvalidCommand = "Invalid command value.";
    static string EventSource_InvalidEventFormat = "Can't specify both etw event format flags.";
    static string EventSource_KeywordCollision = "Keywords {0} and {1} are defined with the same value ({2}).";
    static string EventSource_KeywordNeedPowerOfTwo = "Value {0} for keyword {1} needs to be a power of 2.";
    static string EventSource_ListenerCreatedInsideCallback = "Creating an EventListener inside a EventListener callback.";
    static string EventSource_ListenerNotFound = "Listener not found.";
    static string EventSource_ListenerWriteFailure = "An error occurred when writing to a listener.";
    static string EventSource_MaxChannelExceeded = "Attempt to define more than the maximum limit of 8 channels for a provider.";
    static string EventSource_MismatchIdToWriteEvent = "Event {0} was assigned event ID {1} but {2} was passed to WriteEvent.";
    static string EventSource_NeedGuid = "The Guid of an EventSource must be non zero.";
    static string EventSource_NeedName = "The name of an EventSource must not be null.";
    static string EventSource_NeedPositiveId = "Event IDs must be positive integers.";
    static string EventSource_NoFreeBuffers = "No Free Buffers available from the operating system (e.g. event rate too fast).";
    static string EventSource_NonCompliantTypeError = "The API supports only anonymous types or types decorated with the EventDataAttribute. Non-compliant type: {0} dataType.";
    static string EventSource_NoRelatedActivityId = "EventSource expects the first parameter of the Event method to be of type Guid and to be named "relatedActivityId" when calling WriteEventWithRelatedActivityId.";
    static string EventSource_NotSupportedArrayOfBinary = "Arrays of Binary are not supported.";
    static string EventSource_NotSupportedArrayOfNil = "Arrays of Nil are not supported.";
    static string EventSource_NotSupportedArrayOfNullTerminatedString = "Arrays of null-terminated string are not supported.";
    static string EventSource_NotSupportedCustomSerializedData = "Enumerables of custom-serialized data are not supported";
    static string EventSource_NotSupportedNestedArraysEnums = "Nested arrays/enumerables are not supported.";
    static string EventSource_NullInput = "Null passed as a event argument.";
    static string EventSource_OpcodeCollision = "Opcodes {0} and {1} are defined with the same value ({2}).";
    static string EventSource_PinArrayOutOfRange = "Pins are out of range.";
    static string EventSource_RecursiveTypeDefinition = "Recursive type definition is not supported.";
    static string EventSource_SessionIdError = "Bit position in AllKeywords ({0}) must equal the command argument named "EtwSessionKeyword" ({1}).";
    static string EventSource_StopsFollowStarts = "An event with stop suffix must follow a corresponding event with a start suffix.";
    static string EventSource_TaskCollision = "Tasks {0} and {1} are defined with the same value ({2}).";
    static string EventSource_TaskOpcodePairReused = "Event {0} (with ID {1}) has the same task/opcode pair as event {2} (with ID {3}).";
    static string EventSource_TooManyArgs = "Too many arguments.";
    static string EventSource_TooManyFields = "Too many fields in structure.";
    static string EventSource_ToString = "EventSource({0}, {1})";
    static string EventSource_TraitEven = "There must be an even number of trait strings (they are key-value pairs).";
    static string EventSource_TypeMustBeSealedOrAbstract = "Event source types must be sealed or abstract.";
    static string EventSource_TypeMustDeriveFromEventSource = "Event source types must derive from EventSource.";
    static string EventSource_UndefinedChannel = "Use of undefined channel value {0} for event {1}.";
    static string EventSource_UndefinedKeyword = "Use of undefined keyword value {0} for event {1}.";
    static string EventSource_UndefinedOpcode = "Use of undefined opcode value {0} for event {1}.";
    static string EventSource_UnknownEtwTrait = "Unknown ETW trait "{0}".";
    static string EventSource_UnsupportedEventTypeInManifest = "Unsupported type {0} in event source.";
    static string EventSource_UnsupportedMessageProperty = "Event {0} specifies an illegal or unsupported formatting message ("{1}").";
    static string EventSource_VarArgsParameterMismatch = "The parameters to the Event method do not match the parameters to the WriteEvent method. This may cause the event to be displayed incorrectly.";
    static string Arg_SurrogatesNotAllowedAsSingleChar = "Unicode surrogate characters must be written out as pairs together in the same call, not individually. Consider passing in a character array instead.";
    static string CustomAttributeFormat_InvalidFieldFail = "'{0}' field specified was not found.";
    static string CustomAttributeFormat_InvalidPropertyFail = "'{0}' property specified was not found.";
    static string ArrayTypeMismatch_ConstrainedCopy = "Array.ConstrainedCopy will only work on array types that are provably compatible, without any form of boxing, unboxing, widening, or casting of each array element.  Change the array types (i.e., copy a Derived[] to a Base[]), or use a mitigation strategy in the CER for Array.Copy's less powerful reliability contract, such as cloning the array or throwing away the potentially corrupt destination array.";
    static string Arg_DllNotFoundException = "Dll was not found.";
    static string Arg_DllNotFoundExceptionParameterized = "Unable to load DLL '{0}': The specified module could not be found.";
    static string Arg_DriveNotFoundException = "Attempted to access a drive that is not available.";
    static string WrongSizeArrayInNStruct = "Type could not be marshaled because the length of an embedded array instance does not match the declared length in the layout.";
    static string Arg_InteropMarshalUnmappableChar = "Cannot marshal: Encountered unmappable character.";
    static string Arg_MarshalDirectiveException = "Marshaling directives are invalid.";
    static string Arg_RegSubKeyValueAbsent = "No value exists with that name.";
    static string Arg_RegValStrLenBug = "Registry value names should not be greater than 16,383 characters.";
    static string Serialization_DelegatesNotSupported = "Serializing delegates is not supported on this platform.";
    static string Arg_OpenType = "Cannot create an instance of {0} as it is an open type.";
    static string Arg_PlatformNotSupported_AssemblyName_GetAssemblyName = "AssemblyName.GetAssemblyName() is not supported on this platform.";
    static string NotSupported_OpenType = "Cannot create arrays of open type.";
    static string NotSupported_ByRefLikeArray = "Cannot create arrays of ByRef-like values.";
    static string StackTrace_AtWord = "   at ";
    static string StackTrace_EndStackTraceFromPreviousThrow = "--- End of stack trace from previous location where exception was thrown ---";
    static string InvalidAssemblyName = "The given assembly name or codebase was invalid";
    static string Argument_HasToBeArrayClass = "Must be an array type.";
    static string Argument_IdnBadBidi = "Left to right characters may not be mixed with right to left characters in IDN labels.";
    static string Argument_IdnBadLabelSize = "IDN labels must be between 1 and 63 characters long.";
    static string Argument_IdnBadNameSize = "IDN names must be between 1 and {0} characters long.";
    static string Argument_IdnBadPunycode = "Invalid IDN encoded string.";
    static string Argument_IdnBadStd3 = "Label contains character '{0}' not allowed with UseStd3AsciiRules";
    static string Argument_IdnIllegalName = "Decoded string is not a valid IDN name.";
    static string InvalidOperation_NotGenericType = "This operation is only valid on generic types.";
    static string NotSupported_SignatureType = "This method is not supported on signature types.";
    static string Memory_OutstandingReferences = "Release all references before disposing this instance.";
    static string HashCode_HashCodeNotSupported = "HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.";
    static string HashCode_EqualityNotSupported = "HashCode is a mutable struct and should not be compared with other HashCodes.";
    static string IO_InvalidReadLength = "The read operation returned an invalid length.";
    static string Arg_BasePathNotFullyQualified = "Basepath argument is not fully qualified.";
    static string NullReference_InvokeNullRefReturned = "The target method returned a null reference.";
    static string Thread_Operation_RequiresCurrentThread = "This operation must be performed on the same thread as that represented by the Thread instance.";
    static string InvalidOperation_WrongAsyncResultOrEndReadCalledMultiple = "Either the IAsyncResult object did not come from the corresponding async method on this type, or EndRead was called multiple times with the same IAsyncResult.";
    static string InvalidOperation_WrongAsyncResultOrEndWriteCalledMultiple = "Either the IAsyncResult object did not come from the corresponding async method on this type, or EndWrite was called multiple times with the same IAsyncResult.";
    static string ArgumentOutOfRange_Week_ISO = "The week parameter must be in the range 1 through 53.";
    static string net_uri_BadAuthority = "Invalid URI: The Authority/Host could not be parsed.";
    static string net_uri_BadAuthorityTerminator = "Invalid URI: The Authority/Host cannot end with a backslash character ('\\').";
    static string net_uri_BadFormat = "Invalid URI: The format of the URI could not be determined.";
    static string net_uri_NeedFreshParser = "The URI parser instance passed into 'uriParser' parameter is already registered with the scheme name '{0}'.";
    static string net_uri_AlreadyRegistered = "A URI scheme name '{0}' already has a registered custom parser.";
    static string net_uri_BadHostName = "Invalid URI: The hostname could not be parsed.";
    static string net_uri_BadPort = "Invalid URI: Invalid port specified.";
    static string net_uri_BadScheme = "Invalid URI: The URI scheme is not valid.";
    static string net_uri_BadString = "Invalid URI: There is an invalid sequence in the string.";
    static string net_uri_BadUserPassword = "Invalid URI: The username:password construct is badly formed.";
    static string net_uri_CannotCreateRelative = "A relative URI cannot be created because the 'uriString' parameter represents an absolute URI.";
    static string net_uri_SchemeLimit = "Invalid URI: The Uri scheme is too long.";
    static string net_uri_EmptyUri = "Invalid URI: The URI is empty.";
    static string net_uri_InvalidUriKind = "The value '{0}' passed for the UriKind parameter is invalid.";
    static string net_uri_MustRootedPath = "Invalid URI: A Dos path must be rooted, for example, 'c:\\'.";
    static string net_uri_NotAbsolute = "This operation is not supported for a relative URI.";
    static string net_uri_PortOutOfRange = "A derived type '{0}' has reported an invalid value for the Uri port '{1}'.";
    static string net_uri_SizeLimit = "Invalid URI: The Uri string is too long.";
    static string net_uri_UserDrivenParsing = "A derived type '{0}' is responsible for parsing this Uri instance. The base implementation must not be used.";
    static string net_uri_NotJustSerialization = "UriComponents.SerializationInfoString must not be combined with other UriComponents.";
    static string net_uri_BadUnicodeHostForIdn = "An invalid Unicode character by IDN standards was specified in the host.";
    static string Argument_ExtraNotValid = "Extra portion of URI not valid.";
    static string Argument_InvalidUriSubcomponent = "The subcomponent, {0}, of this uri is not valid.";
    static string AccessControl_InvalidHandle = "The supplied handle is invalid. This can happen when trying to set an ACL on an anonymous kernel object.";
    static string Arg_RegSubKeyAbsent = "Cannot delete a subkey tree because the subkey does not exist.";
    static string Arg_RegKeyDelHive = "Cannot delete a registry hive's subtree.";
    static string Arg_RegKeyNoRemoteConnect = "No remote connection to '{0}' while trying to read the registry.";
    static string Arg_RegKeyOutOfRange = "Registry HKEY was out of the legal range.";
    static string Arg_RegKeyStrLenBug = "Registry key names should not be greater than 255 characters.";
    static string Arg_RegBadKeyKind = "The specified RegistryValueKind is an invalid value.";
    static string Arg_RegSetMismatchedKind = "The type of the value object did not match the specified RegistryValueKind or the object could not be properly converted.";
    static string Arg_RegSetBadArrType = "RegistryKey.SetValue does not support arrays of type '{0}'. Only Byte[] and String[] are supported.";
    static string Arg_RegSetStrArrNull = "RegistryKey.SetValue does not allow a String[] that contains a null String reference.";
    static string Arg_DllInitFailure = "One machine may not have remote administration enabled, or both machines may not be running the remote registry service.";
    static string Argument_InvalidRegistryOptionsCheck = "The specified RegistryOptions value is invalid.";
    static string Argument_InvalidRegistryViewCheck = "The specified RegistryView value is invalid.";
    static string Argument_InvalidRegistryKeyPermissionCheck = "The specified RegistryKeyPermissionCheck value is invalid.";
    static string InvalidOperation_RegRemoveSubKey = "Registry key has subkeys and recursive removes are not supported by this method.";
    static string ObjectDisposed_RegKeyClosed = "Cannot access a closed registry key.";
    static string PlatformNotSupported_Registry = "Registry is not supported on this platform.";
    static string UnauthorizedAccess_RegistryNoWrite = "Cannot write to the registry key.";
    static string Cryptography_ArgECDHKeySizeMismatch = "The keys from both parties must be the same size to generate a secret agreement.";
    static string Cryptography_ArgECDHRequiresECDHKey = "Keys used with the ECDiffieHellmanCng algorithm must have an algorithm group of ECDiffieHellman.";
    static string Cryptography_TlsRequiresLabelAndSeed = "The TLS key derivation function requires both the label and seed properties to be set.";
    static string Cryptography_TlsRequires64ByteSeed = "The TLS key derivation function requires a seed value of exactly 64 bytes.";
    static string Cryptography_Config_EncodedOIDError = "Encoded OID length is too large (greater than 0x7f bytes).";
    static string Cryptography_ECXmlSerializationFormatRequired = "XML serialization of an elliptic curve key requires using an overload which specifies the XML format to be used.";
    static string Cryptography_InvalidCurveOid = "The specified Oid is not valid. The Oid.FriendlyName or Oid.Value property must be set.";
    static string Cryptography_InvalidCurveKeyParameters = "The specified key parameters are not valid. Q.X and Q.Y are required fields. Q.X, Q.Y must be the same length. If D is specified it must be the same length as Q.X and Q.Y for named curves or the same length as Order for explicit curves.";
    static string Cryptography_InvalidECCharacteristic2Curve = "The specified Characteristic2 curve parameters are not valid. Polynomial, A, B, G.X, G.Y, and Order are required. A, B, G.X, G.Y must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.";
    static string Cryptography_InvalidECPrimeCurve = "The specified prime curve parameters are not valid. Prime, A, B, G.X, G.Y and Order are required and must be the same length, and the same length as Q.X, Q.Y and D if those are specified. Seed, Cofactor and Hash are optional. Other parameters are not allowed.";
    static string Cryptography_InvalidECNamedCurve = "The specified named curve parameters are not valid. Only the Oid parameter must be set.";
    static string Cryptography_InvalidKey_SemiWeak = "Specified key is a known semi-weak key for '{0}' and cannot be used.";
    static string Cryptography_InvalidKey_Weak = "Specified key is a known weak key for '{0}' and cannot be used.";
    static string Cryptography_InvalidOperation = "This operation is not supported for this class.";
    static string Cryptography_InvalidPadding = "Padding is invalid and cannot be removed.";
    static string Cryptography_MissingIV = "The cipher mode specified requires that an initialization vector (IV) be used.";
    static string Cryptography_MissingKey = "No asymmetric key object has been associated with this formatter object.";
    static string Cryptography_MissingOID = "Required object identifier (OID) cannot be found.";
    static string Cryptography_MustTransformWholeBlock = "TransformBlock may only process bytes in block sized increments.";
    static string Cryptography_NotValidPrivateKey = "Key is not a valid private key.";
    static string Cryptography_NotValidPublicOrPrivateKey = "Key is not a valid public or private key.";
    static string Cryptography_PartialBlock = "The input data is not a complete block.";
    static string Cryptography_PasswordDerivedBytes_FewBytesSalt = "Salt is not at least eight bytes.";
    static string Cryptography_RC2_EKS40 = "EffectiveKeySize value must be at least 40 bits.";
    static string Cryptography_RC2_EKSKS = "KeySize value must be at least as large as the EffectiveKeySize value.";
    static string Cryptography_RC2_EKSKS2 = "EffectiveKeySize must be the same as KeySize in this implementation.";
    static string Cryptography_Rijndael_BlockSize = "BlockSize must be 128 in this implementation.";
    static string Cryptography_TransformBeyondEndOfBuffer = "Attempt to transform beyond end of buffer.";
    static string Cryptography_CipherModeNotSupported = "The specified CipherMode '{0}' is not supported.";
    static string Cryptography_UnknownPaddingMode = "Unknown padding mode used.";
    static string Cryptography_UnexpectedTransformTruncation = "CNG provider unexpectedly terminated encryption or decryption prematurely.";
    static string Cryptography_UnsupportedPaddingMode = "The specified PaddingMode is not supported.";
    static string NotSupported_Method = "Method not supported.";
    static string Cryptography_AlgorithmTypesMustBeVisible = "Algorithms added to CryptoConfig must be accessable from outside their assembly.";
    static string Cryptography_AddNullOrEmptyName = "CryptoConfig cannot add a mapping for a null or empty name.";
    static string ArgumentOutOfRange_ConsoleKey = "Console key values must be between 0 and 255 inclusive.";
    static string Arg_InvalidComObjectException = "Attempt has been made to use a COM object that does not have a backing class factory.";
    static string Arg_MustBeNullTerminatedString = "The string must be null-terminated.";
    static string Arg_InvalidOleVariantTypeException = "Specified OLE variant was invalid.";
    static string Arg_SafeArrayRankMismatchException = "Specified array was not of the expected rank.";
    static string Arg_SafeArrayTypeMismatchException = "Specified array was not of the expected type.";
    static string TypeNotDelegate = "'Type '{0}' is not a delegate type.  EventTokenTable may only be used with delegate types.'";
    static string InvalidOperationException_ActorGraphCircular = "An Actor must not create a circular reference between itself (or one of its child Actors) and one of its parents.";
    static string InvalidOperation_ClaimCannotBeRemoved = "The Claim '{0}' was not able to be removed.  It is either not part of this Identity or it is a Claim that is owned by the Principal that contains this Identity. For example, the Principal will own the Claim when creating a GenericPrincipal with roles. The roles will be exposed through the Identity that is passed in the constructor, but not actually owned by the Identity.  Similar logic exists for a RolePrincipal.";
    static string PlatformNotSupported_Serialization = "This instance contains state that cannot be serialized and deserialized on this platform.";
    static string PrivilegeNotHeld_Default = "The process does not possess some privilege required for this operation.";
    static string PrivilegeNotHeld_Named = "The process does not possess the '{0}' privilege which is required for this operation.";
    static string CountdownEvent_Decrement_BelowZero = "Invalid attempt made to decrement the event's count below zero.";
    static string CountdownEvent_Increment_AlreadyZero = "The event is already signaled and cannot be incremented.";
    static string CountdownEvent_Increment_AlreadyMax = "The increment operation would cause the CurrentCount to overflow.";
    static string ArrayWithOffsetOverflow = "ArrayWithOffset: offset exceeds array size.";
    static string Arg_NotIsomorphic = "Object contains non-primitive or non-blittable data.";
    static string StructArrayTooLarge = "Array size exceeds addressing limitations.";
    static string IO_DriveNotFound = "Could not find the drive. The drive might not be ready or might not be mapped.";
    static string Argument_MustSupplyParent = "When supplying the ID of a containing object, the FieldInfo that identifies the current field within that object must also be supplied.";
    static string Argument_MemberAndArray = "Cannot supply both a MemberInfo and an Array to indicate the parent of a value type.";
    static string Argument_MustSupplyContainer = "When supplying a FieldInfo for fixing up a nested type, a valid ID for that containing object must also be supplied.";
    static string Serialization_NoID = "Object has never been assigned an objectID";
    static string Arg_SwitchExpressionException = "Non-exhaustive switch expression failed to match its input.";
    static string SwitchExpressionException_UnmatchedValue = "Unmatched value was {0}.";
    static string Argument_InvalidRandomRange = "Range of random number does not contain at least one possibility.";
    static string BufferWriterAdvancedTooFar = "Cannot advance past the end of the buffer, which has a size of {0}.";
    static string net_gssapi_operation_failed_detailed_majoronly = "GSSAPI operation failed with error - {0}.";
    static string net_gssapi_operation_failed_majoronly = "SSAPI operation failed with status: {0}.";

    static /*0x1ec4738*/ string GetString(string name, object[] args);
    static /*0x1ec47a8*/ string GetString(System.Globalization.CultureInfo culture, string name, object[] args);
    static /*0x1ec47b0*/ string GetString(string name);
    static /*0x1ec47b4*/ string GetString(System.Globalization.CultureInfo culture, string name);
    static /*0x1ec47bc*/ string Format(string resourceFormat, object[] args);
    static /*0x1ec366c*/ string Format(string resourceFormat, object p1);
    static /*0x1ec4838*/ string Format(string resourceFormat, object p1, object p2);
    static /*0x1ec48b0*/ string Format(System.Globalization.CultureInfo ci, string resourceFormat, object p1, object p2);
    static /*0x1ec48b8*/ string Format(string resourceFormat, object p1, object p2, object p3);
    static /*0x1ec4940*/ string GetResourceString(string str);
    static /*0x1ec4944*/ object GetObject(string name);
}

namespace Mono
{
    enum CertificateImportFlags
    {
        None = 0,
        DisableNativeBackend = 1,
        DisableAutomaticFallback = 2,
    }

    class DataConverter
    {
        static /*0x0*/ Mono.DataConverter SwapConv;
        static /*0x8*/ Mono.DataConverter CopyConv;
        static /*0x10*/ bool IsLittleEndian;

        static /*0x1ec6d5c*/ DataConverter();
        static /*0x1ec4d44*/ Mono.DataConverter get_LittleEndian();
        static /*0x1ec4ddc*/ Mono.DataConverter get_BigEndian();
        static /*0x1ec4e74*/ Mono.DataConverter get_Native();
        static /*0x1ec4ecc*/ int Align(int current, int align);
        static /*0x1ec4ee0*/ byte[] Pack(string description, object[] args);
        static /*0x1ec5894*/ byte[] PackEnumerable(string description, System.Collections.IEnumerable args);
        static /*0x1ec505c*/ bool PackOne(Mono.DataConverter.PackContext b, object oarg);
        static /*0x1ec5d40*/ bool Prepare(byte[] buffer, ref int idx, int size, ref bool align);
        static /*0x1ec5df4*/ System.Collections.IList Unpack(string description, byte[] buffer, int startIndex);
        /*0x1ec6d54*/ DataConverter();
        double GetDouble(byte[] data, int index);
        float GetFloat(byte[] data, int index);
        long GetInt64(byte[] data, int index);
        int GetInt32(byte[] data, int index);
        short GetInt16(byte[] data, int index);
        uint GetUInt32(byte[] data, int index);
        ushort GetUInt16(byte[] data, int index);
        ulong GetUInt64(byte[] data, int index);
        void PutBytes(byte[] dest, int destIdx, double value);
        void PutBytes(byte[] dest, int destIdx, float value);
        void PutBytes(byte[] dest, int destIdx, int value);
        void PutBytes(byte[] dest, int destIdx, long value);
        void PutBytes(byte[] dest, int destIdx, short value);
        void PutBytes(byte[] dest, int destIdx, ushort value);
        void PutBytes(byte[] dest, int destIdx, uint value);
        void PutBytes(byte[] dest, int destIdx, ulong value);
        /*0x1ec4948*/ byte[] GetBytes(double value);
        /*0x1ec49c4*/ byte[] GetBytes(float value);
        /*0x1ec4a44*/ byte[] GetBytes(int value);
        /*0x1ec4ac4*/ byte[] GetBytes(long value);
        /*0x1ec4b44*/ byte[] GetBytes(short value);
        /*0x1ec4bc4*/ byte[] GetBytes(ushort value);
        /*0x1ec4c44*/ byte[] GetBytes(uint value);
        /*0x1ec4cc4*/ byte[] GetBytes(ulong value);
        /*0x1ec6cac*/ void Check(byte[] dest, int destIdx, int size);

        class PackContext
        {
            /*0x10*/ byte[] buffer;
            /*0x18*/ int next;
            /*0x20*/ string description;
            /*0x28*/ int i;
            /*0x30*/ Mono.DataConverter conv;
            /*0x38*/ int repeat;
            /*0x3c*/ int align;

            /*0x1ec5054*/ PackContext();
            /*0x1ec5b70*/ void Add(byte[] group);
            /*0x1ec5800*/ byte[] Get();
        }

        class CopyConverter : Mono.DataConverter
        {
            /*0x1ec6e98*/ CopyConverter();
            /*0x1ec6ef0*/ double GetDouble(byte[] data, int index);
            /*0x1ec6ff8*/ ulong GetUInt64(byte[] data, int index);
            /*0x1ec7100*/ long GetInt64(byte[] data, int index);
            /*0x1ec7208*/ float GetFloat(byte[] data, int index);
            /*0x1ec7310*/ int GetInt32(byte[] data, int index);
            /*0x1ec7418*/ uint GetUInt32(byte[] data, int index);
            /*0x1ec7520*/ short GetInt16(byte[] data, int index);
            /*0x1ec7628*/ ushort GetUInt16(byte[] data, int index);
            /*0x1ec7730*/ void PutBytes(byte[] dest, int destIdx, double value);
            /*0x1ec7780*/ void PutBytes(byte[] dest, int destIdx, float value);
            /*0x1ec77d0*/ void PutBytes(byte[] dest, int destIdx, int value);
            /*0x1ec7818*/ void PutBytes(byte[] dest, int destIdx, uint value);
            /*0x1ec7860*/ void PutBytes(byte[] dest, int destIdx, long value);
            /*0x1ec78a8*/ void PutBytes(byte[] dest, int destIdx, ulong value);
            /*0x1ec78f0*/ void PutBytes(byte[] dest, int destIdx, short value);
            /*0x1ec7938*/ void PutBytes(byte[] dest, int destIdx, ushort value);
        }

        class SwapConverter : Mono.DataConverter
        {
            /*0x1ec6e40*/ SwapConverter();
            /*0x1ec7980*/ double GetDouble(byte[] data, int index);
            /*0x1ec7a84*/ ulong GetUInt64(byte[] data, int index);
            /*0x1ec7b88*/ long GetInt64(byte[] data, int index);
            /*0x1ec7c8c*/ float GetFloat(byte[] data, int index);
            /*0x1ec7d90*/ int GetInt32(byte[] data, int index);
            /*0x1ec7e94*/ uint GetUInt32(byte[] data, int index);
            /*0x1ec7f98*/ short GetInt16(byte[] data, int index);
            /*0x1ec809c*/ ushort GetUInt16(byte[] data, int index);
            /*0x1ec81a0*/ void PutBytes(byte[] dest, int destIdx, double value);
            /*0x1ec8204*/ void PutBytes(byte[] dest, int destIdx, float value);
            /*0x1ec8268*/ void PutBytes(byte[] dest, int destIdx, int value);
            /*0x1ec82cc*/ void PutBytes(byte[] dest, int destIdx, uint value);
            /*0x1ec8330*/ void PutBytes(byte[] dest, int destIdx, long value);
            /*0x1ec8394*/ void PutBytes(byte[] dest, int destIdx, ulong value);
            /*0x1ec83f8*/ void PutBytes(byte[] dest, int destIdx, short value);
            /*0x1ec844c*/ void PutBytes(byte[] dest, int destIdx, ushort value);
        }
    }

    class DependencyInjector
    {
        static string TypeName = "Mono.SystemDependencyProvider, System";
        static /*0x0*/ object locker;
        static /*0x8*/ Mono.ISystemDependencyProvider systemDependency;

        static /*0x1ec8998*/ DependencyInjector();
        static /*0x1ec84a0*/ Mono.ISystemDependencyProvider get_SystemProvider();
        static /*0x1ec87f0*/ void Register(Mono.ISystemDependencyProvider provider);
        static /*0x1ec86a4*/ Mono.ISystemDependencyProvider ReflectionLoad();
    }

    interface ISystemCertificateProvider
    {
        System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(byte[] data, Mono.CertificateImportFlags importFlags);
        System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(byte[] data, Microsoft.Win32.SafeHandles.SafePasswordHandle password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags, Mono.CertificateImportFlags importFlags);
        System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(System.Security.Cryptography.X509Certificates.X509Certificate cert, Mono.CertificateImportFlags importFlags);
    }

    interface ISystemDependencyProvider
    {
        Mono.ISystemCertificateProvider get_CertificateProvider();
    }

    class Runtime
    {
        static /*0x0*/ object dump;

        static /*0x1ec99fc*/ Runtime();
        static /*0x1ec8a10*/ void mono_runtime_install_handlers();
        static /*0x1ec8a14*/ void InstallSignalHandlers();
        static /*0x1ec8a60*/ void mono_runtime_cleanup_handlers();
        static /*0x1ec8a64*/ void RemoveSignalHandlers();
        static /*0x1ec8ab0*/ string GetDisplayName();
        static /*0x1ec8ab4*/ string GetNativeStackTrace(System.Exception exception);
        static /*0x1ec8ab8*/ bool SetGCAllowSynchronousMajor(bool flag);
        static /*0x1ec8ac0*/ string ExceptionToState_internal(System.Exception exc, ref ulong portable_hash, ref ulong unportable_hash);
        static /*0x1ec8ac4*/ System.Tuple<string, ulong, ulong> ExceptionToState(System.Exception exc);
        static /*0x1ec8ba0*/ string DumpStateSingle_internal(ref ulong portable_hash, ref ulong unportable_hash);
        static /*0x1ec8ba4*/ string DumpStateTotal_internal(ref ulong portable_hash, ref ulong unportable_hash);
        static /*0x1ec8ba8*/ System.Tuple<string, ulong, ulong> DumpStateSingle();
        static /*0x1ec8d30*/ System.Tuple<string, ulong, ulong> DumpStateTotal();
        static /*0x1ec8eb8*/ void RegisterReportingForAllNativeLibs_internal();
        static /*0x1ec8ebc*/ void RegisterReportingForAllNativeLibs();
        static /*0x1ec8f08*/ void RegisterReportingForNativeLib_internal(nint modulePathSuffix, nint moduleName);
        static /*0x1ec8f0c*/ void RegisterReportingForNativeLib(string modulePathSuffix_str, string moduleName_str);
        static /*0x1ec9178*/ void EnableCrashReportLog_internal(nint directory);
        static /*0x1ec917c*/ void EnableCrashReportLog(string directory_str);
        static /*0x1ec9288*/ int CheckCrashReportLog_internal(nint directory, bool clear);
        static /*0x1ec9290*/ Mono.Runtime.CrashReportLogLevel CheckCrashReportLog(string directory_str, bool clear);
        static /*0x1ec93c4*/ string get_breadcrumb_value(string file_prefix, string directory_str, bool clear);
        static /*0x1ec9634*/ long CheckCrashReportHash(string directory_str, bool clear);
        static /*0x1ec9728*/ string CheckCrashReportReason(string directory_str, bool clear);
        static /*0x1ec97a4*/ void AnnotateMicrosoftTelemetry_internal(nint key, nint val);
        static /*0x1ec97a8*/ void AnnotateMicrosoftTelemetry(string key, string val);

        enum CrashReportLogLevel
        {
            MonoSummaryNone = 0,
            MonoSummarySetup = 1,
            MonoSummarySuspendHandshake = 2,
            MonoSummaryUnmanagedStacks = 3,
            MonoSummaryManagedStacks = 4,
            MonoSummaryStateWriter = 5,
            MonoSummaryStateWriterDone = 6,
            MonoSummaryMerpWriter = 7,
            MonoSummaryMerpInvoke = 8,
            MonoSummaryCleanup = 9,
            MonoSummaryDone = 10,
            MonoSummaryDoubleFault = 11,
        }

        class <>c
        {
            static /*0x0*/ Mono.Runtime.<> <>9;
            static /*0x8*/ System.Action<string> <>9__23_0;

            static /*0x1ec9a74*/ <>c();
            /*0x1ec9ad8*/ <>c();
            /*0x1ec9ae0*/ void <get_breadcrumb_value>b__23_0(string f);
        }
    }

    struct RuntimeClassHandle
    {
        /*0x10*/ Mono.RuntimeStructs.MonoClass* value;

        static /*0x1ec9c58*/ bool op_Equality(Mono.RuntimeClassHandle left, object right);
        static /*0x1ec9ccc*/ bool op_Inequality(Mono.RuntimeClassHandle left, object right);
        static /*0x1ec9ce4*/ bool op_Equality(object left, Mono.RuntimeClassHandle right);
        static /*0x1ec9d58*/ bool op_Inequality(object left, Mono.RuntimeClassHandle right);
        static /*0x1ec9d70*/ nint GetTypeFromClass(Mono.RuntimeStructs.MonoClass* klass);
        /*0x1ec9aec*/ RuntimeClassHandle(Mono.RuntimeStructs.MonoClass* value);
        /*0x1ec9af4*/ RuntimeClassHandle(nint ptr);
        /*0x1ec9b14*/ Mono.RuntimeStructs.MonoClass* get_Value();
        /*0x1ec9b1c*/ bool Equals(object obj);
        /*0x1ec9c20*/ int GetHashCode();
        /*0x1ec9c48*/ bool Equals(Mono.RuntimeClassHandle handle);
        /*0x1ec9d74*/ System.RuntimeTypeHandle GetTypeHandle();
    }

    struct RuntimeRemoteClassHandle
    {
        /*0x10*/ Mono.RuntimeStructs.RemoteClass* value;

        /*0x1ec9d7c*/ RuntimeRemoteClassHandle(Mono.RuntimeStructs.RemoteClass* value);
        /*0x1ec9d84*/ Mono.RuntimeClassHandle get_ProxyClass();
    }

    struct RuntimeGenericParamInfoHandle
    {
        /*0x10*/ Mono.RuntimeStructs.GenericParamInfo* value;

        /*0x1ec9da0*/ RuntimeGenericParamInfoHandle(Mono.RuntimeStructs.GenericParamInfo* value);
        /*0x1ec9da8*/ RuntimeGenericParamInfoHandle(nint ptr);
        /*0x1ec9dc8*/ System.Type[] get_Constraints();
        /*0x1ec9ef8*/ System.Reflection.GenericParameterAttributes get_Attributes();
        /*0x1ec9dcc*/ System.Type[] GetConstraints();
        /*0x1ec9f14*/ int GetConstraintsCount();
    }

    struct RuntimeEventHandle
    {
        /*0x10*/ nint value;

        static /*0x1eca084*/ bool op_Equality(Mono.RuntimeEventHandle left, Mono.RuntimeEventHandle right);
        static /*0x1eca08c*/ bool op_Inequality(Mono.RuntimeEventHandle left, Mono.RuntimeEventHandle right);
        /*0x1ec9f54*/ RuntimeEventHandle(nint v);
        /*0x1ec9f5c*/ nint get_Value();
        /*0x1ec9f64*/ bool Equals(object obj);
        /*0x1eca070*/ bool Equals(Mono.RuntimeEventHandle handle);
        /*0x1eca07c*/ int GetHashCode();
    }

    struct RuntimePropertyHandle
    {
        /*0x10*/ nint value;

        static /*0x1eca1d8*/ bool op_Equality(Mono.RuntimePropertyHandle left, Mono.RuntimePropertyHandle right);
        static /*0x1eca1e0*/ bool op_Inequality(Mono.RuntimePropertyHandle left, Mono.RuntimePropertyHandle right);
        /*0x1eca0a8*/ RuntimePropertyHandle(nint v);
        /*0x1eca0b0*/ nint get_Value();
        /*0x1eca0b8*/ bool Equals(object obj);
        /*0x1eca1c4*/ bool Equals(Mono.RuntimePropertyHandle handle);
        /*0x1eca1d0*/ int GetHashCode();
    }

    struct RuntimeGPtrArrayHandle
    {
        /*0x10*/ Mono.RuntimeStructs.GPtrArray* value;

        static /*0x1eca2b0*/ void GPtrArrayFree(Mono.RuntimeStructs.GPtrArray* value);
        static /*0x1eca2b4*/ void DestroyAndFree(ref Mono.RuntimeGPtrArrayHandle h);
        /*0x1eca1fc*/ RuntimeGPtrArrayHandle(Mono.RuntimeStructs.GPtrArray* value);
        /*0x1eca204*/ RuntimeGPtrArrayHandle(nint ptr);
        /*0x1eca224*/ int get_Length();
        /*0x1eca240*/ nint get_Item(int i);
        /*0x1eca244*/ nint Lookup(int i);
    }

    class RuntimeMarshal
    {
        static /*0x1eca2d0*/ string PtrToUtf8String(nint ptr);
        static /*0x1ec90a8*/ Mono.SafeStringMarshal MarshalString(string str);
        static /*0x1eca414*/ int DecodeBlobSize(nint in_ptr, ref nint out_ptr);
        static /*0x1eca494*/ byte[] DecodeBlobArray(nint ptr);
        static /*0x1eca54c*/ int AsciHexDigitValue(int c);
        static /*0x1eca578*/ void FreeAssemblyName(ref Mono.MonoAssemblyName name, bool freeStruct);
    }

    class RuntimeStructs
    {
        struct RemoteClass
        {
            /*0x10*/ nint default_vtable;
            /*0x18*/ nint xdomain_vtable;
            /*0x20*/ Mono.RuntimeStructs.MonoClass* proxy_class;
            /*0x28*/ nint proxy_class_name;
            /*0x30*/ uint interface_count;
        }

        struct MonoClass
        {
        }

        struct GenericParamInfo
        {
            /*0x10*/ Mono.RuntimeStructs.MonoClass* pklass;
            /*0x18*/ nint name;
            /*0x20*/ ushort flags;
            /*0x24*/ uint token;
            /*0x28*/ Mono.RuntimeStructs.MonoClass** constraints;
        }

        struct GPtrArray
        {
            /*0x10*/ nint* data;
            /*0x18*/ int len;
        }
    }

    struct MonoAssemblyName
    {
        static int MONO_PUBLIC_KEY_TOKEN_LENGTH = 17;
        /*0x10*/ nint name;
        /*0x18*/ nint culture;
        /*0x20*/ nint hash_value;
        /*0x28*/ nint public_key;
        /*0x30*/ Mono.MonoAssemblyName.<public_key_token> public_key_token;
        /*0x44*/ uint hash_alg;
        /*0x48*/ uint hash_len;
        /*0x4c*/ uint flags;
        /*0x50*/ ushort major;
        /*0x52*/ ushort minor;
        /*0x54*/ ushort build;
        /*0x56*/ ushort revision;
        /*0x58*/ ushort arch;

        struct <public_key_token>e__FixedBuffer
        {
            /*0x10*/ byte FixedElementField;
        }
    }

    struct ValueTuple
    {
    }

    struct ValueTuple<T1>
    {
        /*0x0*/ T1 Item1;
    }

    struct ValueTuple<T1, T2>
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
    }

    struct ValueTuple<T1, T2, T3>
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
    }

    struct ValueTuple<T1, T2, T3, T4>
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
    }

    struct ValueTuple<T1, T2, T3, T4, T5>
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
        /*0x0*/ T5 Item5;
    }

    class NullByRefReturnException : System.Exception
    {
        /*0x1eca580*/ NullByRefReturnException();
    }

    struct SafeGPtrArrayHandle : System.IDisposable
    {
        /*0x10*/ Mono.RuntimeGPtrArrayHandle handle;

        /*0x1eca5d8*/ SafeGPtrArrayHandle(nint ptr);
        /*0x1eca5f8*/ void Dispose();
        /*0x1eca614*/ int get_Length();
        /*0x1eca630*/ nint get_Item(int i);
    }

    struct SafeStringMarshal : System.IDisposable
    {
        /*0x10*/ string str;
        /*0x18*/ nint marshaled_string;

        static /*0x1eca634*/ nint StringToUtf8_icall(ref string str);
        static /*0x1eca638*/ nint StringToUtf8(string str);
        static /*0x1eca650*/ void GFree(nint ptr);
        /*0x1eca3b4*/ SafeStringMarshal(string str);
        /*0x1ec90f8*/ nint get_Value();
        /*0x1eca654*/ void Dispose();
    }

    namespace Xml
    {
        class SecurityParser : Mono.Xml.SmallXmlParser, Mono.Xml.SmallXmlParser.IContentHandler
        {
            /*0x68*/ System.Security.SecurityElement root;
            /*0x70*/ System.Security.SecurityElement current;
            /*0x78*/ System.Collections.Stack stack;

            /*0x1eca6c8*/ SecurityParser();
            /*0x1eca848*/ void LoadXml(string xml);
            /*0x1ecaa9c*/ System.Security.SecurityElement ToXml();
            /*0x1ecaaa4*/ void OnStartParsing(Mono.Xml.SmallXmlParser parser);
            /*0x1ecaaa8*/ void OnProcessingInstruction(string name, string text);
            /*0x1ecaaac*/ void OnIgnorableWhitespace(string s);
            /*0x1ecaab0*/ void OnStartElement(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
            /*0x1ecad2c*/ void OnEndElement(string name);
            /*0x1ecadb4*/ void OnChars(string ch);
            /*0x1ecae34*/ void OnEndParsing(Mono.Xml.SmallXmlParser parser);
        }

        class DefaultHandler : Mono.Xml.SmallXmlParser.IContentHandler
        {
            /*0x1ecae54*/ DefaultHandler();
            /*0x1ecae38*/ void OnStartParsing(Mono.Xml.SmallXmlParser parser);
            /*0x1ecae3c*/ void OnEndParsing(Mono.Xml.SmallXmlParser parser);
            /*0x1ecae40*/ void OnStartElement(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
            /*0x1ecae44*/ void OnEndElement(string name);
            /*0x1ecae48*/ void OnChars(string s);
            /*0x1ecae4c*/ void OnIgnorableWhitespace(string s);
            /*0x1ecae50*/ void OnProcessingInstruction(string name, string text);
        }

        class SmallXmlParser
        {
            /*0x10*/ Mono.Xml.SmallXmlParser.IContentHandler handler;
            /*0x18*/ System.IO.TextReader reader;
            /*0x20*/ System.Collections.Stack elementNames;
            /*0x28*/ System.Collections.Stack xmlSpaces;
            /*0x30*/ string xmlSpace;
            /*0x38*/ System.Text.StringBuilder buffer;
            /*0x40*/ char[] nameBuffer;
            /*0x48*/ bool isWhitespace;
            /*0x50*/ Mono.Xml.SmallXmlParser.AttrListImpl attributes;
            /*0x58*/ int line;
            /*0x5c*/ int column;
            /*0x60*/ bool resetColumn;

            /*0x1eca730*/ SmallXmlParser();
            /*0x1ecaefc*/ System.Exception Error(string msg);
            /*0x1ecb040*/ System.Exception UnexpectedEndError();
            /*0x1ecb12c*/ bool IsNameChar(char c, bool start);
            /*0x1ecb228*/ bool IsWhitespace(int c);
            /*0x1ecb258*/ void SkipWhitespaces();
            /*0x1ecb30c*/ void HandleWhitespaces();
            /*0x1ecb260*/ void SkipWhitespaces(bool expected);
            /*0x1ecb434*/ int Peek();
            /*0x1ecb3cc*/ int Read();
            /*0x1ecb454*/ void Expect(int c);
            /*0x1ecb514*/ string ReadUntil(char until, bool handleReferences);
            /*0x1ecb7b8*/ string ReadName();
            /*0x1eca8d4*/ void Parse(System.IO.TextReader input, Mono.Xml.SmallXmlParser.IContentHandler handler);
            /*0x1ecc158*/ void Cleanup();
            /*0x1ecb95c*/ void ReadContent();
            /*0x1ecc020*/ void HandleBufferedContent();
            /*0x1ecc55c*/ void ReadCharacters();
            /*0x1ecb5f0*/ void ReadReference();
            /*0x1ecc5e4*/ int ReadCharacterReference();
            /*0x1ecc3f8*/ void ReadAttribute(Mono.Xml.SmallXmlParser.AttrListImpl a);
            /*0x1ecc270*/ void ReadCDATASection();
            /*0x1ecc370*/ void ReadComment();

            interface IContentHandler
            {
                void OnStartParsing(Mono.Xml.SmallXmlParser parser);
                void OnEndParsing(Mono.Xml.SmallXmlParser parser);
                void OnStartElement(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
                void OnEndElement(string name);
                void OnProcessingInstruction(string name, string text);
                void OnChars(string text);
                void OnIgnorableWhitespace(string text);
            }

            interface IAttrList
            {
                int get_Length();
                string GetName(int i);
                string GetValue(int i);
                string GetValue(string name);
                string[] get_Names();
                string[] get_Values();
            }

            class AttrListImpl : Mono.Xml.SmallXmlParser.IAttrList
            {
                /*0x10*/ System.Collections.Generic.List<string> attrNames;
                /*0x18*/ System.Collections.Generic.List<string> attrValues;

                /*0x1ecae5c*/ AttrListImpl();
                /*0x1ecc830*/ int get_Length();
                /*0x1ecc878*/ string GetName(int i);
                /*0x1ecc8d0*/ string GetValue(int i);
                /*0x1ecc928*/ string GetValue(string name);
                /*0x1ecc9e8*/ string[] get_Names();
                /*0x1ecca38*/ string[] get_Values();
                /*0x1ecc1d4*/ void Clear();
                /*0x1ecc71c*/ void Add(string name, string value);
            }
        }

        class SmallXmlParserException : System.SystemException
        {
            /*0x8c*/ int line;
            /*0x90*/ int column;

            /*0x1ecaf74*/ SmallXmlParserException(string msg, int line, int column);
            /*0x1ecca88*/ int get_Line();
            /*0x1ecca90*/ int get_Column();
        }
    }

    namespace Interop
    {
        class MonoPInvokeCallbackAttribute : System.Attribute
        {
            /*0x1ecca98*/ MonoPInvokeCallbackAttribute(System.Type t);
        }
    }

    namespace Globalization
    {
        namespace Unicode
        {
            class CodePointIndexer
            {
                /*0x10*/ Mono.Globalization.Unicode.CodePointIndexer.TableRange[] ranges;
                /*0x18*/ int TotalCount;
                /*0x1c*/ int defaultIndex;
                /*0x20*/ int defaultCP;

                static /*0x1eccaa0*/ System.Array CompressArray(System.Array source, System.Type type, Mono.Globalization.Unicode.CodePointIndexer indexer);
                /*0x1eccb88*/ CodePointIndexer(int[] starts, int[] ends, int defaultIndex, int defaultCP);
                /*0x1ecccf4*/ int ToIndex(int cp);
                /*0x1eccd78*/ int ToCodePoint(int i);

                struct TableRange
                {
                    /*0x10*/ int Start;
                    /*0x14*/ int End;
                    /*0x18*/ int Count;
                    /*0x1c*/ int IndexStart;
                    /*0x20*/ int IndexEnd;

                    /*0x1ecccdc*/ TableRange(int start, int end, int indexStart);
                }
            }

            class TailoringInfo
            {
                /*0x10*/ int LCID;
                /*0x14*/ int TailoringIndex;
                /*0x18*/ int TailoringCount;
                /*0x1c*/ bool FrenchSort;

                /*0x1eccdfc*/ TailoringInfo(int lcid, int tailoringIndex, int tailoringCount, bool frenchSort);
            }

            class Contraction
            {
                /*0x10*/ int Index;
                /*0x18*/ char[] Source;
                /*0x20*/ string Replacement;
                /*0x28*/ byte[] SortKey;

                /*0x1ecce40*/ Contraction(int index, char[] source, string replacement, byte[] sortkey);
            }

            class ContractionComparer : System.Collections.Generic.IComparer<Mono.Globalization.Unicode.Contraction>
            {
                static /*0x0*/ Mono.Globalization.Unicode.ContractionComparer Instance;

                static /*0x1eccf20*/ ContractionComparer();
                /*0x1eccf18*/ ContractionComparer();
                /*0x1ecce84*/ int Compare(Mono.Globalization.Unicode.Contraction c1, Mono.Globalization.Unicode.Contraction c2);
            }

            class Level2Map
            {
                /*0x10*/ byte Source;
                /*0x11*/ byte Replace;

                /*0x1eccf84*/ Level2Map(byte source, byte replace);
            }

            class MSCompatUnicodeTable
            {
                static int ResourceVersionSize = 1;
                static /*0x0*/ int MaxExpansionLength;
                static /*0x8*/ byte* ignorableFlags;
                static /*0x10*/ byte* categories;
                static /*0x18*/ byte* level1;
                static /*0x20*/ byte* level2;
                static /*0x28*/ byte* level3;
                static /*0x30*/ byte* cjkCHScategory;
                static /*0x38*/ byte* cjkCHTcategory;
                static /*0x40*/ byte* cjkJAcategory;
                static /*0x48*/ byte* cjkKOcategory;
                static /*0x50*/ byte* cjkCHSlv1;
                static /*0x58*/ byte* cjkCHTlv1;
                static /*0x60*/ byte* cjkJAlv1;
                static /*0x68*/ byte* cjkKOlv1;
                static /*0x70*/ byte* cjkKOlv2;
                static /*0x78*/ char[] tailoringArr;
                static /*0x80*/ Mono.Globalization.Unicode.TailoringInfo[] tailoringInfos;
                static /*0x88*/ object forLock;
                static /*0x90*/ bool isReady;

                static /*0x1ece550*/ MSCompatUnicodeTable();
                static /*0x1eccfb4*/ Mono.Globalization.Unicode.TailoringInfo GetTailoringInfo(int lcid);
                static /*0x1ecd0b8*/ void BuildTailoringTables(System.Globalization.CultureInfo culture, Mono.Globalization.Unicode.TailoringInfo t, ref Mono.Globalization.Unicode.Contraction[] contractions, ref Mono.Globalization.Unicode.Level2Map[] diacriticals);
                static /*0x1ecd808*/ void SetCJKReferences(string name, ref Mono.Globalization.Unicode.CodePointIndexer cjkIndexer, ref byte* catTable, ref byte* lv1Table, ref Mono.Globalization.Unicode.CodePointIndexer lv2Indexer, ref byte* lv2Table);
                static /*0x1ecda40*/ byte Category(int cp);
                static /*0x1ecdae4*/ byte Level1(int cp);
                static /*0x1ecdb88*/ byte Level2(int cp);
                static /*0x1ecdc2c*/ byte Level3(int cp);
                static /*0x1ecdcd0*/ bool IsSortable(string s);
                static /*0x1ecdd80*/ bool IsSortable(int cp);
                static /*0x1ecde48*/ bool IsIgnorable(int cp);
                static /*0x1ecdea0*/ bool IsIgnorable(int cp, byte flag);
                static /*0x1ecdfb8*/ bool IsIgnorableSymbol(int cp);
                static /*0x1ece010*/ bool IsIgnorableNonSpacing(int cp);
                static /*0x1ece068*/ int ToKanaTypeInsensitive(int i);
                static /*0x1ece088*/ int ToWidthCompat(int i);
                static /*0x1ece214*/ bool HasSpecialWeight(char c);
                static /*0x1ece294*/ byte GetJapaneseDashType(char c);
                static /*0x1ece2fc*/ bool IsHalfWidthKana(char c);
                static /*0x1ece310*/ bool IsHiragana(char c);
                static /*0x1ece328*/ bool IsJapaneseSmallLetter(char c);
                static /*0x1ece410*/ bool get_IsReady();
                static /*0x1ece468*/ nint GetResource(string name);
                static /*0x1ece520*/ uint UInt32FromBytePtr(byte* raw, uint idx);
                static /*0x1ece9fc*/ void FillCJK(string culture, ref Mono.Globalization.Unicode.CodePointIndexer cjkIndexer, ref byte* catTable, ref byte* lv1Table, ref Mono.Globalization.Unicode.CodePointIndexer lv2Indexer, ref byte* lv2Table);
                static /*0x1eceb60*/ void FillCJKCore(string culture, ref Mono.Globalization.Unicode.CodePointIndexer cjkIndexer, ref byte* catTable, ref byte* lv1Table, ref Mono.Globalization.Unicode.CodePointIndexer cjkLv2Indexer, ref byte* lv2Table);
                /*0x1ecf028*/ MSCompatUnicodeTable();

                class <>c
                {
                    static /*0x0*/ Mono.Globalization.Unicode.MSCompatUnicodeTable.<> <>9;
                    static /*0x8*/ System.Comparison<Mono.Globalization.Unicode.Level2Map> <>9__17_0;

                    static /*0x1ecf030*/ <>c();
                    /*0x1ecf094*/ <>c();
                    /*0x1ecf09c*/ int <BuildTailoringTables>b__17_0(Mono.Globalization.Unicode.Level2Map a, Mono.Globalization.Unicode.Level2Map b);
                }
            }

            class MSCompatUnicodeTableUtil
            {
                static byte ResourceVersion = 3;
                static /*0x0*/ Mono.Globalization.Unicode.CodePointIndexer Ignorable;
                static /*0x8*/ Mono.Globalization.Unicode.CodePointIndexer Category;
                static /*0x10*/ Mono.Globalization.Unicode.CodePointIndexer Level1;
                static /*0x18*/ Mono.Globalization.Unicode.CodePointIndexer Level2;
                static /*0x20*/ Mono.Globalization.Unicode.CodePointIndexer Level3;
                static /*0x28*/ Mono.Globalization.Unicode.CodePointIndexer CjkCHS;
                static /*0x30*/ Mono.Globalization.Unicode.CodePointIndexer Cjk;

                static /*0x1ecf0c0*/ MSCompatUnicodeTableUtil();
                /*0x1ecf514*/ MSCompatUnicodeTableUtil();
            }

            class NormalizationTableUtil
            {
                static /*0x0*/ Mono.Globalization.Unicode.CodePointIndexer Prop;
                static /*0x8*/ Mono.Globalization.Unicode.CodePointIndexer Map;
                static /*0x10*/ Mono.Globalization.Unicode.CodePointIndexer Combining;
                static /*0x18*/ Mono.Globalization.Unicode.CodePointIndexer Composite;
                static /*0x20*/ Mono.Globalization.Unicode.CodePointIndexer Helper;

                static /*0x1ecf51c*/ NormalizationTableUtil();
                static /*0x1ecf87c*/ int PropIdx(int cp);
                static /*0x1ecf8e4*/ int PropCP(int index);
                static /*0x1ecf94c*/ int get_PropCount();
                static /*0x1ecf9b0*/ int MapIdx(int cp);
                static /*0x1ecfa18*/ int MapCP(int index);
                static /*0x1ecfa80*/ int CbIdx(int cp);
                static /*0x1ecfae8*/ int CbCP(int index);
                static /*0x1ecfb50*/ int get_MapCount();
                /*0x1ecfbb4*/ NormalizationTableUtil();
            }

            class SimpleCollator : System.Globalization.ISimpleCollator
            {
                static int UnsafeFlagLength = 96;
                static /*0x0*/ Mono.Globalization.Unicode.SimpleCollator invariant;
                /*0x10*/ System.Globalization.TextInfo textInfo;
                /*0x18*/ Mono.Globalization.Unicode.CodePointIndexer cjkIndexer;
                /*0x20*/ Mono.Globalization.Unicode.Contraction[] contractions;
                /*0x28*/ Mono.Globalization.Unicode.Level2Map[] level2Maps;
                /*0x30*/ byte[] unsafeFlags;
                /*0x38*/ byte* cjkCatTable;
                /*0x40*/ byte* cjkLv1Table;
                /*0x48*/ byte* cjkLv2Table;
                /*0x50*/ Mono.Globalization.Unicode.CodePointIndexer cjkLv2Indexer;
                /*0x58*/ int lcid;
                /*0x5c*/ bool frenchSort;

                static /*0x1ed5730*/ SimpleCollator();
                static /*0x1ecffc8*/ System.Globalization.CultureInfo GetNeutralCulture(System.Globalization.CultureInfo info);
                static /*0x1ed028c*/ bool IsHalfKana(int cp, System.Globalization.CompareOptions opt);
                static /*0x1ed0a98*/ byte ToDashTypeValue(Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, System.Globalization.CompareOptions opt);
                static /*0x1ed0ccc*/ bool IsIgnorable(int i, System.Globalization.CompareOptions opt);
                /*0x1ecfbbc*/ SimpleCollator(System.Globalization.CultureInfo culture);
                /*0x1ecfeec*/ void SetCJKTable(System.Globalization.CultureInfo culture, ref Mono.Globalization.Unicode.CodePointIndexer cjkIndexer, ref byte* catTable, ref byte* lv1Table, ref Mono.Globalization.Unicode.CodePointIndexer lv2Indexer, ref byte* lv2Table);
                /*0x1ed0038*/ byte Category(int cp);
                /*0x1ed00cc*/ byte Level1(int cp);
                /*0x1ed0160*/ byte Level2(int cp, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext);
                /*0x1ed0300*/ Mono.Globalization.Unicode.Contraction GetContraction(string s, int start, int end);
                /*0x1ed03c0*/ Mono.Globalization.Unicode.Contraction GetContraction(string s, int start, int end, Mono.Globalization.Unicode.Contraction[] clist);
                /*0x1ed04e4*/ Mono.Globalization.Unicode.Contraction GetTailContraction(string s, int start, int end);
                /*0x1ed05a4*/ Mono.Globalization.Unicode.Contraction GetTailContraction(string s, int start, int end, Mono.Globalization.Unicode.Contraction[] clist);
                /*0x1ed0794*/ Mono.Globalization.Unicode.Contraction GetContraction(char c);
                /*0x1ed0830*/ Mono.Globalization.Unicode.Contraction GetContraction(char c, Mono.Globalization.Unicode.Contraction[] clist);
                /*0x1ed08a0*/ int FilterOptions(int i, System.Globalization.CompareOptions opt);
                /*0x1ed0994*/ Mono.Globalization.Unicode.SimpleCollator.ExtenderType GetExtenderType(int i);
                /*0x1ed0ab8*/ int FilterExtender(int i, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, System.Globalization.CompareOptions opt);
                /*0x1ed0d50*/ bool IsSafe(int i);
                /*0x1ed0db0*/ System.Globalization.SortKey GetSortKey(string s);
                /*0x1ed0db8*/ System.Globalization.SortKey GetSortKey(string s, System.Globalization.CompareOptions options);
                /*0x1ed0dd8*/ System.Globalization.SortKey GetSortKey(string s, int start, int length, System.Globalization.CompareOptions options);
                /*0x1ed0e9c*/ void GetSortKey(string s, int start, int end, Mono.Globalization.Unicode.SortKeyBuffer buf, System.Globalization.CompareOptions opt);
                /*0x1ed1244*/ void FillSortKeyRaw(int i, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, Mono.Globalization.Unicode.SortKeyBuffer buf, System.Globalization.CompareOptions opt);
                /*0x1ed15f0*/ void FillSurrogateSortKeyRaw(int i, Mono.Globalization.Unicode.SortKeyBuffer buf);
                /*0x1ed16a8*/ int Compare(string s1, string s2);
                /*0x1ed17f8*/ int System.Globalization.ISimpleCollator.Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, System.Globalization.CompareOptions options);
                /*0x1ed16e4*/ int Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, System.Globalization.CompareOptions options);
                /*0x1ed1228*/ void ClearBuffer(byte* buffer, int size);
                /*0x1ed17fc*/ int CompareInternal(string s1, int idx1, int len1, string s2, int idx2, int len2, ref bool targetConsumed, ref bool sourceConsumed, bool skipHeadingExtenders, bool immediateBreakup, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x1ed2bd4*/ int CompareFlagPair(bool b1, bool b2);
                /*0x1ed2bf4*/ bool IsPrefix(string src, string target, System.Globalization.CompareOptions opt);
                /*0x1ed2c14*/ bool IsPrefix(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x1ed2d0c*/ bool IsPrefix(string s, string target, int start, int length, bool skipHeadingExtenders, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x1ed2d74*/ bool IsSuffix(string src, string target, System.Globalization.CompareOptions opt);
                /*0x1ed2d94*/ bool IsSuffix(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x1ed2ff4*/ int IndexOf(string s, string target, System.Globalization.CompareOptions opt);
                /*0x1ed3208*/ int QuickIndexOf(string s, string target, int start, int length, ref bool testWasUnable);
                /*0x1ed3014*/ int IndexOf(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x1ed380c*/ int IndexOfOrdinal(string s, string target, int start, int length);
                /*0x1ed38e4*/ int IndexOf(string s, char target, System.Globalization.CompareOptions opt);
                /*0x1ed3904*/ int IndexOf(string s, char target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x1ed3d98*/ int IndexOfOrdinal(string s, char target, int start, int length);
                /*0x1ed3cfc*/ int IndexOfSortKey(string s, int start, int length, byte* sortkey, char target, int ti, bool noLv4, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x1ed3370*/ int IndexOf(string s, string target, int start, int length, byte* targetSortKey, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x1ed3fc0*/ int LastIndexOf(string s, string target, System.Globalization.CompareOptions opt);
                /*0x1ed2e28*/ int LastIndexOf(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x1ed4500*/ int LastIndexOfOrdinal(string s, string target, int start, int length);
                /*0x1ed4634*/ int LastIndexOf(string s, char target, System.Globalization.CompareOptions opt);
                /*0x1ed4654*/ int LastIndexOf(string s, char target, int start, int length, System.Globalization.CompareOptions opt);
                /*0x1ed4ab0*/ int LastIndexOfSortKey(string s, int start, int orgStart, int length, byte* sortkey, int ti, bool noLv4, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x1ed3fe0*/ int LastIndexOf(string s, string target, int start, int length, byte* targetSortKey, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x1ed3e08*/ bool MatchesForward(string s, ref int idx, int end, int ti, byte* sortkey, bool noLv4, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x1ed4d18*/ bool MatchesForwardCore(string s, ref int idx, int end, int ti, byte* sortkey, bool noLv4, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, ref Mono.Globalization.Unicode.Contraction ct, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x1ed506c*/ bool MatchesPrimitive(System.Globalization.CompareOptions opt, byte* source, int si, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, byte* target, int ti, bool noLv4);
                /*0x1ed4b54*/ bool MatchesBackward(string s, ref int idx, int end, int orgStart, int ti, byte* sortkey, bool noLv4, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);
                /*0x1ed5298*/ bool MatchesBackwardCore(string s, ref int idx, int end, int orgStart, int ti, byte* sortkey, bool noLv4, Mono.Globalization.Unicode.SimpleCollator.ExtenderType ext, ref Mono.Globalization.Unicode.Contraction ct, ref Mono.Globalization.Unicode.SimpleCollator.Context ctx);

                struct Context
                {
                    /*0x10*/ System.Globalization.CompareOptions Option;
                    /*0x18*/ byte* NeverMatchFlags;
                    /*0x20*/ byte* AlwaysMatchFlags;
                    /*0x28*/ byte* Buffer1;
                    /*0x30*/ byte* Buffer2;
                    /*0x38*/ int PrevCode;
                    /*0x40*/ byte* PrevSortKey;

                    /*0x1ed57c8*/ Context(System.Globalization.CompareOptions opt, byte* alwaysMatchFlags, byte* neverMatchFlags, byte* buffer1, byte* buffer2, byte* prev1);
                }

                struct PreviousInfo
                {
                    /*0x10*/ int Code;
                    /*0x18*/ byte* SortKey;

                    /*0x1ed57e4*/ PreviousInfo(bool dummy);
                }

                struct Escape
                {
                    /*0x10*/ string Source;
                    /*0x18*/ int Index;
                    /*0x1c*/ int Start;
                    /*0x20*/ int End;
                    /*0x24*/ int Optional;
                }

                enum ExtenderType
                {
                    None = 0,
                    Simple = 1,
                    Voiced = 2,
                    Conditional = 3,
                    Buggy = 4,
                }
            }

            class SortKeyBuffer
            {
                /*0x10*/ byte[] l1b;
                /*0x18*/ byte[] l2b;
                /*0x20*/ byte[] l3b;
                /*0x28*/ byte[] l4sb;
                /*0x30*/ byte[] l4tb;
                /*0x38*/ byte[] l4kb;
                /*0x40*/ byte[] l4wb;
                /*0x48*/ byte[] l5b;
                /*0x50*/ string source;
                /*0x58*/ int l1;
                /*0x5c*/ int l2;
                /*0x60*/ int l3;
                /*0x64*/ int l4s;
                /*0x68*/ int l4t;
                /*0x6c*/ int l4k;
                /*0x70*/ int l4w;
                /*0x74*/ int l5;
                /*0x78*/ int lcid;
                /*0x7c*/ System.Globalization.CompareOptions options;
                /*0x80*/ bool processLevel2;
                /*0x81*/ bool frenchSort;
                /*0x82*/ bool frenchSorted;

                /*0x1ed57f4*/ SortKeyBuffer(int lcid);
                /*0x1ed57fc*/ void Reset();
                /*0x1ed5810*/ void ClearBuffer();
                /*0x1ed5820*/ void Initialize(System.Globalization.CompareOptions options, int lcid, string s, bool frenchSort);
                /*0x1ed5998*/ void AppendCJKExtension(byte lv1msb, byte lv1lsb);
                /*0x1ed5af4*/ void AppendKana(byte category, byte lv1, byte lv2, byte lv3, bool isSmallKana, byte markType, bool isKatakana, bool isHalfWidth);
                /*0x1ed5b88*/ void AppendNormal(byte category, byte lv1, byte lv2, byte lv3);
                /*0x1ed5ccc*/ void AppendLevel5(byte category, byte lv1);
                /*0x1ed5a2c*/ void AppendBufferPrimitive(byte value, ref byte[] buf, ref int bidx);
                /*0x1ed5d64*/ System.Globalization.SortKey GetResultAndReset();
                /*0x1ed6264*/ int GetOptimizedLength(byte[] data, int len, byte defaultValue);
                /*0x1ed5d88*/ System.Globalization.SortKey GetResult();
            }
        }
    }

    namespace Security
    {
        class ASN1
        {
            /*0x10*/ byte m_nTag;
            /*0x18*/ byte[] m_aValue;
            /*0x20*/ System.Collections.ArrayList elist;

            /*0x1ed62c4*/ ASN1();
            /*0x1ed6314*/ ASN1(byte tag);
            /*0x1ed62e4*/ ASN1(byte tag, byte[] data);
            /*0x1ed6340*/ ASN1(byte[] data);
            /*0x1ed65dc*/ int get_Count();
            /*0x1ed65f8*/ byte get_Tag();
            /*0x1ed6600*/ int get_Length();
            /*0x1ed6618*/ byte[] get_Value();
            /*0x1ed66a8*/ void set_Value(byte[] value);
            /*0x1ed6750*/ bool CompareArray(byte[] array1, byte[] array2);
            /*0x1ed67c4*/ bool Equals(byte[] asn1);
            /*0x1ed67ec*/ bool CompareValue(byte[] value);
            /*0x1ed67fc*/ Mono.Security.ASN1 Add(Mono.Security.ASN1 asn1);
            /*0x1ed6888*/ byte[] GetBytes();
            /*0x1ed64b8*/ void Decode(byte[] asn1, ref int anPos, int anLength);
            /*0x1ed6f20*/ void DecodeTLV(byte[] asn1, ref int pos, ref byte tag, ref int length, ref byte[] content);
            /*0x1ed7044*/ Mono.Security.ASN1 get_Item(int index);
            /*0x1ed7174*/ Mono.Security.ASN1 Element(int index, byte anTag);
            /*0x1ed72c8*/ string ToString();
            /*0x1ed7558*/ void SaveToFile(string filename);
        }

        class ASN1Convert
        {
            static /*0x1ed7758*/ Mono.Security.ASN1 FromDateTime(System.DateTime dt);
            static /*0x1ed7910*/ Mono.Security.ASN1 FromInt32(int value);
            static /*0x1ed7a78*/ Mono.Security.ASN1 FromOid(string oid);
            static /*0x1ed7b60*/ Mono.Security.ASN1 FromUnsignedBigInteger(byte[] big);
            static /*0x1ed7c7c*/ int ToInt32(Mono.Security.ASN1 asn1);
            static /*0x1ed7d94*/ string ToOid(Mono.Security.ASN1 asn1);
            static /*0x1ed8020*/ System.DateTime ToDateTime(Mono.Security.ASN1 time);
        }

        class BitConverterLE
        {
            static /*0x1ed8584*/ byte[] GetUShortBytes(byte* bytes);
            static /*0x1ed8654*/ byte[] GetUIntBytes(byte* bytes);
            static /*0x1ed8764*/ byte[] GetULongBytes(byte* bytes);
            static /*0x1ed88f4*/ byte[] GetBytes(bool value);
            static /*0x1ed895c*/ byte[] GetBytes(char value);
            static /*0x1ed8974*/ byte[] GetBytes(short value);
            static /*0x1ed7a60*/ byte[] GetBytes(int value);
            static /*0x1ed898c*/ byte[] GetBytes(long value);
            static /*0x1ed89a4*/ byte[] GetBytes(ushort value);
            static /*0x1ed89bc*/ byte[] GetBytes(uint value);
            static /*0x1ed89d4*/ byte[] GetBytes(ulong value);
            static /*0x1ed89ec*/ byte[] GetBytes(float value);
            static /*0x1ed8a04*/ byte[] GetBytes(double value);
            static /*0x1ed8a1c*/ void UShortFromBytes(byte* dst, byte[] src, int startIndex);
            static /*0x1ed8af8*/ void UIntFromBytes(byte* dst, byte[] src, int startIndex);
            static /*0x1ed8c44*/ void ULongFromBytes(byte* dst, byte[] src, int startIndex);
            static /*0x1ed8d34*/ bool ToBoolean(byte[] value, int startIndex);
            static /*0x1ed8d68*/ char ToChar(byte[] value, int startIndex);
            static /*0x1ed8d8c*/ short ToInt16(byte[] value, int startIndex);
            static /*0x1ed8db0*/ int ToInt32(byte[] value, int startIndex);
            static /*0x1ed8dd4*/ long ToInt64(byte[] value, int startIndex);
            static /*0x1ed8df8*/ ushort ToUInt16(byte[] value, int startIndex);
            static /*0x1ed8e1c*/ uint ToUInt32(byte[] value, int startIndex);
            static /*0x1ed8e40*/ ulong ToUInt64(byte[] value, int startIndex);
            static /*0x1ed8e64*/ float ToSingle(byte[] value, int startIndex);
            static /*0x1ed8e88*/ double ToDouble(byte[] value, int startIndex);
            /*0x1ed857c*/ BitConverterLE();
        }

        class StrongName
        {
            static /*0x0*/ object lockObject;
            static /*0x8*/ bool initialized;
            /*0x10*/ System.Security.Cryptography.RSA rsa;
            /*0x18*/ byte[] publicKey;
            /*0x20*/ byte[] keyToken;
            /*0x28*/ string tokenAlgorithm;

            static /*0x1edc098*/ StrongName();
            static /*0x1ed97dc*/ System.Security.Cryptography.HashAlgorithm GetHashAlgorithm(string algorithm);
            static /*0x1ed9f1c*/ Mono.Security.StrongName.StrongNameSignature Error(string a);
            static /*0x1ed9f24*/ byte[] ReadMore(System.IO.Stream stream, byte[] a, int newSize);
            static /*0x1edb644*/ bool IsAssemblyStrongnamed(string assemblyName);
            static /*0x1edbf88*/ bool VerifySignature(byte[] publicKey, int algorithm, byte[] hash, byte[] signature);
            static /*0x1edb564*/ bool Verify(System.Security.Cryptography.RSA rsa, System.Configuration.Assemblies.AssemblyHashAlgorithm algorithm, byte[] hash, byte[] signature);
            /*0x1ed8eac*/ StrongName();
            /*0x1ed8eb4*/ StrongName(int keySize);
            /*0x1ed8f30*/ StrongName(byte[] data);
            /*0x1ed90cc*/ StrongName(System.Security.Cryptography.RSA rsa);
            /*0x1ed9148*/ void InvalidateCache();
            /*0x1ed9150*/ bool get_CanSign();
            /*0x1ed92b4*/ System.Security.Cryptography.RSA get_RSA();
            /*0x1ed90c0*/ void set_RSA(System.Security.Cryptography.RSA value);
            /*0x1ed92d4*/ byte[] get_PublicKey();
            /*0x1ed961c*/ byte[] get_PublicKeyToken();
            /*0x1ed978c*/ string get_TokenAlgorithm();
            /*0x1ed9948*/ void set_TokenAlgorithm(string value);
            /*0x1ed9a68*/ byte[] GetBytes();
            /*0x1ed9e5c*/ uint RVAtoPosition(uint r, int sections, byte[] headers);
            /*0x1ed9fd8*/ Mono.Security.StrongName.StrongNameSignature StrongHash(System.IO.Stream stream, Mono.Security.StrongName.StrongNameOptions options);
            /*0x1edacc4*/ byte[] Hash(string fileName);
            /*0x1edae58*/ bool Sign(string fileName);
            /*0x1edb28c*/ bool Verify(string fileName);
            /*0x1edb414*/ bool Verify(System.IO.Stream stream);

            class StrongNameSignature
            {
                /*0x10*/ byte[] hash;
                /*0x18*/ byte[] signature;
                /*0x20*/ uint signaturePosition;
                /*0x24*/ uint signatureLength;
                /*0x28*/ uint metadataPosition;
                /*0x2c*/ uint metadataLength;

                /*0x1edacbc*/ StrongNameSignature();
                /*0x1edc110*/ byte[] get_Hash();
                /*0x1edc118*/ void set_Hash(byte[] value);
                /*0x1edc120*/ byte[] get_Signature();
                /*0x1edc128*/ void set_Signature(byte[] value);
                /*0x1edc130*/ void set_MetadataPosition(uint value);
                /*0x1edc138*/ void set_MetadataLength(uint value);
                /*0x1edc140*/ uint get_SignaturePosition();
                /*0x1edc148*/ void set_SignaturePosition(uint value);
                /*0x1edc150*/ void set_SignatureLength(uint value);
            }

            enum StrongNameOptions
            {
                Metadata = 0,
                Signature = 1,
            }
        }

        class StrongNameManager
        {
            static /*0x0*/ System.Collections.Hashtable mappings;
            static /*0x8*/ System.Collections.Hashtable tokens;

            static /*0x1edb8f4*/ void LoadConfig(string filename);
            static /*0x1edc158*/ void LoadMapping(System.Security.SecurityElement mapping);
            static /*0x1edc6d4*/ void LoadVerificationSettings(System.Security.SecurityElement settings);
            static /*0x1edbc1c*/ byte[] GetMappedPublicKey(byte[] token);
            static /*0x1edbce0*/ bool MustVerify(System.Reflection.AssemblyName an);
            /*0x1edd990*/ StrongNameManager();
            /*0x1edd188*/ string ToString();

            class Element
            {
                /*0x10*/ System.Collections.Hashtable assemblies;

                /*0x1edd998*/ Element();
                /*0x1edce50*/ Element(string assembly, string users);
                /*0x1edd10c*/ string GetUsers(string assembly);
            }
        }

        enum UriPartial
        {
            Scheme = 0,
            Authority = 1,
            Path = 2,
        }

        class Uri
        {
            static /*0x0*/ string hexUpperChars;
            static /*0x8*/ string SchemeDelimiter;
            static /*0x10*/ string UriSchemeFile;
            static /*0x18*/ string UriSchemeFtp;
            static /*0x20*/ string UriSchemeGopher;
            static /*0x28*/ string UriSchemeHttp;
            static /*0x30*/ string UriSchemeHttps;
            static /*0x38*/ string UriSchemeMailto;
            static /*0x40*/ string UriSchemeNews;
            static /*0x48*/ string UriSchemeNntp;
            static /*0x50*/ Mono.Security.Uri.UriScheme[] schemes;
            /*0x10*/ bool isUnixFilePath;
            /*0x18*/ string source;
            /*0x20*/ string scheme;
            /*0x28*/ string host;
            /*0x30*/ int port;
            /*0x38*/ string path;
            /*0x40*/ string query;
            /*0x48*/ string fragment;
            /*0x50*/ string userinfo;
            /*0x58*/ bool isUnc;
            /*0x59*/ bool isOpaquePart;
            /*0x60*/ string[] segments;
            /*0x68*/ bool userEscaped;
            /*0x70*/ string cachedAbsoluteUri;
            /*0x78*/ string cachedToString;
            /*0x80*/ string cachedLocalPath;
            /*0x88*/ int cachedHashCode;
            /*0x8c*/ bool reduce;

            static /*0x1ee1d40*/ Uri();
            static /*0x1edf064*/ bool IsIPv4Address(string name);
            static /*0x1edf1f4*/ bool IsDomainAddress(string name);
            static /*0x1edf320*/ bool CheckSchemeName(string schemeName);
            static /*0x1edf7c4*/ int FromHex(char digit);
            static /*0x1edf864*/ string HexEscape(char character);
            static /*0x1edf9a8*/ char HexUnescape(string pattern, ref int index);
            static /*0x1edfcc4*/ bool IsHexDigit(char digit);
            static /*0x1edfd00*/ bool IsHexEncoding(string pattern, int index);
            static /*0x1ede300*/ string EscapeString(string str);
            static /*0x1ee030c*/ string EscapeString(string str, bool escapeReserved, bool escapeHex, bool escapeBrackets);
            static /*0x1ee17c0*/ string Reduce(string path);
            static /*0x1ee1afc*/ string GetSchemeDelimiter(string scheme);
            static /*0x1ede82c*/ int GetDefaultPort(string scheme);
            static /*0x1ee1ca4*/ bool IsExcludedCharacter(char ch);
            static /*0x1ee15fc*/ bool IsPredefinedScheme(string scheme);
            /*0x1edda04*/ Uri(string uriString);
            /*0x1edda0c*/ Uri(string uriString, bool dontEscape);
            /*0x1eddb2c*/ Uri(string uriString, bool dontEscape, bool reduce);
            /*0x1eddbcc*/ Uri(Mono.Security.Uri baseUri, string relativeUri);
            /*0x1eddbd4*/ Uri(Mono.Security.Uri baseUri, string relativeUri, bool dontEscape);
            /*0x1ede360*/ string get_AbsolutePath();
            /*0x1ede368*/ string get_AbsoluteUri();
            /*0x1ede780*/ string get_Authority();
            /*0x1ede938*/ string get_Fragment();
            /*0x1ede940*/ string get_Host();
            /*0x1ede948*/ bool get_IsDefaultPort();
            /*0x1ede9b0*/ bool get_IsFile();
            /*0x1edea18*/ bool get_IsLoopback();
            /*0x1edead4*/ bool get_IsUnc();
            /*0x1edeadc*/ string get_LocalPath();
            /*0x1eded90*/ string get_PathAndQuery();
            /*0x1ededa0*/ int get_Port();
            /*0x1ededa8*/ string get_Query();
            /*0x1ededb0*/ string get_Scheme();
            /*0x1ededb8*/ string[] get_Segments();
            /*0x1edf054*/ bool get_UserEscaped();
            /*0x1edf05c*/ string get_UserInfo();
            /*0x1edf43c*/ bool Equals(object comparant);
            /*0x1edf66c*/ int GetHashCode();
            /*0x1ede39c*/ string GetLeftPart(Mono.Security.UriPartial part);
            /*0x1edfe30*/ string MakeRelative(Mono.Security.Uri toUri);
            /*0x1ee0044*/ string ToString();
            /*0x1ee02ac*/ void Escape();
            /*0x1edda9c*/ void Parse();
            /*0x1eded88*/ string Unescape(string str);
            /*0x1ee0120*/ string Unescape(string str, bool excludeSharp);
            /*0x1ee1174*/ void ParseAsWindowsUNC(string uriString);
            /*0x1ee1310*/ void ParseAsWindowsAbsoluteFilePath(string uriString);
            /*0x1ee1498*/ void ParseAsUnixAbsoluteFilePath(string uriString);
            /*0x1ee0608*/ void Parse(string uriString);
            /*0x1edf740*/ string GetOpaqueWiseSchemeDelimiter();
            /*0x1ee1bfc*/ bool IsBadFileSystemCharacter(char ch);
            /*0x1ee1d04*/ bool IsReservedCharacter(char ch);

            struct UriScheme
            {
                /*0x10*/ string scheme;
                /*0x18*/ string delimiter;
                /*0x20*/ int defaultPort;

                /*0x1ee2034*/ UriScheme(string s, string d, int p);
            }
        }

        namespace Cryptography
        {
            class ARC4Managed : Mono.Security.Cryptography.RC4, System.Security.Cryptography.ICryptoTransform, System.IDisposable
            {
                /*0x48*/ byte[] key;
                /*0x50*/ byte[] state;
                /*0x58*/ byte x;
                /*0x59*/ byte y;
                /*0x5a*/ bool m_disposed;

                /*0x1ee2040*/ ARC4Managed();
                /*0x1ee20c4*/ void Finalize();
                /*0x1ee2164*/ void Dispose(bool disposing);
                /*0x1ee2210*/ byte[] get_Key();
                /*0x1ee22a4*/ void set_Key(byte[] value);
                /*0x1ee245c*/ bool get_CanReuseTransform();
                /*0x1ee2464*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgvIV);
                /*0x1ee2488*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgvIV);
                /*0x1ee24b8*/ void GenerateIV();
                /*0x1ee2514*/ void GenerateKey();
                /*0x1ee25a4*/ bool get_CanTransformMultipleBlocks();
                /*0x1ee25ac*/ int get_InputBlockSize();
                /*0x1ee25b4*/ int get_OutputBlockSize();
                /*0x1ee237c*/ void KeySetup(byte[] key);
                /*0x1ee25bc*/ void CheckInput(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1ee2710*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1ee2880*/ int InternalTransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1ee29b0*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
            }

            class CryptoConvert
            {
                static /*0x1ee2a54*/ int ToInt32LE(byte[] bytes, int offset);
                static /*0x1ee2ac8*/ uint ToUInt32LE(byte[] bytes, int offset);
                static /*0x1ee2b3c*/ byte[] GetBytesLE(int val);
                static /*0x1ee2bd0*/ byte[] Trim(byte[] array);
                static /*0x1ee2c7c*/ bool TryImportCapiPrivateKeyBlob(byte[] blob, int offset);
                static /*0x1ee3360*/ System.Security.Cryptography.RSA FromCapiPrivateKeyBlob(byte[] blob);
                static /*0x1ee3368*/ System.Security.Cryptography.RSA FromCapiPrivateKeyBlob(byte[] blob, int offset);
                static /*0x1ee2dc0*/ System.Security.Cryptography.RSAParameters GetParametersFromCapiPrivateKeyBlob(byte[] blob, int offset);
                static /*0x1ee33e4*/ System.Security.Cryptography.DSA FromCapiPrivateKeyBlobDSA(byte[] blob);
                static /*0x1ee33ec*/ System.Security.Cryptography.DSA FromCapiPrivateKeyBlobDSA(byte[] blob, int offset);
                static /*0x1ed9a88*/ byte[] ToCapiPrivateKeyBlob(System.Security.Cryptography.RSA rsa);
                static /*0x1ee3890*/ byte[] ToCapiPrivateKeyBlob(System.Security.Cryptography.DSA dsa);
                static /*0x1ee3b58*/ bool TryImportCapiPublicKeyBlob(byte[] blob, int offset);
                static /*0x1edc090*/ System.Security.Cryptography.RSA FromCapiPublicKeyBlob(byte[] blob);
                static /*0x1edbe3c*/ System.Security.Cryptography.RSA FromCapiPublicKeyBlob(byte[] blob, int offset);
                static /*0x1ee3c9c*/ System.Security.Cryptography.RSAParameters GetParametersFromCapiPublicKeyBlob(byte[] blob, int offset);
                static /*0x1ee4088*/ System.Security.Cryptography.DSA FromCapiPublicKeyBlobDSA(byte[] blob);
                static /*0x1ee4090*/ System.Security.Cryptography.DSA FromCapiPublicKeyBlobDSA(byte[] blob, int offset);
                static /*0x1ee4548*/ byte[] ToCapiPublicKeyBlob(System.Security.Cryptography.RSA rsa);
                static /*0x1ee4788*/ byte[] ToCapiPublicKeyBlob(System.Security.Cryptography.DSA dsa);
                static /*0x1ed90b8*/ System.Security.Cryptography.RSA FromCapiKeyBlob(byte[] blob);
                static /*0x1ee4a60*/ System.Security.Cryptography.RSA FromCapiKeyBlob(byte[] blob, int offset);
                static /*0x1ee4b80*/ System.Security.Cryptography.DSA FromCapiKeyBlobDSA(byte[] blob);
                static /*0x1ee4b88*/ System.Security.Cryptography.DSA FromCapiKeyBlobDSA(byte[] blob, int offset);
                static /*0x1ee4c88*/ byte[] ToCapiKeyBlob(System.Security.Cryptography.AsymmetricAlgorithm keypair, bool includePrivateKey);
                static /*0x1ed95bc*/ byte[] ToCapiKeyBlob(System.Security.Cryptography.RSA rsa, bool includePrivateKey);
                static /*0x1ee4dac*/ byte[] ToCapiKeyBlob(System.Security.Cryptography.DSA dsa, bool includePrivateKey);
                static /*0x1edce94*/ string ToHex(byte[] input);
                static /*0x1ee4e0c*/ byte FromHexChar(char c);
                static /*0x1edcfc8*/ byte[] FromHex(string hex);
                /*0x1ee2a4c*/ CryptoConvert();
            }

            class KeyBuilder
            {
                static /*0x0*/ System.Security.Cryptography.RandomNumberGenerator rng;

                static /*0x1ee4eb0*/ System.Security.Cryptography.RandomNumberGenerator get_Rng();
                static /*0x1ee2534*/ byte[] Key(int size);
                static /*0x1ee4f18*/ byte[] IV(int size);
                /*0x1ee4ea8*/ KeyBuilder();
            }

            class BlockProcessor
            {
                /*0x10*/ System.Security.Cryptography.ICryptoTransform transform;
                /*0x18*/ byte[] block;
                /*0x20*/ int blockSize;
                /*0x24*/ int blockCount;

                /*0x1ee4f88*/ BlockProcessor(System.Security.Cryptography.ICryptoTransform transform);
                /*0x1ee5038*/ BlockProcessor(System.Security.Cryptography.ICryptoTransform transform, int blockSize);
                /*0x1ee513c*/ void Finalize();
                /*0x1ee51e0*/ void Initialize();
                /*0x1ee5208*/ void Core(byte[] rgb);
                /*0x1ee5224*/ void Core(byte[] rgb, int ib, int cb);
                /*0x1ee547c*/ byte[] Final();
            }

            class KeyPairPersistence
            {
                static /*0x0*/ bool _userPathExists;
                static /*0x8*/ string _userPath;
                static /*0x10*/ bool _machinePathExists;
                static /*0x18*/ string _machinePath;
                static /*0x20*/ object lockobj;
                /*0x10*/ System.Security.Cryptography.CspParameters _params;
                /*0x18*/ string _keyvalue;
                /*0x20*/ string _filename;
                /*0x28*/ string _container;

                static /*0x1ee6e7c*/ KeyPairPersistence();
                static /*0x1ee5e88*/ string get_UserPath();
                static /*0x1ee5928*/ string get_MachinePath();
                static /*0x1ee6da8*/ bool _CanSecure(char* root);
                static /*0x1ee6dac*/ bool _ProtectUser(char* path);
                static /*0x1ee6db0*/ bool _ProtectMachine(char* path);
                static /*0x1ee6db4*/ bool _IsUserProtected(char* path);
                static /*0x1ee6db8*/ bool _IsMachineProtected(char* path);
                static /*0x1ee6dbc*/ bool CanSecure(string path);
                static /*0x1ee6be4*/ bool ProtectUser(string path);
                static /*0x1ee6b54*/ bool ProtectMachine(string path);
                static /*0x1ee6c88*/ bool IsUserProtected(string path);
                static /*0x1ee6d18*/ bool IsMachineProtected(string path);
                /*0x1ee5534*/ KeyPairPersistence(System.Security.Cryptography.CspParameters parameters);
                /*0x1ee553c*/ KeyPairPersistence(System.Security.Cryptography.CspParameters parameters, string keyPair);
                /*0x1ee5658*/ string get_Filename();
                /*0x1ee63e8*/ string get_KeyValue();
                /*0x1ee63f0*/ void set_KeyValue(string value);
                /*0x1ee6414*/ System.Security.Cryptography.CspParameters get_Parameters();
                /*0x1ee641c*/ bool Load();
                /*0x1ee66f4*/ void Save();
                /*0x1ee6c74*/ void Remove();
                /*0x1ee6404*/ bool get_CanChange();
                /*0x1ee6e5c*/ bool get_UseDefaultKeyContainer();
                /*0x1ee5908*/ bool get_UseMachineKeyStore();
                /*0x1ee57e4*/ string get_ContainerName();
                /*0x1ee55c0*/ System.Security.Cryptography.CspParameters Copy(System.Security.Cryptography.CspParameters p);
                /*0x1ee65d0*/ void FromXml(string xml);
                /*0x1ee6940*/ string ToXml();
            }

            class MD2 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x1ee6f14*/ Mono.Security.Cryptography.MD2 Create();
                static /*0x1ee7010*/ Mono.Security.Cryptography.MD2 Create(string hashName);
                /*0x1ee6ef4*/ MD2();
            }

            class MD2Managed : Mono.Security.Cryptography.MD2
            {
                static /*0x0*/ byte[] PI_SUBST;
                /*0x28*/ byte[] state;
                /*0x30*/ byte[] checksum;
                /*0x38*/ byte[] buffer;
                /*0x40*/ int count;
                /*0x48*/ byte[] x;

                static /*0x1ee760c*/ MD2Managed();
                /*0x1ee6f6c*/ MD2Managed();
                /*0x1ee70ec*/ byte[] Padding(int nLength);
                /*0x1ee7188*/ void Initialize();
                /*0x1ee71e8*/ void HashCore(byte[] array, int ibStart, int cbSize);
                /*0x1ee751c*/ byte[] HashFinal();
                /*0x1ee72c4*/ void MD2Transform(byte[] state, byte[] checksum, byte[] block, int index);
            }

            class MD4 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x1ee76c0*/ Mono.Security.Cryptography.MD4 Create();
                static /*0x1ee77e8*/ Mono.Security.Cryptography.MD4 Create(string hashName);
                /*0x1ee76a0*/ MD4();
            }

            class MD4Managed : Mono.Security.Cryptography.MD4
            {
                static int S11 = 3;
                static int S12 = 7;
                static int S13 = 11;
                static int S14 = 19;
                static int S21 = 3;
                static int S22 = 5;
                static int S23 = 9;
                static int S24 = 13;
                static int S31 = 3;
                static int S32 = 9;
                static int S33 = 11;
                static int S34 = 15;
                /*0x28*/ uint[] state;
                /*0x30*/ byte[] buffer;
                /*0x38*/ uint[] count;
                /*0x40*/ uint[] x;
                /*0x48*/ byte[] digest;

                /*0x1ee7718*/ MD4Managed();
                /*0x1ee78c4*/ void Initialize();
                /*0x1ee7978*/ void HashCore(byte[] array, int ibStart, int cbSize);
                /*0x1ee8114*/ byte[] HashFinal();
                /*0x1ee8308*/ byte[] Padding(int nLength);
                /*0x1ee8380*/ uint F(uint x, uint y, uint z);
                /*0x1ee8390*/ uint G(uint x, uint y, uint z);
                /*0x1ee83a4*/ uint H(uint x, uint y, uint z);
                /*0x1ee83b0*/ uint ROL(uint x, byte n);
                /*0x1ee83c0*/ void FF(ref uint a, uint b, uint c, uint d, uint x, byte s);
                /*0x1ee83ec*/ void GG(ref uint a, uint b, uint c, uint d, uint x, byte s);
                /*0x1ee8428*/ void HH(ref uint a, uint b, uint c, uint d, uint x, byte s);
                /*0x1ee8210*/ void Encode(byte[] output, uint[] input);
                /*0x1ee845c*/ void Decode(uint[] output, byte[] input, int index);
                /*0x1ee7a9c*/ void MD4Transform(uint[] state, byte[] block, int index);
            }

            class PKCS1
            {
                static /*0x0*/ byte[] emptySHA1;
                static /*0x8*/ byte[] emptySHA256;
                static /*0x10*/ byte[] emptySHA384;
                static /*0x18*/ byte[] emptySHA512;

                static /*0x1eea7f4*/ PKCS1();
                static /*0x1ee8518*/ bool Compare(byte[] array1, byte[] array2);
                static /*0x1ee858c*/ byte[] xor(byte[] array1, byte[] array2);
                static /*0x1ee8650*/ byte[] GetEmptyHash(System.Security.Cryptography.HashAlgorithm hash);
                static /*0x1ee8814*/ byte[] I2OSP(int x, int size);
                static /*0x1ee88b8*/ byte[] I2OSP(byte[] x, int size);
                static /*0x1ee8944*/ byte[] OS2IP(byte[] x);
                static /*0x1ee8a00*/ byte[] RSAEP(System.Security.Cryptography.RSA rsa, byte[] m);
                static /*0x1ee8a20*/ byte[] RSADP(System.Security.Cryptography.RSA rsa, byte[] c);
                static /*0x1ee8a40*/ byte[] RSASP1(System.Security.Cryptography.RSA rsa, byte[] m);
                static /*0x1ee8a60*/ byte[] RSAVP1(System.Security.Cryptography.RSA rsa, byte[] s);
                static /*0x1ee8a80*/ byte[] Encrypt_OAEP(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.HashAlgorithm hash, System.Security.Cryptography.RandomNumberGenerator rng, byte[] M);
                static /*0x1ee8f3c*/ byte[] Decrypt_OAEP(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.HashAlgorithm hash, byte[] C);
                static /*0x1ee9248*/ byte[] Encrypt_v15(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.RandomNumberGenerator rng, byte[] M);
                static /*0x1ee9440*/ byte[] Decrypt_v15(System.Security.Cryptography.RSA rsa, byte[] C);
                static /*0x1ee95e8*/ byte[] Sign_v15(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.HashAlgorithm hash, byte[] hashValue);
                static /*0x1ee99e8*/ byte[] Sign_v15(System.Security.Cryptography.RSA rsa, string hashName, byte[] hashValue);
                static /*0x1ee9fc0*/ bool Verify_v15(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.HashAlgorithm hash, byte[] hashValue, byte[] signature);
                static /*0x1eea224*/ bool Verify_v15(System.Security.Cryptography.RSA rsa, string hashName, byte[] hashValue, byte[] signature);
                static /*0x1eea040*/ bool Verify_v15(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.HashAlgorithm hash, byte[] hashValue, byte[] signature, bool tryNonStandardEncoding);
                static /*0x1ee9698*/ byte[] Encode_v15(System.Security.Cryptography.HashAlgorithm hash, byte[] hashValue, int emLength);
                static /*0x1ee8d44*/ byte[] MGF1(System.Security.Cryptography.HashAlgorithm hash, byte[] mgfSeed, int maskLen);
                static /*0x1eea400*/ string HashNameFromOid(string oid, bool throwOnError);
                static /*0x1eea798*/ System.Security.Cryptography.HashAlgorithm CreateFromOid(string oid);
                static /*0x1ee9bb0*/ System.Security.Cryptography.HashAlgorithm CreateFromName(string name);
                /*0x1ee8510*/ PKCS1();
            }

            class RC4 : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;

                static /*0x1fd0518*/ RC4();
                static /*0x1fd03dc*/ Mono.Security.Cryptography.RC4 Create();
                static /*0x1fd0438*/ Mono.Security.Cryptography.RC4 Create(string algName);
                /*0x1fd0318*/ RC4();
                /*0x1fd0394*/ byte[] get_IV();
                /*0x1fd03d8*/ void set_IV(byte[] value);
            }

            class RSAManaged : System.Security.Cryptography.RSA
            {
                static int defaultKeySize = 1024;
                /*0x20*/ bool isCRTpossible;
                /*0x21*/ bool keyBlinding;
                /*0x22*/ bool keypairGenerated;
                /*0x23*/ bool m_disposed;
                /*0x28*/ Mono.Math.BigInteger d;
                /*0x30*/ Mono.Math.BigInteger p;
                /*0x38*/ Mono.Math.BigInteger q;
                /*0x40*/ Mono.Math.BigInteger dp;
                /*0x48*/ Mono.Math.BigInteger dq;
                /*0x50*/ Mono.Math.BigInteger qInv;
                /*0x58*/ Mono.Math.BigInteger n;
                /*0x60*/ Mono.Math.BigInteger e;
                /*0x68*/ Mono.Security.Cryptography.RSAManaged.KeyGeneratedEventHandler KeyGenerated;

                /*0x1fd0668*/ RSAManaged();
                /*0x1fd0670*/ RSAManaged(int keySize);
                /*0x1fd0760*/ void Finalize();
                /*0x1fd0800*/ void GenerateKeyPair();
                /*0x1fd1078*/ int get_KeySize();
                /*0x1fd111c*/ string get_KeyExchangeAlgorithm();
                /*0x1fd115c*/ bool get_PublicOnly();
                /*0x1fd12ac*/ string get_SignatureAlgorithm();
                /*0x1fd12ec*/ byte[] DecryptValue(byte[] rgb);
                /*0x1fd1b14*/ byte[] EncryptValue(byte[] rgb);
                /*0x1fd1c20*/ System.Security.Cryptography.RSAParameters ExportParameters(bool includePrivateParameters);
                /*0x1fd2080*/ void ImportParameters(System.Security.Cryptography.RSAParameters parameters);
                /*0x1fd24ec*/ void Dispose(bool disposing);
                /*0x1fd26f0*/ void add_KeyGenerated(Mono.Security.Cryptography.RSAManaged.KeyGeneratedEventHandler value);
                /*0x1fd278c*/ void remove_KeyGenerated(Mono.Security.Cryptography.RSAManaged.KeyGeneratedEventHandler value);
                /*0x1fd2828*/ string ToXmlString(bool includePrivateParameters);
                /*0x1fd2eb0*/ bool get_UseKeyBlinding();
                /*0x1fd2eb8*/ void set_UseKeyBlinding(bool value);
                /*0x1fd2ec4*/ bool get_IsCrtPossible();
                /*0x1fd1a64*/ byte[] GetPaddedValue(Mono.Math.BigInteger value, int length);

                class KeyGeneratedEventHandler : System.MulticastDelegate
                {
                    /*0x1fd2ee4*/ KeyGeneratedEventHandler(object object, nint method);
                    /*0x1fd3014*/ void Invoke(object sender, System.EventArgs e);
                }
            }

            class SymmetricTransform : System.Security.Cryptography.ICryptoTransform, System.IDisposable
            {
                /*0x10*/ System.Security.Cryptography.SymmetricAlgorithm algo;
                /*0x18*/ bool encrypt;
                /*0x1c*/ int BlockSizeByte;
                /*0x20*/ byte[] temp;
                /*0x28*/ byte[] temp2;
                /*0x30*/ byte[] workBuff;
                /*0x38*/ byte[] workout;
                /*0x40*/ System.Security.Cryptography.PaddingMode padmode;
                /*0x44*/ int FeedBackByte;
                /*0x48*/ bool m_disposed;
                /*0x49*/ bool lastBlock;
                /*0x50*/ System.Security.Cryptography.RandomNumberGenerator _rng;

                /*0x1fd3028*/ SymmetricTransform(System.Security.Cryptography.SymmetricAlgorithm symmAlgo, bool encryption, byte[] rgbIV);
                /*0x1fd32f0*/ void Finalize();
                /*0x1fd3390*/ void System.IDisposable.Dispose();
                /*0x1fd33fc*/ void Dispose(bool disposing);
                /*0x1fd3450*/ bool get_CanTransformMultipleBlocks();
                /*0x1fd3458*/ bool get_CanReuseTransform();
                /*0x1fd3460*/ int get_InputBlockSize();
                /*0x1fd3468*/ int get_OutputBlockSize();
                /*0x1fd3470*/ void Transform(byte[] input, byte[] output);
                void ECB(byte[] input, byte[] output);
                /*0x1fd36bc*/ void CBC(byte[] input, byte[] output);
                /*0x1fd3820*/ void CFB(byte[] input, byte[] output);
                /*0x1fd39e8*/ void OFB(byte[] input, byte[] output);
                /*0x1fd3a38*/ void CTS(byte[] input, byte[] output);
                /*0x1fd3a88*/ void CheckInput(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1fd3bdc*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1fd3df4*/ bool get_KeepLastBlock();
                /*0x1fd3e18*/ int InternalTransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1fd3fd4*/ void Random(byte[] buffer, int start, int length);
                /*0x1fd4084*/ void ThrowBadPaddingException(System.Security.Cryptography.PaddingMode padding, int length, int position);
                /*0x1fd4270*/ byte[] FinalEncrypt(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1fd4510*/ byte[] FinalDecrypt(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1fd47bc*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
            }

            class DSAManaged : System.Security.Cryptography.DSA
            {
                static int defaultKeySize = 1024;
                /*0x20*/ bool keypairGenerated;
                /*0x21*/ bool m_disposed;
                /*0x28*/ Mono.Math.BigInteger p;
                /*0x30*/ Mono.Math.BigInteger q;
                /*0x38*/ Mono.Math.BigInteger g;
                /*0x40*/ Mono.Math.BigInteger x;
                /*0x48*/ Mono.Math.BigInteger y;
                /*0x50*/ Mono.Math.BigInteger j;
                /*0x58*/ Mono.Math.BigInteger seed;
                /*0x60*/ int counter;
                /*0x64*/ bool j_missing;
                /*0x68*/ System.Security.Cryptography.RandomNumberGenerator rng;
                /*0x70*/ Mono.Security.Cryptography.DSAManaged.KeyGeneratedEventHandler KeyGenerated;

                /*0x1fd4870*/ DSAManaged();
                /*0x1fd4878*/ DSAManaged(int dwKeySize);
                /*0x1fd4958*/ void Finalize();
                /*0x1fd49f8*/ void Generate();
                /*0x1fd4f6c*/ void GenerateKeyPair();
                /*0x1fd512c*/ void add(byte[] a, byte[] b, int value);
                /*0x1fd4a44*/ void GenerateParams(int keyLength);
                /*0x1fd51d0*/ System.Security.Cryptography.RandomNumberGenerator get_Random();
                /*0x1fd5504*/ int get_KeySize();
                /*0x1fd5530*/ string get_KeyExchangeAlgorithm();
                /*0x1fd5538*/ bool get_PublicOnly();
                /*0x1fd55ac*/ string get_SignatureAlgorithm();
                /*0x1fd55ec*/ byte[] NormalizeArray(byte[] array);
                /*0x1fd5690*/ System.Security.Cryptography.DSAParameters ExportParameters(bool includePrivateParameters);
                /*0x1fd5974*/ void ImportParameters(System.Security.Cryptography.DSAParameters parameters);
                /*0x1fd5c1c*/ byte[] CreateSignature(byte[] rgbHash);
                /*0x1fd5f44*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
                /*0x1fd6404*/ void Dispose(bool disposing);
                /*0x1fd65d4*/ void add_KeyGenerated(Mono.Security.Cryptography.DSAManaged.KeyGeneratedEventHandler value);
                /*0x1fd6670*/ void remove_KeyGenerated(Mono.Security.Cryptography.DSAManaged.KeyGeneratedEventHandler value);

                class KeyGeneratedEventHandler : System.MulticastDelegate
                {
                    /*0x1fd670c*/ KeyGeneratedEventHandler(object object, nint method);
                    /*0x1fd683c*/ void Invoke(object sender, System.EventArgs e);
                }
            }

            class HMACAlgorithm
            {
                /*0x10*/ byte[] key;
                /*0x18*/ byte[] hash;
                /*0x20*/ System.Security.Cryptography.HashAlgorithm algo;
                /*0x28*/ string hashName;
                /*0x30*/ Mono.Security.Cryptography.BlockProcessor block;

                /*0x1fd6850*/ HMACAlgorithm(string algoName);
                /*0x1fd6904*/ void Finalize();
                /*0x1fd687c*/ void CreateHash(string algoName);
                /*0x1fd69ac*/ void Dispose();
                /*0x1fd69c8*/ System.Security.Cryptography.HashAlgorithm get_Algo();
                /*0x1fd69d0*/ string get_HashName();
                /*0x1fd69d8*/ void set_HashName(string value);
                /*0x1fd69dc*/ byte[] get_Key();
                /*0x1fd69e4*/ void set_Key(byte[] value);
                /*0x1fd6ab8*/ void Initialize();
                /*0x1fd6b3c*/ byte[] KeySetup(byte[] key, byte padding);
                /*0x1fd6c30*/ void Core(byte[] rgb, int ib, int cb);
                /*0x1fd6c4c*/ byte[] Final();
            }

            class MACAlgorithm
            {
                /*0x10*/ System.Security.Cryptography.SymmetricAlgorithm algo;
                /*0x18*/ System.Security.Cryptography.ICryptoTransform enc;
                /*0x20*/ byte[] block;
                /*0x28*/ int blockSize;
                /*0x2c*/ int blockCount;

                /*0x1fd6d5c*/ MACAlgorithm(System.Security.Cryptography.SymmetricAlgorithm algorithm);
                /*0x1fd6e20*/ void Initialize(byte[] key);
                /*0x1fd6e88*/ void Core(byte[] rgb, int ib, int cb);
                /*0x1fd70c8*/ byte[] Final();
            }
        }
    }

    namespace Math
    {
        class BigInteger
        {
            static uint DEFAULT_LEN = 20;
            static string WouldReturnNegVal = "Operation would return a negative value";
            static /*0x0*/ uint[] smallPrimes;
            static /*0x8*/ System.Security.Cryptography.RandomNumberGenerator rng;
            /*0x10*/ uint length;
            /*0x18*/ uint[] data;

            static /*0x1fda1e8*/ BigInteger();
            static /*0x1fd0a68*/ Mono.Math.BigInteger op_Implicit(uint value);
            static /*0x1fd0e18*/ Mono.Math.BigInteger op_Implicit(int value);
            static /*0x1fd77f8*/ Mono.Math.BigInteger op_Implicit(ulong value);
            static /*0x1fd7858*/ Mono.Math.BigInteger Parse(string number);
            static /*0x1fd1934*/ Mono.Math.BigInteger op_Addition(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd0ec8*/ Mono.Math.BigInteger op_Subtraction(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd7fc8*/ int op_Modulus(Mono.Math.BigInteger bi, int i);
            static /*0x1fd0b34*/ uint op_Modulus(Mono.Math.BigInteger bi, uint ui);
            static /*0x1fd104c*/ Mono.Math.BigInteger op_Modulus(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd84ac*/ Mono.Math.BigInteger op_Division(Mono.Math.BigInteger bi, int i);
            static /*0x1fd54c4*/ Mono.Math.BigInteger op_Division(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd0be8*/ Mono.Math.BigInteger op_Multiply(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd538c*/ Mono.Math.BigInteger op_Multiply(Mono.Math.BigInteger bi, int i);
            static /*0x1fd87e0*/ Mono.Math.BigInteger op_LeftShift(Mono.Math.BigInteger bi1, int shiftVal);
            static /*0x1fd89b4*/ Mono.Math.BigInteger op_RightShift(Mono.Math.BigInteger bi1, int shiftVal);
            static /*0x1fd8b34*/ Mono.Math.BigInteger Add(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd8b98*/ Mono.Math.BigInteger Subtract(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd8bfc*/ int Modulus(Mono.Math.BigInteger bi, int i);
            static /*0x1fd8c60*/ uint Modulus(Mono.Math.BigInteger bi, uint ui);
            static /*0x1fd8cc4*/ Mono.Math.BigInteger Modulus(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd8d28*/ Mono.Math.BigInteger Divid(Mono.Math.BigInteger bi, int i);
            static /*0x1fd8d8c*/ Mono.Math.BigInteger Divid(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd8df0*/ Mono.Math.BigInteger Multiply(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd8e54*/ Mono.Math.BigInteger Multiply(Mono.Math.BigInteger bi, int i);
            static /*0x1fd8eb8*/ System.Security.Cryptography.RandomNumberGenerator get_Rng();
            static /*0x1fd8f60*/ Mono.Math.BigInteger GenerateRandom(int bits, System.Security.Cryptography.RandomNumberGenerator rng);
            static /*0x1fd1848*/ Mono.Math.BigInteger GenerateRandom(int bits);
            static /*0x1fd50a8*/ bool op_Equality(Mono.Math.BigInteger bi1, uint ui);
            static /*0x1fd5908*/ bool op_Inequality(Mono.Math.BigInteger bi1, uint ui);
            static /*0x1fd11fc*/ bool op_Equality(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd0b38*/ bool op_Inequality(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd191c*/ bool op_GreaterThan(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd0e04*/ bool op_LessThan(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd5114*/ bool op_GreaterThanOrEqual(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fd54ec*/ bool op_LessThanOrEqual(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
            static /*0x1fda0e4*/ Mono.Math.BigInteger NextHighestPrime(Mono.Math.BigInteger bi);
            static /*0x1fd0ac8*/ Mono.Math.BigInteger GeneratePseudoPrime(int bits);
            /*0x1fd7318*/ BigInteger();
            /*0x1fd7384*/ BigInteger(Mono.Math.BigInteger.Sign sign, uint len);
            /*0x1fd73f8*/ BigInteger(Mono.Math.BigInteger bi);
            /*0x1fd74b8*/ BigInteger(Mono.Math.BigInteger bi, uint len);
            /*0x1fd160c*/ BigInteger(byte[] inData);
            /*0x1fd75e4*/ BigInteger(uint[] inData);
            /*0x1fd76cc*/ BigInteger(uint ui);
            /*0x1fd7754*/ BigInteger(ulong ul);
            /*0x1fd90c4*/ void Randomize(System.Security.Cryptography.RandomNumberGenerator rng);
            /*0x1fd504c*/ void Randomize();
            /*0x1fd0d98*/ int BitCount();
            /*0x1fd5480*/ bool TestBit(uint bitNum);
            /*0x1fd9248*/ bool TestBit(int bitNum);
            /*0x1fd92e0*/ void SetBit(uint bitNum);
            /*0x1fd9344*/ void ClearBit(uint bitNum);
            /*0x1fd92e8*/ void SetBit(uint bitNum, bool value);
            /*0x1fd934c*/ int LowestSetBit();
            /*0x1fd1f54*/ byte[] GetBytes();
            /*0x1fd93c8*/ Mono.Math.BigInteger.Sign Compare(Mono.Math.BigInteger bi);
            /*0x1fd93cc*/ string ToString(uint radix);
            /*0x1fd9424*/ string ToString(uint radix, string characterSet);
            /*0x1fd758c*/ void Normalize();
            /*0x1fd1a14*/ void Clear();
            /*0x1fd96cc*/ int GetHashCode();
            /*0x1fd9724*/ string ToString();
            /*0x1fd972c*/ bool Equals(object o);
            /*0x1fd986c*/ Mono.Math.BigInteger GCD(Mono.Math.BigInteger bi);
            /*0x1fd1048*/ Mono.Math.BigInteger ModInverse(Mono.Math.BigInteger modulus);
            /*0x1fd18a4*/ Mono.Math.BigInteger ModPow(Mono.Math.BigInteger exp, Mono.Math.BigInteger n);
            /*0x1fd51f0*/ bool IsProbablePrime();
            /*0x1fda164*/ void Incr2();

            enum Sign
            {
                Negative = -1,
                Zero = 0,
                Positive = 1,
            }

            class ModulusRing
            {
                /*0x10*/ Mono.Math.BigInteger mod;
                /*0x18*/ Mono.Math.BigInteger constant;

                /*0x1fd9ec0*/ ModulusRing(Mono.Math.BigInteger modulus);
                /*0x1fda27c*/ void BarrettReduction(Mono.Math.BigInteger x);
                /*0x1fda880*/ Mono.Math.BigInteger Multiply(Mono.Math.BigInteger a, Mono.Math.BigInteger b);
                /*0x1fda9fc*/ Mono.Math.BigInteger Difference(Mono.Math.BigInteger a, Mono.Math.BigInteger b);
                /*0x1fd9f90*/ Mono.Math.BigInteger Pow(Mono.Math.BigInteger a, Mono.Math.BigInteger k);
                /*0x1fdabb8*/ Mono.Math.BigInteger Pow(uint b, Mono.Math.BigInteger exp);
            }

            class Kernel
            {
                static /*0x1fd7b2c*/ Mono.Math.BigInteger AddSameSign(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
                static /*0x1fd7e24*/ Mono.Math.BigInteger Subtract(Mono.Math.BigInteger big, Mono.Math.BigInteger small);
                static /*0x1fda608*/ void MinusEq(Mono.Math.BigInteger big, Mono.Math.BigInteger small);
                static /*0x1fda708*/ void PlusEq(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
                static /*0x1fd7ce0*/ Mono.Math.BigInteger.Sign Compare(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
                static /*0x1fd9650*/ uint SingleByteDivideInPlace(Mono.Math.BigInteger n, uint d);
                static /*0x1fd7fec*/ uint DwordMod(Mono.Math.BigInteger n, uint d);
                static /*0x1fd8508*/ Mono.Math.BigInteger DwordDiv(Mono.Math.BigInteger n, uint d);
                static /*0x1fdac30*/ Mono.Math.BigInteger[] DwordDivMod(Mono.Math.BigInteger n, uint d);
                static /*0x1fd8058*/ Mono.Math.BigInteger[] multiByteDivide(Mono.Math.BigInteger bi1, Mono.Math.BigInteger bi2);
                static /*0x1fd87e4*/ Mono.Math.BigInteger LeftShift(Mono.Math.BigInteger bi, int n);
                static /*0x1fd89b8*/ Mono.Math.BigInteger RightShift(Mono.Math.BigInteger bi, int n);
                static /*0x1fd86f0*/ Mono.Math.BigInteger MultiplyByDword(Mono.Math.BigInteger n, uint f);
                static /*0x1fd85f4*/ void Multiply(uint[] x, uint xOffset, uint xLen, uint[] y, uint yOffset, uint yLen, uint[] d, uint dOffset);
                static /*0x1fda4d8*/ void MultiplyMod2p32pmod(uint[] x, int xOffset, int xLen, uint[] y, int yOffest, int yLen, uint[] d, int dOffset, int mod);
                static /*0x1fd9870*/ Mono.Math.BigInteger gcd(Mono.Math.BigInteger a, Mono.Math.BigInteger b);
                static /*0x1fdadc0*/ uint modInverse(Mono.Math.BigInteger bi, uint modulus);
                static /*0x1fd99d0*/ Mono.Math.BigInteger modInverse(Mono.Math.BigInteger bi, Mono.Math.BigInteger modulus);
            }
        }

        namespace Prime
        {
            enum ConfidenceFactor
            {
                ExtraLow = 0,
                Low = 1,
                Medium = 2,
                High = 3,
                ExtraHigh = 4,
                Provable = 5,
            }

            class PrimalityTest : System.MulticastDelegate
            {
                /*0x1fdae80*/ PrimalityTest(object object, nint method);
                /*0x1fdafb0*/ bool Invoke(Mono.Math.BigInteger bi, Mono.Math.Prime.ConfidenceFactor confidence);
                /*0x1fdafc4*/ System.IAsyncResult BeginInvoke(Mono.Math.BigInteger bi, Mono.Math.Prime.ConfidenceFactor confidence, System.AsyncCallback callback, object object);
                /*0x1fdb058*/ bool EndInvoke(System.IAsyncResult result);
            }

            class PrimalityTests
            {
                static /*0x1fdb088*/ int GetSPPRounds(Mono.Math.BigInteger bi, Mono.Math.Prime.ConfidenceFactor confidence);
                static /*0x1fda098*/ bool Test(Mono.Math.BigInteger n, Mono.Math.Prime.ConfidenceFactor confidence);
                static /*0x1fdb3e8*/ bool RabinMillerTest(Mono.Math.BigInteger n, Mono.Math.Prime.ConfidenceFactor confidence);
                static /*0x1fdb21c*/ bool SmallPrimeSppTest(Mono.Math.BigInteger bi, Mono.Math.Prime.ConfidenceFactor confidence);
                /*0x1fdb080*/ PrimalityTests();
            }

            namespace Generator
            {
                class NextPrimeFinder : Mono.Math.Prime.Generator.SequentialSearchPrimeGeneratorBase
                {
                    /*0x1fda154*/ NextPrimeFinder();
                    /*0x1fdb678*/ Mono.Math.BigInteger GenerateSearchBase(int bits, object Context);
                }

                class PrimeGeneratorBase
                {
                    /*0x1fdb84c*/ PrimeGeneratorBase();
                    /*0x1fdb76c*/ Mono.Math.Prime.ConfidenceFactor get_Confidence();
                    /*0x1fdb774*/ Mono.Math.Prime.PrimalityTest get_PrimalityTest();
                    /*0x1fdb7e8*/ int get_TrialDivisionBounds();
                    /*0x1fdb7f0*/ bool PostTrialDivisionTests(Mono.Math.BigInteger bi);
                    Mono.Math.BigInteger GenerateNewPrime(int bits);
                }

                class SequentialSearchPrimeGeneratorBase : Mono.Math.Prime.Generator.PrimeGeneratorBase
                {
                    /*0x1fda15c*/ SequentialSearchPrimeGeneratorBase();
                    /*0x1fdb854*/ Mono.Math.BigInteger GenerateSearchBase(int bits, object context);
                    /*0x1fdb8c8*/ Mono.Math.BigInteger GenerateNewPrime(int bits);
                    /*0x1fdb8d8*/ Mono.Math.BigInteger GenerateNewPrime(int bits, object context);
                    /*0x1fdbbbc*/ bool IsPrimeAcceptable(Mono.Math.BigInteger bi, object context);
                }
            }
        }
    }
}

namespace Microsoft
{
    namespace Win32
    {
        enum RegistryHive
        {
            ClassesRoot = -2147483648,
            CurrentUser = -2147483647,
            LocalMachine = -2147483646,
            Users = -2147483645,
            PerformanceData = -2147483644,
            CurrentConfig = -2147483643,
            DynData = -2147483642,
        }

        enum RegistryKeyPermissionCheck
        {
            Default = 0,
            ReadSubTree = 1,
            ReadWriteSubTree = 2,
        }

        enum RegistryOptions
        {
            None = 0,
            Volatile = 1,
        }

        enum RegistryValueKind
        {
            String = 1,
            ExpandString = 2,
            Binary = 3,
            DWord = 4,
            MultiString = 7,
            QWord = 11,
            Unknown = 0,
            None = -1,
        }

        enum RegistryValueOptions
        {
            None = 0,
            DoNotExpandEnvironmentNames = 1,
        }

        enum RegistryView
        {
            Default = 0,
            Registry64 = 256,
            Registry32 = 512,
        }

        class ThrowHelper
        {
            static /*0x1fdbbc4*/ void ThrowArgumentException(string msg);
            static /*0x1fdbc10*/ void ThrowArgumentException(string msg, string argument);
            static /*0x1fdbc64*/ void ThrowArgumentNullException(string argument);
            static /*0x1fdbcb0*/ void ThrowInvalidOperationException(string msg);
            static /*0x1fdbcfc*/ void ThrowSecurityException(string msg);
            static /*0x1fdbd48*/ void ThrowUnauthorizedAccessException(string msg);
            static /*0x1fdbd94*/ void ThrowObjectDisposedException(string objectName, string msg);
        }

        class Registry
        {
            static /*0x0*/ Microsoft.Win32.RegistryKey ClassesRoot;
            static /*0x8*/ Microsoft.Win32.RegistryKey CurrentConfig;
            static /*0x10*/ Microsoft.Win32.RegistryKey CurrentUser;
            static /*0x18*/ Microsoft.Win32.RegistryKey DynData;
            static /*0x20*/ Microsoft.Win32.RegistryKey LocalMachine;
            static /*0x28*/ Microsoft.Win32.RegistryKey PerformanceData;
            static /*0x30*/ Microsoft.Win32.RegistryKey Users;

            static /*0x1fdc550*/ Registry();
            static /*0x1fdbde8*/ Microsoft.Win32.RegistryKey ToKey(string keyName, bool setting);
            static /*0x1fdc268*/ void SetValue(string keyName, string valueName, object value);
            static /*0x1fdc380*/ void SetValue(string keyName, string valueName, object value, Microsoft.Win32.RegistryValueKind valueKind);
            static /*0x1fdc498*/ object GetValue(string keyName, string valueName, object defaultValue);
        }

        class RegistryKey : System.IDisposable
        {
            static /*0x1fdc790*/ Microsoft.Win32.RegistryKey FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle handle);
            static /*0x1fdc7d0*/ Microsoft.Win32.RegistryKey FromHandle(Microsoft.Win32.SafeHandles.SafeRegistryHandle handle, Microsoft.Win32.RegistryView view);
            static /*0x1fdc9d0*/ Microsoft.Win32.RegistryKey OpenBaseKey(Microsoft.Win32.RegistryHive hKey, Microsoft.Win32.RegistryView view);
            static /*0x1fdcb10*/ Microsoft.Win32.RegistryKey OpenRemoteBaseKey(Microsoft.Win32.RegistryHive hKey, string machineName);
            static /*0x1fdcb50*/ Microsoft.Win32.RegistryKey OpenRemoteBaseKey(Microsoft.Win32.RegistryHive hKey, string machineName, Microsoft.Win32.RegistryView view);
            /*0x1fdc5a4*/ RegistryKey(Microsoft.Win32.RegistryHive hiveId);
            /*0x1fdcd10*/ RegistryKey();
            /*0x1fdc5ec*/ void Dispose();
            /*0x1fdc5f0*/ void Close();
            /*0x1fdc228*/ Microsoft.Win32.RegistryKey CreateSubKey(string subkey);
            /*0x1fdc5f4*/ Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable);
            /*0x1fdc634*/ Microsoft.Win32.RegistryKey CreateSubKey(string subkey, bool writable, Microsoft.Win32.RegistryOptions options);
            /*0x1fdc674*/ Microsoft.Win32.RegistryKey CreateSubKey(string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);
            /*0x1fdc6b4*/ Microsoft.Win32.RegistryKey CreateSubKey(string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions);
            /*0x1fdc6f4*/ Microsoft.Win32.RegistryKey CreateSubKey(string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistrySecurity registrySecurity);
            /*0x1fdc734*/ Microsoft.Win32.RegistryKey CreateSubKey(string subkey, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, Microsoft.Win32.RegistryOptions registryOptions, System.Security.AccessControl.RegistrySecurity registrySecurity);
            /*0x1fdc774*/ void DeleteSubKey(string subkey);
            /*0x1fdc778*/ void DeleteSubKey(string subkey, bool throwOnMissingSubKey);
            /*0x1fdc77c*/ void DeleteSubKeyTree(string subkey);
            /*0x1fdc780*/ void DeleteSubKeyTree(string subkey, bool throwOnMissingSubKey);
            /*0x1fdc784*/ void DeleteValue(string name);
            /*0x1fdc788*/ void DeleteValue(string name, bool throwOnMissingValue);
            /*0x1fdc78c*/ void Flush();
            /*0x1fdc810*/ string[] GetSubKeyNames();
            /*0x1fdc850*/ object GetValue(string name);
            /*0x1fdc510*/ object GetValue(string name, object defaultValue);
            /*0x1fdc890*/ object GetValue(string name, object defaultValue, Microsoft.Win32.RegistryValueOptions options);
            /*0x1fdc8d0*/ System.Security.AccessControl.RegistrySecurity GetAccessControl();
            /*0x1fdc910*/ System.Security.AccessControl.RegistrySecurity GetAccessControl(System.Security.AccessControl.AccessControlSections includeSections);
            /*0x1fdc950*/ Microsoft.Win32.RegistryValueKind GetValueKind(string name);
            /*0x1fdc990*/ string[] GetValueNames();
            /*0x1fdca10*/ Microsoft.Win32.RegistryKey OpenSubKey(string name);
            /*0x1fdc1e8*/ Microsoft.Win32.RegistryKey OpenSubKey(string name, bool writable);
            /*0x1fdca50*/ Microsoft.Win32.RegistryKey OpenSubKey(string name, System.Security.AccessControl.RegistryRights rights);
            /*0x1fdca90*/ Microsoft.Win32.RegistryKey OpenSubKey(string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck);
            /*0x1fdcad0*/ Microsoft.Win32.RegistryKey OpenSubKey(string name, Microsoft.Win32.RegistryKeyPermissionCheck permissionCheck, System.Security.AccessControl.RegistryRights rights);
            /*0x1fdcb90*/ void SetAccessControl(System.Security.AccessControl.RegistrySecurity registrySecurity);
            /*0x1fdc37c*/ void SetValue(string name, object value);
            /*0x1fdc494*/ void SetValue(string name, object value, Microsoft.Win32.RegistryValueKind valueKind);
            /*0x1fdcbd0*/ Microsoft.Win32.SafeHandles.SafeRegistryHandle get_Handle();
            /*0x1fdcc10*/ string get_Name();
            /*0x1fdcc50*/ int get_SubKeyCount();
            /*0x1fdcc90*/ int get_ValueCount();
            /*0x1fdccd0*/ Microsoft.Win32.RegistryView get_View();
        }

        class NativeMethods
        {
            static /*0x1fdcd48*/ int GetCurrentProcessId();
        }

        class Win32Native
        {
            static string ADVAPI32 = "advapi32.dll";
            static int ERROR_SUCCESS = 0;
            static int ERROR_INVALID_FUNCTION = 1;
            static int ERROR_FILE_NOT_FOUND = 2;
            static int ERROR_PATH_NOT_FOUND = 3;
            static int ERROR_ACCESS_DENIED = 5;
            static int ERROR_INVALID_HANDLE = 6;
            static int ERROR_NOT_ENOUGH_MEMORY = 8;
            static int ERROR_INVALID_DATA = 13;
            static int ERROR_INVALID_DRIVE = 15;
            static int ERROR_NO_MORE_FILES = 18;
            static int ERROR_NOT_READY = 21;
            static int ERROR_BAD_LENGTH = 24;
            static int ERROR_SHARING_VIOLATION = 32;
            static int ERROR_NOT_SUPPORTED = 50;
            static int ERROR_FILE_EXISTS = 80;
            static int ERROR_INVALID_PARAMETER = 87;
            static int ERROR_BROKEN_PIPE = 109;
            static int ERROR_CALL_NOT_IMPLEMENTED = 120;
            static int ERROR_INSUFFICIENT_BUFFER = 122;
            static int ERROR_INVALID_NAME = 123;
            static int ERROR_BAD_PATHNAME = 161;
            static int ERROR_ALREADY_EXISTS = 183;
            static int ERROR_ENVVAR_NOT_FOUND = 203;
            static int ERROR_FILENAME_EXCED_RANGE = 206;
            static int ERROR_NO_DATA = 232;
            static int ERROR_PIPE_NOT_CONNECTED = 233;
            static int ERROR_MORE_DATA = 234;
            static int ERROR_DIRECTORY = 267;
            static int ERROR_OPERATION_ABORTED = 995;
            static int ERROR_NOT_FOUND = 1168;
            static int ERROR_NO_TOKEN = 1008;
            static int ERROR_DLL_INIT_FAILED = 1114;
            static int ERROR_NON_ACCOUNT_SID = 1257;
            static int ERROR_NOT_ALL_ASSIGNED = 1300;
            static int ERROR_UNKNOWN_REVISION = 1305;
            static int ERROR_INVALID_OWNER = 1307;
            static int ERROR_INVALID_PRIMARY_GROUP = 1308;
            static int ERROR_NO_SUCH_PRIVILEGE = 1313;
            static int ERROR_PRIVILEGE_NOT_HELD = 1314;
            static int ERROR_NONE_MAPPED = 1332;
            static int ERROR_INVALID_ACL = 1336;
            static int ERROR_INVALID_SID = 1337;
            static int ERROR_INVALID_SECURITY_DESCR = 1338;
            static int ERROR_BAD_IMPERSONATION_LEVEL = 1346;
            static int ERROR_CANT_OPEN_ANONYMOUS = 1347;
            static int ERROR_NO_SECURITY_ON_OBJECT = 1350;
            static int ERROR_TRUSTED_RELATIONSHIP_FAILURE = 1789;
            static System.IO.FileAttributes FILE_ATTRIBUTE_DIRECTORY = 16;

            static /*0x1fdcd4c*/ string GetMessage(int hr);
            static /*0x1fdcda8*/ int MakeHRFromErrorCode(int errorCode);
        }

        namespace SafeHandles
        {
            class SafeHandleCache<T>
            {
                static /*0x0*/ T s_invalidHandle;

                static T GetInvalidHandle(System.Func<T> invalidHandleFactory);
                static bool IsCachedInvalidHandle(System.Runtime.InteropServices.SafeHandle handle);
            }

            class SafePasswordHandle : System.Runtime.InteropServices.SafeHandle
            {
                static /*0x1fdd0c4*/ Microsoft.Win32.SafeHandles.SafePasswordHandle get_InvalidHandle();
                /*0x1fdcec0*/ SafePasswordHandle(string password);
                /*0x1fdcf38*/ SafePasswordHandle(System.Security.SecureString password);
                /*0x1fdcdb4*/ nint CreateHandle(string password);
                /*0x1fdce0c*/ nint CreateHandle(System.Security.SecureString password);
                /*0x1fdce64*/ void FreeHandle();
                /*0x1fdcfb0*/ bool ReleaseHandle();
                /*0x1fdd02c*/ void Dispose(bool disposing);
                /*0x1fdd09c*/ bool get_IsInvalid();
                /*0x1fdd1ac*/ string Mono_DangerousGetString();

                class <>c
                {
                    static /*0x0*/ Microsoft.Win32.SafeHandles.SafePasswordHandle.<> <>9;
                    static /*0x8*/ System.Func<Microsoft.Win32.SafeHandles.SafePasswordHandle> <>9__10_0;

                    static /*0x1fdd208*/ <>c();
                    /*0x1fdd26c*/ <>c();
                    /*0x1fdd274*/ Microsoft.Win32.SafeHandles.SafePasswordHandle <get_InvalidHandle>b__10_0();
                }
            }

            class SafeFileHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                /*0x1fdd2e0*/ SafeFileHandle();
                /*0x1fdd34c*/ SafeFileHandle(nint preexistingHandle, bool ownsHandle);
                /*0x1fdd374*/ bool ReleaseHandle();
            }

            class SafeFindHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                /*0x1fdd3f0*/ SafeFindHandle();
                /*0x1fdd3f8*/ SafeFindHandle(nint preexistingHandle);
                /*0x1fdd420*/ bool ReleaseHandle();
            }

            class SafeRegistryHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                /*0x1fdd47c*/ SafeRegistryHandle();
                /*0x1fdd484*/ SafeRegistryHandle(nint preexistingHandle, bool ownsHandle);
                /*0x1fdd4ac*/ bool ReleaseHandle();
            }

            class SafeWaitHandle : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                /*0x1fdd4b4*/ SafeWaitHandle();
                /*0x1fdd4bc*/ SafeWaitHandle(nint existingHandle, bool ownsHandle);
                /*0x1fdd4e4*/ bool ReleaseHandle();
            }

            class SafeHandleZeroOrMinusOneIsInvalid : System.Runtime.InteropServices.SafeHandle
            {
                /*0x1fdd2e8*/ SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
                /*0x1fdd500*/ bool get_IsInvalid();
            }

            class SafeHandleMinusOneIsInvalid : System.Runtime.InteropServices.SafeHandle
            {
                /*0x1fdd55c*/ SafeHandleMinusOneIsInvalid(bool ownsHandle);
                /*0x1fdd5a0*/ bool get_IsInvalid();
            }

            class CriticalHandleZeroOrMinusOneIsInvalid : System.Runtime.InteropServices.CriticalHandle
            {
                /*0x1fdd5e0*/ CriticalHandleZeroOrMinusOneIsInvalid();
                /*0x1fdd634*/ bool get_IsInvalid();
            }

            class CriticalHandleMinusOneIsInvalid : System.Runtime.InteropServices.CriticalHandle
            {
                /*0x1fdd690*/ CriticalHandleMinusOneIsInvalid();
                /*0x1fdd6cc*/ bool get_IsInvalid();
            }

            class SafeAccessTokenHandle : System.Runtime.InteropServices.SafeHandle
            {
                static /*0x1fdd7d0*/ Microsoft.Win32.SafeHandles.SafeAccessTokenHandle get_InvalidHandle();
                /*0x1fdd70c*/ SafeAccessTokenHandle();
                /*0x1fdd764*/ SafeAccessTokenHandle(nint handle);
                /*0x1fdd84c*/ bool get_IsInvalid();
                /*0x1fdd8e4*/ bool ReleaseHandle();
            }
        }
    }
}

namespace Internal
{
    namespace Threading
    {
        namespace Tasks
        {
            namespace Tracing
            {
                class TaskTrace
                {
                    static /*0x0*/ Internal.Runtime.Augments.TaskTraceCallbacks s_callbacks;

                    static /*0x1fdd8ec*/ bool get_Enabled();
                    static /*0x1fdd94c*/ void Initialize(Internal.Runtime.Augments.TaskTraceCallbacks callbacks);
                    static /*0x1fdd998*/ void TaskWaitBegin_Asynchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                    static /*0x1fdda1c*/ void TaskWaitBegin_Synchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                    static /*0x1fddaa0*/ void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                    static /*0x1fddb24*/ void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions);
                    static /*0x1fddbc4*/ void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                    static /*0x1fddc48*/ void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
                }
            }
        }
    }

    namespace Runtime
    {
        namespace CompilerServices
        {
            class RelocatedTypeAttribute : System.Attribute
            {
                /*0x1fddce0*/ RelocatedTypeAttribute(string originalAssemblySimpleName);
            }
        }

        namespace Augments
        {
            enum CausalityRelation
            {
                AssignDelegate = 0,
                Join = 1,
                Choice = 2,
                Cancel = 3,
                Error = 4,
            }

            enum CausalitySource
            {
                Application = 0,
                Library = 1,
                System = 2,
            }

            enum CausalityTraceLevel
            {
                Required = 0,
                Important = 1,
                Verbose = 2,
            }

            enum AsyncStatus
            {
                Started = 0,
                Completed = 1,
                Canceled = 2,
                Error = 3,
            }

            enum CausalitySynchronousWork
            {
                CompletionNotification = 0,
                ProgressNotification = 1,
                Execution = 2,
            }

            class TaskTraceCallbacks
            {
                /*0x1fddce8*/ TaskTraceCallbacks();
                bool get_Enabled();
                void TaskWaitBegin_Asynchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                void TaskWaitBegin_Synchronous(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions);
                void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
                void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
            }

            class EnvironmentAugments
            {
                static /*0x0*/ string StackTrace;

                static /*0x1fddcf0*/ EnvironmentAugments();
            }

            class RuntimeAugments
            {
                static /*0x0*/ Internal.Runtime.Augments.ReflectionExecutionDomainCallbacks s_reflectionExecutionDomainCallbacks;

                static /*0x1fdddd0*/ RuntimeAugments();
                static /*0x1fddd50*/ void ReportUnhandledException(System.Exception exception);
                static /*0x1fddd70*/ Internal.Runtime.Augments.ReflectionExecutionDomainCallbacks get_Callbacks();
                /*0x1fdddc8*/ RuntimeAugments();
            }

            class ReflectionExecutionDomainCallbacks
            {
                /*0x1fdde48*/ ReflectionExecutionDomainCallbacks();
                /*0x1fdde50*/ System.Exception CreateMissingMetadataException(System.Type attributeType);
            }

            class RuntimeThread
            {
                static /*0x0*/ int OptimalMaxSpinWaitsPerSpinIteration;
                /*0x10*/ System.Threading.Thread thread;

                static /*0x1fde080*/ RuntimeThread();
                static /*0x1fdded8*/ Internal.Runtime.Augments.RuntimeThread InitializeThreadPoolThread();
                static /*0x1fddf38*/ Internal.Runtime.Augments.RuntimeThread Create(System.Threading.ParameterizedThreadStart start, int maxStackSize);
                static /*0x1fde050*/ void Sleep(int millisecondsTimeout);
                static /*0x1fde058*/ bool Yield();
                static /*0x1fde060*/ bool SpinWait(int iterations);
                static /*0x1fde078*/ int GetCurrentProcessorId();
                /*0x1fddeac*/ RuntimeThread(System.Threading.Thread t);
                /*0x1fdded4*/ void ResetThreadPoolThread();
                /*0x1fddfdc*/ bool get_IsBackground();
                /*0x1fddff8*/ void set_IsBackground(bool value);
                /*0x1fde018*/ void Start();
                /*0x1fde034*/ void Start(object state);
            }
        }
    }

    namespace Cryptography
    {
        class Helpers
        {
            static /*0x1fde0cc*/ byte[] CloneByteArray(byte[] src);
            static /*0x1fde144*/ System.Security.Cryptography.KeySizes[] CloneKeySizesArray(System.Security.Cryptography.KeySizes[] src);
            static /*0x1fde1bc*/ bool UsesIv(System.Security.Cryptography.CipherMode cipherMode);
            static /*0x1fde1c8*/ byte[] GetCipherIv(System.Security.Cryptography.CipherMode cipherMode, byte[] iv);
            static /*0x1fde234*/ bool IsLegalSize(int size, System.Security.Cryptography.KeySizes[] legalSizes);
            static /*0x1fde2b8*/ byte[] GenerateRandom(int count);
            static /*0x1fde460*/ void WriteInt(uint i, byte[] arr, int offset);
            static /*0x1fde4e0*/ byte[] FixupKeyParity(byte[] key);
            static /*0x1fde5a8*/ void ConvertIntToByteArray(uint value, byte[] dest);
            static /*0x1fde5fc*/ char[] ToHexArrayUpper(byte[] bytes);
            static /*0x1fde704*/ string ToHexStringUpper(byte[] bytes);
            static /*0x1fde71c*/ byte[] DecodeHexString(string s);
            static /*0x1fde8cc*/ byte HexToByte(char val);
            static /*0x1fde6e8*/ char NibbleToHex(byte b);
            static /*0x1fde918*/ bool ContentsEqual(byte[] a1, byte[] a2);
            static void AddRange<T>(System.Collections.Generic.ICollection<T> coll, System.Collections.Generic.IEnumerable<T> newData);
            static /*0x1fde98c*/ bool IsValidDay(System.Globalization.Calendar calendar, int year, int month, int day, int era);
            static /*0x1fdea14*/ bool IsValidMonth(System.Globalization.Calendar calendar, int year, int month, int era);
            static /*0x1fdea94*/ bool IsValidYear(System.Globalization.Calendar calendar, int year, int era);
            static /*0x1fdeb1c*/ void DisposeAll(System.Collections.Generic.IEnumerable<System.IDisposable> disposables);
        }

        class ErrorCode
        {
            static int CERT_E_CHAINING = -2146762486;
            static int CERT_E_CRITICAL = -2146762491;
            static int CERT_E_EXPIRED = -2146762495;
            static int CERT_E_INVALID_NAME = -2146762476;
            static int CERT_E_INVALID_POLICY = -2146762477;
            static int CERT_E_UNTRUSTEDROOT = -2146762487;
            static int CERT_E_VALIDITYPERIODNESTING = -2146762494;
            static int CERT_E_WRONG_USAGE = -2146762480;
            static int CERTSRV_E_WEAK_SIGNATURE_OR_KEY = -2146877418;
            static int CRYPT_E_NO_REVOCATION_CHECK = -2146885614;
            static int CRYPT_E_NOT_FOUND = -2146885628;
            static int CRYPT_E_REVOCATION_OFFLINE = -2146885613;
            static int CRYPT_E_REVOKED = -2146885616;
            static int CRYPT_E_SIGNER_NOT_FOUND = -2146889714;
            static int E_POINTER = -2147467261;
            static int ERROR_INVALID_PARAMETER = 87;
            static int HRESULT_INVALID_HANDLE = -2147024890;
            static int NTE_BAD_PUBLIC_KEY = -2146893803;
            static int TRUST_E_BASIC_CONSTRAINTS = -2146869223;
            static int TRUST_E_CERT_SIGNATURE = -2146869244;
            static int TRUST_E_EXPLICIT_DISTRUST = -2146762479;
        }

        struct PinAndClear : System.IDisposable
        {
            /*0x10*/ byte[] _data;
            /*0x18*/ System.Runtime.InteropServices.GCHandle _gcHandle;

            static /*0x1fdee48*/ Internal.Cryptography.PinAndClear Track(byte[] data);
            /*0x1fdee6c*/ void Dispose();
        }
    }

    namespace IO
    {
        class File
        {
            static /*0x1fdeea0*/ bool InternalExists(string fullPath);
        }
    }
}

namespace System
{
    class String : System.IComparable, System.Collections.IEnumerable, System.Collections.Generic.IEnumerable<char>, System.IComparable<string>, System.IEquatable<string>, System.IConvertible, System.ICloneable
    {
        static int StackallocIntBufferSizeLimit = 128;
        static int PROBABILISTICMAP_BLOCK_INDEX_MASK = 7;
        static int PROBABILISTICMAP_BLOCK_INDEX_SHIFT = 3;
        static int PROBABILISTICMAP_SIZE = 8;
        static /*0x0*/ string Empty;
        /*0x10*/ int _stringLength;
        /*0x14*/ char _firstChar;

        static /*0x1fdef5c*/ int CompareOrdinalIgnoreCaseHelper(string strA, string strB);
        static /*0x1fdf038*/ bool EqualsHelper(string strA, string strB);
        static /*0x1fdf06c*/ int CompareOrdinalHelper(string strA, int indexA, int countA, string strB, int indexB, int countB);
        static /*0x1fdf0a4*/ bool EqualsIgnoreCaseAsciiHelper(string strA, string strB);
        static /*0x1fdf114*/ int CompareOrdinalHelper(string strA, string strB);
        static /*0x1fdf2b8*/ int Compare(string strA, string strB);
        static /*0x1fdf560*/ int Compare(string strA, string strB, bool ignoreCase);
        static /*0x1fdf2c0*/ int Compare(string strA, string strB, System.StringComparison comparisonType);
        static /*0x1fdf584*/ int Compare(string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);
        static /*0x1fdf624*/ int Compare(string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);
        static /*0x1fdf634*/ int Compare(string strA, int indexA, string strB, int indexB, int length);
        static /*0x1fdf63c*/ int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
        static /*0x1fdf780*/ int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);
        static /*0x1fdf790*/ int Compare(string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);
        static /*0x1fdf8fc*/ int Compare(string strA, int indexA, string strB, int indexB, int length, System.StringComparison comparisonType);
        static /*0x1fdfd2c*/ int CompareOrdinal(string strA, string strB);
        static /*0x1fdfd70*/ int CompareOrdinal(System.ReadOnlySpan<char> strA, System.ReadOnlySpan<char> strB);
        static /*0x1fdfe10*/ int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
        static /*0x1fe0870*/ bool Equals(string a, string b);
        static /*0x1fe08bc*/ bool Equals(string a, string b, System.StringComparison comparisonType);
        static /*0x1fdc1e4*/ bool op_Equality(string a, string b);
        static /*0x1fe0b48*/ bool op_Inequality(string a, string b);
        static /*0x1fdf568*/ void CheckStringComparison(System.StringComparison comparisonType);
        static /*0x1fe1084*/ void FillStringChecked(string dest, int destPos, string src);
        static /*0x1fe110c*/ string Concat(object arg0);
        static /*0x1fe1174*/ string Concat(object arg0, object arg1);
        static /*0x1fe121c*/ string Concat(object arg0, object arg1, object arg2);
        static /*0x1fe13c0*/ string Concat(object[] args);
        static string Concat<T>(System.Collections.Generic.IEnumerable<T> values);
        static /*0x1fe161c*/ string Concat(System.Collections.Generic.IEnumerable<string> values);
        static /*0x1fd35d4*/ string Concat(string str0, string str1);
        static /*0x1fe1300*/ string Concat(string str0, string str1, string str2);
        static /*0x1fe1af4*/ string Concat(string str0, string str1, string str2, string str3);
        static /*0x1fe1bfc*/ string Concat(string[] values);
        static /*0x1fd422c*/ string Format(string format, object arg0);
        static /*0x1fe1edc*/ string Format(string format, object arg0, object arg1);
        static /*0x1fe1f20*/ string Format(string format, object arg0, object arg1, object arg2);
        static /*0x1fe1f64*/ string Format(string format, object[] args);
        static /*0x1fe2014*/ string Format(System.IFormatProvider provider, string format, object arg0);
        static /*0x1fe2068*/ string Format(System.IFormatProvider provider, string format, object arg0, object arg1);
        static /*0x1fe20c0*/ string Format(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2);
        static /*0x1fe211c*/ string Format(System.IFormatProvider provider, string format, object[] args);
        static /*0x1fe1e0c*/ string FormatHelper(System.IFormatProvider provider, string format, System.ParamsArray args);
        static /*0x1fe2318*/ string Join(char separator, string[] value);
        static /*0x1fe23c0*/ string Join(char separator, object[] values);
        static string Join<T>(char separator, System.Collections.Generic.IEnumerable<T> values);
        static /*0x1fe2398*/ string Join(char separator, string[] value, int startIndex, int count);
        static /*0x1fe2944*/ string Join(string separator, string[] value);
        static /*0x1fe2a28*/ string Join(string separator, object[] values);
        static string Join<T>(string separator, System.Collections.Generic.IEnumerable<T> values);
        static /*0x1fe2a90*/ string Join(string separator, System.Collections.Generic.IEnumerable<string> values);
        static /*0x1fe29a8*/ string Join(string separator, string[] value, int startIndex, int count);
        static /*0x1fe23e0*/ string JoinCore(char* separator, int separatorLength, object[] values);
        static string JoinCore<T>(char* separator, int separatorLength, System.Collections.Generic.IEnumerable<T> values);
        static /*0x1fe2584*/ string JoinCore(char* separator, int separatorLength, string[] value, int startIndex, int count);
        static /*0x1fe5e84*/ void InitializeProbabilisticMap(uint* charMap, System.ReadOnlySpan<char> anyOf);
        static /*0x1fe6ed8*/ bool ArrayContains(char searchChar, char[] anyOf);
        static /*0x1fe5f4c*/ bool IsCharBitSet(uint* charMap, byte value);
        static /*0x1fe6f24*/ void SetCharBit(uint* charMap, byte value);
        static /*0x1fe7b8c*/ string Ctor(char[] value);
        static /*0x1fe7c20*/ string Ctor(char[] value, int startIndex, int length);
        static /*0x1fe7de0*/ string Ctor(char* ptr);
        static /*0x1fe7f7c*/ string Ctor(char* ptr, int startIndex, int length);
        static /*0x1fe8110*/ string Ctor(sbyte* value);
        static /*0x1fe8298*/ string Ctor(sbyte* value, int startIndex, int length);
        static /*0x1fe8218*/ string CreateStringForSByteConstructor(byte* pb, int numBytes);
        static /*0x1fe8424*/ string Ctor(sbyte* value, int startIndex, int length, System.Text.Encoding enc);
        static /*0x1fe861c*/ string Ctor(char c, int count);
        static /*0x1fe8740*/ string Ctor(System.ReadOnlySpan<char> value);
        static string Create<TState>(int length, TState state, System.Buffers.SpanAction<char, TState> action);
        static /*0x1fe8800*/ System.ReadOnlySpan<char> op_Implicit(string value);
        static /*0x1fe8854*/ string Copy(string str);
        static /*0x1fe1ad8*/ bool IsNullOrEmpty(string value);
        static /*0x1fe8ce4*/ bool IsNullOrWhiteSpace(string value);
        static /*0x1fe8d94*/ string CreateStringFromEncoding(byte* bytes, int byteLength, System.Text.Encoding encoding);
        static /*0x1fe8e5c*/ string CreateFromChar(char c);
        static /*0x1fe1100*/ void wstrcpy(char* dmem, char* smem, int charCount);
        static /*0x1fe7e6c*/ int wcslen(char* ptr);
        static /*0x1fe9798*/ string Concat(object arg0, object arg1, object arg2, object arg3);
        static /*0x1fe1618*/ string FastAllocateString(int length);
        static /*0x1fe9c54*/ string InternalIsInterned(string str);
        static /*0x1fe9c58*/ string InternalIntern(string str);
        static /*0x1fe9c5c*/ int FastCompareStringHelper(uint* strAChars, int countA, uint* strBChars, int countB);
        static /*0x1fe9d08*/ void memset(byte* dest, int val, int len);
        static /*0x1fe9dc4*/ void memcpy(byte* dest, byte* src, int size);
        static /*0x1fe9dd0*/ void bzero(byte* dest, int len);
        static /*0x1fe9ddc*/ void bzero_aligned_1(byte* dest, int len);
        static /*0x1fe9de4*/ void bzero_aligned_2(byte* dest, int len);
        static /*0x1fe9dec*/ void bzero_aligned_4(byte* dest, int len);
        static /*0x1fe9df4*/ void bzero_aligned_8(byte* dest, int len);
        static /*0x1fe9dfc*/ void memcpy_aligned_1(byte* dest, byte* src, int size);
        static /*0x1fe9e08*/ void memcpy_aligned_2(byte* dest, byte* src, int size);
        static /*0x1fe9e14*/ void memcpy_aligned_4(byte* dest, byte* src, int size);
        static /*0x1fe9e20*/ void memcpy_aligned_8(byte* dest, byte* src, int size);
        static /*0x1fe9e88*/ string Intern(string str);
        static /*0x1fe9ee0*/ string IsInterned(string str);
        /*0x1fe7b88*/ String(char[] value);
        /*0x1fe7c1c*/ String(char[] value, int startIndex, int length);
        /*0x1fe7ddc*/ String(char* value);
        /*0x1fe7f78*/ String(char* value, int startIndex, int length);
        /*0x1fe810c*/ String(sbyte* value);
        /*0x1fe8294*/ String(sbyte* value, int startIndex, int length);
        /*0x1fe8420*/ String(sbyte* value, int startIndex, int length, System.Text.Encoding enc);
        /*0x1fe8618*/ String(char c, int count);
        /*0x1fe873c*/ String(System.ReadOnlySpan<char> value);
        /*0x1fe0018*/ int CompareTo(object value);
        /*0x1fe00d8*/ int CompareTo(string strB);
        /*0x1fe00e0*/ bool EndsWith(string value);
        /*0x1fe00e8*/ bool EndsWith(string value, System.StringComparison comparisonType);
        /*0x1fe0398*/ bool EndsWith(string value, bool ignoreCase, System.Globalization.CultureInfo culture);
        /*0x1fe04b0*/ bool EndsWith(char value);
        /*0x1fe0500*/ bool Equals(object obj);
        /*0x1fe05a4*/ bool Equals(string value);
        /*0x1fe05e4*/ bool Equals(string value, System.StringComparison comparisonType);
        /*0x1fe0b60*/ int GetHashCode();
        /*0x1fe0bb4*/ int GetHashCode(System.StringComparison comparisonType);
        /*0x1fe0b64*/ int GetLegacyNonRandomizedHashCode();
        /*0x1fe0c30*/ bool StartsWith(string value);
        /*0x1fe0c8c*/ bool StartsWith(string value, System.StringComparison comparisonType);
        /*0x1fe0f50*/ bool StartsWith(string value, bool ignoreCase, System.Globalization.CultureInfo culture);
        /*0x1fe1064*/ bool StartsWith(char value);
        /*0x1fe21d4*/ string Insert(int startIndex, string value);
        /*0x1fe2f64*/ string PadLeft(int totalWidth);
        /*0x1fe2f6c*/ string PadLeft(int totalWidth, char paddingChar);
        /*0x1fe304c*/ string PadRight(int totalWidth);
        /*0x1fe3054*/ string PadRight(int totalWidth, char paddingChar);
        /*0x1fe313c*/ string Remove(int startIndex, int count);
        /*0x1fe32e4*/ string Remove(int startIndex);
        /*0x1fe354c*/ string Replace(string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);
        /*0x1fe37f8*/ string Replace(string oldValue, string newValue, System.StringComparison comparisonType);
        /*0x1fe3568*/ string ReplaceCore(string oldValue, string newValue, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);
        /*0x1fe3cd8*/ string Replace(char oldChar, char newChar);
        /*0x1fe39a0*/ string Replace(string oldValue, string newValue);
        /*0x1fe3db0*/ string ReplaceHelper(int oldValueLength, string newValue, System.ReadOnlySpan<int> indices);
        /*0x1fdc184*/ string[] Split(char separator, System.StringSplitOptions options);
        /*0x1fe4464*/ string[] Split(char separator, int count, System.StringSplitOptions options);
        /*0x1fe44c8*/ string[] Split(char[] separator);
        /*0x1fe453c*/ string[] Split(char[] separator, int count);
        /*0x1fe45b4*/ string[] Split(char[] separator, System.StringSplitOptions options);
        /*0x1fe462c*/ string[] Split(char[] separator, int count, System.StringSplitOptions options);
        /*0x1fe4108*/ string[] SplitInternal(System.ReadOnlySpan<char> separators, int count, System.StringSplitOptions options);
        /*0x1fe5094*/ string[] Split(string separator, System.StringSplitOptions options);
        /*0x1fe5558*/ string[] Split(string separator, int count, System.StringSplitOptions options);
        /*0x1fe55e0*/ string[] Split(string[] separator, System.StringSplitOptions options);
        /*0x1fe55f4*/ string[] Split(string[] separator, int count, System.StringSplitOptions options);
        /*0x1fe5118*/ string[] SplitInternal(string separator, string[] separators, int count, System.StringSplitOptions options);
        /*0x1fe5608*/ string[] SplitInternal(string separator, int count, System.StringSplitOptions options);
        /*0x1fe4b78*/ string[] SplitKeepEmptyEntries(System.ReadOnlySpan<int> sepList, System.ReadOnlySpan<int> lengthList, int defaultLength, int count);
        /*0x1fe4da8*/ string[] SplitOmitEmptyEntries(System.ReadOnlySpan<int> sepList, System.ReadOnlySpan<int> lengthList, int defaultLength, int count);
        /*0x1fe46b0*/ void MakeSeparatorList(System.ReadOnlySpan<char> separators, ref System.Collections.Generic.ValueListBuilder<int> sepListBuilder);
        /*0x1fe5b98*/ void MakeSeparatorList(string separator, ref System.Collections.Generic.ValueListBuilder<int> sepListBuilder);
        /*0x1fe5804*/ void MakeSeparatorList(string[] separators, ref System.Collections.Generic.ValueListBuilder<int> sepListBuilder, ref System.Collections.Generic.ValueListBuilder<int> lengthListBuilder);
        /*0x1fe5e78*/ string Substring(int startIndex);
        /*0x1fe33a4*/ string Substring(int startIndex, int length);
        /*0x1fe5f70*/ string InternalSubString(int startIndex, int length);
        /*0x1fe5fc8*/ string ToLower();
        /*0x1fe604c*/ string ToLower(System.Globalization.CultureInfo culture);
        /*0x1fe60dc*/ string ToLowerInvariant();
        /*0x1fe6160*/ string ToUpper();
        /*0x1fe61e4*/ string ToUpper(System.Globalization.CultureInfo culture);
        /*0x1fe6274*/ string ToUpperInvariant();
        /*0x1fe62f8*/ string Trim();
        /*0x1fe6438*/ string Trim(char trimChar);
        /*0x1fe6590*/ string Trim(char[] trimChars);
        /*0x1fe65c4*/ string TrimStart();
        /*0x1fe65cc*/ string TrimStart(char trimChar);
        /*0x1fe65ec*/ string TrimStart(char[] trimChars);
        /*0x1fe6620*/ string TrimEnd();
        /*0x1fe6628*/ string TrimEnd(char trimChar);
        /*0x1fe6648*/ string TrimEnd(char[] trimChars);
        /*0x1fe6300*/ string TrimWhiteSpaceHelper(System.String.TrimType trimType);
        /*0x1fe6458*/ string TrimHelper(char* trimChars, int trimCharsLength, System.String.TrimType trimType);
        /*0x1fe667c*/ string CreateTrimmedString(int start, int end);
        /*0x1fe670c*/ bool Contains(string value);
        /*0x1fe6740*/ bool Contains(string value, System.StringComparison comparisonType);
        /*0x1fe6764*/ bool Contains(char value);
        /*0x1fe6798*/ bool Contains(char value, System.StringComparison comparisonType);
        /*0x1fe6788*/ int IndexOf(char value);
        /*0x1fe69d0*/ int IndexOf(char value, int startIndex);
        /*0x1fe67b0*/ int IndexOf(char value, System.StringComparison comparisonType);
        /*0x1fe69dc*/ int IndexOf(char value, int startIndex, int count);
        /*0x1fe6abc*/ int IndexOfAny(char[] anyOf);
        /*0x1fe6c8c*/ int IndexOfAny(char[] anyOf, int startIndex);
        /*0x1fe6ac8*/ int IndexOfAny(char[] anyOf, int startIndex, int count);
        /*0x1fe6c98*/ int IndexOfAny(char value1, char value2, int startIndex, int count);
        /*0x1fe6d1c*/ int IndexOfAny(char value1, char value2, char value3, int startIndex, int count);
        /*0x1fe6d70*/ int IndexOfCharArray(char[] anyOf, int startIndex, int count);
        /*0x1fe6f48*/ int IndexOf(string value);
        /*0x1fe6f58*/ int IndexOf(string value, int startIndex);
        /*0x1fe6f78*/ int IndexOf(string value, int startIndex, int count);
        /*0x1fe6730*/ int IndexOf(string value, System.StringComparison comparisonType);
        /*0x1fe6f68*/ int IndexOf(string value, int startIndex, System.StringComparison comparisonType);
        /*0x1fe7040*/ int IndexOf(string value, int startIndex, int count, System.StringComparison comparisonType);
        /*0x1fe7388*/ int LastIndexOf(char value);
        /*0x1fe7398*/ int LastIndexOf(char value, int startIndex);
        /*0x1fe73a0*/ int LastIndexOf(char value, int startIndex, int count);
        /*0x1fe748c*/ int LastIndexOfAny(char[] anyOf);
        /*0x1fe75d0*/ int LastIndexOfAny(char[] anyOf, int startIndex);
        /*0x1fe7498*/ int LastIndexOfAny(char[] anyOf, int startIndex, int count);
        /*0x1fe75d8*/ int LastIndexOfCharArray(char[] anyOf, int startIndex, int count);
        /*0x1fe7740*/ int LastIndexOf(string value);
        /*0x1fe7aec*/ int LastIndexOf(string value, int startIndex);
        /*0x1fe7af8*/ int LastIndexOf(string value, int startIndex, int count);
        /*0x1fe7b6c*/ int LastIndexOf(string value, System.StringComparison comparisonType);
        /*0x1fe7b7c*/ int LastIndexOf(string value, int startIndex, System.StringComparison comparisonType);
        /*0x1fe7750*/ int LastIndexOf(string value, int startIndex, int count, System.StringComparison comparisonType);
        /*0x1fe8850*/ object Clone();
        /*0x1fe88ec*/ void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
        /*0x1fe8a74*/ char[] ToCharArray();
        /*0x1fe8b50*/ char[] ToCharArray(int startIndex, int length);
        /*0x1fdf064*/ ref char GetRawStringData();
        /*0x1fe8e80*/ string ToString();
        /*0x1fe8e84*/ string ToString(System.IFormatProvider provider);
        /*0x1fe8e88*/ System.CharEnumerator GetEnumerator();
        /*0x1fe8eec*/ System.Collections.Generic.IEnumerator<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
        /*0x1fe8f50*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
        /*0x1fe8fb4*/ System.TypeCode GetTypeCode();
        /*0x1fe8fbc*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x1fe9024*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x1fe908c*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x1fe90f4*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x1fe915c*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x1fe91c4*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x1fe922c*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x1fe9294*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x1fe92fc*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x1fe9364*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x1fe93cc*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x1fe9434*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x1fe949c*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x1fe9504*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x1fe956c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
        /*0x1fe95dc*/ bool IsNormalized();
        /*0x1fe95e4*/ bool IsNormalized(System.Text.NormalizationForm normalizationForm);
        /*0x1fe964c*/ string Normalize();
        /*0x1fe9654*/ string Normalize(System.Text.NormalizationForm normalizationForm);
        /*0x1fe96bc*/ int get_Length();
        /*0x1fe96c4*/ int IndexOfUnchecked(string value, int startIndex, int count);
        /*0x1fe97d8*/ int IndexOfUncheckedIgnoreCase(string value, int startIndex, int count);
        /*0x1fe998c*/ int LastIndexOfUnchecked(string value, int startIndex, int count);
        /*0x1fe9a5c*/ int LastIndexOfUncheckedIgnoreCase(string value, int startIndex, int count);
        /*0x1fe9bfc*/ bool StartsWithOrdinalUnchecked(string value);
        /*0x1fe9e2c*/ string CreateString(sbyte* value);
        /*0x1fe8608*/ string CreateString(sbyte* value, int startIndex, int length);
        /*0x1fe9e34*/ string CreateString(char* value);
        /*0x1fe9e3c*/ string CreateString(char* value, int startIndex, int length);
        /*0x1fe9e4c*/ string CreateString(char[] val, int startIndex, int length);
        /*0x1fde714*/ string CreateString(char[] val);
        /*0x1fe9e5c*/ string CreateString(char c, int count);
        /*0x1fe9e68*/ string CreateString(sbyte* value, int startIndex, int length, System.Text.Encoding enc);
        /*0x1fe9e7c*/ string CreateString(System.ReadOnlySpan<char> value);
        /*0x1fd7af0*/ char get_Chars(int index);
        /*0x1fe9f38*/ int LegacyStringGetHashCode();

        enum TrimType
        {
            Head = 0,
            Tail = 1,
            Both = 2,
        }

        struct ProbabilisticMap
        {
        }
    }

    class TimeZoneInfo : System.IEquatable<System.TimeZoneInfo>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
    {
        static string DefaultTimeZoneDirectory = "/usr/share/zoneinfo/";
        static string ZoneTabFileName = "zone.tab";
        static string TimeZoneEnvironmentVariable = "TZ";
        static string TimeZoneDirectoryEnvironmentVariable = "TZDIR";
        static string UtcId = "UTC";
        static string LocalId = "Local";
        static /*0x0*/ System.TimeZoneInfo s_utcTimeZone;
        static /*0x8*/ System.TimeZoneInfo.CachedData s_cachedData;
        static /*0x10*/ System.DateTime s_maxDateOnly;
        static /*0x18*/ System.DateTime s_minDateOnly;
        static /*0x20*/ System.TimeSpan MaxOffset;
        static /*0x28*/ System.TimeSpan MinOffset;
        /*0x10*/ string _id;
        /*0x18*/ string _displayName;
        /*0x20*/ string _standardDisplayName;
        /*0x28*/ string _daylightDisplayName;
        /*0x30*/ System.TimeSpan _baseUtcOffset;
        /*0x38*/ bool _supportsDaylightSavingTime;
        /*0x40*/ System.TimeZoneInfo.AdjustmentRule[] _adjustmentRules;

        static /*0x2109bc8*/ TimeZoneInfo();
        static /*0x20fd8d8*/ void PopulateAllSystemTimeZones(System.TimeZoneInfo.CachedData cachedData);
        static /*0x20fe190*/ System.TimeZoneInfo GetLocalTimeZone(System.TimeZoneInfo.CachedData cachedData);
        static /*0x20fe340*/ System.TimeZoneInfo.TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, ref System.TimeZoneInfo value, ref System.Exception e);
        static /*0x20fdbb0*/ System.Collections.Generic.List<string> GetTimeZoneIds(string timeZoneDirectory);
        static /*0x20fe790*/ bool TryGetLocalTzFile(ref byte[] rawData, ref string id);
        static /*0x20fe940*/ string GetTzEnvironmentVariable();
        static /*0x20fe9d8*/ bool TryLoadTzFile(string tzFilePath, ref byte[] rawData, ref string id);
        static /*0x20feb68*/ string FindTimeZoneIdUsingReadLink(string tzFilePath);
        static /*0x20feee8*/ string GetDirectoryEntryFullPath(ref Interop.Sys.DirectoryEntry dirent, string currentPath);
        static /*0x20ff074*/ void EnumerateFilesRecursively(string path, System.Predicate<string> condition);
        static /*0x20fec74*/ string FindTimeZoneId(byte[] rawData);
        static /*0x20ff66c*/ bool CompareTimeZoneFile(string filePath, byte[] buffer, byte[] rawData);
        static /*0x20fe1dc*/ System.TimeZoneInfo GetLocalTimeZoneFromTzFile();
        static /*0x20fe5d0*/ System.TimeZoneInfo GetTimeZoneFromTzData(byte[] rawData, string id);
        static /*0x20fda64*/ string GetTimeZoneDirectory();
        static /*0x20ffef8*/ System.TimeZoneInfo FindSystemTimeZoneById(string id);
        static /*0x2100390*/ System.TimeSpan GetDateTimeNowUtcOffsetFromUtc(System.DateTime time, ref bool isAmbiguousLocalDst);
        static /*0x20fcf18*/ void TZif_GenerateAdjustmentRules(ref System.TimeZoneInfo.AdjustmentRule[] rules, System.TimeSpan baseUtcOffset, System.DateTime[] dts, byte[] typeOfLocalTime, System.TimeZoneInfo.TZifType[] transitionType, bool[] StandardTime, bool[] GmtTime, string futureTransitionsPosixFormat);
        static /*0x21006d8*/ void TZif_GenerateAdjustmentRule(ref int index, System.TimeSpan timeZoneBaseUtcOffset, System.Collections.Generic.List<System.TimeZoneInfo.AdjustmentRule> rulesList, System.DateTime[] dts, byte[] typeOfLocalTime, System.TimeZoneInfo.TZifType[] transitionTypes, bool[] StandardTime, bool[] GmtTime, string futureTransitionsPosixFormat);
        static /*0x2100e44*/ System.TimeSpan TZif_CalculateTransitionOffsetFromBase(System.TimeSpan transitionOffset, System.TimeSpan timeZoneBaseUtcOffset);
        static /*0x2100da0*/ System.TimeZoneInfo.TZifType TZif_GetEarlyDateTransitionType(System.TimeZoneInfo.TZifType[] transitionTypes);
        static /*0x21012c0*/ System.TimeZoneInfo.AdjustmentRule TZif_CreateAdjustmentRuleForPosixFormat(string posixFormat, System.DateTime startTransitionDate, System.TimeSpan timeZoneBaseUtcOffset);
        static /*0x21017e0*/ System.Nullable<System.TimeSpan> TZif_ParseOffsetString(string offset);
        static /*0x2101c34*/ System.DateTime ParseTimeOfDay(string time);
        static /*0x21019d8*/ System.TimeZoneInfo.TransitionTime TZif_CreateTransitionTimeFromPosixRule(string date, string time);
        static /*0x21020d4*/ void TZif_ParseJulianDay(string date, ref int month, ref int day);
        static /*0x2101e70*/ bool TZif_ParseMDateRule(string dateRule, ref int month, ref int week, ref System.DayOfWeek dayOfWeek);
        static /*0x21015e4*/ bool TZif_ParsePosixFormat(string posixFormat, ref string standardName, ref string standardOffset, ref string daylightSavingsName, ref string daylightSavingsOffset, ref string start, ref string startTime, ref string end, ref string endTime);
        static /*0x21022a0*/ string TZif_ParsePosixName(string posixFormat, ref int index);
        static /*0x21024d4*/ string TZif_ParsePosixOffset(string posixFormat, ref int index);
        static /*0x21025e0*/ void TZif_ParsePosixDateTime(string posixFormat, ref int index, ref string date, ref string time);
        static /*0x2102754*/ string TZif_ParsePosixDate(string posixFormat, ref int index);
        static /*0x2102860*/ string TZif_ParsePosixTime(string posixFormat, ref int index);
        static /*0x21026bc*/ string TZif_ParsePosixString(string posixFormat, ref int index, System.Func<char, bool> breakCondition);
        static /*0x20fceb4*/ string TZif_GetZoneAbbreviation(string zoneAbbreviations, int index);
        static /*0x210296c*/ int TZif_ToInt32(byte[] value, int startIndex);
        static /*0x210299c*/ long TZif_ToInt64(byte[] value, int startIndex);
        static /*0x21029cc*/ long TZif_ToUnixTime(byte[] value, int startIndex, System.TimeZoneInfo.TZVersion version);
        static /*0x2102a54*/ System.DateTime TZif_UnixTimeToDateTime(long unixTime);
        static /*0x20fc99c*/ void TZif_ParseRaw(byte[] data, ref System.TimeZoneInfo.TZifHead t, ref System.DateTime[] dts, ref byte[] typeOfLocalTime, ref System.TimeZoneInfo.TZifType[] transitionType, ref string zoneAbbreviations, ref bool[] StandardTime, ref bool[] GmtTime, ref string futureTransitionsPosixFormat);
        static /*0x21045b0*/ System.TimeSpan GetLocalUtcOffset(System.DateTime dateTime, System.TimeZoneInfoOptions flags);
        static /*0x210584c*/ void ClearCachedData();
        static /*0x21058dc*/ System.DateTimeOffset ConvertTimeBySystemTimeZoneId(System.DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
        static /*0x2105950*/ System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime dateTime, string destinationTimeZoneId);
        static /*0x2105b14*/ System.DateTime ConvertTimeBySystemTimeZoneId(System.DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
        static /*0x2103234*/ System.DateTimeOffset ConvertTime(System.DateTimeOffset dateTimeOffset, System.TimeZoneInfo destinationTimeZone);
        static /*0x21059bc*/ System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo destinationTimeZone);
        static /*0x2105d08*/ System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone, System.TimeZoneInfo destinationTimeZone);
        static /*0x2104750*/ System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone, System.TimeZoneInfo destinationTimeZone, System.TimeZoneInfoOptions flags);
        static /*0x2103de4*/ System.DateTime ConvertTime(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone, System.TimeZoneInfo destinationTimeZone, System.TimeZoneInfoOptions flags, System.TimeZoneInfo.CachedData cachedData);
        static /*0x2105f68*/ System.DateTime ConvertTimeFromUtc(System.DateTime dateTime, System.TimeZoneInfo destinationTimeZone);
        static /*0x2105fdc*/ System.DateTime ConvertTimeToUtc(System.DateTime dateTime);
        static /*0x21060a0*/ System.DateTime ConvertTimeToUtc(System.DateTime dateTime, System.TimeZoneInfoOptions flags);
        static /*0x2106170*/ System.DateTime ConvertTimeToUtc(System.DateTime dateTime, System.TimeZoneInfo sourceTimeZone);
        static /*0x210640c*/ System.TimeZoneInfo FromSerializedString(string source);
        static /*0x2106750*/ System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> GetSystemTimeZones();
        static /*0x21002a4*/ System.TimeZoneInfo get_Local();
        static /*0x210710c*/ System.TimeZoneInfo get_Utc();
        static /*0x2107250*/ System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
        static /*0x21072ec*/ System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules);
        static /*0x2107384*/ System.TimeZoneInfo CreateCustomTimeZone(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
        static /*0x2105d84*/ System.DateTime ConvertUtcToTimeZone(long ticks, System.TimeZoneInfo destinationTimeZone, ref bool isAmbiguousLocalDst);
        static /*0x2104fd4*/ bool GetIsDaylightSavings(System.DateTime time, System.TimeZoneInfo.AdjustmentRule rule, System.Globalization.DaylightTimeStruct daylightTime, System.TimeZoneInfoOptions flags);
        static /*0x2108844*/ bool GetIsDaylightSavingsFromUtc(System.DateTime time, int year, System.TimeSpan utc, System.TimeZoneInfo.AdjustmentRule rule, System.Nullable<int> ruleIndex, ref bool isAmbiguousLocalDst, System.TimeZoneInfo zone);
        static /*0x2108524*/ bool CheckIsDst(System.DateTime startTime, System.DateTime time, System.DateTime endTime, bool ignoreYearAdjustment, System.TimeZoneInfo.AdjustmentRule rule);
        static /*0x21036d8*/ bool GetIsAmbiguousTime(System.DateTime time, System.TimeZoneInfo.AdjustmentRule rule, System.Globalization.DaylightTimeStruct daylightTime);
        static /*0x21054a0*/ bool GetIsInvalidTime(System.DateTime time, System.TimeZoneInfo.AdjustmentRule rule, System.Globalization.DaylightTimeStruct daylightTime);
        static /*0x21047d8*/ System.TimeSpan GetUtcOffset(System.DateTime time, System.TimeZoneInfo zone, System.TimeZoneInfoOptions flags);
        static /*0x2104378*/ System.TimeSpan GetUtcOffsetFromUtc(System.DateTime time, System.TimeZoneInfo zone);
        static /*0x2104c7c*/ System.TimeSpan GetUtcOffsetFromUtc(System.DateTime time, System.TimeZoneInfo zone, ref bool isDaylightSavings);
        static /*0x2100408*/ System.TimeSpan GetUtcOffsetFromUtc(System.DateTime time, System.TimeZoneInfo zone, ref bool isDaylightSavings, ref bool isAmbiguousLocalDst);
        static /*0x2108138*/ System.DateTime TransitionTimeToDateTime(int year, System.TimeZoneInfo.TransitionTime transitionTime);
        static /*0x20fdff0*/ System.TimeZoneInfo.TimeZoneInfoResult TryGetTimeZone(string id, bool dstDisabled, ref System.TimeZoneInfo value, ref System.Exception e, System.TimeZoneInfo.CachedData cachedData, bool alwaysFallbackToLocalMachine);
        static /*0x2108fc4*/ System.TimeZoneInfo.TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, bool dstDisabled, ref System.TimeZoneInfo value, ref System.Exception e, System.TimeZoneInfo.CachedData cachedData);
        static /*0x20fd064*/ void ValidateTimeZoneInfo(string id, System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules, ref bool adjustmentRulesSupportDst);
        static /*0x21091e8*/ bool UtcOffsetOutOfRange(System.TimeSpan offset);
        static /*0x2109310*/ System.TimeSpan GetUtcOffset(System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule adjustmentRule);
        static /*0x210100c*/ bool IsValidAdjustmentRuleOffest(System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule adjustmentRule);
        static /*0x2101080*/ void NormalizeAdjustmentRuleOffset(System.TimeSpan baseUtcOffset, ref System.TimeZoneInfo.AdjustmentRule adjustmentRule);
        static /*0x21093d8*/ string GetTimeZoneDirectoryUnity();
        static /*0x2109420*/ System.Collections.Generic.List<System.TimeZoneInfo.AdjustmentRule> CreateAdjustmentRule(int year, ref long[] data, ref string[] names, string standardNameCurrentYear, string daylightNameCurrentYear);
        static /*0x20ff9fc*/ System.TimeZoneInfo CreateLocalUnity();
        /*0x20fc568*/ TimeZoneInfo(byte[] data, string id, bool dstDisabled);
        /*0x2107164*/ TimeZoneInfo(string id, System.TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, System.TimeZoneInfo.AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
        /*0x2107850*/ TimeZoneInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2109d3c*/ TimeZoneInfo();
        /*0x20fd398*/ System.TimeZoneInfo.AdjustmentRule[] GetAdjustmentRules();
        /*0x2102e3c*/ string get_Id();
        /*0x2102e44*/ string get_DisplayName();
        /*0x2102e98*/ string get_StandardName();
        /*0x2102eec*/ string get_DaylightName();
        /*0x2102f40*/ System.TimeSpan get_BaseUtcOffset();
        /*0x2102f48*/ bool get_SupportsDaylightSavingTime();
        /*0x2102f50*/ System.TimeSpan[] GetAmbiguousTimeOffsets(System.DateTimeOffset dateTimeOffset);
        /*0x2103a84*/ System.TimeSpan[] GetAmbiguousTimeOffsets(System.DateTime dateTime);
        /*0x21033e0*/ System.TimeZoneInfo.AdjustmentRule GetAdjustmentRuleForAmbiguousOffsets(System.DateTime adjustedTime, ref System.Nullable<int> ruleIndex);
        /*0x21041d8*/ System.TimeZoneInfo.AdjustmentRule GetPreviousAdjustmentRule(System.TimeZoneInfo.AdjustmentRule rule, System.Nullable<int> ruleIndex);
        /*0x21042fc*/ System.TimeSpan GetUtcOffset(System.DateTimeOffset dateTimeOffset);
        /*0x21043e8*/ System.TimeSpan GetUtcOffset(System.DateTime dateTime);
        /*0x210464c*/ System.TimeSpan GetUtcOffset(System.DateTime dateTime, System.TimeZoneInfoOptions flags);
        /*0x210445c*/ System.TimeSpan GetUtcOffset(System.DateTime dateTime, System.TimeZoneInfoOptions flags, System.TimeZoneInfo.CachedData cachedData);
        /*0x210496c*/ bool IsAmbiguousTime(System.DateTimeOffset dateTimeOffset);
        /*0x2104a1c*/ bool IsAmbiguousTime(System.DateTime dateTime);
        /*0x2104a24*/ bool IsAmbiguousTime(System.DateTime dateTime, System.TimeZoneInfoOptions flags);
        /*0x2104bf4*/ bool IsDaylightSavingTime(System.DateTimeOffset dateTimeOffset);
        /*0x2104cfc*/ bool IsDaylightSavingTime(System.DateTime dateTime);
        /*0x2104f5c*/ bool IsDaylightSavingTime(System.DateTime dateTime, System.TimeZoneInfoOptions flags);
        /*0x2104d70*/ bool IsDaylightSavingTime(System.DateTime dateTime, System.TimeZoneInfoOptions flags, System.TimeZoneInfo.CachedData cachedData);
        /*0x2105350*/ bool IsInvalidTime(System.DateTime dateTime);
        /*0x21061e4*/ bool Equals(System.TimeZoneInfo other);
        /*0x21063a8*/ bool Equals(object obj);
        /*0x21066b0*/ int GetHashCode();
        /*0x2106234*/ bool HasSameRules(System.TimeZoneInfo other);
        /*0x2106c00*/ string ToSerializedString();
        /*0x21070b8*/ string ToString();
        /*0x2107490*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
        /*0x2107674*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x21041cc*/ System.TimeZoneInfo.AdjustmentRule GetAdjustmentRuleForTime(System.DateTime dateTime, ref System.Nullable<int> ruleIndex);
        /*0x2107c64*/ System.TimeZoneInfo.AdjustmentRule GetAdjustmentRuleForTime(System.DateTime dateTime, bool dateTimeisUtc, ref System.Nullable<int> ruleIndex);
        /*0x2107e14*/ int CompareAdjustmentRuleToDateTime(System.TimeZoneInfo.AdjustmentRule rule, System.TimeZoneInfo.AdjustmentRule previousRule, System.DateTime dateTime, System.DateTime dateOnly, bool dateTimeisUtc);
        /*0x2107fa4*/ System.DateTime ConvertToUtc(System.DateTime dateTime, System.TimeSpan daylightDelta, System.TimeSpan baseUtcOffsetDelta);
        /*0x2108130*/ System.DateTime ConvertFromUtc(System.DateTime dateTime, System.TimeSpan daylightDelta, System.TimeSpan baseUtcOffsetDelta);
        /*0x2107fac*/ System.DateTime ConvertToFromUtc(System.DateTime dateTime, System.TimeSpan daylightDelta, System.TimeSpan baseUtcOffsetDelta, bool convertToUtc);
        /*0x210359c*/ System.Globalization.DaylightTimeStruct GetDaylightTime(int year, System.TimeZoneInfo.AdjustmentRule rule, System.Nullable<int> ruleIndex);
        /*0x2108704*/ System.TimeSpan GetDaylightSavingsStartOffsetFromUtc(System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule rule, System.Nullable<int> ruleIndex);
        /*0x21087cc*/ System.TimeSpan GetDaylightSavingsEndOffsetFromUtc(System.TimeSpan baseUtcOffset, System.TimeZoneInfo.AdjustmentRule rule);

        struct TZifType
        {
            /*0x10*/ System.TimeSpan UtcOffset;
            /*0x18*/ bool IsDst;
            /*0x19*/ byte AbbreviationIndex;

            /*0x2102cfc*/ TZifType(byte[] data, int index);
        }

        struct TZifHead
        {
            /*0x10*/ uint Magic;
            /*0x14*/ System.TimeZoneInfo.TZVersion Version;
            /*0x18*/ uint IsGmtCount;
            /*0x1c*/ uint IsStdCount;
            /*0x20*/ uint LeapCount;
            /*0x24*/ uint TimeCount;
            /*0x28*/ uint TypeCount;
            /*0x2c*/ uint CharCount;

            /*0x2102b48*/ TZifHead(byte[] data, int index);
        }

        enum TZVersion
        {
            V1 = 0,
            V2 = 1,
            V3 = 2,
        }

        class AdjustmentRule : System.IEquatable<System.TimeZoneInfo.AdjustmentRule>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
        {
            /*0x10*/ System.DateTime _dateStart;
            /*0x18*/ System.DateTime _dateEnd;
            /*0x20*/ System.TimeSpan _daylightDelta;
            /*0x28*/ System.TimeZoneInfo.TransitionTime _daylightTransitionStart;
            /*0x40*/ System.TimeZoneInfo.TransitionTime _daylightTransitionEnd;
            /*0x58*/ System.TimeSpan _baseUtcOffsetDelta;
            /*0x60*/ bool _noDaylightTransitions;

            static /*0x20fd7c8*/ System.TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd);
            static /*0x2100f1c*/ System.TimeZoneInfo.AdjustmentRule CreateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd, System.TimeSpan baseUtcOffsetDelta, bool noDaylightTransitions);
            static /*0x2109fa4*/ void ValidateAdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd, bool noDaylightTransitions);
            /*0x2109edc*/ AdjustmentRule(System.DateTime dateStart, System.DateTime dateEnd, System.TimeSpan daylightDelta, System.TimeZoneInfo.TransitionTime daylightTransitionStart, System.TimeZoneInfo.TransitionTime daylightTransitionEnd, System.TimeSpan baseUtcOffsetDelta, bool noDaylightTransitions);
            /*0x210a788*/ AdjustmentRule(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x210aba0*/ AdjustmentRule();
            /*0x2109d74*/ System.DateTime get_DateStart();
            /*0x2109d7c*/ System.DateTime get_DateEnd();
            /*0x2109d84*/ System.TimeSpan get_DaylightDelta();
            /*0x2109d8c*/ System.TimeZoneInfo.TransitionTime get_DaylightTransitionStart();
            /*0x2109da0*/ System.TimeZoneInfo.TransitionTime get_DaylightTransitionEnd();
            /*0x2109db4*/ System.TimeSpan get_BaseUtcOffsetDelta();
            /*0x2109dbc*/ bool get_NoDaylightTransitions();
            /*0x2103440*/ bool get_HasDaylightSaving();
            /*0x2106a9c*/ bool Equals(System.TimeZoneInfo.AdjustmentRule other);
            /*0x2109ed0*/ int GetHashCode();
            /*0x21083c4*/ bool IsStartDateMarkerForBeginningOfYear();
            /*0x2108474*/ bool IsEndDateMarkerForEndOfYear();
            /*0x210a42c*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x210a544*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        struct StringSerializer
        {
            /*0x10*/ string _serializedText;
            /*0x18*/ int _currentTokenStartIndex;
            /*0x1c*/ System.TimeZoneInfo.StringSerializer.State _state;

            static /*0x2106c04*/ string GetSerializedString(System.TimeZoneInfo zone);
            static /*0x21064e4*/ System.TimeZoneInfo GetDeserializedTimeZoneInfo(string source);
            static /*0x210abd8*/ void SerializeSubstitute(string text, System.Text.StringBuilder serializedText);
            static /*0x210ac94*/ void SerializeTransitionTime(System.TimeZoneInfo.TransitionTime time, System.Text.StringBuilder serializedText);
            static /*0x210b394*/ void VerifyIsEscapableCharacter(char c);
            /*0x210aec4*/ StringSerializer(string str);
            /*0x210b430*/ void SkipVersionNextDataFields(int depth);
            /*0x210aed8*/ string GetNextStringValue();
            /*0x210b568*/ System.DateTime GetNextDateTimeValue(string format);
            /*0x210b0e0*/ System.TimeSpan GetNextTimeSpanValue();
            /*0x210b67c*/ int GetNextInt32Value();
            /*0x210b1d8*/ System.TimeZoneInfo.AdjustmentRule[] GetNextAdjustmentRuleArrayValue();
            /*0x210b75c*/ System.TimeZoneInfo.AdjustmentRule GetNextAdjustmentRuleValue();
            /*0x210bb70*/ System.TimeZoneInfo.TransitionTime GetNextTransitionTimeValue();

            enum State
            {
                Escaped = 0,
                NotEscaped = 1,
                StartOfToken = 2,
                EndOfLine = 3,
            }
        }

        struct TransitionTime : System.IEquatable<System.TimeZoneInfo.TransitionTime>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
        {
            /*0x10*/ System.DateTime _timeOfDay;
            /*0x18*/ byte _month;
            /*0x19*/ byte _week;
            /*0x1a*/ byte _day;
            /*0x1c*/ System.DayOfWeek _dayOfWeek;
            /*0x20*/ bool _isFixedDateRule;

            static /*0x2109dc4*/ bool op_Inequality(System.TimeZoneInfo.TransitionTime t1, System.TimeZoneInfo.TransitionTime t2);
            static /*0x20fd768*/ System.TimeZoneInfo.TransitionTime CreateFixedDateRule(System.DateTime timeOfDay, int month, int day);
            static /*0x210206c*/ System.TimeZoneInfo.TransitionTime CreateFloatingDateRule(System.DateTime timeOfDay, int month, int week, System.DayOfWeek dayOfWeek);
            static /*0x210c110*/ void ValidateTransitionTime(System.DateTime timeOfDay, int month, int week, int day, System.DayOfWeek dayOfWeek);
            /*0x210c0a0*/ TransitionTime(System.DateTime timeOfDay, int month, int week, int day, System.DayOfWeek dayOfWeek, bool isFixedDateRule);
            /*0x210c5f8*/ TransitionTime(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x210bfcc*/ System.DateTime get_TimeOfDay();
            /*0x210bfd4*/ int get_Month();
            /*0x210bfdc*/ int get_Week();
            /*0x210bfe4*/ int get_Day();
            /*0x210bfec*/ System.DayOfWeek get_DayOfWeek();
            /*0x210bff4*/ bool get_IsFixedDateRule();
            /*0x210bffc*/ bool Equals(object obj);
            /*0x2109df8*/ bool Equals(System.TimeZoneInfo.TransitionTime other);
            /*0x210c08c*/ int GetHashCode();
            /*0x210c35c*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x210c44c*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum TimeZoneInfoResult
        {
            Success = 0,
            TimeZoneNotFoundException = 1,
            InvalidTimeZoneException = 2,
            SecurityException = 3,
        }

        class CachedData
        {
            /*0x10*/ System.TimeZoneInfo _localTimeZone;
            /*0x18*/ System.Collections.Generic.Dictionary<string, System.TimeZoneInfo> _systemTimeZones;
            /*0x20*/ System.Collections.ObjectModel.ReadOnlyCollection<System.TimeZoneInfo> _readOnlySystemTimeZones;
            /*0x28*/ bool _allSystemTimeZonesRead;

            /*0x21058d4*/ CachedData();
            /*0x210c974*/ System.TimeZoneInfo CreateLocal();
            /*0x2103dac*/ System.TimeZoneInfo get_Local();
            /*0x21046c4*/ System.DateTimeKind GetCorrespondingKind(System.TimeZoneInfo timeZone);
        }

        class <>c__DisplayClass16_0
        {
            /*0x10*/ string localtimeFilePath;
            /*0x18*/ string posixrulesFilePath;
            /*0x20*/ byte[] buffer;
            /*0x28*/ byte[] rawData;
            /*0x30*/ string id;
            /*0x38*/ string timeZoneDirectory;

            /*0x20ff664*/ <>c__DisplayClass16_0();
            /*0x210cb04*/ bool <FindTimeZoneId>b__0(string filePath);
        }

        class <>c
        {
            static /*0x0*/ System.TimeZoneInfo.<> <>9;
            static /*0x8*/ System.Func<char, bool> <>9__34_1;
            static /*0x10*/ System.Func<char, bool> <>9__34_0;
            static /*0x18*/ System.Func<char, bool> <>9__35_0;
            static /*0x20*/ System.Func<char, bool> <>9__37_0;
            static /*0x28*/ System.Func<char, bool> <>9__38_0;
            static /*0x30*/ System.Comparison<System.TimeZoneInfo> <>9__113_0;
            static /*0x38*/ System.Comparison<System.TimeZoneInfo.AdjustmentRule> <>9__161_0;

            static /*0x210cbf8*/ <>c();
            /*0x210cc5c*/ <>c();
            /*0x210cc64*/ bool <TZif_ParsePosixName>b__34_1(char c);
            /*0x210cc74*/ bool <TZif_ParsePosixName>b__34_0(char c);
            /*0x210cd78*/ bool <TZif_ParsePosixOffset>b__35_0(char c);
            /*0x210ce00*/ bool <TZif_ParsePosixDate>b__37_0(char c);
            /*0x210ce1c*/ bool <TZif_ParsePosixTime>b__38_0(char c);
            /*0x210ce2c*/ int <GetSystemTimeZones>b__113_0(System.TimeZoneInfo x, System.TimeZoneInfo y);
            /*0x210ced4*/ int <CreateLocalUnity>b__161_0(System.TimeZoneInfo.AdjustmentRule rule1, System.TimeZoneInfo.AdjustmentRule rule2);
        }
    }

    class AccessViolationException : System.SystemException
    {
        /*0x90*/ nint _ip;
        /*0x98*/ nint _target;
        /*0xa0*/ int _accessType;

        /*0x210cf08*/ AccessViolationException();
        /*0x210cf64*/ AccessViolationException(string message);
        /*0x210cf88*/ AccessViolationException(string message, System.Exception innerException);
        /*0x210cfac*/ AccessViolationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class Action : System.MulticastDelegate
    {
        /*0x210cfb4*/ Action(object object, nint method);
        /*0x210d070*/ void Invoke();
        /*0x210d084*/ System.IAsyncResult BeginInvoke(System.AsyncCallback callback, object object);
        /*0x210d0a4*/ void EndInvoke(System.IAsyncResult result);
    }

    class Action<T> : System.MulticastDelegate
    {
        Action(object object, nint method);
        void Invoke(T obj);
        System.IAsyncResult BeginInvoke(T obj, System.AsyncCallback callback, object object);
        void EndInvoke(System.IAsyncResult result);
    }

    class Action<T1, T2> : System.MulticastDelegate
    {
        Action(object object, nint method);
        void Invoke(T1 arg1, T2 arg2);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, System.AsyncCallback callback, object object);
        void EndInvoke(System.IAsyncResult result);
    }

    class Action<T1, T2, T3> : System.MulticastDelegate
    {
        Action(object object, nint method);
        void Invoke(T1 arg1, T2 arg2, T3 arg3);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, System.AsyncCallback callback, object object);
        void EndInvoke(System.IAsyncResult result);
    }

    class Action<T1, T2, T3, T4> : System.MulticastDelegate
    {
        Action(object object, nint method);
        void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, System.AsyncCallback callback, object object);
        void EndInvoke(System.IAsyncResult result);
    }

    class Action<T1, T2, T3, T4, T5> : System.MulticastDelegate
    {
        Action(object object, nint method);
        void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, System.AsyncCallback callback, object object);
        void EndInvoke(System.IAsyncResult result);
    }

    class Action<T1, T2, T3, T4, T5, T6> : System.MulticastDelegate
    {
        Action(object object, nint method);
        void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, System.AsyncCallback callback, object object);
        void EndInvoke(System.IAsyncResult result);
    }

    class Action<T1, T2, T3, T4, T5, T6, T7> : System.MulticastDelegate
    {
        Action(object object, nint method);
        void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, System.AsyncCallback callback, object object);
        void EndInvoke(System.IAsyncResult result);
    }

    class Action<T1, T2, T3, T4, T5, T6, T7, T8> : System.MulticastDelegate
    {
        Action(object object, nint method);
        void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, System.AsyncCallback callback, object object);
        void EndInvoke(System.IAsyncResult result);
    }

    class Func<TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        TResult Invoke();
        System.IAsyncResult BeginInvoke(System.AsyncCallback callback, object object);
        TResult EndInvoke(System.IAsyncResult result);
    }

    class Func<T, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        TResult Invoke(T arg);
        System.IAsyncResult BeginInvoke(T arg, System.AsyncCallback callback, object object);
        TResult EndInvoke(System.IAsyncResult result);
    }

    class Func<T1, T2, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        TResult Invoke(T1 arg1, T2 arg2);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, System.AsyncCallback callback, object object);
        TResult EndInvoke(System.IAsyncResult result);
    }

    class Func<T1, T2, T3, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, System.AsyncCallback callback, object object);
        TResult EndInvoke(System.IAsyncResult result);
    }

    class Func<T1, T2, T3, T4, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, System.AsyncCallback callback, object object);
        TResult EndInvoke(System.IAsyncResult result);
    }

    class Func<T1, T2, T3, T4, T5, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, System.AsyncCallback callback, object object);
        TResult EndInvoke(System.IAsyncResult result);
    }

    class Func<T1, T2, T3, T4, T5, T6, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, System.AsyncCallback callback, object object);
        TResult EndInvoke(System.IAsyncResult result);
    }

    class Func<T1, T2, T3, T4, T5, T6, T7, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, System.AsyncCallback callback, object object);
        TResult EndInvoke(System.IAsyncResult result);
    }

    class Func<T1, T2, T3, T4, T5, T6, T7, T8, TResult> : System.MulticastDelegate
    {
        Func(object object, nint method);
        TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
        System.IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, System.AsyncCallback callback, object object);
        TResult EndInvoke(System.IAsyncResult result);
    }

    class Comparison<T> : System.MulticastDelegate
    {
        Comparison(object object, nint method);
        int Invoke(T x, T y);
        System.IAsyncResult BeginInvoke(T x, T y, System.AsyncCallback callback, object object);
        int EndInvoke(System.IAsyncResult result);
    }

    class Converter<TInput, TOutput> : System.MulticastDelegate
    {
        Converter(object object, nint method);
        TOutput Invoke(TInput input);
        System.IAsyncResult BeginInvoke(TInput input, System.AsyncCallback callback, object object);
        TOutput EndInvoke(System.IAsyncResult result);
    }

    class Predicate<T> : System.MulticastDelegate
    {
        Predicate(object object, nint method);
        bool Invoke(T obj);
        System.IAsyncResult BeginInvoke(T obj, System.AsyncCallback callback, object object);
        bool EndInvoke(System.IAsyncResult result);
    }

    class AggregateException : System.Exception
    {
        /*0x90*/ System.Collections.ObjectModel.ReadOnlyCollection<System.Exception> m_innerExceptions;

        /*0x210d0b0*/ AggregateException();
        /*0x210d1c4*/ AggregateException(string message);
        /*0x210d2d0*/ AggregateException(string message, System.Exception innerException);
        /*0x210d434*/ AggregateException(System.Collections.Generic.IEnumerable<System.Exception> innerExceptions);
        /*0x210d550*/ AggregateException(System.Exception[] innerExceptions);
        /*0x210d48c*/ AggregateException(string message, System.Collections.Generic.IEnumerable<System.Exception> innerExceptions);
        /*0x210d5a8*/ AggregateException(string message, System.Exception[] innerExceptions);
        /*0x210d5ac*/ AggregateException(string message, System.Collections.Generic.IList<System.Exception> innerExceptions);
        /*0x210d990*/ AggregateException(System.Collections.Generic.IEnumerable<System.Runtime.ExceptionServices.ExceptionDispatchInfo> innerExceptionInfos);
        /*0x210d9e8*/ AggregateException(string message, System.Collections.Generic.IEnumerable<System.Runtime.ExceptionServices.ExceptionDispatchInfo> innerExceptionInfos);
        /*0x210daac*/ AggregateException(string message, System.Collections.Generic.IList<System.Runtime.ExceptionServices.ExceptionDispatchInfo> innerExceptionInfos);
        /*0x210dee8*/ AggregateException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x210e0d0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x210e21c*/ System.Exception GetBaseException();
        /*0x210e2d4*/ System.Collections.ObjectModel.ReadOnlyCollection<System.Exception> get_InnerExceptions();
        /*0x210e2dc*/ void Handle(System.Func<System.Exception, bool> predicate);
        /*0x210e51c*/ System.AggregateException Flatten();
        /*0x210e8e0*/ string get_Message();
        /*0x210ea70*/ string ToString();
        /*0x210ec84*/ int get_InnerExceptionCount();
    }

    class ApplicationException : System.Exception
    {
        /*0x210ecd4*/ ApplicationException();
        /*0x210ed54*/ ApplicationException(string message);
        /*0x210edcc*/ ApplicationException(string message, System.Exception innerException);
        /*0x210ee4c*/ ApplicationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class ArgumentException : System.SystemException
    {
        /*0x90*/ string _paramName;

        /*0x210eecc*/ ArgumentException();
        /*0x210d96c*/ ArgumentException(string message);
        /*0x210ef28*/ ArgumentException(string message, System.Exception innerException);
        /*0x210ef4c*/ ArgumentException(string message, string paramName, System.Exception innerException);
        /*0x2103200*/ ArgumentException(string message, string paramName);
        /*0x210ef84*/ ArgumentException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x210f00c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x210f0e8*/ string get_Message();
        /*0x210f188*/ string get_ParamName();
    }

    class ArgumentNullException : System.ArgumentException
    {
        /*0x210f190*/ ArgumentNullException();
        /*0x2100324*/ ArgumentNullException(string paramName);
        /*0x210f1ec*/ ArgumentNullException(string message, System.Exception innerException);
        /*0x210f210*/ ArgumentNullException(string paramName, string message);
        /*0x210f248*/ ArgumentNullException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class ArgumentOutOfRangeException : System.ArgumentException
    {
        /*0x98*/ object _actualValue;

        /*0x210f24c*/ ArgumentOutOfRangeException();
        /*0x210f2a8*/ ArgumentOutOfRangeException(string paramName);
        /*0x21092d8*/ ArgumentOutOfRangeException(string paramName, string message);
        /*0x210f314*/ ArgumentOutOfRangeException(string message, System.Exception innerException);
        /*0x210a3f0*/ ArgumentOutOfRangeException(string paramName, object actualValue, string message);
        /*0x210f338*/ ArgumentOutOfRangeException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x210f410*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x210f4e8*/ string get_Message();
        /*0x210f594*/ object get_ActualValue();
    }

    class ArithmeticException : System.SystemException
    {
        /*0x210f59c*/ ArithmeticException();
        /*0x210f5f8*/ ArithmeticException(string message);
        /*0x210f61c*/ ArithmeticException(string message, System.Exception innerException);
        /*0x210f640*/ ArithmeticException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct ArraySegment<T> : System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IReadOnlyList<T>, System.Collections.Generic.IReadOnlyCollection<T>
    {
        static /*0x0*/ System.ArraySegment<T> <Empty>k__BackingField;
        /*0x0*/ T[] _array;
        /*0x0*/ int _offset;
        /*0x0*/ int _count;

        static ArraySegment();
        static System.ArraySegment<T> get_Empty();
        static bool op_Equality(System.ArraySegment<T> a, System.ArraySegment<T> b);
        static bool op_Inequality(System.ArraySegment<T> a, System.ArraySegment<T> b);
        static System.ArraySegment<T> op_Implicit(T[] array);
        ArraySegment(T[] array);
        ArraySegment(T[] array, int offset, int count);
        T[] get_Array();
        int get_Offset();
        int get_Count();
        T get_Item(int index);
        void set_Item(int index, T value);
        System.ArraySegment.Enumerator<T> GetEnumerator();
        int GetHashCode();
        void CopyTo(T[] destination);
        void CopyTo(T[] destination, int destinationIndex);
        void CopyTo(System.ArraySegment<T> destination);
        bool Equals(object obj);
        bool Equals(System.ArraySegment<T> obj);
        System.ArraySegment<T> Slice(int index);
        System.ArraySegment<T> Slice(int index, int count);
        T[] ToArray();
        T System.Collections.Generic.IList<T>.get_Item(int index);
        void System.Collections.Generic.IList<T>.set_Item(int index, T value);
        int System.Collections.Generic.IList<T>.IndexOf(T item);
        void System.Collections.Generic.IList<T>.Insert(int index, T item);
        void System.Collections.Generic.IList<T>.RemoveAt(int index);
        T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
        bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
        void System.Collections.Generic.ICollection<T>.Add(T item);
        void System.Collections.Generic.ICollection<T>.Clear();
        bool System.Collections.Generic.ICollection<T>.Contains(T item);
        bool System.Collections.Generic.ICollection<T>.Remove(T item);
        System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
        void ThrowInvalidOperationIfDefault();

        struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
        {
            /*0x0*/ T[] _array;
            /*0x0*/ int _start;
            /*0x0*/ int _end;
            /*0x0*/ int _current;

            Enumerator(System.ArraySegment<T> arraySegment);
            bool MoveNext();
            T get_Current();
            object System.Collections.IEnumerator.get_Current();
            void System.Collections.IEnumerator.Reset();
            void Dispose();
        }
    }

    class ArrayTypeMismatchException : System.SystemException
    {
        /*0x210f648*/ ArrayTypeMismatchException();
        /*0x210f6a4*/ ArrayTypeMismatchException(string message);
        /*0x210f6c8*/ ArrayTypeMismatchException(string message, System.Exception innerException);
        /*0x210f6ec*/ ArrayTypeMismatchException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class AssemblyLoadEventArgs : System.EventArgs
    {
        /*0x10*/ System.Reflection.Assembly <LoadedAssembly>k__BackingField;

        /*0x210f6f4*/ AssemblyLoadEventArgs(System.Reflection.Assembly loadedAssembly);
        /*0x210f760*/ System.Reflection.Assembly get_LoadedAssembly();
    }

    class AssemblyLoadEventHandler : System.MulticastDelegate
    {
        /*0x210f768*/ AssemblyLoadEventHandler(object object, nint method);
        /*0x210f898*/ void Invoke(object sender, System.AssemblyLoadEventArgs args);
        /*0x210f8ac*/ System.IAsyncResult BeginInvoke(object sender, System.AssemblyLoadEventArgs args, System.AsyncCallback callback, object object);
        /*0x210f8d4*/ void EndInvoke(System.IAsyncResult result);
    }

    class AsyncCallback : System.MulticastDelegate
    {
        /*0x210f8e0*/ AsyncCallback(object object, nint method);
        /*0x210fa0c*/ void Invoke(System.IAsyncResult ar);
        /*0x210fa20*/ System.IAsyncResult BeginInvoke(System.IAsyncResult ar, System.AsyncCallback callback, object object);
        /*0x210fa40*/ void EndInvoke(System.IAsyncResult result);
    }

    enum AttributeTargets
    {
        Assembly = 1,
        Module = 2,
        Class = 4,
        Struct = 8,
        Enum = 16,
        Constructor = 32,
        Method = 64,
        Property = 128,
        Field = 256,
        Event = 512,
        Interface = 1024,
        Parameter = 2048,
        Delegate = 4096,
        ReturnValue = 8192,
        GenericParameter = 16384,
        All = 32767,
    }

    class AttributeUsageAttribute : System.Attribute
    {
        static /*0x0*/ System.AttributeUsageAttribute Default;
        /*0x10*/ System.AttributeTargets _attributeTarget;
        /*0x14*/ bool _allowMultiple;
        /*0x15*/ bool _inherited;

        static /*0x210fb04*/ AttributeUsageAttribute();
        /*0x210fa4c*/ AttributeUsageAttribute(System.AttributeTargets validOn);
        /*0x210fa84*/ AttributeUsageAttribute(System.AttributeTargets validOn, bool allowMultiple, bool inherited);
        /*0x210fad4*/ System.AttributeTargets get_ValidOn();
        /*0x210fadc*/ bool get_AllowMultiple();
        /*0x210fae4*/ void set_AllowMultiple(bool value);
        /*0x210faf0*/ bool get_Inherited();
        /*0x210faf8*/ void set_Inherited(bool value);
    }

    class BadImageFormatException : System.SystemException
    {
        /*0x90*/ string _fileName;
        /*0x98*/ string _fusionLog;

        /*0x210fb7c*/ BadImageFormatException();
        /*0x210fbd8*/ BadImageFormatException(string message);
        /*0x210fbfc*/ BadImageFormatException(string message, System.Exception inner);
        /*0x210fc20*/ BadImageFormatException(string message, string fileName);
        /*0x210fc54*/ BadImageFormatException(string message, string fileName, System.Exception inner);
        /*0x210fc8c*/ BadImageFormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x210fd3c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x210fe54*/ string get_Message();
        /*0x210fe6c*/ void SetMessageField();
        /*0x210fee8*/ string get_FileName();
        /*0x210fef0*/ string ToString();
        /*0x21100e0*/ string get_FusionLog();
    }

    class BitConverter
    {
        static /*0x0*/ bool IsLittleEndian;

        static /*0x2111734*/ BitConverter();
        static /*0x21100e8*/ byte[] GetBytes(bool value);
        static /*0x2110150*/ bool TryWriteBytes(System.Span<byte> destination, bool value);
        static /*0x21101d8*/ byte[] GetBytes(char value);
        static /*0x211023c*/ bool TryWriteBytes(System.Span<byte> destination, char value);
        static /*0x21102c0*/ byte[] GetBytes(short value);
        static /*0x2110324*/ bool TryWriteBytes(System.Span<byte> destination, short value);
        static /*0x21103a8*/ byte[] GetBytes(int value);
        static /*0x211040c*/ bool TryWriteBytes(System.Span<byte> destination, int value);
        static /*0x2110490*/ byte[] GetBytes(long value);
        static /*0x21104f4*/ bool TryWriteBytes(System.Span<byte> destination, long value);
        static /*0x2110578*/ byte[] GetBytes(ushort value);
        static /*0x21105dc*/ bool TryWriteBytes(System.Span<byte> destination, ushort value);
        static /*0x2110660*/ byte[] GetBytes(uint value);
        static /*0x21106c4*/ bool TryWriteBytes(System.Span<byte> destination, uint value);
        static /*0x2110748*/ byte[] GetBytes(ulong value);
        static /*0x21107ac*/ bool TryWriteBytes(System.Span<byte> destination, ulong value);
        static /*0x2110830*/ byte[] GetBytes(float value);
        static /*0x211089c*/ bool TryWriteBytes(System.Span<byte> destination, float value);
        static /*0x2110920*/ byte[] GetBytes(double value);
        static /*0x211098c*/ bool TryWriteBytes(System.Span<byte> destination, double value);
        static /*0x2110a10*/ char ToChar(byte[] value, int startIndex);
        static /*0x2110af8*/ char ToChar(System.ReadOnlySpan<byte> value);
        static /*0x2110a74*/ short ToInt16(byte[] value, int startIndex);
        static /*0x2110b70*/ short ToInt16(System.ReadOnlySpan<byte> value);
        static /*0x2110be8*/ int ToInt32(byte[] value, int startIndex);
        static /*0x2110c6c*/ int ToInt32(System.ReadOnlySpan<byte> value);
        static /*0x2110ce4*/ long ToInt64(byte[] value, int startIndex);
        static /*0x2110d68*/ long ToInt64(System.ReadOnlySpan<byte> value);
        static /*0x2110de0*/ ushort ToUInt16(byte[] value, int startIndex);
        static /*0x2110e44*/ ushort ToUInt16(System.ReadOnlySpan<byte> value);
        static /*0x2110ebc*/ uint ToUInt32(byte[] value, int startIndex);
        static /*0x2110f20*/ uint ToUInt32(System.ReadOnlySpan<byte> value);
        static /*0x2110f98*/ ulong ToUInt64(byte[] value, int startIndex);
        static /*0x2110ffc*/ ulong ToUInt64(System.ReadOnlySpan<byte> value);
        static /*0x2111074*/ float ToSingle(byte[] value, int startIndex);
        static /*0x21110e0*/ float ToSingle(System.ReadOnlySpan<byte> value);
        static /*0x2111158*/ double ToDouble(byte[] value, int startIndex);
        static /*0x21111c4*/ double ToDouble(System.ReadOnlySpan<byte> value);
        static /*0x211123c*/ string ToString(byte[] value, int startIndex, int length);
        static /*0x211151c*/ string ToString(byte[] value);
        static /*0x211158c*/ string ToString(byte[] value, int startIndex);
        static /*0x2111604*/ bool ToBoolean(byte[] value, int startIndex);
        static /*0x2111694*/ bool ToBoolean(System.ReadOnlySpan<byte> value);
        static /*0x2111714*/ long DoubleToInt64Bits(double value);
        static /*0x211171c*/ double Int64BitsToDouble(long value);
        static /*0x2111724*/ int SingleToInt32Bits(float value);
        static /*0x211172c*/ float Int32BitsToSingle(int value);

        class <>c
        {
            static /*0x0*/ System.BitConverter.<> <>9;
            static /*0x8*/ System.Buffers.SpanAction<char, System.ValueTuple<System.Byte[], int, int>> <>9__38_0;

            static /*0x2111780*/ <>c();
            /*0x21117e4*/ <>c();
            /*0x21117ec*/ void <ToString>b__38_0(System.Span<char> dst, System.ValueTuple<System.Byte[], int, int> state);
        }
    }

    struct Boolean : System.IComparable, System.IConvertible, System.IComparable<bool>, System.IEquatable<bool>
    {
        static int True = 1;
        static int False = 0;
        static string TrueLiteral = "True";
        static string FalseLiteral = "False";
        static /*0x0*/ string TrueString;
        static /*0x8*/ string FalseString;
        /*0x10*/ bool m_value;

        static /*0x2112a08*/ Boolean();
        static /*0x2111ca8*/ bool Parse(string value);
        static /*0x2111d84*/ bool Parse(System.ReadOnlySpan<char> value);
        static /*0x211213c*/ bool TryParse(string value, ref bool result);
        static /*0x2111e48*/ bool TryParse(System.ReadOnlySpan<char> value, ref bool result);
        static /*0x21121f8*/ System.ReadOnlySpan<char> TrimWhiteSpaceAndNull(System.ReadOnlySpan<char> value);
        /*0x2111980*/ int GetHashCode();
        /*0x2111990*/ string ToString();
        /*0x21119fc*/ string ToString(System.IFormatProvider provider);
        /*0x2111a00*/ bool TryFormat(System.Span<char> destination, ref int charsWritten);
        /*0x2111b1c*/ bool Equals(object obj);
        /*0x2111b94*/ bool Equals(bool obj);
        /*0x2111ba8*/ int CompareTo(object obj);
        /*0x2111c80*/ int CompareTo(bool value);
        /*0x2112404*/ System.TypeCode GetTypeCode();
        /*0x211240c*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x211241c*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x21124a8*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x2112508*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x2112568*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x21125c8*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x2112628*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x2112688*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x21126e8*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x2112748*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x21127a8*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x2112808*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x2112868*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x21128c8*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x2112954*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct Byte : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<byte>, System.IEquatable<byte>, System.ISpanFormattable
    {
        static byte MaxValue = 255;
        static byte MinValue = 0;
        /*0x10*/ byte m_value;

        static /*0x2112bec*/ byte Parse(string s);
        static /*0x2112e0c*/ byte Parse(string s, System.Globalization.NumberStyles style);
        static /*0x2112ea0*/ byte Parse(string s, System.IFormatProvider provider);
        static /*0x2112f2c*/ byte Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x2112fd0*/ byte Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x2112c70*/ byte Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info);
        static /*0x2113024*/ bool TryParse(string s, ref byte result);
        static /*0x2113160*/ bool TryParse(System.ReadOnlySpan<char> s, ref byte result);
        static /*0x211319c*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref byte result);
        static /*0x2113244*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref byte result);
        static /*0x21130a4*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref byte result);
        /*0x2112a94*/ int CompareTo(object value);
        /*0x2112b50*/ int CompareTo(byte value);
        /*0x2112b5c*/ bool Equals(object obj);
        /*0x2112bd4*/ bool Equals(byte obj);
        /*0x2112be4*/ int GetHashCode();
        /*0x21132a0*/ string ToString();
        /*0x2113338*/ string ToString(string format);
        /*0x21133ec*/ string ToString(System.IFormatProvider provider);
        /*0x2113488*/ string ToString(string format, System.IFormatProvider provider);
        /*0x2113540*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x21135e4*/ System.TypeCode GetTypeCode();
        /*0x21135ec*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x2113648*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x21136a4*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x2113700*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x2113708*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x2113764*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x21137c0*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x211381c*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x2113878*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x21138d4*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x2113930*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x211398c*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x21139e8*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x2113a44*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x2113ad0*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class CLSCompliantAttribute : System.Attribute
    {
        /*0x10*/ bool _compliant;

        /*0x2113b7c*/ CLSCompliantAttribute(bool isCompliant);
        /*0x2113ba4*/ bool get_IsCompliant();
    }

    struct Char : System.IComparable, System.IComparable<char>, System.IEquatable<char>, System.IConvertible
    {
        static char MaxValue = 65535;
        static char MinValue = 0;
        static int UNICODE_PLANE00_END = 65535;
        static int UNICODE_PLANE01_START = 65536;
        static int UNICODE_PLANE16_END = 1114111;
        static int HIGH_SURROGATE_START = 55296;
        static int LOW_SURROGATE_END = 57343;
        static /*0x0*/ byte[] s_categoryForLatin1;
        /*0x10*/ char m_value;

        static /*0x2116a94*/ Char();
        static /*0x2113bac*/ bool IsLatin1(char ch);
        static /*0x2113bbc*/ bool IsAscii(char ch);
        static /*0x2113bcc*/ System.Globalization.UnicodeCategory GetLatin1UnicodeCategory(char ch);
        static /*0x2113da4*/ string ToString(char c);
        static /*0x2113e08*/ char Parse(string s);
        static /*0x2113eac*/ bool TryParse(string s, ref char result);
        static /*0x210ccf4*/ bool IsDigit(char c);
        static /*0x2113eec*/ bool CheckLetter(System.Globalization.UnicodeCategory uc);
        static /*0x2113ef8*/ bool IsLetter(char c);
        static /*0x2113fd0*/ bool IsWhiteSpaceLatin1(char c);
        static /*0x211234c*/ bool IsWhiteSpace(char c);
        static /*0x211400c*/ bool IsUpper(char c);
        static /*0x21140c8*/ bool IsLower(char c);
        static /*0x2114184*/ bool CheckPunctuation(System.Globalization.UnicodeCategory uc);
        static /*0x2114194*/ bool IsPunctuation(char c);
        static /*0x2114240*/ bool CheckLetterOrDigit(System.Globalization.UnicodeCategory uc);
        static /*0x211425c*/ bool IsLetterOrDigit(char c);
        static /*0x2114318*/ char ToUpper(char c, System.Globalization.CultureInfo culture);
        static /*0x21143a4*/ char ToUpper(char c);
        static /*0x2114428*/ char ToUpperInvariant(char c);
        static /*0x21144ac*/ char ToLower(char c, System.Globalization.CultureInfo culture);
        static /*0x2114538*/ char ToLower(char c);
        static /*0x21145bc*/ char ToLowerInvariant(char c);
        static /*0x2114c98*/ bool IsControl(char c);
        static /*0x2114d24*/ bool IsControl(string s, int index);
        static /*0x2114e64*/ bool IsDigit(string s, int index);
        static /*0x2114f94*/ bool IsLetter(string s, int index);
        static /*0x2115120*/ bool IsLetterOrDigit(string s, int index);
        static /*0x2115290*/ bool IsLower(string s, int index);
        static /*0x2115400*/ bool CheckNumber(System.Globalization.UnicodeCategory uc);
        static /*0x2115410*/ bool IsNumber(char c);
        static /*0x21154e8*/ bool IsNumber(string s, int index);
        static /*0x2115674*/ bool IsPunctuation(string s, int index);
        static /*0x21157d4*/ bool CheckSeparator(System.Globalization.UnicodeCategory uc);
        static /*0x21157e4*/ bool IsSeparatorLatin1(char c);
        static /*0x21157f8*/ bool IsSeparator(char c);
        static /*0x21158a8*/ bool IsSeparator(string s, int index);
        static /*0x2115a0c*/ bool IsSurrogate(char c);
        static /*0x2115a1c*/ bool IsSurrogate(string s, int index);
        static /*0x2115b20*/ bool CheckSymbol(System.Globalization.UnicodeCategory uc);
        static /*0x2115b30*/ bool IsSymbol(char c);
        static /*0x2115bdc*/ bool IsSymbol(string s, int index);
        static /*0x2115d3c*/ bool IsUpper(string s, int index);
        static /*0x2115eac*/ bool IsWhiteSpace(string s, int index);
        static /*0x211602c*/ System.Globalization.UnicodeCategory GetUnicodeCategory(char c);
        static /*0x21160ac*/ System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int index);
        static /*0x21161f8*/ double GetNumericValue(char c);
        static /*0x2116200*/ double GetNumericValue(string s, int index);
        static /*0x211629c*/ bool IsHighSurrogate(char c);
        static /*0x21162ac*/ bool IsHighSurrogate(string s, int index);
        static /*0x21163b4*/ bool IsLowSurrogate(char c);
        static /*0x21163c4*/ bool IsLowSurrogate(string s, int index);
        static /*0x21164cc*/ bool IsSurrogatePair(string s, int index);
        static /*0x2116610*/ bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
        static /*0x2116634*/ string ConvertFromUtf32(int utf32);
        static /*0x2116764*/ int ConvertToUtf32(char highSurrogate, char lowSurrogate);
        static /*0x2116890*/ int ConvertToUtf32(string s, int index);
        /*0x2113c48*/ int GetHashCode();
        /*0x2113c54*/ bool Equals(object obj);
        /*0x2113ccc*/ bool Equals(char obj);
        /*0x2113cdc*/ int CompareTo(object value);
        /*0x2113d98*/ int CompareTo(char value);
        /*0x20ffe9c*/ string ToString();
        /*0x2113dac*/ string ToString(System.IFormatProvider provider);
        /*0x2114640*/ System.TypeCode GetTypeCode();
        /*0x2114648*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x21146d4*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x21146dc*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x2114738*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x2114794*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x21147f0*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x211484c*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x21148a8*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x2114904*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x2114960*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x21149bc*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x2114a48*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x2114ad4*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x2114b60*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x2114bec*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class CharEnumerator : System.Collections.IEnumerator, System.Collections.Generic.IEnumerator<char>, System.IDisposable, System.ICloneable
    {
        /*0x10*/ string _str;
        /*0x18*/ int _index;
        /*0x1c*/ char _currentElement;

        /*0x21f1524*/ CharEnumerator(string str);
        /*0x21f16e0*/ CharEnumerator();
        /*0x21f1554*/ object Clone();
        /*0x21f155c*/ bool MoveNext();
        /*0x21f15b0*/ void Dispose();
        /*0x21f15c8*/ object System.Collections.IEnumerator.get_Current();
        /*0x21f162c*/ char get_Current();
        /*0x21f16d0*/ void Reset();
    }

    class Convert
    {
        static byte EncodingPad = 61;
        static int base64LineBreakPosition = 76;
        static /*0x0*/ sbyte[] s_decodingMap;
        static /*0x8*/ System.Type[] ConvertTypes;
        static /*0x10*/ System.Type EnumType;
        static /*0x18*/ char[] base64Table;
        static /*0x20*/ object DBNull;

        static /*0x21fd588*/ Convert();
        static /*0x21f1718*/ bool TryDecodeFromUtf16(System.ReadOnlySpan<char> utf16, System.Span<byte> bytes, ref int consumed, ref int written);
        static /*0x21f1a8c*/ int Decode(ref char encodedChars, ref sbyte decodingMap);
        static /*0x21f1adc*/ void WriteThreeLowOrderBytes(ref byte destination, int value);
        static /*0x21f1af4*/ System.TypeCode GetTypeCode(object value);
        static /*0x21f1bb8*/ bool IsDBNull(object value);
        static /*0x21f1cac*/ object ChangeType(object value, System.TypeCode typeCode);
        static /*0x21f1d48*/ object ChangeType(object value, System.TypeCode typeCode, System.IFormatProvider provider);
        static /*0x21f2594*/ object DefaultToType(System.IConvertible value, System.Type targetType, System.IFormatProvider provider);
        static /*0x21f32ac*/ object ChangeType(object value, System.Type conversionType);
        static /*0x21f3348*/ object ChangeType(object value, System.Type conversionType, System.IFormatProvider provider);
        static /*0x21f3f48*/ void ThrowCharOverflowException();
        static /*0x21f3f98*/ void ThrowByteOverflowException();
        static /*0x21f3fe8*/ void ThrowSByteOverflowException();
        static /*0x21f4038*/ void ThrowInt16OverflowException();
        static /*0x21f4088*/ void ThrowUInt16OverflowException();
        static /*0x21f40d8*/ void ThrowInt32OverflowException();
        static /*0x21f4128*/ void ThrowUInt32OverflowException();
        static /*0x21f4178*/ void ThrowInt64OverflowException();
        static /*0x21f41c8*/ void ThrowUInt64OverflowException();
        static /*0x21f4218*/ bool ToBoolean(object value);
        static /*0x21f430c*/ bool ToBoolean(object value, System.IFormatProvider provider);
        static /*0x21f4410*/ bool ToBoolean(bool value);
        static /*0x21f4418*/ bool ToBoolean(sbyte value);
        static /*0x21f4424*/ bool ToBoolean(char value);
        static /*0x21f44b4*/ bool ToBoolean(byte value);
        static /*0x21f44c0*/ bool ToBoolean(short value);
        static /*0x21f44cc*/ bool ToBoolean(ushort value);
        static /*0x21f44d8*/ bool ToBoolean(int value);
        static /*0x21f44e4*/ bool ToBoolean(uint value);
        static /*0x21f44f0*/ bool ToBoolean(long value);
        static /*0x21f44fc*/ bool ToBoolean(ulong value);
        static /*0x21f4508*/ bool ToBoolean(string value);
        static /*0x21f4574*/ bool ToBoolean(string value, System.IFormatProvider provider);
        static /*0x21f45e0*/ bool ToBoolean(float value);
        static /*0x21f45ec*/ bool ToBoolean(double value);
        static /*0x21f45f8*/ bool ToBoolean(decimal value);
        static /*0x21f466c*/ bool ToBoolean(System.DateTime value);
        static /*0x21f474c*/ char ToChar(object value);
        static /*0x21f4840*/ char ToChar(object value, System.IFormatProvider provider);
        static /*0x21f4944*/ char ToChar(bool value);
        static /*0x21f49d0*/ char ToChar(char value);
        static /*0x21f49d4*/ char ToChar(sbyte value);
        static /*0x21f4a28*/ char ToChar(byte value);
        static /*0x21f4a30*/ char ToChar(short value);
        static /*0x21f4a88*/ char ToChar(ushort value);
        static /*0x21f4a8c*/ char ToChar(int value);
        static /*0x21f4ae4*/ char ToChar(uint value);
        static /*0x21f4b3c*/ char ToChar(long value);
        static /*0x21f4b94*/ char ToChar(ulong value);
        static /*0x21f4bec*/ char ToChar(string value);
        static /*0x21f4c40*/ char ToChar(string value, System.IFormatProvider provider);
        static /*0x21f4d08*/ char ToChar(float value);
        static /*0x21f4d9c*/ char ToChar(double value);
        static /*0x21f4e80*/ char ToChar(decimal value);
        static /*0x21f4f38*/ char ToChar(System.DateTime value);
        static /*0x21f5018*/ sbyte ToSByte(object value);
        static /*0x21f510c*/ sbyte ToSByte(object value, System.IFormatProvider provider);
        static /*0x21f5210*/ sbyte ToSByte(bool value);
        static /*0x21f5218*/ sbyte ToSByte(sbyte value);
        static /*0x21f521c*/ sbyte ToSByte(char value);
        static /*0x21f5278*/ sbyte ToSByte(byte value);
        static /*0x21f52d0*/ sbyte ToSByte(short value);
        static /*0x21f5330*/ sbyte ToSByte(ushort value);
        static /*0x21f538c*/ sbyte ToSByte(int value);
        static /*0x21f53e4*/ sbyte ToSByte(uint value);
        static /*0x21f543c*/ sbyte ToSByte(long value);
        static /*0x21f5494*/ sbyte ToSByte(ulong value);
        static /*0x21f54ec*/ sbyte ToSByte(float value);
        static /*0x21f5548*/ sbyte ToSByte(double value);
        static /*0x21f56a4*/ sbyte ToSByte(decimal value);
        static /*0x21f5718*/ sbyte ToSByte(string value);
        static /*0x21f5790*/ sbyte ToSByte(string value, System.IFormatProvider provider);
        static /*0x21f57a0*/ sbyte ToSByte(System.DateTime value);
        static /*0x21f5880*/ byte ToByte(object value);
        static /*0x21f5974*/ byte ToByte(object value, System.IFormatProvider provider);
        static /*0x21f5a78*/ byte ToByte(bool value);
        static /*0x21f5a80*/ byte ToByte(byte value);
        static /*0x21f5a84*/ byte ToByte(char value);
        static /*0x21f5ae0*/ byte ToByte(sbyte value);
        static /*0x21f5b38*/ byte ToByte(short value);
        static /*0x21f5b94*/ byte ToByte(ushort value);
        static /*0x21f5bf0*/ byte ToByte(int value);
        static /*0x21f5c48*/ byte ToByte(uint value);
        static /*0x21f5ca0*/ byte ToByte(long value);
        static /*0x21f5cf8*/ byte ToByte(ulong value);
        static /*0x21f5d50*/ byte ToByte(float value);
        static /*0x21f5dac*/ byte ToByte(double value);
        static /*0x21f5e0c*/ byte ToByte(decimal value);
        static /*0x21f5e80*/ byte ToByte(string value);
        static /*0x21f5ef8*/ byte ToByte(string value, System.IFormatProvider provider);
        static /*0x21f5f10*/ byte ToByte(System.DateTime value);
        static /*0x21f5ff0*/ short ToInt16(object value);
        static /*0x21f60e4*/ short ToInt16(object value, System.IFormatProvider provider);
        static /*0x21f61e8*/ short ToInt16(bool value);
        static /*0x21f61f0*/ short ToInt16(char value);
        static /*0x21f6248*/ short ToInt16(sbyte value);
        static /*0x21f6250*/ short ToInt16(byte value);
        static /*0x21f6258*/ short ToInt16(ushort value);
        static /*0x21f62b0*/ short ToInt16(int value);
        static /*0x21f6308*/ short ToInt16(uint value);
        static /*0x21f6360*/ short ToInt16(short value);
        static /*0x21f6364*/ short ToInt16(long value);
        static /*0x21f63bc*/ short ToInt16(ulong value);
        static /*0x21f6414*/ short ToInt16(float value);
        static /*0x21f6470*/ short ToInt16(double value);
        static /*0x21f64d0*/ short ToInt16(decimal value);
        static /*0x21f6544*/ short ToInt16(string value);
        static /*0x21f65bc*/ short ToInt16(string value, System.IFormatProvider provider);
        static /*0x21f65d4*/ short ToInt16(System.DateTime value);
        static /*0x21f66b4*/ ushort ToUInt16(object value);
        static /*0x21f67a8*/ ushort ToUInt16(object value, System.IFormatProvider provider);
        static /*0x21f68ac*/ ushort ToUInt16(bool value);
        static /*0x21f68b4*/ ushort ToUInt16(char value);
        static /*0x21f68b8*/ ushort ToUInt16(sbyte value);
        static /*0x21f690c*/ ushort ToUInt16(byte value);
        static /*0x21f6914*/ ushort ToUInt16(short value);
        static /*0x21f696c*/ ushort ToUInt16(int value);
        static /*0x21f69c4*/ ushort ToUInt16(ushort value);
        static /*0x21f69c8*/ ushort ToUInt16(uint value);
        static /*0x21f6a20*/ ushort ToUInt16(long value);
        static /*0x21f6a78*/ ushort ToUInt16(ulong value);
        static /*0x21f6ad0*/ ushort ToUInt16(float value);
        static /*0x21f6b2c*/ ushort ToUInt16(double value);
        static /*0x21f6b8c*/ ushort ToUInt16(decimal value);
        static /*0x21f6c00*/ ushort ToUInt16(string value);
        static /*0x21f6c78*/ ushort ToUInt16(string value, System.IFormatProvider provider);
        static /*0x21f6c90*/ ushort ToUInt16(System.DateTime value);
        static /*0x21f6d70*/ int ToInt32(object value);
        static /*0x21f6e64*/ int ToInt32(object value, System.IFormatProvider provider);
        static /*0x21f6f68*/ int ToInt32(bool value);
        static /*0x21f6f70*/ int ToInt32(char value);
        static /*0x21f6f78*/ int ToInt32(sbyte value);
        static /*0x21f6f80*/ int ToInt32(byte value);
        static /*0x21f6f88*/ int ToInt32(short value);
        static /*0x21f6f90*/ int ToInt32(ushort value);
        static /*0x21f6f98*/ int ToInt32(uint value);
        static /*0x21f6fec*/ int ToInt32(int value);
        static /*0x21f6ff0*/ int ToInt32(long value);
        static /*0x21f7048*/ int ToInt32(ulong value);
        static /*0x21f70a0*/ int ToInt32(float value);
        static /*0x21f55a8*/ int ToInt32(double value);
        static /*0x21f70fc*/ int ToInt32(decimal value);
        static /*0x21f7170*/ int ToInt32(string value);
        static /*0x21f71e8*/ int ToInt32(string value, System.IFormatProvider provider);
        static /*0x21f7200*/ int ToInt32(System.DateTime value);
        static /*0x21f72e0*/ uint ToUInt32(object value);
        static /*0x21f73d4*/ uint ToUInt32(object value, System.IFormatProvider provider);
        static /*0x21f74d8*/ uint ToUInt32(bool value);
        static /*0x21f74e0*/ uint ToUInt32(char value);
        static /*0x21f74e8*/ uint ToUInt32(sbyte value);
        static /*0x21f753c*/ uint ToUInt32(byte value);
        static /*0x21f7544*/ uint ToUInt32(short value);
        static /*0x21f7598*/ uint ToUInt32(ushort value);
        static /*0x21f75a0*/ uint ToUInt32(int value);
        static /*0x21f75f4*/ uint ToUInt32(uint value);
        static /*0x21f75f8*/ uint ToUInt32(long value);
        static /*0x21f7650*/ uint ToUInt32(ulong value);
        static /*0x21f76a8*/ uint ToUInt32(float value);
        static /*0x21f7704*/ uint ToUInt32(double value);
        static /*0x21f77ac*/ uint ToUInt32(decimal value);
        static /*0x21f7820*/ uint ToUInt32(string value);
        static /*0x21f7898*/ uint ToUInt32(string value, System.IFormatProvider provider);
        static /*0x21f78b0*/ uint ToUInt32(System.DateTime value);
        static /*0x21f7990*/ long ToInt64(object value);
        static /*0x21f7a84*/ long ToInt64(object value, System.IFormatProvider provider);
        static /*0x21f7b88*/ long ToInt64(bool value);
        static /*0x21f7b90*/ long ToInt64(char value);
        static /*0x21f7b98*/ long ToInt64(sbyte value);
        static /*0x21f7ba0*/ long ToInt64(byte value);
        static /*0x21f7ba8*/ long ToInt64(short value);
        static /*0x21f7bb0*/ long ToInt64(ushort value);
        static /*0x21f7bb8*/ long ToInt64(int value);
        static /*0x21f7bc0*/ long ToInt64(uint value);
        static /*0x21f7bc8*/ long ToInt64(ulong value);
        static /*0x21f7c1c*/ long ToInt64(long value);
        static /*0x21f7c20*/ long ToInt64(float value);
        static /*0x21f7c7c*/ long ToInt64(double value);
        static /*0x21f7d8c*/ long ToInt64(decimal value);
        static /*0x21f7e00*/ long ToInt64(string value);
        static /*0x21f7e78*/ long ToInt64(string value, System.IFormatProvider provider);
        static /*0x21f7e90*/ long ToInt64(System.DateTime value);
        static /*0x21f7f70*/ ulong ToUInt64(object value);
        static /*0x21f8064*/ ulong ToUInt64(object value, System.IFormatProvider provider);
        static /*0x21f8168*/ ulong ToUInt64(bool value);
        static /*0x21f8170*/ ulong ToUInt64(char value);
        static /*0x21f8178*/ ulong ToUInt64(sbyte value);
        static /*0x21f81d0*/ ulong ToUInt64(byte value);
        static /*0x21f81d8*/ ulong ToUInt64(short value);
        static /*0x21f8230*/ ulong ToUInt64(ushort value);
        static /*0x21f8238*/ ulong ToUInt64(int value);
        static /*0x21f828c*/ ulong ToUInt64(uint value);
        static /*0x21f8294*/ ulong ToUInt64(long value);
        static /*0x21f82e8*/ ulong ToUInt64(ulong value);
        static /*0x21f82ec*/ ulong ToUInt64(float value);
        static /*0x21f8348*/ ulong ToUInt64(double value);
        static /*0x21f8444*/ ulong ToUInt64(decimal value);
        static /*0x21f84b8*/ ulong ToUInt64(string value);
        static /*0x21f8530*/ ulong ToUInt64(string value, System.IFormatProvider provider);
        static /*0x21f8548*/ ulong ToUInt64(System.DateTime value);
        static /*0x21f8628*/ float ToSingle(object value);
        static /*0x21f871c*/ float ToSingle(object value, System.IFormatProvider provider);
        static /*0x21f8820*/ float ToSingle(sbyte value);
        static /*0x21f882c*/ float ToSingle(byte value);
        static /*0x21f8838*/ float ToSingle(char value);
        static /*0x21f88c4*/ float ToSingle(short value);
        static /*0x21f88d0*/ float ToSingle(ushort value);
        static /*0x21f88dc*/ float ToSingle(int value);
        static /*0x21f88e4*/ float ToSingle(uint value);
        static /*0x21f88f0*/ float ToSingle(long value);
        static /*0x21f88f8*/ float ToSingle(ulong value);
        static /*0x21f8904*/ float ToSingle(float value);
        static /*0x21f8908*/ float ToSingle(double value);
        static /*0x21f8910*/ float ToSingle(decimal value);
        static /*0x21f8978*/ float ToSingle(string value);
        static /*0x21f89f0*/ float ToSingle(string value, System.IFormatProvider provider);
        static /*0x21f8a0c*/ float ToSingle(bool value);
        static /*0x21f8a20*/ float ToSingle(System.DateTime value);
        static /*0x21f8b00*/ double ToDouble(object value);
        static /*0x21f8bf4*/ double ToDouble(object value, System.IFormatProvider provider);
        static /*0x21f8cf8*/ double ToDouble(sbyte value);
        static /*0x21f8d04*/ double ToDouble(byte value);
        static /*0x21f8d10*/ double ToDouble(short value);
        static /*0x21f8d1c*/ double ToDouble(char value);
        static /*0x21f8da8*/ double ToDouble(ushort value);
        static /*0x21f8db4*/ double ToDouble(int value);
        static /*0x21f8dbc*/ double ToDouble(uint value);
        static /*0x21f8dc4*/ double ToDouble(long value);
        static /*0x21f8dcc*/ double ToDouble(ulong value);
        static /*0x21f8dd4*/ double ToDouble(float value);
        static /*0x21f8ddc*/ double ToDouble(double value);
        static /*0x21f8de0*/ double ToDouble(decimal value);
        static /*0x21f8e48*/ double ToDouble(string value);
        static /*0x21f8f90*/ double ToDouble(string value, System.IFormatProvider provider);
        static /*0x21f908c*/ double ToDouble(bool value);
        static /*0x21f90a0*/ double ToDouble(System.DateTime value);
        static /*0x21f9180*/ decimal ToDecimal(object value);
        static /*0x21f929c*/ decimal ToDecimal(object value, System.IFormatProvider provider);
        static /*0x21f93c4*/ decimal ToDecimal(sbyte value);
        static /*0x21f941c*/ decimal ToDecimal(byte value);
        static /*0x21f9474*/ decimal ToDecimal(char value);
        static /*0x21f9500*/ decimal ToDecimal(short value);
        static /*0x21f9558*/ decimal ToDecimal(ushort value);
        static /*0x21f95b0*/ decimal ToDecimal(int value);
        static /*0x21f9608*/ decimal ToDecimal(uint value);
        static /*0x21f9660*/ decimal ToDecimal(long value);
        static /*0x21f96b8*/ decimal ToDecimal(ulong value);
        static /*0x21f9710*/ decimal ToDecimal(float value);
        static /*0x21f9770*/ decimal ToDecimal(double value);
        static /*0x21f97d0*/ decimal ToDecimal(string value);
        static /*0x21f9888*/ decimal ToDecimal(string value, System.IFormatProvider provider);
        static /*0x21f9910*/ decimal ToDecimal(decimal value);
        static /*0x21f9914*/ decimal ToDecimal(bool value);
        static /*0x21f9970*/ decimal ToDecimal(System.DateTime value);
        static /*0x21f9a50*/ System.DateTime ToDateTime(System.DateTime value);
        static /*0x21f9a54*/ System.DateTime ToDateTime(object value);
        static /*0x21f9b74*/ System.DateTime ToDateTime(object value, System.IFormatProvider provider);
        static /*0x21f9ca4*/ System.DateTime ToDateTime(string value);
        static /*0x21f9ecc*/ System.DateTime ToDateTime(string value, System.IFormatProvider provider);
        static /*0x21f9f3c*/ System.DateTime ToDateTime(sbyte value);
        static /*0x21f9fc8*/ System.DateTime ToDateTime(byte value);
        static /*0x21fa054*/ System.DateTime ToDateTime(short value);
        static /*0x21fa0e0*/ System.DateTime ToDateTime(ushort value);
        static /*0x21fa16c*/ System.DateTime ToDateTime(int value);
        static /*0x21fa1f8*/ System.DateTime ToDateTime(uint value);
        static /*0x21fa284*/ System.DateTime ToDateTime(long value);
        static /*0x21fa310*/ System.DateTime ToDateTime(ulong value);
        static /*0x21fa39c*/ System.DateTime ToDateTime(bool value);
        static /*0x21fa428*/ System.DateTime ToDateTime(char value);
        static /*0x21fa4b4*/ System.DateTime ToDateTime(float value);
        static /*0x21fa548*/ System.DateTime ToDateTime(double value);
        static /*0x21fa62c*/ System.DateTime ToDateTime(decimal value);
        static /*0x21fa6e4*/ string ToString(object value);
        static /*0x21fa73c*/ string ToString(object value, System.IFormatProvider provider);
        static /*0x21fa8dc*/ string ToString(bool value);
        static /*0x21fa8fc*/ string ToString(bool value, System.IFormatProvider provider);
        static /*0x21fa91c*/ string ToString(char value);
        static /*0x21fa974*/ string ToString(char value, System.IFormatProvider provider);
        static /*0x21fa990*/ string ToString(sbyte value);
        static /*0x21fa9f8*/ string ToString(sbyte value, System.IFormatProvider provider);
        static /*0x21faa14*/ string ToString(byte value);
        static /*0x21faa7c*/ string ToString(byte value, System.IFormatProvider provider);
        static /*0x21faa98*/ string ToString(short value);
        static /*0x21fab00*/ string ToString(short value, System.IFormatProvider provider);
        static /*0x21fab1c*/ string ToString(ushort value);
        static /*0x21fab84*/ string ToString(ushort value, System.IFormatProvider provider);
        static /*0x21faba0*/ string ToString(int value);
        static /*0x21fac08*/ string ToString(int value, System.IFormatProvider provider);
        static /*0x21fac24*/ string ToString(uint value);
        static /*0x21fac8c*/ string ToString(uint value, System.IFormatProvider provider);
        static /*0x21faca8*/ string ToString(long value);
        static /*0x21fad10*/ string ToString(long value, System.IFormatProvider provider);
        static /*0x21fad2c*/ string ToString(ulong value);
        static /*0x21fad94*/ string ToString(ulong value, System.IFormatProvider provider);
        static /*0x21fadb0*/ string ToString(float value);
        static /*0x21fae18*/ string ToString(float value, System.IFormatProvider provider);
        static /*0x21fae38*/ string ToString(double value);
        static /*0x21faf28*/ string ToString(double value, System.IFormatProvider provider);
        static /*0x21faf44*/ string ToString(decimal value);
        static /*0x21fafd4*/ string ToString(decimal value, System.IFormatProvider provider);
        static /*0x21fb01c*/ string ToString(System.DateTime value);
        static /*0x21fb094*/ string ToString(System.DateTime value, System.IFormatProvider provider);
        static /*0x21fb118*/ string ToString(string value);
        static /*0x21fb11c*/ string ToString(string value, System.IFormatProvider provider);
        static /*0x21fb120*/ byte ToByte(string value, int fromBase);
        static /*0x21fb230*/ sbyte ToSByte(string value, int fromBase);
        static /*0x21fb350*/ short ToInt16(string value, int fromBase);
        static /*0x21fb470*/ ushort ToUInt16(string value, int fromBase);
        static /*0x21fb580*/ int ToInt32(string value, int fromBase);
        static /*0x21fb65c*/ uint ToUInt32(string value, int fromBase);
        static /*0x21fb738*/ long ToInt64(string value, int fromBase);
        static /*0x21fb814*/ ulong ToUInt64(string value, int fromBase);
        static /*0x21fb8f0*/ string ToString(byte value, int toBase);
        static /*0x21fb97c*/ string ToString(short value, int toBase);
        static /*0x21fba08*/ string ToString(int value, int toBase);
        static /*0x21fba90*/ string ToString(long value, int toBase);
        static /*0x21fbb18*/ string ToBase64String(byte[] inArray);
        static /*0x21fbd90*/ string ToBase64String(byte[] inArray, System.Base64FormattingOptions options);
        static /*0x21fbe54*/ string ToBase64String(byte[] inArray, int offset, int length);
        static /*0x21fbec4*/ string ToBase64String(byte[] inArray, int offset, int length, System.Base64FormattingOptions options);
        static /*0x21fbbd8*/ string ToBase64String(System.ReadOnlySpan<byte> bytes, System.Base64FormattingOptions options);
        static /*0x21fc37c*/ int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut);
        static /*0x21fc404*/ int ToBase64CharArray(byte[] inArray, int offsetIn, int length, char[] outArray, int offsetOut, System.Base64FormattingOptions options);
        static /*0x21fc73c*/ bool TryToBase64Chars(System.ReadOnlySpan<byte> bytes, System.Span<char> chars, ref int charsWritten, System.Base64FormattingOptions options);
        static /*0x21fc138*/ int ConvertToBase64Array(char* outChars, byte* inData, int offset, int length, bool insertLineBreaks);
        static /*0x21fc080*/ int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks);
        static /*0x21fc91c*/ byte[] FromBase64String(string s);
        static /*0x21fcb7c*/ bool TryFromBase64String(string s, System.Span<byte> bytes, ref int bytesWritten);
        static /*0x21fcc84*/ bool TryFromBase64Chars(System.ReadOnlySpan<char> chars, System.Span<byte> bytes, ref int bytesWritten);
        static /*0x21fd17c*/ void CopyToTempBufferWithoutWhiteSpace(System.ReadOnlySpan<char> chars, System.Span<char> tempBuffer, ref int consumed, ref int charsWritten);
        static /*0x21fd29c*/ bool IsSpace(char c);
        static /*0x21fd2d4*/ byte[] FromBase64CharArray(char[] inArray, int offset, int length);
        static /*0x21fc9d8*/ byte[] FromBase64CharPtr(char* inputPtr, int inputLength);
        static /*0x21fd4cc*/ int FromBase64_ComputeResultLength(char* inputPtr, int inputLength);
    }

    enum Base64FormattingOptions
    {
        None = 0,
        InsertLineBreaks = 1,
    }

    class CurrentSystemTimeZone : System.TimeZone
    {
        /*0x10*/ long m_ticksOffset;
        /*0x18*/ string m_standardName;
        /*0x20*/ string m_daylightName;
        /*0x28*/ System.Collections.Hashtable m_CachedDaylightChanges;

        static /*0x21fe5dc*/ System.Globalization.DaylightTime CreateDaylightChanges(int year);
        static /*0x21fe914*/ bool GetTimeZoneData(int year, ref long[] data, ref string[] names, ref bool daylight_inverted);
        /*0x21fdcdc*/ CurrentSystemTimeZone();
        /*0x21fdda0*/ string get_StandardName();
        /*0x21fdda8*/ string get_DaylightName();
        /*0x21fddb0*/ long GetUtcOffsetFromUniversalTime(System.DateTime time, ref bool isAmbiguousLocalDst);
        /*0x21fe0c8*/ System.DateTime ToLocalTime(System.DateTime time);
        /*0x21fe320*/ System.Globalization.DaylightTime GetDaylightChanges(int year);
        /*0x21fe860*/ System.TimeSpan GetUtcOffset(System.DateTime time);
        /*0x21fe3f0*/ System.Globalization.DaylightTime GetCachedDaylightChanges(int year);
    }

    class DBNull : System.Runtime.Serialization.ISerializable, System.IConvertible
    {
        static /*0x0*/ System.DBNull Value;

        static /*0x21feeec*/ DBNull();
        /*0x21fe918*/ DBNull();
        /*0x21fe920*/ DBNull(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x21fe978*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x21fe988*/ string ToString();
        /*0x21fe9d0*/ string ToString(System.IFormatProvider provider);
        /*0x21fea18*/ System.TypeCode GetTypeCode();
        /*0x21fea20*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x21fea70*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x21feac0*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x21feb10*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x21feb60*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x21febb0*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x21fec00*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x21fec50*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x21feca0*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x21fecf0*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x21fed40*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x21fed90*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x21fede0*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x21fee30*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x21fee80*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class DataMisalignedException : System.SystemException
    {
        /*0x21fef50*/ DataMisalignedException();
        /*0x21fefac*/ DataMisalignedException(string message);
        /*0x21fefd0*/ DataMisalignedException(string message, System.Exception innerException);
        /*0x21feff4*/ DataMisalignedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct DateTime : System.IComparable, System.IFormattable, System.IConvertible, System.IComparable<System.DateTime>, System.IEquatable<System.DateTime>, System.Runtime.Serialization.ISerializable, System.ISpanFormattable
    {
        static long TicksPerMillisecond = 10000;
        static long TicksPerSecond = 10000000;
        static long TicksPerMinute = 600000000;
        static long TicksPerHour = 36000000000;
        static long TicksPerDay = 864000000000;
        static int MillisPerSecond = 1000;
        static int MillisPerMinute = 60000;
        static int MillisPerHour = 3600000;
        static int MillisPerDay = 86400000;
        static int DaysPerYear = 365;
        static int DaysPer4Years = 1461;
        static int DaysPer100Years = 36524;
        static int DaysPer400Years = 146097;
        static int DaysTo1601 = 584388;
        static int DaysTo1899 = 693593;
        static int DaysTo1970 = 719162;
        static int DaysTo10000 = 3652059;
        static long MinTicks = 0;
        static long MaxTicks = 3155378975999999999;
        static long MaxMillis = 315537897600000;
        static long UnixEpochTicks = 621355968000000000;
        static long FileTimeOffset = 504911232000000000;
        static long DoubleDateOffset = 599264352000000000;
        static long OADateMinAsTicks = 31241376000000000;
        static double OADateMinAsDouble = -657435;
        static double OADateMaxAsDouble = 2958466;
        static int DatePartYear = 0;
        static int DatePartDayOfYear = 1;
        static int DatePartMonth = 2;
        static int DatePartDay = 3;
        static ulong TicksMask = 4611686018427387903;
        static ulong FlagsMask = 13835058055282163712;
        static ulong LocalMask = 9223372036854775808;
        static long TicksCeiling = 4611686018427387904;
        static ulong KindUnspecified = 0;
        static ulong KindUtc = 4611686018427387904;
        static ulong KindLocal = 9223372036854775808;
        static ulong KindLocalAmbiguousDst = 13835058055282163712;
        static int KindShift = 62;
        static string TicksField = "ticks";
        static string DateDataField = "dateData";
        static /*0x0*/ int[] s_daysToMonth365;
        static /*0x8*/ int[] s_daysToMonth366;
        static /*0x10*/ System.DateTime MinValue;
        static /*0x18*/ System.DateTime MaxValue;
        static /*0x20*/ System.DateTime UnixEpoch;
        /*0x10*/ ulong _dateData;

        static /*0x2203e1c*/ DateTime();
        static /*0x2200794*/ int Compare(System.DateTime t1, System.DateTime t2);
        static /*0x21ff084*/ long DateToTicks(int year, int month, int day);
        static /*0x21ff390*/ long TimeToTicks(int hour, int minute, int second);
        static /*0x22005d4*/ int DaysInMonth(int year, int month);
        static /*0x22009f4*/ long DoubleDateToTicks(double value);
        static /*0x2200bb8*/ bool Equals(System.DateTime t1, System.DateTime t2);
        static /*0x2200bc8*/ System.DateTime FromBinary(long dateData);
        static /*0x2200dfc*/ System.DateTime FromBinaryRaw(long dateData);
        static /*0x2200e84*/ System.DateTime FromFileTime(long fileTime);
        static /*0x2200ef8*/ System.DateTime FromFileTimeUtc(long fileTime);
        static /*0x2200fb0*/ System.DateTime FromOADate(double d);
        static /*0x220118c*/ System.DateTime SpecifyKind(System.DateTime value, System.DateTimeKind kind);
        static /*0x22015bc*/ System.DateTime get_Now();
        static /*0x2201784*/ System.DateTime get_Today();
        static /*0x2200928*/ bool IsLeapYear(int year);
        static /*0x2201808*/ System.DateTime Parse(string s);
        static /*0x21f9dd4*/ System.DateTime Parse(string s, System.IFormatProvider provider);
        static /*0x22018f0*/ System.DateTime Parse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles);
        static /*0x2201a24*/ System.DateTime Parse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles);
        static /*0x2201b00*/ System.DateTime ParseExact(string s, string format, System.IFormatProvider provider);
        static /*0x2201c68*/ System.DateTime ParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style);
        static /*0x2201e0c*/ System.DateTime ParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style);
        static /*0x2201f00*/ System.DateTime ParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style);
        static /*0x2202044*/ System.DateTime ParseExact(System.ReadOnlySpan<char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style);
        static /*0x22021e4*/ double TicksToOADate(long value);
        static /*0x2202a40*/ bool TryParse(string s, ref System.DateTime result);
        static /*0x2202b3c*/ bool TryParse(System.ReadOnlySpan<char> s, ref System.DateTime result);
        static /*0x2202be8*/ bool TryParse(string s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles, ref System.DateTime result);
        static /*0x2202d30*/ bool TryParse(System.ReadOnlySpan<char> s, System.IFormatProvider provider, System.Globalization.DateTimeStyles styles, ref System.DateTime result);
        static /*0x2202e14*/ bool TryParseExact(string s, string format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, ref System.DateTime result);
        static /*0x2202fa8*/ bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, ref System.DateTime result);
        static /*0x22030a4*/ bool TryParseExact(string s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, ref System.DateTime result);
        static /*0x22031f4*/ bool TryParseExact(System.ReadOnlySpan<char> s, string[] formats, System.IFormatProvider provider, System.Globalization.DateTimeStyles style, ref System.DateTime result);
        static /*0x22032e8*/ System.DateTime op_Addition(System.DateTime d, System.TimeSpan t);
        static /*0x21fdff0*/ System.DateTime op_Subtraction(System.DateTime d, System.TimeSpan t);
        static /*0x220338c*/ System.TimeSpan op_Subtraction(System.DateTime d1, System.DateTime d2);
        static /*0x220339c*/ bool op_Equality(System.DateTime d1, System.DateTime d2);
        static /*0x22033ac*/ bool op_Inequality(System.DateTime d1, System.DateTime d2);
        static /*0x21fe0a0*/ bool op_LessThan(System.DateTime t1, System.DateTime t2);
        static /*0x22033bc*/ bool op_LessThanOrEqual(System.DateTime t1, System.DateTime t2);
        static /*0x21fe08c*/ bool op_GreaterThan(System.DateTime t1, System.DateTime t2);
        static /*0x21fe0b4*/ bool op_GreaterThanOrEqual(System.DateTime t1, System.DateTime t2);
        static /*0x2203c20*/ bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, ref System.DateTime result);
        static /*0x22016b0*/ System.DateTime get_UtcNow();
        static /*0x2203e10*/ long GetSystemTimeAsFileTime();
        /*0x21f9d44*/ DateTime(long ticks);
        /*0x21feffc*/ DateTime(ulong dateData);
        /*0x21fe194*/ DateTime(long ticks, System.DateTimeKind kind);
        /*0x21fe27c*/ DateTime(long ticks, System.DateTimeKind kind, bool isAmbiguousDst);
        /*0x21ff004*/ DateTime(int year, int month, int day);
        /*0x21ff230*/ DateTime(int year, int month, int day, System.Globalization.Calendar calendar);
        /*0x21ff2e4*/ DateTime(int year, int month, int day, int hour, int minute, int second);
        /*0x21ff468*/ DateTime(int year, int month, int day, int hour, int minute, int second, System.DateTimeKind kind);
        /*0x21ff258*/ DateTime(int year, int month, int day, int hour, int minute, int second, System.Globalization.Calendar calendar);
        /*0x21ff584*/ DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
        /*0x21ff75c*/ DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.DateTimeKind kind);
        /*0x21ff990*/ DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar);
        /*0x21ffb38*/ DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, System.DateTimeKind kind);
        /*0x21ffd3c*/ DateTime(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x21fffdc*/ long get_InternalTicks();
        /*0x21fffe8*/ ulong get_InternalKind();
        /*0x21ffff4*/ System.DateTime Add(System.TimeSpan value);
        /*0x22000a8*/ System.DateTime Add(double value, int scale);
        /*0x220017c*/ System.DateTime AddDays(double value);
        /*0x2200188*/ System.DateTime AddHours(double value);
        /*0x2200194*/ System.DateTime AddMilliseconds(double value);
        /*0x220019c*/ System.DateTime AddMinutes(double value);
        /*0x22001a4*/ System.DateTime AddMonths(int months);
        /*0x2200704*/ System.DateTime AddSeconds(double value);
        /*0x21ffff8*/ System.DateTime AddTicks(long value);
        /*0x220070c*/ System.DateTime AddYears(int value);
        /*0x22007b4*/ int CompareTo(object value);
        /*0x22008b4*/ int CompareTo(System.DateTime value);
        /*0x2200b28*/ bool Equals(object value);
        /*0x2200ba4*/ bool Equals(System.DateTime value);
        /*0x2201030*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2201100*/ bool IsDaylightSavingTime();
        /*0x22011b0*/ long ToBinary();
        /*0x2201248*/ System.DateTime get_Date();
        /*0x2201284*/ int GetDatePart(int part);
        /*0x22003e8*/ void GetDatePart(ref int year, ref int month, ref int day);
        /*0x2201474*/ int get_Day();
        /*0x220147c*/ System.DayOfWeek get_DayOfWeek();
        /*0x22014c8*/ int get_DayOfYear();
        /*0x22014d0*/ int GetHashCode();
        /*0x22014e0*/ int get_Hour();
        /*0x220151c*/ bool IsAmbiguousDaylightSavingTime();
        /*0x21fe160*/ System.DateTimeKind get_Kind();
        /*0x2201530*/ int get_Millisecond();
        /*0x2201578*/ int get_Minute();
        /*0x22015b4*/ int get_Month();
        /*0x2201714*/ int get_Second();
        /*0x21fe188*/ long get_Ticks();
        /*0x2201750*/ System.TimeSpan get_TimeOfDay();
        /*0x21fdfe8*/ int get_Year();
        /*0x2202128*/ System.TimeSpan Subtract(System.DateTime value);
        /*0x220213c*/ System.DateTime Subtract(System.TimeSpan value);
        /*0x2202310*/ double ToOADate();
        /*0x220236c*/ long ToFileTime();
        /*0x22023e8*/ long ToFileTimeUtc();
        /*0x2200fa8*/ System.DateTime ToLocalTime();
        /*0x2202470*/ System.DateTime ToLocalTime(bool throwOnOverflow);
        /*0x22025c4*/ string ToLongDateString();
        /*0x22026b0*/ string ToLongTimeString();
        /*0x2202724*/ string ToShortDateString();
        /*0x2202798*/ string ToShortTimeString();
        /*0x21fb034*/ string ToString();
        /*0x220280c*/ string ToString(string format);
        /*0x21fb0ac*/ string ToString(System.IFormatProvider provider);
        /*0x2202878*/ string ToString(string format, System.IFormatProvider provider);
        /*0x22028e8*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x2202388*/ System.DateTime ToUniversalTime();
        /*0x22033d0*/ string[] GetDateTimeFormats();
        /*0x2203430*/ string[] GetDateTimeFormats(System.IFormatProvider provider);
        /*0x22036fc*/ string[] GetDateTimeFormats(char format);
        /*0x220376c*/ string[] GetDateTimeFormats(char format, System.IFormatProvider provider);
        /*0x2203b68*/ System.TypeCode GetTypeCode();
        /*0x21f46c0*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x21f4f8c*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x21f57f4*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x21f5f64*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x21f6628*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x21f6ce4*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x21f7254*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x21f7904*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x21f7ee4*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x21f859c*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x21f8a74*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x21f90f4*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x21f99c4*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x2203b70*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x2203b78*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
        /*0x2203e14*/ long ToBinaryRaw();
    }

    enum DateTimeKind
    {
        Unspecified = 0,
        Utc = 1,
        Local = 2,
    }

    struct DateTimeOffset : System.IComparable, System.IFormattable, System.IComparable<System.DateTimeOffset>, System.IEquatable<System.DateTimeOffset>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback, System.ISpanFormattable
    {
        static long MaxOffset = 504000000000;
        static long MinOffset = -504000000000;
        static long UnixEpochSeconds = 62135596800;
        static long UnixEpochMilliseconds = 62135596800000;
        static long UnixMinSeconds = -62135596800;
        static long UnixMaxSeconds = 253402300799;
        static /*0x0*/ System.DateTimeOffset MinValue;
        static /*0x10*/ System.DateTimeOffset MaxValue;
        static /*0x20*/ System.DateTimeOffset UnixEpoch;
        /*0x10*/ System.DateTime _dateTime;
        /*0x18*/ short _offsetMinutes;

        static /*0x2208230*/ DateTimeOffset();
        static /*0x2204660*/ System.DateTimeOffset get_Now();
        static /*0x22046cc*/ System.DateTimeOffset get_UtcNow();
        static /*0x2204ff4*/ int Compare(System.DateTimeOffset first, System.DateTimeOffset second);
        static /*0x22054a0*/ bool Equals(System.DateTimeOffset first, System.DateTimeOffset second);
        static /*0x2205524*/ System.DateTimeOffset FromFileTime(long fileTime);
        static /*0x2205598*/ System.DateTimeOffset FromUnixTimeSeconds(long seconds);
        static /*0x220570c*/ System.DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
        static /*0x2205ca4*/ System.DateTimeOffset Parse(string input);
        static /*0x2205db8*/ System.DateTimeOffset Parse(string input, System.IFormatProvider formatProvider);
        static /*0x2205e28*/ System.DateTimeOffset Parse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);
        static /*0x2206070*/ System.DateTimeOffset Parse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);
        static /*0x22061a0*/ System.DateTimeOffset ParseExact(string input, string format, System.IFormatProvider formatProvider);
        static /*0x2206230*/ System.DateTimeOffset ParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);
        static /*0x220640c*/ System.DateTimeOffset ParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);
        static /*0x2206554*/ System.DateTimeOffset ParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);
        static /*0x22066d4*/ System.DateTimeOffset ParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles);
        static /*0x22071f8*/ bool TryParse(string input, ref System.DateTimeOffset result);
        static /*0x2207320*/ bool TryParse(System.ReadOnlySpan<char> input, ref System.DateTimeOffset result);
        static /*0x2207404*/ bool TryParse(string input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, ref System.DateTimeOffset result);
        static /*0x2207590*/ bool TryParse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, ref System.DateTimeOffset result);
        static /*0x22076d4*/ bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, ref System.DateTimeOffset result);
        static /*0x22078a0*/ bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, ref System.DateTimeOffset result);
        static /*0x22079fc*/ bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, ref System.DateTimeOffset result);
        static /*0x2207b88*/ bool TryParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.DateTimeStyles styles, ref System.DateTimeOffset result);
        static /*0x2203fa0*/ short ValidateOffset(System.TimeSpan offset);
        static /*0x22040b4*/ System.DateTime ValidateDate(System.DateTime dateTime, System.TimeSpan offset);
        static /*0x2205f98*/ System.Globalization.DateTimeStyles ValidateStyles(System.Globalization.DateTimeStyles style, string parameterName);
        static /*0x2207ce4*/ System.DateTimeOffset op_Implicit(System.DateTime dateTime);
        static /*0x2207d0c*/ System.DateTimeOffset op_Addition(System.DateTimeOffset dateTimeOffset, System.TimeSpan timeSpan);
        static /*0x2207dc8*/ System.DateTimeOffset op_Subtraction(System.DateTimeOffset dateTimeOffset, System.TimeSpan timeSpan);
        static /*0x2207e84*/ System.TimeSpan op_Subtraction(System.DateTimeOffset left, System.DateTimeOffset right);
        static /*0x2207f08*/ bool op_Equality(System.DateTimeOffset left, System.DateTimeOffset right);
        static /*0x2207f8c*/ bool op_Inequality(System.DateTimeOffset left, System.DateTimeOffset right);
        static /*0x2208010*/ bool op_LessThan(System.DateTimeOffset left, System.DateTimeOffset right);
        static /*0x2208098*/ bool op_LessThanOrEqual(System.DateTimeOffset left, System.DateTimeOffset right);
        static /*0x2208120*/ bool op_GreaterThan(System.DateTimeOffset left, System.DateTimeOffset right);
        static /*0x22081a8*/ bool op_GreaterThanOrEqual(System.DateTimeOffset left, System.DateTimeOffset right);
        /*0x2203f0c*/ DateTimeOffset(long ticks, System.TimeSpan offset);
        /*0x220415c*/ DateTimeOffset(System.DateTime dateTime);
        /*0x2204220*/ DateTimeOffset(System.DateTime dateTime, System.TimeSpan offset);
        /*0x22043d4*/ DateTimeOffset(int year, int month, int day, int hour, int minute, int second, System.TimeSpan offset);
        /*0x22044a0*/ DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System.TimeSpan offset);
        /*0x220457c*/ DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, System.Globalization.Calendar calendar, System.TimeSpan offset);
        /*0x2205acc*/ DateTimeOffset(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2204738*/ System.DateTime get_DateTime();
        /*0x22047dc*/ System.DateTime get_UtcDateTime();
        /*0x2204850*/ System.DateTime get_LocalDateTime();
        /*0x2204870*/ System.DateTimeOffset ToOffset(System.TimeSpan offset);
        /*0x220473c*/ System.DateTime get_ClockDateTime();
        /*0x2204928*/ System.DateTime get_Date();
        /*0x220496c*/ int get_Day();
        /*0x220498c*/ System.DayOfWeek get_DayOfWeek();
        /*0x22049e0*/ int get_DayOfYear();
        /*0x2204a00*/ int get_Hour();
        /*0x2204a44*/ int get_Millisecond();
        /*0x2204a94*/ int get_Minute();
        /*0x2204ad8*/ int get_Month();
        /*0x22048fc*/ System.TimeSpan get_Offset();
        /*0x2204af8*/ int get_Second();
        /*0x2204b3c*/ long get_Ticks();
        /*0x2204b50*/ long get_UtcTicks();
        /*0x2204b64*/ System.TimeSpan get_TimeOfDay();
        /*0x2204ba0*/ int get_Year();
        /*0x2204bc0*/ System.DateTimeOffset Add(System.TimeSpan timeSpan);
        /*0x2204c30*/ System.DateTimeOffset AddDays(double days);
        /*0x2204cb0*/ System.DateTimeOffset AddHours(double hours);
        /*0x2204d30*/ System.DateTimeOffset AddMilliseconds(double milliseconds);
        /*0x2204dac*/ System.DateTimeOffset AddMinutes(double minutes);
        /*0x2204e28*/ System.DateTimeOffset AddMonths(int months);
        /*0x2204e98*/ System.DateTimeOffset AddSeconds(double seconds);
        /*0x2204f14*/ System.DateTimeOffset AddTicks(long ticks);
        /*0x2204f84*/ System.DateTimeOffset AddYears(int years);
        /*0x2205080*/ int System.IComparable.CompareTo(object obj);
        /*0x22051b0*/ int CompareTo(System.DateTimeOffset other);
        /*0x2205258*/ bool Equals(object obj);
        /*0x2205314*/ bool Equals(System.DateTimeOffset other);
        /*0x2205348*/ bool EqualsExact(System.DateTimeOffset other);
        /*0x2205880*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
        /*0x2205a00*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2205c8c*/ int GetHashCode();
        /*0x220680c*/ System.TimeSpan Subtract(System.DateTimeOffset value);
        /*0x2206840*/ System.DateTimeOffset Subtract(System.TimeSpan value);
        /*0x22068b0*/ long ToFileTime();
        /*0x22068e0*/ long ToUnixTimeSeconds();
        /*0x2206918*/ long ToUnixTimeMilliseconds();
        /*0x2206950*/ System.DateTimeOffset ToLocalTime();
        /*0x2206958*/ System.DateTimeOffset ToLocalTime(bool throwOnOverflow);
        /*0x2206998*/ string ToString();
        /*0x2206d00*/ string ToString(string format);
        /*0x2206d9c*/ string ToString(System.IFormatProvider formatProvider);
        /*0x2206e38*/ string ToString(string format, System.IFormatProvider formatProvider);
        /*0x2206ee0*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider);
        /*0x22071cc*/ System.DateTimeOffset ToUniversalTime();
    }

    enum DayOfWeek
    {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6,
    }

    class DivideByZeroException : System.ArithmeticException
    {
        /*0x2208334*/ DivideByZeroException();
        /*0x2208390*/ DivideByZeroException(string message);
        /*0x22083b4*/ DivideByZeroException(string message, System.Exception innerException);
        /*0x22083d8*/ DivideByZeroException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class DllNotFoundException : System.TypeLoadException
    {
        /*0x22083e0*/ DllNotFoundException();
        /*0x220843c*/ DllNotFoundException(string message);
        /*0x2208460*/ DllNotFoundException(string message, System.Exception inner);
        /*0x2208484*/ DllNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct Double : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<double>, System.IEquatable<double>, System.ISpanFormattable
    {
        static double MinValue = -1.7976931348623157e+308;
        static double MaxValue = 1.7976931348623157e+308;
        static double Epsilon = 5e-324;
        static double NegativeInfinity = -Infinity;
        static double PositiveInfinity = Infinity;
        static double NaN = NaN;
        static double NegativeZero = 0;
        /*0x10*/ double m_value;

        static /*0x220848c*/ bool IsFinite(double d);
        static /*0x22084f4*/ bool IsInfinity(double d);
        static /*0x2208560*/ bool IsNaN(double d);
        static /*0x22085cc*/ bool IsNegative(double d);
        static /*0x220862c*/ bool IsNegativeInfinity(double d);
        static /*0x2208640*/ bool IsNormal(double d);
        static /*0x22086bc*/ bool IsPositiveInfinity(double d);
        static /*0x22086d0*/ bool IsSubnormal(double d);
        static /*0x2208ac4*/ bool op_Equality(double left, double right);
        static /*0x2208ad0*/ bool op_Inequality(double left, double right);
        static /*0x2208adc*/ bool op_LessThan(double left, double right);
        static /*0x2208ae8*/ bool op_GreaterThan(double left, double right);
        static /*0x2208af4*/ bool op_LessThanOrEqual(double left, double right);
        static /*0x2208b00*/ bool op_GreaterThanOrEqual(double left, double right);
        static /*0x2208ea0*/ double Parse(string s);
        static /*0x2208f64*/ double Parse(string s, System.Globalization.NumberStyles style);
        static /*0x21f8ebc*/ double Parse(string s, System.IFormatProvider provider);
        static /*0x21f8fa8*/ double Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x2209040*/ double Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x22090e0*/ bool TryParse(string s, ref double result);
        static /*0x2209610*/ bool TryParse(System.ReadOnlySpan<char> s, ref double result);
        static /*0x220964c*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref double result);
        static /*0x22096f4*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref double result);
        static /*0x2209160*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref double result);
        /*0x220874c*/ int CompareTo(object value);
        /*0x22088c8*/ int CompareTo(double value);
        /*0x22089ac*/ bool Equals(object obj);
        /*0x2208b0c*/ bool Equals(double obj);
        /*0x2208bdc*/ int GetHashCode();
        /*0x2208c4c*/ string ToString();
        /*0x2208cc8*/ string ToString(string format);
        /*0x21fae9c*/ string ToString(System.IFormatProvider provider);
        /*0x2208d50*/ string ToString(string format, System.IFormatProvider provider);
        /*0x2208de0*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x2209750*/ System.TypeCode GetTypeCode();
        /*0x2209758*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x21f4df4*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x22097bc*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x220981c*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x220987c*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x22098dc*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x220993c*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x220999c*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x22099fc*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x2209a5c*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x2209abc*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x2209b1c*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x2209b24*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x21fa5a0*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x2209b84*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class DuplicateWaitObjectException : System.ArgumentException
    {
        static /*0x0*/ string s_duplicateWaitObjectMessage;

        static /*0x2209c2c*/ string get_DuplicateWaitObjectMessage();
        /*0x2209cb8*/ DuplicateWaitObjectException();
        /*0x2209ce8*/ DuplicateWaitObjectException(string parameterName);
        /*0x2209d28*/ DuplicateWaitObjectException(string parameterName, string message);
        /*0x2209d58*/ DuplicateWaitObjectException(string message, System.Exception innerException);
        /*0x2209d7c*/ DuplicateWaitObjectException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class EntryPointNotFoundException : System.TypeLoadException
    {
        /*0x2209d84*/ EntryPointNotFoundException();
        /*0x2209de0*/ EntryPointNotFoundException(string message);
        /*0x2209e04*/ EntryPointNotFoundException(string message, System.Exception inner);
        /*0x2209e28*/ EntryPointNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class EventArgs
    {
        static /*0x0*/ System.EventArgs Empty;

        static /*0x2209e38*/ EventArgs();
        /*0x2209e30*/ EventArgs();
    }

    class EventHandler : System.MulticastDelegate
    {
        /*0x2209e9c*/ EventHandler(object object, nint method);
        /*0x2209fcc*/ void Invoke(object sender, System.EventArgs e);
        /*0x2209fe0*/ System.IAsyncResult BeginInvoke(object sender, System.EventArgs e, System.AsyncCallback callback, object object);
        /*0x220a008*/ void EndInvoke(System.IAsyncResult result);
    }

    class EventHandler<TEventArgs> : System.MulticastDelegate
    {
        EventHandler(object object, nint method);
        void Invoke(object sender, TEventArgs e);
        System.IAsyncResult BeginInvoke(object sender, TEventArgs e, System.AsyncCallback callback, object object);
        void EndInvoke(System.IAsyncResult result);
    }

    class ExecutionEngineException : System.SystemException
    {
        /*0x220a014*/ ExecutionEngineException();
        /*0x220a070*/ ExecutionEngineException(string message);
        /*0x220a094*/ ExecutionEngineException(string message, System.Exception innerException);
        /*0x220a0b8*/ ExecutionEngineException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class FieldAccessException : System.MemberAccessException
    {
        /*0x220a0c0*/ FieldAccessException();
        /*0x220a11c*/ FieldAccessException(string message);
        /*0x220a140*/ FieldAccessException(string message, System.Exception inner);
        /*0x220a164*/ FieldAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class FlagsAttribute : System.Attribute
    {
        /*0x220a16c*/ FlagsAttribute();
    }

    class FormatException : System.SystemException
    {
        /*0x220a174*/ FormatException();
        /*0x21f4ce4*/ FormatException(string message);
        /*0x220a1d0*/ FormatException(string message, System.Exception innerException);
        /*0x220a1f4*/ FormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class FormattableString : System.IFormattable
    {
        static /*0x220a210*/ string Invariant(System.FormattableString formattable);
        /*0x220a330*/ FormattableString();
        string get_Format();
        object[] GetArguments();
        int get_ArgumentCount();
        object GetArgument(int index);
        string ToString(System.IFormatProvider formatProvider);
        /*0x220a1fc*/ string System.IFormattable.ToString(string ignored, System.IFormatProvider formatProvider);
        /*0x220a2c8*/ string ToString();
    }

    class Gen2GcCallback : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
    {
        /*0x10*/ System.Func<object, bool> _callback;
        /*0x18*/ System.Runtime.InteropServices.GCHandle _weakTargetObj;

        static /*0x220a340*/ void Register(System.Func<object, bool> callback, object targetObj);
        /*0x220a338*/ Gen2GcCallback();
        /*0x220a3c0*/ void Setup(System.Func<object, bool> callback, object targetObj);
        /*0x220a3e8*/ void Finalize();
    }

    class DateTimeFormat
    {
        static int MaxSecondsFractionDigits = 7;
        static string RoundtripFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK";
        static string RoundtripDateTimeUnfixed = "yyyy'-'MM'-'ddTHH':'mm':'ss zzz";
        static int DEFAULT_ALL_DATETIMES_SIZE = 132;
        static string Gmt = "GMT";
        static /*0x0*/ System.TimeSpan NullOffset;
        static /*0x8*/ char[] allStandardFormats;
        static /*0x10*/ System.Globalization.DateTimeFormatInfo InvariantFormatInfo;
        static /*0x18*/ string[] InvariantAbbreviatedMonthNames;
        static /*0x20*/ string[] InvariantAbbreviatedDayNames;
        static /*0x28*/ string[] fixedNumberFormats;

        static /*0x220d6ac*/ DateTimeFormat();
        static /*0x220a594*/ void FormatDigits(System.Text.StringBuilder outputBuffer, int value, int len);
        static /*0x220a604*/ void FormatDigits(System.Text.StringBuilder outputBuffer, int value, int len, bool overrideLengthLimit);
        static /*0x220a6fc*/ void HebrewFormatDigits(System.Text.StringBuilder outputBuffer, int digits);
        static /*0x220a778*/ int ParseRepeatPattern(System.ReadOnlySpan<char> format, int pos, char patternChar);
        static /*0x220a7f0*/ string FormatDayOfWeek(int dayOfWeek, int repeat, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x220a824*/ string FormatMonth(int month, int repeatCount, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x220a858*/ string FormatHebrewMonthName(System.DateTime time, int month, int repeatCount, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x220a918*/ int ParseQuoteString(System.ReadOnlySpan<char> format, int pos, System.Text.StringBuilder result);
        static /*0x220aac8*/ int ParseNextChar(System.ReadOnlySpan<char> format, int pos);
        static /*0x220ab38*/ bool IsUseGenitiveForm(System.ReadOnlySpan<char> format, int index, int tokenLen, char patternToMatch);
        static /*0x220ac84*/ System.Text.StringBuilder FormatCustomized(System.DateTime dateTime, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.TimeSpan offset, System.Text.StringBuilder result);
        static /*0x220bd58*/ void FormatCustomizedTimeZone(System.DateTime dateTime, System.TimeSpan offset, System.ReadOnlySpan<char> format, int tokenLen, bool timeOnly, System.Text.StringBuilder result);
        static /*0x220c074*/ void FormatCustomizedRoundripTimeZone(System.DateTime dateTime, System.TimeSpan offset, System.Text.StringBuilder result);
        static /*0x220c270*/ void Append2DigitNumber(System.Text.StringBuilder result, int val);
        static /*0x220c2cc*/ string GetRealFormat(System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x220c574*/ string ExpandPredefinedFormat(System.ReadOnlySpan<char> format, ref System.DateTime dateTime, ref System.Globalization.DateTimeFormatInfo dtfi, ref System.TimeSpan offset);
        static /*0x2202638*/ string Format(System.DateTime dateTime, string format, System.IFormatProvider provider);
        static /*0x2206a30*/ string Format(System.DateTime dateTime, string format, System.IFormatProvider provider, System.TimeSpan offset);
        static /*0x2202988*/ bool TryFormat(System.DateTime dateTime, System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x2206fbc*/ bool TryFormat(System.DateTime dateTime, System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.TimeSpan offset);
        static /*0x220d208*/ System.Text.StringBuilder FormatStringBuilder(System.DateTime dateTime, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.TimeSpan offset);
        static /*0x220c8e8*/ bool TryFormatO(System.DateTime dateTime, System.TimeSpan offset, System.Span<char> destination, ref int charsWritten);
        static /*0x220cdf0*/ bool TryFormatR(System.DateTime dateTime, System.TimeSpan offset, System.Span<char> destination, ref int charsWritten);
        static /*0x220d514*/ void WriteTwoDecimalDigits(uint value, System.Span<char> destination, int offset);
        static /*0x220d560*/ void WriteFourDecimalDigits(uint value, System.Span<char> buffer, int startingIndex);
        static /*0x220d600*/ void WriteDigits(ulong value, System.Span<char> buffer);
        static /*0x2203814*/ string[] GetAllDateTimes(System.DateTime dateTime, char format, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x22034d0*/ string[] GetAllDateTimes(System.DateTime dateTime, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x220c8e4*/ void InvalidFormatForLocal(System.ReadOnlySpan<char> format, System.DateTime dateTime);
    }

    class DateTimeParse
    {
        static int MaxDateTimeNumberDigits = 8;
        static string GMTName = "GMT";
        static string ZuluName = "Z";
        static int ORDER_YMD = 0;
        static int ORDER_MDY = 1;
        static int ORDER_DMY = 2;
        static int ORDER_YDM = 3;
        static int ORDER_YM = 4;
        static int ORDER_MY = 5;
        static int ORDER_MD = 6;
        static int ORDER_DM = 7;
        static /*0x0*/ System.DateTimeParse.MatchNumberDelegate m_hebrewNumberParser;
        static /*0x8*/ System.DateTimeParse.DS[][] dateParsingStates;

        static /*0x221a560*/ DateTimeParse();
        static /*0x220ea04*/ System.DateTime ParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style);
        static /*0x220edec*/ System.DateTime ParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.TimeSpan offset);
        static /*0x220ef48*/ bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTime result);
        static /*0x220f084*/ bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTime result, ref System.TimeSpan offset);
        static /*0x220eb3c*/ bool TryParseExact(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTimeResult result);
        static /*0x220fad0*/ System.DateTime ParseExactMultiple(System.ReadOnlySpan<char> s, string[] formats, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style);
        static /*0x220fe5c*/ System.DateTime ParseExactMultiple(System.ReadOnlySpan<char> s, string[] formats, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.TimeSpan offset);
        static /*0x220ffb0*/ bool TryParseExactMultiple(System.ReadOnlySpan<char> s, string[] formats, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTime result, ref System.TimeSpan offset);
        static /*0x221012c*/ bool TryParseExactMultiple(System.ReadOnlySpan<char> s, string[] formats, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTime result);
        static /*0x220fbd4*/ bool TryParseExactMultiple(System.ReadOnlySpan<char> s, string[] formats, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles style, ref System.DateTimeResult result);
        static /*0x22102c0*/ bool MatchWord(ref System.__DTString str, string target);
        static /*0x2210484*/ bool GetTimeZoneName(ref System.__DTString str);
        static /*0x2210534*/ bool IsDigit(char ch);
        static /*0x2210548*/ bool ParseFraction(ref System.__DTString str, ref double result);
        static /*0x2210684*/ bool ParseTimeZone(ref System.__DTString str, ref System.TimeSpan result);
        static /*0x2210a94*/ bool HandleTimeZone(ref System.__DTString str, ref System.DateTimeResult result);
        static /*0x2210c98*/ bool Lex(System.DateTimeParse.DS dps, ref System.__DTString str, ref System.DateTimeToken dtok, ref System.DateTimeRawInfo raw, ref System.DateTimeResult result, ref System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles);
        static /*0x22120a8*/ System.Globalization.Calendar GetJapaneseCalendarDefaultInstance();
        static /*0x2212198*/ System.Globalization.Calendar GetTaiwanCalendarDefaultInstance();
        static /*0x2212294*/ bool VerifyValidPunctuation(ref System.__DTString str);
        static /*0x2212450*/ bool GetYearMonthDayOrder(string datePattern, System.Globalization.DateTimeFormatInfo dtfi, ref int order);
        static /*0x22126f4*/ bool GetYearMonthOrder(string pattern, System.Globalization.DateTimeFormatInfo dtfi, ref int order);
        static /*0x22128ac*/ bool GetMonthDayOrder(string pattern, System.Globalization.DateTimeFormatInfo dtfi, ref int order);
        static /*0x2212aa4*/ bool TryAdjustYear(ref System.DateTimeResult result, int year, ref int adjustedYear);
        static /*0x2212b68*/ bool SetDateYMD(ref System.DateTimeResult result, int year, int month, int day);
        static /*0x2212bd8*/ bool SetDateMDY(ref System.DateTimeResult result, int month, int day, int year);
        static /*0x2212c54*/ bool SetDateDMY(ref System.DateTimeResult result, int day, int month, int year);
        static /*0x2212cd0*/ bool SetDateYDM(ref System.DateTimeResult result, int year, int day, int month);
        static /*0x2212d4c*/ void GetDefaultYear(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles);
        static /*0x2212ed0*/ bool GetDayOfNN(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x2213094*/ bool GetDayOfNNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x2213380*/ bool GetDayOfMN(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x22135e4*/ bool GetHebrewDayOfNM(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x2213744*/ bool GetDayOfNM(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x22139a8*/ bool GetDayOfMNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x2213cd0*/ bool GetDayOfYNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x2213e50*/ bool GetDayOfNNY(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x221400c*/ bool GetDayOfYMN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x2214120*/ bool GetDayOfYN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x221422c*/ bool GetDayOfYM(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x2214330*/ void AdjustTimeMark(System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeRawInfo raw);
        static /*0x22143f0*/ bool AdjustHour(ref int hour, System.DateTimeParse.TM timeMark);
        static /*0x2214438*/ bool GetTimeOfN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x22144f8*/ bool GetTimeOfNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x2214578*/ bool GetTimeOfNNN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x2214600*/ bool GetDateOfDSN(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x2214680*/ bool GetDateOfNDS(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw);
        static /*0x221478c*/ bool GetDateOfNNDS(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x22149c8*/ bool ProcessDateTimeSuffix(ref System.DateTimeResult result, ref System.DateTimeRawInfo raw, ref System.DateTimeToken dtok);
        static /*0x2214ac0*/ bool ProcessHebrewTerminalState(System.DateTimeParse.DS dps, ref System.__DTString str, ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x2211da4*/ bool ProcessTerminalState(System.DateTimeParse.DS dps, ref System.__DTString str, ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles, ref System.DateTimeRawInfo raw, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x2214e28*/ System.DateTime Parse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles);
        static /*0x221572c*/ System.DateTime Parse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles, ref System.TimeSpan offset);
        static /*0x221583c*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles, ref System.DateTime result);
        static /*0x2215960*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles, ref System.DateTime result, ref System.TimeSpan offset);
        static /*0x2214f24*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.DateTimeFormatInfo dtfi, System.Globalization.DateTimeStyles styles, ref System.DateTimeResult result);
        static /*0x2216350*/ bool DetermineTimeZoneAdjustments(ref System.__DTString str, ref System.DateTimeResult result, System.Globalization.DateTimeStyles styles, bool bTimeOnly);
        static /*0x2216590*/ bool DateTimeOffsetTimeZonePostProcessing(ref System.__DTString str, ref System.DateTimeResult result, System.Globalization.DateTimeStyles styles);
        static /*0x22167a4*/ bool AdjustTimeZoneToUniversal(ref System.DateTimeResult result);
        static /*0x2216870*/ bool AdjustTimeZoneToLocal(ref System.DateTimeResult result, bool bTimeOnly);
        static /*0x2215bbc*/ bool ParseISO8601(ref System.DateTimeRawInfo raw, ref System.__DTString str, System.Globalization.DateTimeStyles styles, ref System.DateTimeResult result);
        static /*0x2216cc0*/ bool MatchHebrewDigits(ref System.__DTString str, int digitLen, ref int number);
        static /*0x2216b74*/ bool ParseDigits(ref System.__DTString str, int digitLen, ref int result);
        static /*0x2216d98*/ bool ParseDigits(ref System.__DTString str, int minDigitLen, int maxDigitLen, ref int result);
        static /*0x2216f30*/ bool ParseFractionExact(ref System.__DTString str, int maxDigitLen, ref double result);
        static /*0x2217148*/ bool ParseSign(ref System.__DTString str, ref bool result);
        static /*0x22171b4*/ bool ParseTimeZoneOffset(ref System.__DTString str, int len, ref System.TimeSpan result);
        static /*0x221745c*/ bool MatchAbbreviatedMonthName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x2217bb8*/ bool MatchMonthName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x2217e60*/ bool MatchAbbreviatedDayName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x2218044*/ bool MatchDayName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x2218228*/ bool MatchEraName(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref int result);
        static /*0x22184d0*/ bool MatchTimeMark(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeParse.TM result);
        static /*0x2218774*/ bool MatchAbbreviatedTimeMark(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeParse.TM result);
        static /*0x2218860*/ bool CheckNewValue(ref int currentValue, int newValue, char patternChar, ref System.DateTimeResult result);
        static /*0x2212de8*/ System.DateTime GetDateTimeNow(ref System.DateTimeResult result, ref System.Globalization.DateTimeStyles styles);
        static /*0x22160d4*/ bool CheckDefaultDateTime(ref System.DateTimeResult result, ref System.Globalization.Calendar cal, System.Globalization.DateTimeStyles styles);
        static /*0x2218918*/ string ExpandPredefinedFormat(System.ReadOnlySpan<char> format, ref System.Globalization.DateTimeFormatInfo dtfi, ref System.ParsingInfo parseInfo, ref System.DateTimeResult result);
        static /*0x2218c44*/ bool ParseJapaneseEraStart(ref System.__DTString str, System.Globalization.DateTimeFormatInfo dtfi);
        static /*0x2218d24*/ bool ParseByFormat(ref System.__DTString str, ref System.__DTString format, ref System.ParsingInfo parseInfo, System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeResult result);
        static /*0x2219e20*/ bool TryParseQuoteString(System.ReadOnlySpan<char> format, int pos, System.Text.StringBuilder result, ref int returnValue);
        static /*0x220f2b0*/ bool DoStrictParse(System.ReadOnlySpan<char> s, System.ReadOnlySpan<char> formatParam, System.Globalization.DateTimeStyles styles, System.Globalization.DateTimeFormatInfo dtfi, ref System.DateTimeResult result);
        static /*0x220ec38*/ System.Exception GetDateTimeParseException(ref System.DateTimeResult result);
        static /*0x221a550*/ void LexTraceExit(string message, System.DateTimeParse.DS dps);
        static /*0x221a554*/ void PTSTraceExit(System.DateTimeParse.DS dps, bool passed);
        static /*0x221a558*/ void TPTraceExit(string message, System.DateTimeParse.DS dps);
        static /*0x221a55c*/ void DTFITrace(System.Globalization.DateTimeFormatInfo dtfi);

        class MatchNumberDelegate : System.MulticastDelegate
        {
            /*0x221ace0*/ MatchNumberDelegate(object object, nint method);
            /*0x221adb8*/ bool Invoke(ref System.__DTString str, int digitLen, ref int result);
        }

        enum DTT
        {
            End = 0,
            NumEnd = 1,
            NumAmpm = 2,
            NumSpace = 3,
            NumDatesep = 4,
            NumTimesep = 5,
            MonthEnd = 6,
            MonthSpace = 7,
            MonthDatesep = 8,
            NumDatesuff = 9,
            NumTimesuff = 10,
            DayOfWeek = 11,
            YearSpace = 12,
            YearDateSep = 13,
            YearEnd = 14,
            TimeZone = 15,
            Era = 16,
            NumUTCTimeMark = 17,
            Unk = 18,
            NumLocalTimeMark = 19,
            Max = 20,
        }

        enum TM
        {
            NotSet = -1,
            AM = 0,
            PM = 1,
        }

        enum DS
        {
            BEGIN = 0,
            N = 1,
            NN = 2,
            D_Nd = 3,
            D_NN = 4,
            D_NNd = 5,
            D_M = 6,
            D_MN = 7,
            D_NM = 8,
            D_MNd = 9,
            D_NDS = 10,
            D_Y = 11,
            D_YN = 12,
            D_YNd = 13,
            D_YM = 14,
            D_YMd = 15,
            D_S = 16,
            T_S = 17,
            T_Nt = 18,
            T_NNt = 19,
            ERROR = 20,
            DX_NN = 21,
            DX_NNN = 22,
            DX_MN = 23,
            DX_NM = 24,
            DX_MNN = 25,
            DX_DS = 26,
            DX_DSN = 27,
            DX_NDS = 28,
            DX_NNDS = 29,
            DX_YNN = 30,
            DX_YMN = 31,
            DX_YN = 32,
            DX_YM = 33,
            TX_N = 34,
            TX_NN = 35,
            TX_NNN = 36,
            TX_TS = 37,
            DX_NNY = 38,
        }

        class <>c
        {
            static /*0x0*/ System.DateTimeParse.<> <>9;
            static /*0x8*/ System.Func<System.DateTimeParse.MatchNumberDelegate> <>9__98_0;

            static /*0x221adcc*/ <>c();
            /*0x221ae30*/ <>c();
            /*0x221ae38*/ System.DateTimeParse.MatchNumberDelegate <DoStrictParse>b__98_0();
        }
    }

    struct __DTString
    {
        static /*0x0*/ char[] WhiteSpaceChecks;
        /*0x10*/ System.ReadOnlySpan<char> Value;
        /*0x20*/ int Index;
        /*0x24*/ char m_current;
        /*0x28*/ System.Globalization.CompareInfo m_info;
        /*0x30*/ bool m_checkDigitToken;

        static /*0x221b208*/ __DTString();
        /*0x2219f78*/ __DTString(System.ReadOnlySpan<char> str, System.Globalization.DateTimeFormatInfo dtfi, bool checkDigitToken);
        /*0x2215af4*/ __DTString(System.ReadOnlySpan<char> str, System.Globalization.DateTimeFormatInfo dtfi);
        /*0x2210448*/ int get_Length();
        /*0x221aeac*/ System.Globalization.CompareInfo get_CompareInfo();
        /*0x221060c*/ bool GetNext();
        /*0x221608c*/ bool AtEnd();
        /*0x221aeb4*/ bool Advance(int count);
        /*0x22119c8*/ void GetRegularToken(ref System.TokenType tokenType, ref int tokenValue, System.Globalization.DateTimeFormatInfo dtfi);
        /*0x2211cb0*/ System.TokenType GetSeparatorToken(System.Globalization.DateTimeFormatInfo dtfi, ref int indexBeforeSeparator, ref char charBeforeSeparator);
        /*0x221b054*/ bool MatchSpecifiedWord(string target);
        /*0x22176b4*/ bool MatchSpecifiedWords(string target, bool checkWordBoundary, ref int matchLength);
        /*0x2217330*/ bool Match(string str);
        /*0x2216bfc*/ bool Match(char ch);
        /*0x2217b00*/ int MatchLongestWords(string[] words, ref int maxMatchStrLen);
        /*0x2219d78*/ int GetRepeatCount();
        /*0x221b154*/ bool GetNextDigit();
        /*0x2216c98*/ char GetChar();
        /*0x2216f04*/ int GetDigit();
        /*0x2216aa0*/ void SkipWhiteSpaces();
        /*0x221af2c*/ bool SkipWhiteSpaceCurrent();
        /*0x2219f9c*/ void TrimTail();
        /*0x221a0a8*/ void RemoveTrailingInQuoteSpaces();
        /*0x221a2dc*/ void RemoveLeadingInQuoteSpaces();
        /*0x22108c4*/ System.DTSubString GetSubString();
        /*0x2210a28*/ void ConsumeSubString(System.DTSubString sub);
    }

    enum DTSubStringType
    {
        Unknown = 0,
        Invalid = 1,
        Number = 2,
        End = 3,
        Other = 4,
    }

    struct DTSubString
    {
        /*0x10*/ System.ReadOnlySpan<char> s;
        /*0x20*/ int index;
        /*0x24*/ int length;
        /*0x28*/ System.DTSubStringType type;
        /*0x2c*/ int value;

        /*0x22109fc*/ char get_Item(int relativeIndex);
    }

    struct DateTimeToken
    {
        /*0x10*/ System.DateTimeParse.DTT dtt;
        /*0x14*/ System.TokenType suffix;
        /*0x18*/ int num;
    }

    struct DateTimeRawInfo
    {
        /*0x10*/ int* num;
        /*0x18*/ int numCount;
        /*0x1c*/ int month;
        /*0x20*/ int year;
        /*0x24*/ int dayOfWeek;
        /*0x28*/ int era;
        /*0x2c*/ System.DateTimeParse.TM timeMark;
        /*0x30*/ double fraction;
        /*0x38*/ bool hasSameDateAndTimeSeparators;

        /*0x2215ad4*/ void Init(int* numberBuffer);
        /*0x2211d8c*/ void AddNumber(int value);
        /*0x2213088*/ int GetNumber(int index);
    }

    enum ParseFailureKind
    {
        None = 0,
        ArgumentNull = 1,
        Format = 2,
        FormatWithParameter = 3,
        FormatWithOriginalDateTime = 4,
        FormatWithFormatSpecifier = 5,
        FormatWithOriginalDateTimeAndParameter = 6,
        FormatBadDateTimeCalendar = 7,
    }

    enum ParseFlags
    {
        HaveYear = 1,
        HaveMonth = 2,
        HaveDay = 4,
        HaveHour = 8,
        HaveMinute = 16,
        HaveSecond = 32,
        HaveTime = 64,
        HaveDate = 128,
        TimeZoneUsed = 256,
        TimeZoneUtc = 512,
        ParsedMonthName = 1024,
        CaptureOffset = 2048,
        YearDefault = 4096,
        Rfc1123Pattern = 8192,
        UtcSortPattern = 16384,
    }

    struct DateTimeResult
    {
        /*0x10*/ int Year;
        /*0x14*/ int Month;
        /*0x18*/ int Day;
        /*0x1c*/ int Hour;
        /*0x20*/ int Minute;
        /*0x24*/ int Second;
        /*0x28*/ double fraction;
        /*0x30*/ int era;
        /*0x34*/ System.ParseFlags flags;
        /*0x38*/ System.TimeSpan timeZoneOffset;
        /*0x40*/ System.Globalization.Calendar calendar;
        /*0x48*/ System.DateTime parsedDate;
        /*0x50*/ System.ParseFailureKind failure;
        /*0x58*/ string failureMessageID;
        /*0x60*/ object failureMessageFormatArgument;
        /*0x68*/ string failureArgumentName;
        /*0x70*/ System.ReadOnlySpan<char> originalDateTimeString;
        /*0x80*/ System.ReadOnlySpan<char> failedFormatSpecifier;

        /*0x220eb18*/ void Init(System.ReadOnlySpan<char> originalDateTimeString);
        /*0x2212bcc*/ void SetDate(int year, int month, int day);
        /*0x220f21c*/ void SetBadFormatSpecifierFailure();
        /*0x2219f08*/ void SetBadFormatSpecifierFailure(System.ReadOnlySpan<char> failedFormatSpecifier);
        /*0x2210270*/ void SetBadDateTimeFailure();
        /*0x220f210*/ void SetFailure(System.ParseFailureKind failure, string failureMessageID);
        /*0x2212288*/ void SetFailure(System.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
        /*0x2210260*/ void SetFailure(System.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName);
    }

    struct ParsingInfo
    {
        /*0x10*/ System.Globalization.Calendar calendar;
        /*0x18*/ int dayOfWeek;
        /*0x1c*/ System.DateTimeParse.TM timeMark;
        /*0x20*/ bool fUseHour12;
        /*0x21*/ bool fUseTwoDigitYear;
        /*0x22*/ bool fAllowInnerWhite;
        /*0x23*/ bool fAllowTrailingWhite;
        /*0x24*/ bool fCustomNumberParser;
        /*0x28*/ System.DateTimeParse.MatchNumberDelegate parseNumberDelegate;

        /*0x2219f6c*/ void Init();
    }

    enum TokenType
    {
        NumberToken = 1,
        YearNumberToken = 2,
        Am = 3,
        Pm = 4,
        MonthToken = 5,
        EndOfString = 6,
        DayOfWeekToken = 7,
        TimeZoneToken = 8,
        EraToken = 9,
        DateWordToken = 10,
        UnknownToken = 11,
        HebrewNumber = 12,
        JapaneseEraToken = 13,
        TEraToken = 14,
        IgnorableSymbol = 15,
        SEP_Unk = 256,
        SEP_End = 512,
        SEP_Space = 768,
        SEP_Am = 1024,
        SEP_Pm = 1280,
        SEP_Date = 1536,
        SEP_Time = 1792,
        SEP_YearSuff = 2048,
        SEP_MonthSuff = 2304,
        SEP_DaySuff = 2560,
        SEP_HourSuff = 2816,
        SEP_MinuteSuff = 3072,
        SEP_SecondSuff = 3328,
        SEP_LocalTimeMark = 3584,
        SEP_DateOrOffset = 3840,
        RegularTokenMask = 255,
        SeparatorTokenMask = 65280,
    }

    struct Guid : System.IFormattable, System.IComparable, System.IComparable<System.Guid>, System.IEquatable<System.Guid>, System.ISpanFormattable
    {
        static /*0x0*/ System.Guid Empty;
        /*0x10*/ int _a;
        /*0x14*/ short _b;
        /*0x16*/ short _c;
        /*0x18*/ byte _d;
        /*0x19*/ byte _e;
        /*0x1a*/ byte _f;
        /*0x1b*/ byte _g;
        /*0x1c*/ byte _h;
        /*0x1d*/ byte _i;
        /*0x1e*/ byte _j;
        /*0x1f*/ byte _k;

        static /*0x221e940*/ Guid();
        static /*0x221b29c*/ System.Guid NewGuid();
        static /*0x221ba2c*/ System.Guid Parse(string input);
        static /*0x221bb0c*/ System.Guid Parse(System.ReadOnlySpan<char> input);
        static /*0x221bbcc*/ bool TryParse(string input, ref System.Guid result);
        static /*0x221bc88*/ bool TryParse(System.ReadOnlySpan<char> input, ref System.Guid result);
        static /*0x221bd30*/ System.Guid ParseExact(string input, string format);
        static /*0x221be84*/ System.Guid ParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format);
        static /*0x221c03c*/ bool TryParseExact(string input, string format, ref System.Guid result);
        static /*0x221c148*/ bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, ref System.Guid result);
        static /*0x221b7a4*/ bool TryParseGuid(System.ReadOnlySpan<char> guidString, System.Guid.GuidStyles flags, ref System.Guid.GuidResult result);
        static /*0x221c5dc*/ bool TryParseGuidWithHexPrefix(System.ReadOnlySpan<char> guidString, ref System.Guid.GuidResult result);
        static /*0x221ccd8*/ bool TryParseGuidWithNoStyle(System.ReadOnlySpan<char> guidString, ref System.Guid.GuidResult result);
        static /*0x221c2bc*/ bool TryParseGuidWithDashes(System.ReadOnlySpan<char> guidString, ref System.Guid.GuidResult result);
        static /*0x221d380*/ bool StringToShort(System.ReadOnlySpan<char> str, int requiredLength, int flags, ref short result, ref System.Guid.GuidResult parseResult);
        static /*0x221d768*/ bool StringToShort(System.ReadOnlySpan<char> str, ref int parsePos, int requiredLength, int flags, ref short result, ref System.Guid.GuidResult parseResult);
        static /*0x221d2dc*/ bool StringToInt(System.ReadOnlySpan<char> str, int requiredLength, int flags, ref int result, ref System.Guid.GuidResult parseResult);
        static /*0x221d57c*/ bool StringToInt(System.ReadOnlySpan<char> str, ref int parsePos, int requiredLength, int flags, ref int result, ref System.Guid.GuidResult parseResult);
        static /*0x221d424*/ bool StringToLong(System.ReadOnlySpan<char> str, ref int parsePos, int flags, ref long result, ref System.Guid.GuidResult parseResult);
        static /*0x221cfd4*/ System.ReadOnlySpan<char> EatAllWhitespace(System.ReadOnlySpan<char> str);
        static /*0x221d210*/ bool IsHexPrefix(System.ReadOnlySpan<char> str, int i);
        static /*0x221e170*/ bool op_Equality(System.Guid a, System.Guid b);
        static /*0x221e1b0*/ bool op_Inequality(System.Guid a, System.Guid b);
        static /*0x221e1f4*/ char HexToChar(int a);
        static /*0x221e210*/ int HexsToChars(char* guidChars, int a, int b);
        static /*0x221e2e4*/ int HexsToCharsHexOutput(char* guidChars, int a, int b);
        static /*0x221e890*/ byte[] FastNewGuidArray();
        /*0x221b2e8*/ Guid(byte[] b);
        /*0x221b380*/ Guid(System.ReadOnlySpan<byte> b);
        /*0x221b4a8*/ Guid(uint a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
        /*0x221b4e8*/ Guid(int a, short b, short c, byte[] d);
        /*0x221b624*/ Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
        /*0x221b664*/ Guid(string g);
        /*0x221d824*/ void WriteByteHelper(System.Span<byte> destination);
        /*0x221d934*/ byte[] ToByteArray();
        /*0x221dab0*/ bool TryWriteBytes(System.Span<byte> destination);
        /*0x221db90*/ string ToString();
        /*0x221ddf4*/ int GetHashCode();
        /*0x221de0c*/ bool Equals(object o);
        /*0x221deb4*/ bool Equals(System.Guid g);
        /*0x221def8*/ int GetResult(uint me, uint them);
        /*0x221df08*/ int CompareTo(object value);
        /*0x221e094*/ int CompareTo(System.Guid value);
        /*0x221e1f0*/ string ToString(string format);
        /*0x221dbd8*/ string ToString(string format, System.IFormatProvider provider);
        /*0x221e3d8*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format);
        /*0x221e88c*/ bool System.ISpanFormattable.TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);

        enum GuidStyles
        {
            None = 0,
            AllowParenthesis = 1,
            AllowBraces = 2,
            AllowDashes = 4,
            AllowHexPrefix = 8,
            RequireParenthesis = 16,
            RequireBraces = 32,
            RequireDashes = 64,
            RequireHexPrefix = 128,
            HexFormat = 160,
            NumberFormat = 0,
            DigitFormat = 64,
            BraceFormat = 96,
            ParenthesisFormat = 80,
            Any = 15,
        }

        enum GuidParseThrowStyle
        {
            None = 0,
            All = 1,
            AllButOverflow = 2,
        }

        enum ParseFailureKind
        {
            None = 0,
            ArgumentNull = 1,
            Format = 2,
            FormatWithParameter = 3,
            NativeException = 4,
            FormatWithInnerException = 5,
        }

        struct GuidResult
        {
            /*0x10*/ System.Guid _parsedGuid;
            /*0x20*/ System.Guid.GuidParseThrowStyle _throwStyle;
            /*0x24*/ System.Guid.ParseFailureKind _failure;
            /*0x28*/ string _failureMessageID;
            /*0x30*/ object _failureMessageFormatArgument;
            /*0x38*/ string _failureArgumentName;
            /*0x40*/ System.Exception _innerException;

            /*0x221e944*/ void Init(System.Guid.GuidParseThrowStyle canThrow);
            /*0x221e94c*/ void SetFailure(System.Exception nativeException);
            /*0x221e95c*/ void SetFailure(System.Guid.ParseFailureKind failure, string failureMessageID);
            /*0x221e9ac*/ void SetFailure(System.Guid.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
            /*0x221e96c*/ void SetFailure(System.Guid.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument, string failureArgumentName, System.Exception innerException);
            /*0x221e9b8*/ System.Exception GetGuidParseException();
        }
    }

    class HResults
    {
        static int COR_E_ABANDONEDMUTEX = -2146233043;
        static int COR_E_AMBIGUOUSMATCH = -2147475171;
        static int COR_E_AMBIGUOUSIMPLEMENTATION = -2146234262;
        static int COR_E_APPDOMAINUNLOADED = -2146234348;
        static int COR_E_APPLICATION = -2146232832;
        static int COR_E_ARGUMENT = -2147024809;
        static int COR_E_ARGUMENTOUTOFRANGE = -2146233086;
        static int COR_E_ARITHMETIC = -2147024362;
        static int COR_E_ARRAYTYPEMISMATCH = -2146233085;
        static int COR_E_BADEXEFORMAT = -2147024703;
        static int COR_E_BADIMAGEFORMAT = -2147024885;
        static int COR_E_CANNOTUNLOADAPPDOMAIN = -2146234347;
        static int COR_E_COMEMULATE = -2146233035;
        static int COR_E_CONTEXTMARSHAL = -2146233084;
        static int COR_E_CUSTOMATTRIBUTEFORMAT = -2146232827;
        static int COR_E_DATAMISALIGNED = -2146233023;
        static int COR_E_DIRECTORYNOTFOUND = -2147024893;
        static int COR_E_DIVIDEBYZERO = -2147352558;
        static int COR_E_DLLNOTFOUND = -2146233052;
        static int COR_E_DUPLICATEWAITOBJECT = -2146233047;
        static int COR_E_ENDOFSTREAM = -2147024858;
        static int COR_E_ENTRYPOINTNOTFOUND = -2146233053;
        static int COR_E_EXCEPTION = -2146233088;
        static int COR_E_EXECUTIONENGINE = -2146233082;
        static int COR_E_FIELDACCESS = -2146233081;
        static int COR_E_FILELOAD = -2146232799;
        static int COR_E_FILENOTFOUND = -2147024894;
        static int COR_E_FORMAT = -2146233033;
        static int COR_E_HOSTPROTECTION = -2146232768;
        static int COR_E_INDEXOUTOFRANGE = -2146233080;
        static int COR_E_INSUFFICIENTEXECUTIONSTACK = -2146232968;
        static int COR_E_INSUFFICIENTMEMORY = -2146233027;
        static int COR_E_INVALIDCAST = -2147467262;
        static int COR_E_INVALIDCOMOBJECT = -2146233049;
        static int COR_E_INVALIDFILTERCRITERIA = -2146232831;
        static int COR_E_INVALIDOLEVARIANTTYPE = -2146233039;
        static int COR_E_INVALIDOPERATION = -2146233079;
        static int COR_E_INVALIDPROGRAM = -2146233030;
        static int COR_E_IO = -2146232800;
        static int COR_E_KEYNOTFOUND = -2146232969;
        static int COR_E_MARSHALDIRECTIVE = -2146233035;
        static int COR_E_MEMBERACCESS = -2146233062;
        static int COR_E_METHODACCESS = -2146233072;
        static int COR_E_MISSINGFIELD = -2146233071;
        static int COR_E_MISSINGMANIFESTRESOURCE = -2146233038;
        static int COR_E_MISSINGMEMBER = -2146233070;
        static int COR_E_MISSINGMETHOD = -2146233069;
        static int COR_E_MISSINGSATELLITEASSEMBLY = -2146233034;
        static int COR_E_MULTICASTNOTSUPPORTED = -2146233068;
        static int COR_E_NOTFINITENUMBER = -2146233048;
        static int COR_E_NOTSUPPORTED = -2146233067;
        static int COR_E_NULLREFERENCE = -2147467261;
        static int COR_E_OBJECTDISPOSED = -2146232798;
        static int COR_E_OPERATIONCANCELED = -2146233029;
        static int COR_E_OUTOFMEMORY = -2147024882;
        static int COR_E_OVERFLOW = -2146233066;
        static int COR_E_PATHTOOLONG = -2147024690;
        static int COR_E_PLATFORMNOTSUPPORTED = -2146233031;
        static int COR_E_RANK = -2146233065;
        static int COR_E_REFLECTIONTYPELOAD = -2146232830;
        static int COR_E_RUNTIMEWRAPPED = -2146233026;
        static int COR_E_SAFEARRAYRANKMISMATCH = -2146233032;
        static int COR_E_SAFEARRAYTYPEMISMATCH = -2146233037;
        static int COR_E_SAFEHANDLEMISSINGATTRIBUTE = -2146232797;
        static int COR_E_SECURITY = -2146233078;
        static int COR_E_SEMAPHOREFULL = -2146233045;
        static int COR_E_SERIALIZATION = -2146233076;
        static int COR_E_STACKOVERFLOW = -2147023895;
        static int COR_E_SYNCHRONIZATIONLOCK = -2146233064;
        static int COR_E_SYSTEM = -2146233087;
        static int COR_E_TARGET = -2146232829;
        static int COR_E_TARGETINVOCATION = -2146232828;
        static int COR_E_TARGETPARAMCOUNT = -2147352562;
        static int COR_E_THREADABORTED = -2146233040;
        static int COR_E_THREADINTERRUPTED = -2146233063;
        static int COR_E_THREADSTART = -2146233051;
        static int COR_E_THREADSTATE = -2146233056;
        static int COR_E_THREADSTOP = -2146233055;
        static int COR_E_TIMEOUT = -2146233083;
        static int COR_E_TYPEACCESS = -2146233021;
        static int COR_E_TYPEINITIALIZATION = -2146233036;
        static int COR_E_TYPELOAD = -2146233054;
        static int COR_E_TYPEUNLOADED = -2146234349;
        static int COR_E_UNAUTHORIZEDACCESS = -2147024891;
        static int COR_E_UNSUPPORTEDFORMAT = -2146233053;
        static int COR_E_VERIFICATION = -2146233075;
        static int COR_E_WAITHANDLECANNOTBEOPENED = -2146233044;
        static int DISP_E_OVERFLOW = -2147352566;
        static int E_BOUNDS = -2147483637;
        static int E_CHANGED_STATE = -2147483636;
        static int E_FAIL = -2147467259;
        static int E_HANDLE = -2147024890;
        static int E_INVALIDARG = -2147024809;
        static int E_NOTIMPL = -2147467263;
        static int E_POINTER = -2147467261;
        static int ERROR_MRM_MAP_NOT_FOUND = -2147009761;
        static int RO_E_CLOSED = -2147483629;
        static int TYPE_E_TYPEMISMATCH = -2147316576;
    }

    struct HashCode
    {
        static uint Prime1 = 2654435761;
        static uint Prime2 = 2246822519;
        static uint Prime3 = 3266489917;
        static uint Prime4 = 668265263;
        static uint Prime5 = 374761393;
        static /*0x0*/ uint s_seed;
        /*0x10*/ uint _v1;
        /*0x14*/ uint _v2;
        /*0x18*/ uint _v3;
        /*0x1c*/ uint _v4;
        /*0x20*/ uint _queue1;
        /*0x24*/ uint _queue2;
        /*0x28*/ uint _queue3;
        /*0x2c*/ uint _length;

        static /*0x221f384*/ HashCode();
        static /*0x221eb34*/ uint GenerateGlobalSeed();
        static int Combine<T1>(T1 value1);
        static int Combine<T1, T2>(T1 value1, T2 value2);
        static int Combine<T1, T2, T3>(T1 value1, T2 value2, T3 value3);
        static int Combine<T1, T2, T3, T4>(T1 value1, T2 value2, T3 value3, T4 value4);
        static int Combine<T1, T2, T3, T4, T5>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
        static int Combine<T1, T2, T3, T4, T5, T6>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
        static int Combine<T1, T2, T3, T4, T5, T6, T7>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
        static int Combine<T1, T2, T3, T4, T5, T6, T7, T8>(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
        static /*0x221eb58*/ uint Rol(uint value, int count);
        static /*0x221eb64*/ void Initialize(ref uint v1, ref uint v2, ref uint v3, ref uint v4);
        static /*0x221ec1c*/ uint Round(uint hash, uint input);
        static /*0x221ec94*/ uint QueueRound(uint hash, uint queuedValue);
        static /*0x221ed0c*/ uint MixState(uint v1, uint v2, uint v3, uint v4);
        static /*0x221ed94*/ uint MixEmptyState();
        static /*0x221edf8*/ uint MixFinal(uint hash);
        void Add<T>(T value);
        void Add<T>(T value, System.Collections.Generic.IEqualityComparer<T> comparer);
        /*0x221ee20*/ void Add(int value);
        /*0x221f0a8*/ int ToHashCode();
        /*0x221f2c8*/ int GetHashCode();
        /*0x221f338*/ bool Equals(object obj);
    }

    interface IAsyncDisposable
    {
        System.Threading.Tasks.ValueTask DisposeAsync();
    }

    interface IAsyncResult
    {
        bool get_IsCompleted();
        System.Threading.WaitHandle get_AsyncWaitHandle();
        object get_AsyncState();
        bool get_CompletedSynchronously();
    }

    interface ICloneable
    {
        object Clone();
    }

    interface IComparable
    {
        int CompareTo(object obj);
    }

    interface IComparable<T>
    {
        int CompareTo(T other);
    }

    interface IConvertible
    {
        System.TypeCode GetTypeCode();
        bool ToBoolean(System.IFormatProvider provider);
        char ToChar(System.IFormatProvider provider);
        sbyte ToSByte(System.IFormatProvider provider);
        byte ToByte(System.IFormatProvider provider);
        short ToInt16(System.IFormatProvider provider);
        ushort ToUInt16(System.IFormatProvider provider);
        int ToInt32(System.IFormatProvider provider);
        uint ToUInt32(System.IFormatProvider provider);
        long ToInt64(System.IFormatProvider provider);
        ulong ToUInt64(System.IFormatProvider provider);
        float ToSingle(System.IFormatProvider provider);
        double ToDouble(System.IFormatProvider provider);
        decimal ToDecimal(System.IFormatProvider provider);
        System.DateTime ToDateTime(System.IFormatProvider provider);
        string ToString(System.IFormatProvider provider);
        object ToType(System.Type conversionType, System.IFormatProvider provider);
    }

    interface ICustomFormatter
    {
        string Format(string format, object arg, System.IFormatProvider formatProvider);
    }

    interface IDisposable
    {
        void Dispose();
    }

    interface IEquatable<T>
    {
        bool Equals(T other);
    }

    interface IFormatProvider
    {
        object GetFormat(System.Type formatType);
    }

    interface IFormattable
    {
        string ToString(string format, System.IFormatProvider formatProvider);
    }

    interface IObservable<T>
    {
        System.IDisposable Subscribe(System.IObserver<T> observer);
    }

    interface IObserver<T>
    {
        void OnNext(T value);
        void OnError(System.Exception error);
        void OnCompleted();
    }

    interface IProgress<T>
    {
        void Report(T value);
    }

    interface ISpanFormattable
    {
        bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
    }

    struct Index : System.IEquatable<System.Index>
    {
        /*0x10*/ int _value;

        static /*0x221f424*/ System.Index get_Start();
        static /*0x221f42c*/ System.Index get_End();
        static /*0x221f434*/ System.Index FromStart(int value);
        static /*0x221f454*/ System.Index FromEnd(int value);
        static /*0x221f530*/ System.Index op_Implicit(int value);
        /*0x221f3e4*/ Index(int value, bool fromEnd);
        /*0x221f41c*/ Index(int value);
        /*0x221f474*/ int get_Value();
        /*0x221f480*/ bool get_IsFromEnd();
        /*0x221f48c*/ int GetOffset(int length);
        /*0x221f4a0*/ bool Equals(object value);
        /*0x221f518*/ bool Equals(System.Index other);
        /*0x221f528*/ int GetHashCode();
        /*0x221f550*/ string ToString();
        /*0x221f584*/ string ToStringFromEnd();
    }

    class IndexOutOfRangeException : System.SystemException
    {
        /*0x221f714*/ IndexOutOfRangeException();
        /*0x221f770*/ IndexOutOfRangeException(string message);
        /*0x221f794*/ IndexOutOfRangeException(string message, System.Exception innerException);
        /*0x221f7b8*/ IndexOutOfRangeException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class InsufficientExecutionStackException : System.SystemException
    {
        /*0x221f7c0*/ InsufficientExecutionStackException();
        /*0x221f81c*/ InsufficientExecutionStackException(string message);
        /*0x221f840*/ InsufficientExecutionStackException(string message, System.Exception innerException);
        /*0x221f864*/ InsufficientExecutionStackException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct Int16 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<short>, System.IEquatable<short>, System.ISpanFormattable
    {
        static short MaxValue = 32767;
        static short MinValue = -32768;
        /*0x10*/ short m_value;

        static /*0x2220cb0*/ short Parse(string s);
        static /*0x2220ed8*/ short Parse(string s, System.Globalization.NumberStyles style);
        static /*0x2220f6c*/ short Parse(string s, System.IFormatProvider provider);
        static /*0x2220ff8*/ short Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x222109c*/ short Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x2220d34*/ short Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info);
        static /*0x22212c8*/ bool TryParse(string s, ref short result);
        static /*0x222140c*/ bool TryParse(System.ReadOnlySpan<char> s, ref short result);
        static /*0x2221448*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref short result);
        static /*0x22214f0*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref short result);
        static /*0x2221348*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref short result);
        /*0x221f86c*/ int CompareTo(object value);
        /*0x221f92c*/ int CompareTo(short value);
        /*0x221f938*/ bool Equals(object obj);
        /*0x221f9b0*/ bool Equals(short obj);
        /*0x221f9c0*/ int GetHashCode();
        /*0x221f9cc*/ string ToString();
        /*0x221fe20*/ string ToString(System.IFormatProvider provider);
        /*0x221feb8*/ string ToString(string format);
        /*0x221fec0*/ string ToString(string format, System.IFormatProvider provider);
        /*0x22203a4*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x22216d8*/ System.TypeCode GetTypeCode();
        /*0x22216e0*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x222173c*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x2221798*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x22217f4*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x2221850*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x2221858*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x22218b4*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x2221910*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x222196c*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x22219c8*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x2221a24*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x2221a80*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x2221adc*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x2221b38*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x2221be4*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct Int32 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<int>, System.IEquatable<int>, System.ISpanFormattable
    {
        static int MaxValue = 2147483647;
        static int MinValue = -2147483648;
        /*0x10*/ int m_value;

        static /*0x222213c*/ int Parse(string s);
        static /*0x22221fc*/ int Parse(string s, System.Globalization.NumberStyles style);
        static /*0x22222d4*/ int Parse(string s, System.IFormatProvider provider);
        static /*0x22223a4*/ int Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x2222484*/ int Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x2222520*/ bool TryParse(string s, ref int result);
        static /*0x22225f0*/ bool TryParse(System.ReadOnlySpan<char> s, ref int result);
        static /*0x2222674*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref int result);
        static /*0x2222768*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref int result);
        /*0x2221c90*/ int CompareTo(object value);
        /*0x2221d60*/ int CompareTo(int value);
        /*0x2221d7c*/ bool Equals(object obj);
        /*0x2221df4*/ bool Equals(int obj);
        /*0x2221e04*/ int GetHashCode();
        /*0x2221e0c*/ string ToString();
        /*0x2221ea0*/ string ToString(string format);
        /*0x2221f50*/ string ToString(System.IFormatProvider provider);
        /*0x2221fe8*/ string ToString(string format, System.IFormatProvider provider);
        /*0x222209c*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x222280c*/ System.TypeCode GetTypeCode();
        /*0x2222814*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x2222870*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x22228cc*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x2222928*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x2222984*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x22229e0*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x2222a3c*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x2222a44*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x2222aa0*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x2222afc*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x2222b58*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x2222bb4*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x2222c10*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x2222c6c*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x2222cf4*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct Int64 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<long>, System.IEquatable<long>, System.ISpanFormattable
    {
        static long MaxValue = 9223372036854775807;
        static long MinValue = -9223372036854775808;
        /*0x10*/ long m_value;

        static /*0x222384c*/ long Parse(string s);
        static /*0x2223ae8*/ long Parse(string s, System.Globalization.NumberStyles style);
        static /*0x2223bc0*/ long Parse(string s, System.IFormatProvider provider);
        static /*0x2223c90*/ long Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x2223d70*/ long Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x2223e0c*/ bool TryParse(string s, ref long result);
        static /*0x2224068*/ bool TryParse(System.ReadOnlySpan<char> s, ref long result);
        static /*0x22240ec*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref long result);
        static /*0x22241e0*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref long result);
        /*0x2222da0*/ int CompareTo(object value);
        /*0x2222e70*/ int CompareTo(long value);
        /*0x2222e8c*/ bool Equals(object obj);
        /*0x2222f04*/ bool Equals(long obj);
        /*0x2222f14*/ int GetHashCode();
        /*0x2222f20*/ string ToString();
        /*0x222327c*/ string ToString(System.IFormatProvider provider);
        /*0x2223314*/ string ToString(string format);
        /*0x22233c4*/ string ToString(string format, System.IFormatProvider provider);
        /*0x2223478*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x2224284*/ System.TypeCode GetTypeCode();
        /*0x222428c*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x22242e8*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x2224344*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x22243a0*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x22243fc*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x2224458*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x22244b4*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x2224510*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x222456c*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x2224574*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x22245d0*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x222462c*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x2224688*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x22246e4*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x222476c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class InvalidCastException : System.SystemException
    {
        /*0x2224818*/ InvalidCastException();
        /*0x2221bc0*/ InvalidCastException(string message);
        /*0x2224874*/ InvalidCastException(string message, System.Exception innerException);
        /*0x2224898*/ InvalidCastException(string message, int errorCode);
        /*0x22248c0*/ InvalidCastException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class InvalidOperationException : System.SystemException
    {
        /*0x22248c8*/ InvalidOperationException();
        /*0x2224924*/ InvalidOperationException(string message);
        /*0x2224948*/ InvalidOperationException(string message, System.Exception innerException);
        /*0x222496c*/ InvalidOperationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class InvalidProgramException : System.SystemException
    {
        /*0x2224974*/ InvalidProgramException();
        /*0x22249d0*/ InvalidProgramException(string message);
        /*0x22249f4*/ InvalidProgramException(string message, System.Exception inner);
        /*0x2224a18*/ InvalidProgramException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class InvalidTimeZoneException : System.Exception
    {
        /*0x2224a20*/ InvalidTimeZoneException();
        /*0x2224a78*/ InvalidTimeZoneException(string message);
        /*0x2224ae0*/ InvalidTimeZoneException(string message, System.Exception innerException);
        /*0x2224b50*/ InvalidTimeZoneException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    enum LazyState
    {
        NoneViaConstructor = 0,
        NoneViaFactory = 1,
        NoneException = 2,
        PublicationOnlyViaConstructor = 3,
        PublicationOnlyViaFactory = 4,
        PublicationOnlyWait = 5,
        PublicationOnlyException = 6,
        ExecutionAndPublicationViaConstructor = 7,
        ExecutionAndPublicationViaFactory = 8,
        ExecutionAndPublicationException = 9,
    }

    class LazyHelper
    {
        static /*0x0*/ System.LazyHelper NoneViaConstructor;
        static /*0x8*/ System.LazyHelper NoneViaFactory;
        static /*0x10*/ System.LazyHelper PublicationOnlyViaConstructor;
        static /*0x18*/ System.LazyHelper PublicationOnlyViaFactory;
        static /*0x20*/ System.LazyHelper PublicationOnlyWaitForOtherThreadToPublish;
        /*0x10*/ System.LazyState <State>k__BackingField;
        /*0x18*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo _exceptionDispatch;

        static /*0x2224f4c*/ LazyHelper();
        static /*0x2224c94*/ System.Nullable<System.Threading.LazyThreadSafetyMode> GetMode(System.LazyHelper state);
        static /*0x2224d1c*/ bool GetIsValueFaulted(System.LazyHelper state);
        static /*0x2224d30*/ System.LazyHelper Create(System.Threading.LazyThreadSafetyMode mode, bool useDefaultConstructor);
        static /*0x2224e70*/ object CreateViaDefaultConstructor(System.Type type);
        static /*0x2224f3c*/ System.Threading.LazyThreadSafetyMode GetModeFromIsThreadSafe(bool isThreadSafe);
        /*0x2224bd8*/ LazyHelper(System.LazyState state);
        /*0x2224c00*/ LazyHelper(System.Threading.LazyThreadSafetyMode mode, System.Exception exception);
        /*0x2224bd0*/ System.LazyState get_State();
        /*0x2224c50*/ void ThrowException();
        /*0x2224c6c*/ System.Threading.LazyThreadSafetyMode GetMode();
    }

    class Lazy<T>
    {
        /*0x0*/ System.LazyHelper _state;
        /*0x0*/ System.Func<T> _factory;
        /*0x0*/ T _value;

        static T CreateViaDefaultConstructor();
        Lazy();
        Lazy(T value);
        Lazy(System.Func<T> valueFactory);
        Lazy(bool isThreadSafe);
        Lazy(System.Threading.LazyThreadSafetyMode mode);
        Lazy(System.Func<T> valueFactory, bool isThreadSafe);
        Lazy(System.Func<T> valueFactory, System.Threading.LazyThreadSafetyMode mode);
        Lazy(System.Func<T> valueFactory, System.Threading.LazyThreadSafetyMode mode, bool useDefaultConstructor);
        void ViaConstructor();
        void ViaFactory(System.Threading.LazyThreadSafetyMode mode);
        void ExecutionAndPublication(System.LazyHelper executionAndPublication, bool useDefaultConstructor);
        void PublicationOnly(System.LazyHelper publicationOnly, T possibleValue);
        void PublicationOnlyViaConstructor(System.LazyHelper initializer);
        void PublicationOnlyViaFactory(System.LazyHelper initializer);
        void PublicationOnlyWaitForOtherThreadToPublish();
        T CreateValue();
        string ToString();
        T get_ValueForDebugDisplay();
        System.Nullable<System.Threading.LazyThreadSafetyMode> get_Mode();
        bool get_IsValueFaulted();
        bool get_IsValueCreated();
        T get_Value();
    }

    class LazyDebugView<T>
    {
        /*0x0*/ System.Lazy<T> _lazy;

        LazyDebugView(System.Lazy<T> lazy);
        bool get_IsValueCreated();
        T get_Value();
        System.Nullable<System.Threading.LazyThreadSafetyMode> get_Mode();
        bool get_IsValueFaulted();
    }

    class Marvin
    {
        static /*0x0*/ ulong <DefaultSeed>k__BackingField;

        static /*0x22255cc*/ Marvin();
        static /*0x2225058*/ int ComputeHash32(System.ReadOnlySpan<byte> data, ulong seed);
        static /*0x2225104*/ int ComputeHash32(ref byte data, int count, ulong seed);
        static /*0x22254d4*/ void Block(ref uint rp0, ref uint rp1);
        static /*0x222555c*/ uint _rotl(uint value, int shift);
        static /*0x2225568*/ ulong get_DefaultSeed();
        static /*0x22255c0*/ ulong GenerateSeed();
    }

    class Math
    {
        static double E = 2.718281828459045;
        static double PI = 3.141592653589793;
        static int maxRoundingDigits = 15;
        static /*0x0*/ double doubleRoundLimit;
        static /*0x8*/ double[] roundPower10Double;

        static /*0x2227338*/ Math();
        static /*0x222561c*/ short Abs(short value);
        static /*0x22256d0*/ int Abs(int value);
        static /*0x222572c*/ long Abs(long value);
        static /*0x2225788*/ sbyte Abs(sbyte value);
        static /*0x22257ec*/ decimal Abs(decimal value);
        static /*0x2225680*/ void ThrowAbsOverflow();
        static /*0x2225870*/ long BigMul(int a, int b);
        static /*0x2225878*/ int DivRem(int a, int b, ref int result);
        static /*0x222588c*/ long DivRem(long a, long b, ref long result);
        static /*0x22258a0*/ uint DivRem(uint a, uint b, ref uint result);
        static /*0x22258b4*/ ulong DivRem(ulong a, ulong b, ref ulong result);
        static /*0x22258c8*/ decimal Ceiling(decimal d);
        static /*0x2225930*/ byte Clamp(byte value, byte min, byte max);
        static /*0x22259dc*/ decimal Clamp(decimal value, decimal min, decimal max);
        static /*0x2225b2c*/ double Clamp(double value, double min, double max);
        static /*0x2225bd0*/ short Clamp(short value, short min, short max);
        static /*0x2225c7c*/ int Clamp(int value, int min, int max);
        static /*0x2225d20*/ long Clamp(long value, long min, long max);
        static /*0x2225dc4*/ sbyte Clamp(sbyte value, sbyte min, sbyte max);
        static /*0x2225e70*/ float Clamp(float value, float min, float max);
        static /*0x2225f14*/ ushort Clamp(ushort value, ushort min, ushort max);
        static /*0x2225fc0*/ uint Clamp(uint value, uint min, uint max);
        static /*0x2226064*/ ulong Clamp(ulong value, ulong min, ulong max);
        static /*0x2226108*/ decimal Floor(decimal d);
        static /*0x2226170*/ double IEEERemainder(double x, double y);
        static /*0x2226468*/ double Log(double a, double newBase);
        static /*0x22265b8*/ byte Max(byte val1, byte val2);
        static /*0x22265c8*/ decimal Max(decimal val1, decimal val2);
        static /*0x2226660*/ double Max(double val1, double val2);
        static /*0x22266d8*/ short Max(short val1, short val2);
        static /*0x22266e8*/ int Max(int val1, int val2);
        static /*0x22266f4*/ long Max(long val1, long val2);
        static /*0x2226700*/ sbyte Max(sbyte val1, sbyte val2);
        static /*0x2226710*/ float Max(float val1, float val2);
        static /*0x2226788*/ ushort Max(ushort val1, ushort val2);
        static /*0x2226798*/ uint Max(uint val1, uint val2);
        static /*0x22267a4*/ ulong Max(ulong val1, ulong val2);
        static /*0x22267b0*/ byte Min(byte val1, byte val2);
        static /*0x22267c0*/ decimal Min(decimal val1, decimal val2);
        static /*0x2226858*/ double Min(double val1, double val2);
        static /*0x22268d0*/ short Min(short val1, short val2);
        static /*0x22268e0*/ int Min(int val1, int val2);
        static /*0x22268ec*/ long Min(long val1, long val2);
        static /*0x22268f8*/ sbyte Min(sbyte val1, sbyte val2);
        static /*0x2226908*/ float Min(float val1, float val2);
        static /*0x2226980*/ ushort Min(ushort val1, ushort val2);
        static /*0x2226990*/ uint Min(uint val1, uint val2);
        static /*0x222699c*/ ulong Min(ulong val1, ulong val2);
        static /*0x22269a8*/ decimal Round(decimal d);
        static /*0x2226a14*/ decimal Round(decimal d, int decimals);
        static /*0x2226a84*/ decimal Round(decimal d, System.MidpointRounding mode);
        static /*0x2226af8*/ decimal Round(decimal d, int decimals, System.MidpointRounding mode);
        static /*0x2226b78*/ double Round(double a);
        static /*0x2226bfc*/ double Round(double value, int digits);
        static /*0x2226f10*/ double Round(double value, System.MidpointRounding mode);
        static /*0x2226c64*/ double Round(double value, int digits, System.MidpointRounding mode);
        static /*0x2226f7c*/ int Sign(decimal value);
        static /*0x22263ec*/ int Sign(double value);
        static /*0x2227000*/ int Sign(short value);
        static /*0x2227064*/ int Sign(int value);
        static /*0x2227074*/ int Sign(long value);
        static /*0x2227088*/ int Sign(sbyte value);
        static /*0x22270ec*/ int Sign(float value);
        static /*0x2227168*/ decimal Truncate(decimal d);
        static /*0x22271d0*/ double Truncate(double d);
        static /*0x222723c*/ double copysign(double x, double y);
        static void ThrowMinMaxException<T>(T min, T max);
        static /*0x22272c4*/ double Abs(double value);
        static /*0x22272cc*/ float Abs(float value);
        static /*0x22272d4*/ double Acos(double d);
        static /*0x22272d8*/ double Acosh(double d);
        static /*0x22272dc*/ double Asin(double d);
        static /*0x22272e0*/ double Asinh(double d);
        static /*0x22272e4*/ double Atan(double d);
        static /*0x22272e8*/ double Atan2(double y, double x);
        static /*0x22272ec*/ double Atanh(double d);
        static /*0x22272f0*/ double Cbrt(double d);
        static /*0x22272f4*/ double Ceiling(double a);
        static /*0x22272fc*/ double Cos(double d);
        static /*0x2227300*/ double Cosh(double value);
        static /*0x2227304*/ double Exp(double d);
        static /*0x2227308*/ double Floor(double d);
        static /*0x2227310*/ double Log(double d);
        static /*0x2227314*/ double Log10(double d);
        static /*0x2227318*/ double Pow(double x, double y);
        static /*0x222731c*/ double Sin(double a);
        static /*0x2227320*/ double Sinh(double value);
        static /*0x2227324*/ double Sqrt(double d);
        static /*0x222732c*/ double Tan(double a);
        static /*0x2227330*/ double Tanh(double value);
        static /*0x2227334*/ double FMod(double x, double y);
        static /*0x2226f78*/ double ModF(double x, double* intptr);
    }

    class MathF
    {
        static float E = 2.7182817459106445;
        static float PI = 3.1415927410125732;
        static int maxRoundingDigits = 6;
        static /*0x0*/ float[] roundPower10Single;
        static /*0x8*/ float singleRoundLimit;

        static /*0x2228058*/ MathF();
        static /*0x22273e8*/ float Abs(float x);
        static /*0x2227444*/ float IEEERemainder(float x, float y);
        static /*0x2227704*/ float Log(float x, float y);
        static /*0x2227854*/ float Max(float x, float y);
        static /*0x22278b8*/ float Min(float x, float y);
        static /*0x222791c*/ float Round(float x);
        static /*0x2227a8c*/ float Round(float x, int digits);
        static /*0x2227de8*/ float Round(float x, System.MidpointRounding mode);
        static /*0x2227af4*/ float Round(float x, int digits, System.MidpointRounding mode);
        static /*0x2227e50*/ int Sign(float x);
        static /*0x2227eac*/ float Truncate(float x);
        static /*0x2227a04*/ float CopySign(float x, float y);
        static /*0x2227f20*/ float Acos(float x);
        static /*0x2227f24*/ float Acosh(float x);
        static /*0x2227f5c*/ float Asin(float x);
        static /*0x2227f60*/ float Asinh(float x);
        static /*0x2227f98*/ float Atan(float x);
        static /*0x2227f9c*/ float Atan2(float y, float x);
        static /*0x2227fa0*/ float Atanh(float x);
        static /*0x2227fd8*/ float Cbrt(float x);
        static /*0x2228010*/ float Ceiling(float x);
        static /*0x2228018*/ float Cos(float x);
        static /*0x222801c*/ float Cosh(float x);
        static /*0x2228020*/ float Exp(float x);
        static /*0x2228024*/ float Floor(float x);
        static /*0x222802c*/ float Log(float x);
        static /*0x2228030*/ float Log10(float x);
        static /*0x2228034*/ float Pow(float x, float y);
        static /*0x2228038*/ float Sin(float x);
        static /*0x222803c*/ float Sinh(float x);
        static /*0x2228040*/ float Sqrt(float x);
        static /*0x2228048*/ float Tan(float x);
        static /*0x222804c*/ float Tanh(float x);
        static /*0x2228050*/ float FMod(float x, float y);
        static /*0x2228054*/ float ModF(float x, float* intptr);
    }

    class MemberAccessException : System.SystemException
    {
        /*0x2228100*/ MemberAccessException();
        /*0x222815c*/ MemberAccessException(string message);
        /*0x2228180*/ MemberAccessException(string message, System.Exception inner);
        /*0x22281a4*/ MemberAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct Memory<T> : System.IEquatable<System.Memory<T>>
    {
        static int RemoveFlagsBitMask = 2147483647;
        /*0x0*/ object _object;
        /*0x0*/ int _index;
        /*0x0*/ int _length;

        static System.Memory<T> op_Implicit(T[] array);
        static System.Memory<T> op_Implicit(System.ArraySegment<T> segment);
        static System.ReadOnlyMemory<T> op_Implicit(System.Memory<T> memory);
        static System.Memory<T> get_Empty();
        static int CombineHashCodes(int left, int right);
        static int CombineHashCodes(int h1, int h2, int h3);
        Memory(T[] array);
        Memory(T[] array, int start);
        Memory(T[] array, int start, int length);
        Memory(System.Buffers.MemoryManager<T> manager, int length);
        Memory(System.Buffers.MemoryManager<T> manager, int start, int length);
        Memory(object obj, int start, int length);
        int get_Length();
        bool get_IsEmpty();
        string ToString();
        System.Memory<T> Slice(int start);
        System.Memory<T> Slice(int start, int length);
        System.Span<T> get_Span();
        void CopyTo(System.Memory<T> destination);
        bool TryCopyTo(System.Memory<T> destination);
        System.Buffers.MemoryHandle Pin();
        T[] ToArray();
        bool Equals(object obj);
        bool Equals(System.Memory<T> other);
        int GetHashCode();
    }

    class MemoryDebugView<T>
    {
        /*0x0*/ System.ReadOnlyMemory<T> _memory;

        MemoryDebugView(System.Memory<T> memory);
        MemoryDebugView(System.ReadOnlyMemory<T> memory);
        T[] get_Items();
    }

    class MemoryExtensions
    {
        static /*0x22281ac*/ bool Contains(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.StringComparison comparisonType);
        static /*0x22283c0*/ bool Equals(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> other, System.StringComparison comparisonType);
        static /*0x22286b4*/ bool EqualsOrdinal(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value);
        static /*0x22287e8*/ bool EqualsOrdinalIgnoreCase(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value);
        static /*0x2228894*/ bool Contains(System.ReadOnlySpan<char> source, char value);
        static /*0x222890c*/ int CompareTo(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> other, System.StringComparison comparisonType);
        static /*0x22281c4*/ int IndexOf(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.StringComparison comparisonType);
        static /*0x2228b84*/ int ToLower(System.ReadOnlySpan<char> source, System.Span<char> destination, System.Globalization.CultureInfo culture);
        static /*0x2228cb8*/ int ToLowerInvariant(System.ReadOnlySpan<char> source, System.Span<char> destination);
        static /*0x2228e04*/ int ToUpper(System.ReadOnlySpan<char> source, System.Span<char> destination, System.Globalization.CultureInfo culture);
        static /*0x2228f48*/ int ToUpperInvariant(System.ReadOnlySpan<char> source, System.Span<char> destination);
        static /*0x22290a4*/ bool EndsWith(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.StringComparison comparisonType);
        static /*0x22293dc*/ bool StartsWith(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.StringComparison comparisonType);
        static System.Span<T> AsSpan<T>(T[] array, int start);
        static System.Span<T> AsSpan<T>(T[] array, System.Index startIndex);
        static System.Span<T> AsSpan<T>(T[] array, System.Range range);
        static /*0x2229700*/ System.ReadOnlySpan<char> AsSpan(string text);
        static /*0x2229758*/ System.ReadOnlySpan<char> AsSpan(string text, int start);
        static /*0x22297e4*/ System.ReadOnlySpan<char> AsSpan(string text, int start, int length);
        static /*0x2229884*/ System.ReadOnlyMemory<char> AsMemory(string text);
        static /*0x22298d4*/ System.ReadOnlyMemory<char> AsMemory(string text, int start);
        static /*0x222995c*/ System.ReadOnlyMemory<char> AsMemory(string text, System.Index startIndex);
        static /*0x22299ec*/ System.ReadOnlyMemory<char> AsMemory(string text, int start, int length);
        static /*0x2229a84*/ System.ReadOnlyMemory<char> AsMemory(string text, System.Range range);
        static /*0x2229b80*/ System.ReadOnlySpan<char> Trim(System.ReadOnlySpan<char> span);
        static /*0x2229b90*/ System.ReadOnlySpan<char> TrimStart(System.ReadOnlySpan<char> span);
        static /*0x2229c84*/ System.ReadOnlySpan<char> TrimEnd(System.ReadOnlySpan<char> span);
        static /*0x2229d78*/ System.ReadOnlySpan<char> Trim(System.ReadOnlySpan<char> span, char trimChar);
        static /*0x2229d90*/ System.ReadOnlySpan<char> TrimStart(System.ReadOnlySpan<char> span, char trimChar);
        static /*0x2229e50*/ System.ReadOnlySpan<char> TrimEnd(System.ReadOnlySpan<char> span, char trimChar);
        static /*0x2229f04*/ System.ReadOnlySpan<char> Trim(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> trimChars);
        static /*0x2229f2c*/ System.ReadOnlySpan<char> TrimStart(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> trimChars);
        static /*0x222a058*/ System.ReadOnlySpan<char> TrimEnd(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> trimChars);
        static /*0x222a194*/ bool IsWhiteSpace(System.ReadOnlySpan<char> span);
        static int IndexOf<T>(System.Span<T> span, T value);
        static int IndexOf<T>(System.Span<T> span, System.ReadOnlySpan<T> value);
        static int LastIndexOf<T>(System.Span<T> span, T value);
        static int LastIndexOf<T>(System.Span<T> span, System.ReadOnlySpan<T> value);
        static bool SequenceEqual<T>(System.Span<T> span, System.ReadOnlySpan<T> other);
        static int SequenceCompareTo<T>(System.Span<T> span, System.ReadOnlySpan<T> other);
        static int IndexOf<T>(System.ReadOnlySpan<T> span, T value);
        static int IndexOf<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> value);
        static int LastIndexOf<T>(System.ReadOnlySpan<T> span, T value);
        static int LastIndexOf<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> value);
        static int IndexOfAny<T>(System.Span<T> span, T value0, T value1);
        static int IndexOfAny<T>(System.Span<T> span, T value0, T value1, T value2);
        static int IndexOfAny<T>(System.Span<T> span, System.ReadOnlySpan<T> values);
        static int IndexOfAny<T>(System.ReadOnlySpan<T> span, T value0, T value1);
        static int IndexOfAny<T>(System.ReadOnlySpan<T> span, T value0, T value1, T value2);
        static int IndexOfAny<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> values);
        static int LastIndexOfAny<T>(System.Span<T> span, T value0, T value1);
        static int LastIndexOfAny<T>(System.Span<T> span, T value0, T value1, T value2);
        static int LastIndexOfAny<T>(System.Span<T> span, System.ReadOnlySpan<T> values);
        static int LastIndexOfAny<T>(System.ReadOnlySpan<T> span, T value0, T value1);
        static int LastIndexOfAny<T>(System.ReadOnlySpan<T> span, T value0, T value1, T value2);
        static int LastIndexOfAny<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> values);
        static bool SequenceEqual<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> other);
        static int SequenceCompareTo<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> other);
        static bool StartsWith<T>(System.Span<T> span, System.ReadOnlySpan<T> value);
        static bool StartsWith<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> value);
        static bool EndsWith<T>(System.Span<T> span, System.ReadOnlySpan<T> value);
        static bool EndsWith<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> value);
        static void Reverse<T>(System.Span<T> span);
        static System.Span<T> AsSpan<T>(T[] array);
        static System.Span<T> AsSpan<T>(T[] array, int start, int length);
        static System.Span<T> AsSpan<T>(System.ArraySegment<T> segment);
        static System.Span<T> AsSpan<T>(System.ArraySegment<T> segment, int start);
        static System.Span<T> AsSpan<T>(System.ArraySegment<T> segment, System.Index startIndex);
        static System.Span<T> AsSpan<T>(System.ArraySegment<T> segment, int start, int length);
        static System.Span<T> AsSpan<T>(System.ArraySegment<T> segment, System.Range range);
        static System.Memory<T> AsMemory<T>(T[] array);
        static System.Memory<T> AsMemory<T>(T[] array, int start);
        static System.Memory<T> AsMemory<T>(T[] array, System.Index startIndex);
        static System.Memory<T> AsMemory<T>(T[] array, int start, int length);
        static System.Memory<T> AsMemory<T>(T[] array, System.Range range);
        static System.Memory<T> AsMemory<T>(System.ArraySegment<T> segment);
        static System.Memory<T> AsMemory<T>(System.ArraySegment<T> segment, int start);
        static System.Memory<T> AsMemory<T>(System.ArraySegment<T> segment, int start, int length);
        static void CopyTo<T>(T[] source, System.Span<T> destination);
        static void CopyTo<T>(T[] source, System.Memory<T> destination);
        static bool Overlaps<T>(System.Span<T> span, System.ReadOnlySpan<T> other);
        static bool Overlaps<T>(System.Span<T> span, System.ReadOnlySpan<T> other, ref int elementOffset);
        static bool Overlaps<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> other);
        static bool Overlaps<T>(System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> other, ref int elementOffset);
        static int BinarySearch<T>(System.Span<T> span, System.IComparable<T> comparable);
        static int BinarySearch<T, TComparable>(System.Span<T> span, TComparable comparable);
        static int BinarySearch<T, TComparer>(System.Span<T> span, T value, TComparer comparer);
        static int BinarySearch<T>(System.ReadOnlySpan<T> span, System.IComparable<T> comparable);
        static int BinarySearch<T, TComparable>(System.ReadOnlySpan<T> span, TComparable comparable);
        static int BinarySearch<T, TComparer>(System.ReadOnlySpan<T> span, T value, TComparer comparer);
        static bool IsTypeComparableAsBytes<T>(ref ulong size);
    }

    class MethodAccessException : System.MemberAccessException
    {
        /*0x222a234*/ MethodAccessException();
        /*0x222a290*/ MethodAccessException(string message);
        /*0x222a2b4*/ MethodAccessException(string message, System.Exception inner);
        /*0x222a2d8*/ MethodAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    enum MidpointRounding
    {
        ToEven = 0,
        AwayFromZero = 1,
    }

    class MissingMethodException : System.MissingMemberException
    {
        /*0x222a2e0*/ MissingMethodException();
        /*0x222a33c*/ MissingMethodException(string message);
        /*0x222a360*/ MissingMethodException(string message, System.Exception inner);
        /*0x222a384*/ MissingMethodException(string className, string methodName);
        /*0x222a3b0*/ MissingMethodException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x222a3b8*/ string get_Message();
    }

    class MulticastNotSupportedException : System.SystemException
    {
        /*0x222a4e4*/ MulticastNotSupportedException();
        /*0x222a540*/ MulticastNotSupportedException(string message);
        /*0x222a564*/ MulticastNotSupportedException(string message, System.Exception inner);
        /*0x222a588*/ MulticastNotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class NonSerializedAttribute : System.Attribute
    {
        /*0x222a590*/ NonSerializedAttribute();
    }

    class NotFiniteNumberException : System.ArithmeticException
    {
        /*0x90*/ double _offendingNumber;

        /*0x222a598*/ NotFiniteNumberException();
        /*0x222a5f8*/ NotFiniteNumberException(double offendingNumber);
        /*0x222a62c*/ NotFiniteNumberException(string message);
        /*0x222a654*/ NotFiniteNumberException(string message, double offendingNumber);
        /*0x222a688*/ NotFiniteNumberException(string message, System.Exception innerException);
        /*0x222a6ac*/ NotFiniteNumberException(string message, double offendingNumber, System.Exception innerException);
        /*0x222a6e0*/ NotFiniteNumberException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x222a76c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x222a880*/ double get_OffendingNumber();
    }

    class NotImplementedException : System.SystemException
    {
        /*0x222a888*/ NotImplementedException();
        /*0x222a8e4*/ NotImplementedException(string message);
        /*0x222a908*/ NotImplementedException(string message, System.Exception inner);
        /*0x222a92c*/ NotImplementedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class NotSupportedException : System.SystemException
    {
        /*0x222a934*/ NotSupportedException();
        /*0x221f314*/ NotSupportedException(string message);
        /*0x222a990*/ NotSupportedException(string message, System.Exception innerException);
        /*0x222a9b4*/ NotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class NullReferenceException : System.SystemException
    {
        /*0x222a9bc*/ NullReferenceException();
        /*0x222aa18*/ NullReferenceException(string message);
        /*0x222aa3c*/ NullReferenceException(string message, System.Exception innerException);
        /*0x222aa60*/ NullReferenceException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct Nullable<T>
    {
        /*0x0*/ bool hasValue;
        /*0x0*/ T value;

        static System.Nullable<T> op_Implicit(T value);
        static T op_Explicit(System.Nullable<T> value);
        static object Box(System.Nullable<T> o);
        static System.Nullable<T> Unbox(object o);
        static System.Nullable<T> UnboxExact(object o);
        Nullable(T value);
        bool get_HasValue();
        T get_Value();
        T GetValueOrDefault();
        T GetValueOrDefault(T defaultValue);
        bool Equals(object other);
        int GetHashCode();
        string ToString();
    }

    class Nullable
    {
        static int Compare<T>(System.Nullable<T> n1, System.Nullable<T> n2);
        static bool Equals<T>(System.Nullable<T> n1, System.Nullable<T> n2);
        static /*0x222aa68*/ System.Type GetUnderlyingType(System.Type nullableType);
    }

    class Number
    {
        static int DecimalPrecision = 29;
        static int FloatPrecision = 7;
        static int DoublePrecision = 15;
        static int ScaleNAN = -2147483648;
        static int ScaleINF = 2147483647;
        static int MaxUInt32DecDigits = 10;
        static int CharStackBufferSize = 32;
        static string PosNumberFormat = "#";
        static int NumberMaxDigits = 50;
        static int Int32Precision = 10;
        static int UInt32Precision = 10;
        static int Int64Precision = 19;
        static int UInt64Precision = 20;
        static int _CVTBUFSIZE = 349;
        static int MAX_BUFFER_SIZE = 50;
        static /*0x0*/ string[] s_posCurrencyFormats;
        static /*0x8*/ string[] s_negCurrencyFormats;
        static /*0x10*/ string[] s_posPercentFormats;
        static /*0x18*/ string[] s_negPercentFormats;
        static /*0x20*/ string[] s_negNumberFormats;
        static /*0x28*/ int[] s_charToHexLookup;
        static /*0x30*/ ulong[] s_rgval64Power10;
        static /*0x38*/ sbyte[] s_rgexp64Power10;
        static /*0x40*/ ulong[] s_rgval64Power10By16;
        static /*0x48*/ short[] s_rgexp64Power10By16;

        static /*0x2236894*/ Number();
        static /*0x222abb8*/ string FormatDecimal(decimal value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info);
        static /*0x222c788*/ bool TryFormatDecimal(decimal value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info, System.Span<char> destination, ref int charsWritten);
        static /*0x222aed8*/ void DecimalToNumber(decimal value, ref System.Number.NumberBuffer number);
        static /*0x222c9e0*/ string FormatDouble(double value, string format, System.Globalization.NumberFormatInfo info);
        static /*0x222ce24*/ bool TryFormatDouble(double value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info, System.Span<char> destination, ref int charsWritten);
        static /*0x222cb40*/ string FormatDouble(ref System.Text.ValueStringBuilder sb, double value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info);
        static /*0x222d9e0*/ string FormatSingle(float value, string format, System.Globalization.NumberFormatInfo info);
        static /*0x222de30*/ bool TryFormatSingle(float value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info, System.Span<char> destination, ref int charsWritten);
        static /*0x222db40*/ string FormatSingle(ref System.Text.ValueStringBuilder sb, float value, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info);
        static /*0x222cfa0*/ bool TryCopyTo(string source, System.Span<char> destination, ref int charsWritten);
        static /*0x221fa60*/ string FormatInt32(int value, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x2220890*/ bool TryFormatInt32(int value, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Span<char> destination, ref int charsWritten);
        static /*0x2220034*/ string FormatUInt32(uint value, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x22204b8*/ bool TryFormatUInt32(uint value, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Span<char> destination, ref int charsWritten);
        static /*0x2222fb4*/ string FormatInt64(long value, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x2223518*/ bool TryFormatInt64(long value, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Span<char> destination, ref int charsWritten);
        static /*0x222f918*/ string FormatUInt64(ulong value, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        static /*0x222fd3c*/ bool TryFormatUInt64(ulong value, System.ReadOnlySpan<char> format, System.IFormatProvider provider, System.Span<char> destination, ref int charsWritten);
        static /*0x2230018*/ void Int32ToNumber(int value, ref System.Number.NumberBuffer number);
        static /*0x222e13c*/ string NegativeInt32ToDecStr(int value, int digits, string sNegative);
        static /*0x222e5e4*/ bool TryNegativeInt32ToDecStr(int value, int digits, string sNegative, System.Span<char> destination, ref int charsWritten);
        static /*0x222e2e8*/ string Int32ToHexStr(int value, char hexBase, int digits);
        static /*0x222e7cc*/ bool TryInt32ToHexStr(int value, char hexBase, int digits, System.Span<char> destination, ref int charsWritten);
        static /*0x2230144*/ char* Int32ToHexChars(char* buffer, uint value, int hexBase, int digits);
        static /*0x2230184*/ void UInt32ToNumber(uint value, ref System.Number.NumberBuffer number);
        static /*0x222c994*/ char* UInt32ToDecChars(char* bufferEnd, uint value, int digits);
        static /*0x222dfac*/ string UInt32ToDecStr(uint value, int digits);
        static /*0x222e420*/ bool TryUInt32ToDecStr(uint value, int digits, System.Span<char> destination, ref int charsWritten);
        static /*0x223029c*/ bool TryCopyTo(char* src, int length, System.Span<char> destination, ref int charsWritten);
        static /*0x222f024*/ void Int64ToNumber(long input, ref System.Number.NumberBuffer number);
        static /*0x222eb98*/ string NegativeInt64ToDecStr(long input, int digits, string sNegative);
        static /*0x222f450*/ bool TryNegativeInt64ToDecStr(long input, int digits, string sNegative, System.Span<char> destination, ref int charsWritten);
        static /*0x222ee38*/ string Int64ToHexStr(long value, char hexBase, int digits);
        static /*0x222f714*/ bool TryInt64ToHexStr(long value, char hexBase, int digits, System.Span<char> destination, ref int charsWritten);
        static /*0x222fba8*/ void UInt64ToNumber(ulong value, ref System.Number.NumberBuffer number);
        static /*0x222e940*/ string UInt64ToDecStr(ulong value, int digits);
        static /*0x222f1cc*/ bool TryUInt64ToDecStr(ulong value, int digits, System.Span<char> destination, ref int charsWritten);
        static /*0x222ad98*/ char ParseFormatSpecifier(System.ReadOnlySpan<char> format, ref int digits);
        static /*0x222b0f0*/ void NumberToString(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, char format, int nMaxDigits, System.Globalization.NumberFormatInfo info, bool isDecimal);
        static /*0x222b670*/ void NumberToStringFormat(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, System.ReadOnlySpan<char> format, System.Globalization.NumberFormatInfo info);
        static /*0x22304b0*/ void FormatCurrency(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info);
        static /*0x2230718*/ void FormatFixed(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info, int[] groupDigits, string sDecimal, string sGroup);
        static /*0x2230c58*/ void FormatNumber(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info);
        static /*0x2230eac*/ void FormatScientific(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info, char expChar);
        static /*0x2231858*/ void FormatExponent(ref System.Text.ValueStringBuilder sb, System.Globalization.NumberFormatInfo info, int value, char expChar, int minDigits, bool positiveSign);
        static /*0x2231104*/ void FormatGeneral(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info, char expChar, bool bSuppressScientific);
        static /*0x22314bc*/ void FormatPercent(ref System.Text.ValueStringBuilder sb, ref System.Number.NumberBuffer number, int nMinDigits, int nMaxDigits, System.Globalization.NumberFormatInfo info);
        static /*0x22303b0*/ void RoundNumber(ref System.Number.NumberBuffer number, int pos);
        static /*0x2231724*/ int FindSection(System.ReadOnlySpan<char> format, int section);
        static /*0x22303ac*/ uint Low32(ulong value);
        static /*0x22303a4*/ uint High32(ulong value);
        static /*0x223036c*/ uint Int64DivMod1E9(ref ulong value);
        static /*0x2231b00*/ bool NumberToInt32(ref System.Number.NumberBuffer number, ref int value);
        static /*0x2231bbc*/ bool NumberToInt64(ref System.Number.NumberBuffer number, ref long value);
        static /*0x2231c70*/ bool NumberToUInt32(ref System.Number.NumberBuffer number, ref uint value);
        static /*0x2231d20*/ bool NumberToUInt64(ref System.Number.NumberBuffer number, ref ulong value);
        static /*0x22210f0*/ int ParseInt32(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x222390c*/ long ParseInt64(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x2233580*/ uint ParseUInt32(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x2233ed8*/ ulong ParseUInt64(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x223483c*/ bool ParseNumber(ref char* str, char* strEnd, System.Globalization.NumberStyles styles, ref System.Number.NumberBuffer number, System.Globalization.NumberFormatInfo info, bool parseDecimal);
        static /*0x222154c*/ bool TryParseInt32(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref int result);
        static /*0x2231dd0*/ bool TryParseInt32IntegerStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref int result, ref bool failureIsOverflow);
        static /*0x2232a88*/ bool TryParseInt64IntegerStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref long result, ref bool failureIsOverflow);
        static /*0x2223edc*/ bool TryParseInt64(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref long result);
        static /*0x22351a0*/ bool TryParseUInt32(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref uint result);
        static /*0x2233738*/ bool TryParseUInt32IntegerStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref uint result, ref bool failureIsOverflow);
        static /*0x223260c*/ bool TryParseUInt32HexNumberStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref uint result, ref bool failureIsOverflow);
        static /*0x223532c*/ bool TryParseUInt64(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref ulong result);
        static /*0x2234090*/ bool TryParseUInt64IntegerStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref ulong result, ref bool failureIsOverflow);
        static /*0x223323c*/ bool TryParseUInt64HexNumberStyle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref ulong result, ref bool failureIsOverflow);
        static /*0x22354b8*/ decimal ParseDecimal(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x22355c0*/ bool NumberBufferToDecimal(ref System.Number.NumberBuffer number, ref decimal value);
        static /*0x2235898*/ double ParseDouble(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x2235e98*/ float ParseSingle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info);
        static /*0x2236438*/ bool TryParseDecimal(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref decimal result);
        static /*0x223653c*/ bool TryParseDouble(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref double result);
        static /*0x2236640*/ bool TryParseSingle(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, System.Globalization.NumberFormatInfo info, ref float result);
        static /*0x2232950*/ void StringToNumber(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, ref System.Number.NumberBuffer number, System.Globalization.NumberFormatInfo info, bool parseDecimal);
        static /*0x2234ff4*/ bool TryStringToNumber(System.ReadOnlySpan<char> value, System.Globalization.NumberStyles styles, ref System.Number.NumberBuffer number, System.Globalization.NumberFormatInfo info, bool parseDecimal);
        static /*0x2235124*/ bool TrailingZeros(System.ReadOnlySpan<char> value, int index);
        static /*0x2234f60*/ char* MatchChars(char* p, char* pEnd, string value);
        static /*0x2234f44*/ bool IsWhite(int ch);
        static /*0x2234fe4*/ bool IsDigit(int ch);
        static /*0x2232578*/ void ThrowOverflowOrFormatException(bool overflow, string overflowResourceKey);
        static /*0x2235dc8*/ bool NumberBufferToDouble(ref System.Number.NumberBuffer number, ref double value);
        static /*0x22367b4*/ uint DigitsToInt(char* p, int count);
        static /*0x22367e8*/ ulong Mul32x32To64(uint a, uint b);
        static /*0x22367f0*/ ulong Mul64Lossy(ulong a, ulong b, ref int pexp);
        static /*0x2236888*/ int abs(int value);
        static /*0x222d4f8*/ double NumberToDouble(ref System.Number.NumberBuffer number);
        static /*0x222d07c*/ void DoubleToNumber(double value, int precision, ref System.Number.NumberBuffer number);

        struct NumberBuffer
        {
            /*0x10*/ int precision;
            /*0x14*/ int scale;
            /*0x18*/ int _sign;
            /*0x1c*/ System.Number.NumberBuffer.DigitsAndNullTerminator _digits;
            /*0x82*/ char* _allDigits;

            /*0x2238560*/ bool get_sign();
            /*0x2238570*/ void set_sign(bool value);
            /*0x223857c*/ char* get_digits();

            struct DigitsAndNullTerminator
            {
            }
        }
    }

    class ObjectDisposedException : System.InvalidOperationException
    {
        /*0x90*/ string _objectName;

        /*0x2238584*/ ObjectDisposedException();
        /*0x223861c*/ ObjectDisposedException(string objectName);
        /*0x22385e4*/ ObjectDisposedException(string objectName, string message);
        /*0x2238688*/ ObjectDisposedException(string message, System.Exception innerException);
        /*0x22386ac*/ ObjectDisposedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2238734*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2238924*/ string get_Message();
        /*0x223883c*/ string get_ObjectName();
    }

    class ObsoleteAttribute : System.Attribute
    {
        /*0x10*/ string _message;
        /*0x18*/ bool _error;

        /*0x22389f8*/ ObsoleteAttribute();
        /*0x2238a18*/ ObsoleteAttribute(string message);
        /*0x2238a44*/ ObsoleteAttribute(string message, bool error);
        /*0x2238a74*/ string get_Message();
        /*0x2238a7c*/ bool get_IsError();
    }

    class OperationCanceledException : System.SystemException
    {
        /*0x90*/ System.Threading.CancellationToken _cancellationToken;

        /*0x2238a94*/ OperationCanceledException();
        /*0x2238b64*/ OperationCanceledException(string message);
        /*0x2238b84*/ OperationCanceledException(string message, System.Exception innerException);
        /*0x2238c24*/ OperationCanceledException(System.Threading.CancellationToken token);
        /*0x2238c48*/ OperationCanceledException(string message, System.Threading.CancellationToken token);
        /*0x2238c78*/ OperationCanceledException(string message, System.Exception innerException, System.Threading.CancellationToken token);
        /*0x2238ca8*/ OperationCanceledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2238a84*/ System.Threading.CancellationToken get_CancellationToken();
        /*0x2238a8c*/ void set_CancellationToken(System.Threading.CancellationToken value);
    }

    class OverflowException : System.ArithmeticException
    {
        /*0x2238d2c*/ OverflowException();
        /*0x2238d88*/ OverflowException(string message);
        /*0x2238dac*/ OverflowException(string message, System.Exception innerException);
        /*0x2238dd0*/ OverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class ParamArrayAttribute : System.Attribute
    {
        /*0x2238dd8*/ ParamArrayAttribute();
    }

    struct ParamsArray
    {
        static /*0x0*/ object[] s_oneArgArray;
        static /*0x8*/ object[] s_twoArgArray;
        static /*0x10*/ object[] s_threeArgArray;
        /*0x10*/ object _arg0;
        /*0x18*/ object _arg1;
        /*0x20*/ object _arg2;
        /*0x28*/ object[] _args;

        static /*0x2239030*/ ParamsArray();
        /*0x2238de0*/ ParamsArray(object arg0);
        /*0x2238e54*/ ParamsArray(object arg0, object arg1);
        /*0x2238ecc*/ ParamsArray(object arg0, object arg1, object arg2);
        /*0x2238f50*/ ParamsArray(object[] args);
        /*0x2238fb0*/ int get_Length();
        /*0x2238fcc*/ object get_Item(int index);
        /*0x2238fdc*/ object GetAtSlow(int index);
    }

    class ParseNumbers
    {
        static int LeftAlign = 1;
        static int RightAlign = 4;
        static int PrefixSpace = 8;
        static int PrintSign = 16;
        static int PrintBase = 32;
        static int PrintAsI1 = 64;
        static int PrintAsI2 = 128;
        static int PrintAsI4 = 256;
        static int TreatAsUnsigned = 512;
        static int TreatAsI1 = 1024;
        static int TreatAsI2 = 2048;
        static int IsTight = 4096;
        static int NoSpace = 8192;
        static int PrintRadixBase = 16384;
        static int MinRadix = 2;
        static int MaxRadix = 36;

        static /*0x22390c8*/ long StringToLong(System.ReadOnlySpan<char> s, int radix, int flags);
        static /*0x22390e0*/ long StringToLong(System.ReadOnlySpan<char> s, int radix, int flags, ref int currPos);
        static /*0x2239704*/ int StringToInt(System.ReadOnlySpan<char> s, int radix, int flags);
        static /*0x223971c*/ int StringToInt(System.ReadOnlySpan<char> s, int radix, int flags, ref int currPos);
        static /*0x2239d0c*/ string IntToString(int n, int radix, int width, char paddingChar, int flags);
        static /*0x223a08c*/ string LongToString(long n, int radix, int width, char paddingChar, int flags);
        static /*0x2239450*/ void EatWhiteSpace(System.ReadOnlySpan<char> s, ref int i);
        static /*0x2239514*/ long GrabLongs(int radix, System.ReadOnlySpan<char> s, ref int i, bool isUnsigned);
        static /*0x2239ae8*/ int GrabInts(int radix, System.ReadOnlySpan<char> s, ref int i, bool isUnsigned);
        static /*0x223a520*/ void ThrowOverflowInt32Exception();
        static /*0x223a488*/ void ThrowOverflowInt64Exception();
        static /*0x223a56c*/ void ThrowOverflowUInt32Exception();
        static /*0x223a4d4*/ void ThrowOverflowUInt64Exception();
        static /*0x223a5b8*/ bool IsDigit(char c, int radix, ref int result);
    }

    class PlatformNotSupportedException : System.NotSupportedException
    {
        /*0x223a60c*/ PlatformNotSupportedException();
        /*0x223a668*/ PlatformNotSupportedException(string message);
        /*0x223a68c*/ PlatformNotSupportedException(string message, System.Exception inner);
        /*0x223a6b0*/ PlatformNotSupportedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class Progress<T> : System.IProgress<T>
    {
        /*0x0*/ System.Threading.SynchronizationContext _synchronizationContext;
        /*0x0*/ System.Action<T> _handler;
        /*0x0*/ System.Threading.SendOrPostCallback _invokeHandlers;
        /*0x0*/ System.EventHandler<T> ProgressChanged;

        Progress();
        Progress(System.Action<T> handler);
        void add_ProgressChanged(System.EventHandler<T> value);
        void remove_ProgressChanged(System.EventHandler<T> value);
        void OnReport(T value);
        void System.IProgress<T>.Report(T value);
        void InvokeHandlers(object state);
    }

    class ProgressStatics
    {
        static /*0x0*/ System.Threading.SynchronizationContext DefaultContext;

        static /*0x223a6b8*/ ProgressStatics();
    }

    class Random
    {
        static int MBIG = 2147483647;
        static int MSEED = 161803398;
        static int MZ = 0;
        static /*0x0*/ System.Random s_globalRandom;
        [ThreadStatic] static System.Random t_threadRandom;
        /*0x10*/ int _inext;
        /*0x14*/ int _inextp;
        /*0x18*/ int[] _seedArray;

        static /*0x223af30*/ Random();
        static /*0x223a78c*/ int GenerateSeed();
        static /*0x223abac*/ int GenerateGlobalSeed();
        /*0x223a730*/ Random();
        /*0x223a94c*/ Random(int Seed);
        /*0x223aafc*/ double Sample();
        /*0x223ab1c*/ int InternalSample();
        /*0x223abd0*/ int Next();
        /*0x223abd4*/ double GetSampleForLargeRange();
        /*0x223ac20*/ int Next(int minValue, int maxValue);
        /*0x223ad3c*/ int Next(int maxValue);
        /*0x223ae04*/ double NextDouble();
        /*0x223ae10*/ void NextBytes(byte[] buffer);
        /*0x223aec0*/ void NextBytes(System.Span<byte> buffer);
    }

    struct Range : System.IEquatable<System.Range>
    {
        /*0x10*/ System.Index <Start>k__BackingField;
        /*0x14*/ System.Index <End>k__BackingField;

        static /*0x223b48c*/ System.Range StartAt(System.Index start);
        static /*0x223b4ac*/ System.Range EndAt(System.Index end);
        static /*0x223b4c8*/ System.Range get_All();
        /*0x223afc4*/ Range(System.Index start, System.Index end);
        /*0x223afb4*/ System.Index get_Start();
        /*0x223afbc*/ System.Index get_End();
        /*0x223afcc*/ bool Equals(object value);
        /*0x223b078*/ bool Equals(System.Range other);
        /*0x223b0d0*/ int GetHashCode();
        /*0x223b148*/ string ToString();
        /*0x223b4f0*/ System.ValueTuple<int, int> GetOffsetAndLength(int length);
    }

    class RankException : System.SystemException
    {
        /*0x223b5d8*/ RankException();
        /*0x223b630*/ RankException(string message);
        /*0x223b650*/ RankException(string message, System.Exception innerException);
        /*0x223b670*/ RankException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct ReadOnlyMemory<T> : System.IEquatable<System.ReadOnlyMemory<T>>
    {
        static int RemoveFlagsBitMask = 2147483647;
        /*0x0*/ object _object;
        /*0x0*/ int _index;
        /*0x0*/ int _length;

        static System.ReadOnlyMemory<T> op_Implicit(T[] array);
        static System.ReadOnlyMemory<T> op_Implicit(System.ArraySegment<T> segment);
        static System.ReadOnlyMemory<T> get_Empty();
        static int CombineHashCodes(int left, int right);
        static int CombineHashCodes(int h1, int h2, int h3);
        ReadOnlyMemory(T[] array);
        ReadOnlyMemory(T[] array, int start, int length);
        ReadOnlyMemory(object obj, int start, int length);
        int get_Length();
        bool get_IsEmpty();
        string ToString();
        System.ReadOnlyMemory<T> Slice(int start);
        System.ReadOnlyMemory<T> Slice(int start, int length);
        System.ReadOnlySpan<T> get_Span();
        void CopyTo(System.Memory<T> destination);
        bool TryCopyTo(System.Memory<T> destination);
        System.Buffers.MemoryHandle Pin();
        T[] ToArray();
        bool Equals(object obj);
        bool Equals(System.ReadOnlyMemory<T> other);
        int GetHashCode();
        object GetObjectStartLength(ref int start, ref int length);
    }

    struct ReadOnlySpan<T>
    {
        /*0x0*/ System.ByReference<T> _pointer;
        /*0x0*/ int _length;

        static bool op_Equality(System.ReadOnlySpan<T> left, System.ReadOnlySpan<T> right);
        static bool op_Inequality(System.ReadOnlySpan<T> left, System.ReadOnlySpan<T> right);
        static System.ReadOnlySpan<T> op_Implicit(T[] array);
        static System.ReadOnlySpan<T> op_Implicit(System.ArraySegment<T> segment);
        static System.ReadOnlySpan<T> get_Empty();
        ReadOnlySpan(T[] array);
        ReadOnlySpan(T[] array, int start, int length);
        ReadOnlySpan(void* pointer, int length);
        ReadOnlySpan(ref T ptr, int length);
        ref T get_Item(int index);
        ref T GetPinnableReference();
        void CopyTo(System.Span<T> destination);
        bool TryCopyTo(System.Span<T> destination);
        string ToString();
        System.ReadOnlySpan<T> Slice(int start);
        System.ReadOnlySpan<T> Slice(int start, int length);
        T[] ToArray();
        int get_Length();
        bool get_IsEmpty();
        bool Equals(object obj);
        int GetHashCode();
        System.ReadOnlySpan.Enumerator<T> GetEnumerator();

        struct Enumerator<T>
        {
            /*0x0*/ System.ReadOnlySpan<T> _span;
            /*0x0*/ int _index;

            Enumerator(System.ReadOnlySpan<T> span);
        }
    }

    class ResolveEventArgs : System.EventArgs
    {
        /*0x10*/ string <Name>k__BackingField;
        /*0x18*/ System.Reflection.Assembly <RequestingAssembly>k__BackingField;

        /*0x223b674*/ ResolveEventArgs(string name);
        /*0x223b6e0*/ ResolveEventArgs(string name, System.Reflection.Assembly requestingAssembly);
        /*0x223b750*/ string get_Name();
        /*0x223b758*/ System.Reflection.Assembly get_RequestingAssembly();
    }

    class ResolveEventHandler : System.MulticastDelegate
    {
        /*0x223b760*/ ResolveEventHandler(object object, nint method);
        /*0x223b890*/ System.Reflection.Assembly Invoke(object sender, System.ResolveEventArgs args);
        /*0x223b8a4*/ System.IAsyncResult BeginInvoke(object sender, System.ResolveEventArgs args, System.AsyncCallback callback, object object);
        /*0x223b8cc*/ System.Reflection.Assembly EndInvoke(System.IAsyncResult result);
    }

    struct SByte : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<sbyte>, System.IEquatable<sbyte>, System.ISpanFormattable
    {
        static sbyte MaxValue = 127;
        static sbyte MinValue = -128;
        /*0x10*/ sbyte m_value;

        static /*0x223be0c*/ sbyte Parse(string s);
        static /*0x223c030*/ sbyte Parse(string s, System.Globalization.NumberStyles style);
        static /*0x223c0c4*/ sbyte Parse(string s, System.IFormatProvider provider);
        static /*0x223c150*/ sbyte Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x223c1f4*/ sbyte Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x223c248*/ sbyte Parse(string s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info);
        static /*0x223be90*/ sbyte Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info);
        static /*0x223c2cc*/ bool TryParse(string s, ref sbyte result);
        static /*0x223c414*/ bool TryParse(System.ReadOnlySpan<char> s, ref sbyte result);
        static /*0x223c450*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref sbyte result);
        static /*0x223c4f8*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref sbyte result);
        static /*0x223c34c*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref sbyte result);
        /*0x223b8d8*/ int CompareTo(object obj);
        /*0x223b998*/ int CompareTo(sbyte value);
        /*0x223b9a4*/ bool Equals(object obj);
        /*0x223ba1c*/ bool Equals(sbyte obj);
        /*0x223ba2c*/ int GetHashCode();
        /*0x223ba38*/ string ToString();
        /*0x223bad0*/ string ToString(System.IFormatProvider provider);
        /*0x223bb6c*/ string ToString(string format);
        /*0x223bb74*/ string ToString(string format, System.IFormatProvider provider);
        /*0x223bcf0*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x223c554*/ System.TypeCode GetTypeCode();
        /*0x223c55c*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x223c5b8*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x223c614*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x223c61c*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x223c678*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x223c6d4*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x223c730*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x223c738*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x223c794*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x223c7f0*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x223c84c*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x223c8a8*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x223c904*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x223c960*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x223c9ec*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class SerializableAttribute : System.Attribute
    {
        /*0x223ca98*/ SerializableAttribute();
    }

    struct Single : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<float>, System.IEquatable<float>, System.ISpanFormattable
    {
        static float MinValue = -3.4028234663852886e+38;
        static float Epsilon = 1.401298464324817e-45;
        static float MaxValue = 3.4028234663852886e+38;
        static float PositiveInfinity = Infinity;
        static float NegativeInfinity = -Infinity;
        static float NaN = NaN;
        static float NegativeZero = 0;
        /*0x10*/ float m_value;

        static /*0x223caa0*/ bool IsFinite(float f);
        static /*0x223cb08*/ bool IsInfinity(float f);
        static /*0x223cb74*/ bool IsNaN(float f);
        static /*0x223cbe0*/ bool IsNegative(float f);
        static /*0x223cc40*/ bool IsNegativeInfinity(float f);
        static /*0x223cc54*/ bool IsNormal(float f);
        static /*0x223ccd0*/ bool IsPositiveInfinity(float f);
        static /*0x223cce4*/ bool IsSubnormal(float f);
        static /*0x223cfc0*/ bool op_Equality(float left, float right);
        static /*0x223cfcc*/ bool op_Inequality(float left, float right);
        static /*0x223cfd8*/ bool op_LessThan(float left, float right);
        static /*0x223cfe4*/ bool op_GreaterThan(float left, float right);
        static /*0x223cff0*/ bool op_LessThanOrEqual(float left, float right);
        static /*0x223cffc*/ bool op_GreaterThanOrEqual(float left, float right);
        static /*0x223d538*/ float Parse(string s);
        static /*0x223d5fc*/ float Parse(string s, System.Globalization.NumberStyles style);
        static /*0x223d6d8*/ float Parse(string s, System.IFormatProvider provider);
        static /*0x223d7ac*/ float Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x223d890*/ float Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x223d930*/ bool TryParse(string s, ref float result);
        static /*0x223de54*/ bool TryParse(System.ReadOnlySpan<char> s, ref float result);
        static /*0x223de90*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref float result);
        static /*0x223df38*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref float result);
        static /*0x223d9b0*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref float result);
        /*0x223cd60*/ int CompareTo(object value);
        /*0x223cedc*/ int CompareTo(float value);
        /*0x223d008*/ bool Equals(object obj);
        /*0x223d120*/ bool Equals(float obj);
        /*0x223d1f0*/ int GetHashCode();
        /*0x223d258*/ string ToString();
        /*0x223d2d4*/ string ToString(System.IFormatProvider provider);
        /*0x223d360*/ string ToString(string format);
        /*0x223d3e8*/ string ToString(string format, System.IFormatProvider provider);
        /*0x223d478*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x223df94*/ System.TypeCode GetTypeCode();
        /*0x223df9c*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x223e000*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x223e08c*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x223e0f0*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x223e154*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x223e1b8*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x223e21c*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x223e280*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x223e2e4*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x223e348*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x223e3ac*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x223e3b4*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x223e418*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x223e47c*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x223e508*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct Span<T>
    {
        /*0x0*/ System.ByReference<T> _pointer;
        /*0x0*/ int _length;

        static bool op_Equality(System.Span<T> left, System.Span<T> right);
        static System.ReadOnlySpan<T> op_Implicit(System.Span<T> span);
        static bool op_Inequality(System.Span<T> left, System.Span<T> right);
        static System.Span<T> op_Implicit(T[] array);
        static System.Span<T> op_Implicit(System.ArraySegment<T> segment);
        static System.Span<T> get_Empty();
        Span(T[] array);
        Span(T[] array, int start, int length);
        Span(void* pointer, int length);
        Span(ref T ptr, int length);
        ref T get_Item(int index);
        ref T GetPinnableReference();
        void Clear();
        void Fill(T value);
        void CopyTo(System.Span<T> destination);
        bool TryCopyTo(System.Span<T> destination);
        string ToString();
        System.Span<T> Slice(int start);
        System.Span<T> Slice(int start, int length);
        T[] ToArray();
        int get_Length();
        bool get_IsEmpty();
        bool Equals(object obj);
        int GetHashCode();
        System.Span.Enumerator<T> GetEnumerator();

        struct Enumerator<T>
        {
            /*0x0*/ System.Span<T> _span;
            /*0x0*/ int _index;

            Enumerator(System.Span<T> span);
        }
    }

    class SpanDebugView<T>
    {
        /*0x0*/ T[] _array;

        SpanDebugView(System.Span<T> span);
        SpanDebugView(System.ReadOnlySpan<T> span);
        T[] get_Items();
    }

    class SpanHelpers
    {
        static ulong XorPowerOfTwoToHighChar = 4295098372;

        static int BinarySearch<T, TComparable>(System.ReadOnlySpan<T> span, TComparable comparable);
        static int BinarySearch<T, TComparable>(ref T spanStart, int length, TComparable comparable);
        static /*0x223e5b4*/ int IndexOf(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength);
        static /*0x223e918*/ int IndexOfAny(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength);
        static /*0x223e998*/ int LastIndexOfAny(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength);
        static /*0x223e680*/ int IndexOf(ref byte searchSpace, byte value, int length);
        static /*0x223ec8c*/ int LastIndexOf(ref byte searchSpace, int searchSpaceLength, ref byte value, int valueLength);
        static /*0x223ea08*/ int LastIndexOf(ref byte searchSpace, byte value, int length);
        static /*0x223ed7c*/ int IndexOfAny(ref byte searchSpace, byte value0, byte value1, int length);
        static /*0x223f080*/ int IndexOfAny(ref byte searchSpace, byte value0, byte value1, byte value2, int length);
        static /*0x223f3f8*/ int LastIndexOfAny(ref byte searchSpace, byte value0, byte value1, int length);
        static /*0x223f6e0*/ int LastIndexOfAny(ref byte searchSpace, byte value0, byte value1, byte value2, int length);
        static /*0x223fa34*/ bool SequenceEqual(ref byte first, ref byte second, ulong length);
        static /*0x223fbfc*/ int SequenceCompareTo(ref byte first, int firstLength, ref byte second, int secondLength);
        static /*0x223fda8*/ int SequenceCompareTo(ref char first, int firstLength, ref char second, int secondLength);
        static /*0x2240278*/ int IndexOf(ref char searchSpace, char value, int length);
        static /*0x22409b4*/ int LastIndexOf(ref char searchSpace, char value, int length);
        static /*0x2241098*/ int LocateFirstFoundChar(System.Numerics.Vector<ushort> match);
        static /*0x2241258*/ int LocateFirstFoundChar(ulong match);
        static /*0x2241278*/ int LocateLastFoundChar(System.Numerics.Vector<ushort> match);
        static /*0x2241438*/ int LocateLastFoundChar(ulong match);
        static int IndexOf<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength);
        static int IndexOf<T>(ref T searchSpace, T value, int length);
        static int IndexOfAny<T>(ref T searchSpace, T value0, T value1, int length);
        static int IndexOfAny<T>(ref T searchSpace, T value0, T value1, T value2, int length);
        static int IndexOfAny<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength);
        static int LastIndexOf<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength);
        static int LastIndexOf<T>(ref T searchSpace, T value, int length);
        static int LastIndexOfAny<T>(ref T searchSpace, T value0, T value1, int length);
        static int LastIndexOfAny<T>(ref T searchSpace, T value0, T value1, T value2, int length);
        static int LastIndexOfAny<T>(ref T searchSpace, int searchSpaceLength, ref T value, int valueLength);
        static bool SequenceEqual<T>(ref T first, ref T second, int length);
        static int SequenceCompareTo<T>(ref T first, int firstLength, ref T second, int secondLength);
        static /*0x2241464*/ int IndexOfCultureHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.Globalization.CompareInfo compareInfo);
        static /*0x2241588*/ int IndexOfCultureIgnoreCaseHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.Globalization.CompareInfo compareInfo);
        static /*0x22416ac*/ int IndexOfOrdinalHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, bool ignoreCase);
        static /*0x22417e0*/ bool StartsWithCultureHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.Globalization.CompareInfo compareInfo);
        static /*0x22419cc*/ bool StartsWithCultureIgnoreCaseHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.Globalization.CompareInfo compareInfo);
        static /*0x2241aec*/ bool StartsWithOrdinalIgnoreCaseHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value);
        static /*0x2241bc4*/ bool EndsWithCultureHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.Globalization.CompareInfo compareInfo);
        static /*0x2241dc4*/ bool EndsWithCultureIgnoreCaseHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value, System.Globalization.CompareInfo compareInfo);
        static /*0x2241ee4*/ bool EndsWithOrdinalIgnoreCaseHelper(System.ReadOnlySpan<char> span, System.ReadOnlySpan<char> value);
        static /*0x2241fcc*/ void ClearWithoutReferences(ref byte b, ulong byteLength);
        static /*0x22421b4*/ void ClearWithReferences(ref nint ip, ulong pointerSizeLength);
        static void CopyTo<T>(ref T dst, int dstLength, ref T src, int srcLength);
        static nint Add<T>(nint start, int index);
        static bool IsReferenceOrContainsReferences<T>();
        static /*0x2242304*/ bool IsReferenceOrContainsReferencesCore(System.Type type);
        static /*0x2242748*/ void ClearLessThanPointerSized(byte* ptr, nuint byteLength);
        static /*0x2242804*/ void ClearLessThanPointerSized(ref byte b, nuint byteLength);
        static /*0x22428c8*/ void ClearPointerSizedWithoutReferences(ref byte b, nuint byteLength);
        static /*0x2242bb0*/ void ClearPointerSizedWithReferences(ref nint ip, nuint pointerSizeLength);
        static /*0x2242ef4*/ bool LessThanEqual(nint index, nuint length);

        struct ComparerComparable<T, TComparer> : System.IComparable<T>
        {
            /*0x0*/ T _value;
            /*0x0*/ TComparer _comparer;

            ComparerComparable(T value, TComparer comparer);
            int CompareTo(T other);
        }

        struct Reg64
        {
        }

        struct Reg32
        {
        }

        struct Reg16
        {
        }

        class PerTypeValues<T>
        {
            static /*0x0*/ bool IsReferenceOrContainsReferences;
            static /*0x0*/ T[] EmptyArray;
            static /*0x0*/ nint ArrayAdjustment;

            static PerTypeValues();
            static nint MeasureArrayAdjustment();
        }
    }

    class StackOverflowException : System.SystemException
    {
        /*0x2242f78*/ StackOverflowException();
        /*0x2242fd0*/ StackOverflowException(string message);
        /*0x2242ff0*/ StackOverflowException(string message, System.Exception innerException);
        /*0x2243010*/ StackOverflowException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class StringComparer : System.Collections.IComparer, System.Collections.IEqualityComparer, System.Collections.Generic.IComparer<string>, System.Collections.Generic.IEqualityComparer<string>
    {
        static /*0x0*/ System.CultureAwareComparer s_invariantCulture;
        static /*0x8*/ System.CultureAwareComparer s_invariantCultureIgnoreCase;
        static /*0x10*/ System.OrdinalCaseSensitiveComparer s_ordinal;
        static /*0x18*/ System.OrdinalIgnoreCaseComparer s_ordinalIgnoreCase;

        static /*0x22439b4*/ StringComparer();
        static /*0x2243014*/ System.StringComparer get_InvariantCulture();
        static /*0x224306c*/ System.StringComparer get_InvariantCultureIgnoreCase();
        static /*0x22430c4*/ System.StringComparer get_CurrentCulture();
        static /*0x22431a0*/ System.StringComparer get_CurrentCultureIgnoreCase();
        static /*0x2243234*/ System.StringComparer get_Ordinal();
        static /*0x224328c*/ System.StringComparer get_OrdinalIgnoreCase();
        static /*0x22432e4*/ System.StringComparer FromComparison(System.StringComparison comparisonType);
        static /*0x224351c*/ System.StringComparer Create(System.Globalization.CultureInfo culture, bool ignoreCase);
        static /*0x22435d4*/ System.StringComparer Create(System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);
        /*0x22439ac*/ StringComparer();
        /*0x224368c*/ int Compare(object x, object y);
        /*0x224381c*/ bool Equals(object x, object y);
        /*0x22438e4*/ int GetHashCode(object obj);
        int Compare(string x, string y);
        bool Equals(string x, string y);
        int GetHashCode(string obj);
    }

    class CultureAwareComparer : System.StringComparer, System.Runtime.Serialization.ISerializable
    {
        static System.Globalization.CompareOptions ValidCompareMaskOffFlags = -536870944;
        /*0x10*/ System.Globalization.CompareInfo _compareInfo;
        /*0x18*/ System.Globalization.CompareOptions _options;

        /*0x2243158*/ CultureAwareComparer(System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);
        /*0x2243b24*/ CultureAwareComparer(System.Globalization.CompareInfo compareInfo, System.Globalization.CompareOptions options);
        /*0x2243c08*/ CultureAwareComparer(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2243e14*/ int Compare(string x, string y);
        /*0x2243e68*/ bool Equals(string x, string y);
        /*0x2243eb8*/ int GetHashCode(string obj);
        /*0x2243f2c*/ bool Equals(object obj);
        /*0x2243fc4*/ int GetHashCode();
        /*0x2243ff8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class OrdinalComparer : System.StringComparer
    {
        /*0x10*/ bool _ignoreCase;

        /*0x22440e4*/ OrdinalComparer(bool ignoreCase);
        /*0x2244150*/ int Compare(string x, string y);
        /*0x22441a8*/ bool Equals(string x, string y);
        /*0x2244228*/ int GetHashCode(string obj);
        /*0x22442bc*/ bool Equals(object obj);
        /*0x2244354*/ int GetHashCode();
    }

    class OrdinalCaseSensitiveComparer : System.OrdinalComparer, System.Runtime.Serialization.ISerializable
    {
        /*0x2243b14*/ OrdinalCaseSensitiveComparer();
        /*0x22443b8*/ int Compare(string x, string y);
        /*0x22443c8*/ bool Equals(string x, string y);
        /*0x22443d8*/ int GetHashCode(string obj);
        /*0x22443fc*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class OrdinalIgnoreCaseComparer : System.OrdinalComparer, System.Runtime.Serialization.ISerializable
    {
        /*0x2243b1c*/ OrdinalIgnoreCaseComparer();
        /*0x22444b0*/ int Compare(string x, string y);
        /*0x22444c8*/ bool Equals(string x, string y);
        /*0x22444e0*/ int GetHashCode(string obj);
        /*0x2244548*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    enum StringComparison
    {
        CurrentCulture = 0,
        CurrentCultureIgnoreCase = 1,
        InvariantCulture = 2,
        InvariantCultureIgnoreCase = 3,
        Ordinal = 4,
        OrdinalIgnoreCase = 5,
    }

    enum StringSplitOptions
    {
        None = 0,
        RemoveEmptyEntries = 1,
    }

    class SystemException : System.Exception
    {
        /*0x22445fc*/ SystemException();
        /*0x2238aec*/ SystemException(string message);
        /*0x2238ba4*/ SystemException(string message, System.Exception innerException);
        /*0x2238cac*/ SystemException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class STAThreadAttribute : System.Attribute
    {
        /*0x224467c*/ STAThreadAttribute();
    }

    class MTAThreadAttribute : System.Attribute
    {
        /*0x2244684*/ MTAThreadAttribute();
    }

    class ThreadStaticAttribute : System.Attribute
    {
        /*0x224468c*/ ThreadStaticAttribute();
    }

    struct TimeSpan : System.IComparable, System.IComparable<System.TimeSpan>, System.IEquatable<System.TimeSpan>, System.IFormattable, System.ISpanFormattable
    {
        static long TicksPerMillisecond = 10000;
        static double MillisecondsPerTick = 0.0001;
        static long TicksPerSecond = 10000000;
        static double SecondsPerTick = 1e-7;
        static long TicksPerMinute = 600000000;
        static double MinutesPerTick = 1.6666666666666667e-9;
        static long TicksPerHour = 36000000000;
        static double HoursPerTick = 2.7777777777777777e-11;
        static long TicksPerDay = 864000000000;
        static double DaysPerTick = 1.1574074074074074e-12;
        static int MillisPerSecond = 1000;
        static int MillisPerMinute = 60000;
        static int MillisPerHour = 3600000;
        static int MillisPerDay = 86400000;
        static long MaxSeconds = 922337203685;
        static long MinSeconds = -922337203685;
        static long MaxMilliSeconds = 922337203685477;
        static long MinMilliSeconds = -922337203685477;
        static long TicksPerTenthSecond = 1000000;
        static /*0x0*/ System.TimeSpan Zero;
        static /*0x8*/ System.TimeSpan MaxValue;
        static /*0x10*/ System.TimeSpan MinValue;
        /*0x10*/ long _ticks;

        static /*0x2246750*/ TimeSpan();
        static /*0x2244adc*/ int Compare(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x2244bd8*/ System.TimeSpan FromDays(double value);
        static /*0x2244ecc*/ bool Equals(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x2244ee4*/ System.TimeSpan FromHours(double value);
        static /*0x2244c3c*/ System.TimeSpan Interval(double value, int scale);
        static /*0x2244f48*/ System.TimeSpan FromMilliseconds(double value);
        static /*0x2244fa8*/ System.TimeSpan FromMinutes(double value);
        static /*0x22450c0*/ System.TimeSpan FromSeconds(double value);
        static /*0x224573c*/ System.TimeSpan FromTicks(long value);
        static /*0x224471c*/ long TimeToTicks(int hour, int minute, int second);
        static /*0x2245740*/ void ValidateStyles(System.Globalization.TimeSpanStyles style, string parameterName);
        static /*0x22457a8*/ System.TimeSpan Parse(string s);
        static /*0x224581c*/ System.TimeSpan Parse(string input, System.IFormatProvider formatProvider);
        static /*0x2245894*/ System.TimeSpan Parse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider);
        static /*0x224589c*/ System.TimeSpan ParseExact(string input, string format, System.IFormatProvider formatProvider);
        static /*0x224598c*/ System.TimeSpan ParseExact(string input, string[] formats, System.IFormatProvider formatProvider);
        static /*0x2245a18*/ System.TimeSpan ParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles);
        static /*0x2245b6c*/ System.TimeSpan ParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles);
        static /*0x2245c24*/ System.TimeSpan ParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles);
        static /*0x2245d14*/ System.TimeSpan ParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles);
        static /*0x2245dbc*/ bool TryParse(string s, ref System.TimeSpan result);
        static /*0x2245e28*/ bool TryParse(System.ReadOnlySpan<char> s, ref System.TimeSpan result);
        static /*0x2245e38*/ bool TryParse(string input, System.IFormatProvider formatProvider, ref System.TimeSpan result);
        static /*0x2245eb4*/ bool TryParse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider, ref System.TimeSpan result);
        static /*0x2245ebc*/ bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, ref System.TimeSpan result);
        static /*0x2245f90*/ bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, ref System.TimeSpan result);
        static /*0x2245fa0*/ bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, ref System.TimeSpan result);
        static /*0x2246028*/ bool TryParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, ref System.TimeSpan result);
        static /*0x2246038*/ bool TryParseExact(string input, string format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.TimeSpan result);
        static /*0x2246168*/ bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.TimeSpan result);
        static /*0x2246228*/ bool TryParseExact(string input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.TimeSpan result);
        static /*0x224631c*/ bool TryParseExact(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.TimeSpan result);
        static /*0x22465c0*/ System.TimeSpan op_UnaryNegation(System.TimeSpan t);
        static /*0x2246670*/ System.TimeSpan op_Subtraction(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x2246688*/ System.TimeSpan op_UnaryPlus(System.TimeSpan t);
        static /*0x224668c*/ System.TimeSpan op_Addition(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x22451f4*/ System.TimeSpan op_Multiply(System.TimeSpan timeSpan, double factor);
        static /*0x22466a4*/ System.TimeSpan op_Multiply(double factor, System.TimeSpan timeSpan);
        static /*0x2245470*/ System.TimeSpan op_Division(System.TimeSpan timeSpan, double divisor);
        static /*0x224572c*/ double op_Division(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x2246708*/ bool op_Equality(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x2246714*/ bool op_Inequality(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x2246720*/ bool op_LessThan(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x224672c*/ bool op_LessThanOrEqual(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x2246738*/ bool op_GreaterThan(System.TimeSpan t1, System.TimeSpan t2);
        static /*0x2246744*/ bool op_GreaterThanOrEqual(System.TimeSpan t1, System.TimeSpan t2);
        /*0x2244694*/ TimeSpan(long ticks);
        /*0x224469c*/ TimeSpan(int hours, int minutes, int seconds);
        /*0x22447b8*/ TimeSpan(int days, int hours, int minutes, int seconds);
        /*0x22447c0*/ TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
        /*0x2244880*/ long get_Ticks();
        /*0x2244888*/ int get_Days();
        /*0x22448b4*/ int get_Hours();
        /*0x22448fc*/ int get_Milliseconds();
        /*0x2244948*/ int get_Minutes();
        /*0x2244990*/ int get_Seconds();
        /*0x22449dc*/ double get_TotalDays();
        /*0x22449f4*/ double get_TotalHours();
        /*0x2244a0c*/ double get_TotalMilliseconds();
        /*0x2244a40*/ double get_TotalMinutes();
        /*0x2244a58*/ double get_TotalSeconds();
        /*0x2244a70*/ System.TimeSpan Add(System.TimeSpan ts);
        /*0x2244af4*/ int CompareTo(object value);
        /*0x2244bbc*/ int CompareTo(System.TimeSpan value);
        /*0x2244d88*/ System.TimeSpan Duration();
        /*0x2244e44*/ bool Equals(object value);
        /*0x2244ebc*/ bool Equals(System.TimeSpan obj);
        /*0x2244ed8*/ int GetHashCode();
        /*0x2245008*/ System.TimeSpan Negate();
        /*0x2245120*/ System.TimeSpan Subtract(System.TimeSpan ts);
        /*0x224518c*/ System.TimeSpan Multiply(double factor);
        /*0x2245408*/ System.TimeSpan Divide(double divisor);
        /*0x22456c0*/ double Divide(System.TimeSpan ts);
        /*0x22463d4*/ string ToString();
        /*0x2246438*/ string ToString(string format);
        /*0x22464a8*/ string ToString(string format, System.IFormatProvider formatProvider);
        /*0x224651c*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider);
    }

    class TimeZone
    {
        static /*0x0*/ System.TimeZone currentTimeZone;
        static /*0x8*/ object s_InternalSyncObject;

        static /*0x22467a8*/ object get_InternalSyncObject();
        static /*0x2246850*/ System.TimeZone get_CurrentTimeZone();
        static /*0x22469bc*/ void ResetTimeZone();
        static /*0x2246cb8*/ bool IsDaylightSavingTime(System.DateTime time, System.Globalization.DaylightTime daylightTimes);
        static /*0x2246d3c*/ System.TimeSpan CalculateUtcOffset(System.DateTime time, System.Globalization.DaylightTime daylightTimes);
        static /*0x2246f58*/ void ClearCachedData();
        /*0x2246848*/ TimeZone();
        string get_StandardName();
        string get_DaylightName();
        System.TimeSpan GetUtcOffset(System.DateTime time);
        /*0x2246abc*/ System.DateTime ToUniversalTime(System.DateTime time);
        /*0x2246b84*/ System.DateTime ToLocalTime(System.DateTime time);
        System.Globalization.DaylightTime GetDaylightChanges(int year);
        /*0x2246c68*/ bool IsDaylightSavingTime(System.DateTime time);
    }

    enum TimeZoneInfoOptions
    {
        None = 1,
        NoThrowOnInvalidTime = 2,
    }

    class TimeZoneNotFoundException : System.Exception
    {
        /*0x2246fa4*/ TimeZoneNotFoundException();
        /*0x2246ffc*/ TimeZoneNotFoundException(string message);
        /*0x2247064*/ TimeZoneNotFoundException(string message, System.Exception innerException);
        /*0x22470d4*/ TimeZoneNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class TimeoutException : System.SystemException
    {
        /*0x2247154*/ TimeoutException();
        /*0x22471ac*/ TimeoutException(string message);
        /*0x22471cc*/ TimeoutException(string message, System.Exception innerException);
        /*0x22471ec*/ TimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    interface ITupleInternal : System.Runtime.CompilerServices.ITuple
    {
        string ToString(System.Text.StringBuilder sb);
        int GetHashCode(System.Collections.IEqualityComparer comparer);
    }

    class Tuple
    {
        static System.Tuple<T1> Create<T1>(T1 item1);
        static System.Tuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2);
        static System.Tuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3);
        static System.Tuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4);
        static System.Tuple<T1, T2, T3, T4, T5> Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
        static System.Tuple<T1, T2, T3, T4, T5, T6> Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7> Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
        static /*0x22471f0*/ int CombineHashCodes(int h1, int h2);
        static /*0x22471fc*/ int CombineHashCodes(int h1, int h2, int h3);
        static /*0x2247210*/ int CombineHashCodes(int h1, int h2, int h3, int h4);
        static /*0x224722c*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
        static /*0x2247250*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
        static /*0x224727c*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
        static /*0x22472b0*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
    }

    class Tuple<T1> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;

        Tuple(T1 item1);
        T1 get_Item1();
        bool Equals(object obj);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int System.ITupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    class Tuple<T1, T2> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;

        Tuple(T1 item1, T2 item2);
        T1 get_Item1();
        T2 get_Item2();
        bool Equals(object obj);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int System.ITupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    class Tuple<T1, T2, T3> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;
        /*0x0*/ T3 m_Item3;

        Tuple(T1 item1, T2 item2, T3 item3);
        T1 get_Item1();
        T2 get_Item2();
        T3 get_Item3();
        bool Equals(object obj);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int System.ITupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    class Tuple<T1, T2, T3, T4> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;
        /*0x0*/ T3 m_Item3;
        /*0x0*/ T4 m_Item4;

        Tuple(T1 item1, T2 item2, T3 item3, T4 item4);
        T1 get_Item1();
        T2 get_Item2();
        T3 get_Item3();
        T4 get_Item4();
        bool Equals(object obj);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int System.ITupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    class Tuple<T1, T2, T3, T4, T5> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;
        /*0x0*/ T3 m_Item3;
        /*0x0*/ T4 m_Item4;
        /*0x0*/ T5 m_Item5;

        Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
        T1 get_Item1();
        T2 get_Item2();
        T3 get_Item3();
        T4 get_Item4();
        T5 get_Item5();
        bool Equals(object obj);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int System.ITupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    class Tuple<T1, T2, T3, T4, T5, T6> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;
        /*0x0*/ T3 m_Item3;
        /*0x0*/ T4 m_Item4;
        /*0x0*/ T5 m_Item5;
        /*0x0*/ T6 m_Item6;

        Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
        T1 get_Item1();
        T2 get_Item2();
        T3 get_Item3();
        T4 get_Item4();
        T5 get_Item5();
        T6 get_Item6();
        bool Equals(object obj);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int System.ITupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    class Tuple<T1, T2, T3, T4, T5, T6, T7> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;
        /*0x0*/ T3 m_Item3;
        /*0x0*/ T4 m_Item4;
        /*0x0*/ T5 m_Item5;
        /*0x0*/ T6 m_Item6;
        /*0x0*/ T7 m_Item7;

        Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
        T1 get_Item1();
        T2 get_Item2();
        T3 get_Item3();
        T4 get_Item4();
        T5 get_Item5();
        T6 get_Item6();
        T7 get_Item7();
        bool Equals(object obj);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int System.ITupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    class Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> : System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.ITupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 m_Item1;
        /*0x0*/ T2 m_Item2;
        /*0x0*/ T3 m_Item3;
        /*0x0*/ T4 m_Item4;
        /*0x0*/ T5 m_Item5;
        /*0x0*/ T6 m_Item6;
        /*0x0*/ T7 m_Item7;
        /*0x0*/ TRest m_Rest;

        Tuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
        T1 get_Item1();
        T2 get_Item2();
        T3 get_Item3();
        T4 get_Item4();
        T5 get_Item5();
        T6 get_Item6();
        T7 get_Item7();
        TRest get_Rest();
        bool Equals(object obj);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object obj);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int System.ITupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.ITupleInternal.ToString(System.Text.StringBuilder sb);
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    class TupleExtensions
    {
        static void Deconstruct<T1>(System.Tuple<T1> value, ref T1 item1);
        static void Deconstruct<T1, T2>(System.Tuple<T1, T2> value, ref T1 item1, ref T2 item2);
        static void Deconstruct<T1, T2, T3>(System.Tuple<T1, T2, T3> value, ref T1 item1, ref T2 item2, ref T3 item3);
        static void Deconstruct<T1, T2, T3, T4>(System.Tuple<T1, T2, T3, T4> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4);
        static void Deconstruct<T1, T2, T3, T4, T5>(System.Tuple<T1, T2, T3, T4, T5> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5);
        static void Deconstruct<T1, T2, T3, T4, T5, T6>(System.Tuple<T1, T2, T3, T4, T5, T6> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7>(System.Tuple<T1, T2, T3, T4, T5, T6, T7> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12, ref T13 item13);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12, ref T13 item13, ref T14 item14);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15>>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12, ref T13 item13, ref T14 item14, ref T15 item15);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16>>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12, ref T13 item13, ref T14 item14, ref T15 item15, ref T16 item16);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17>>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12, ref T13 item13, ref T14 item14, ref T15 item15, ref T16 item16, ref T17 item17);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18>>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12, ref T13 item13, ref T14 item14, ref T15 item15, ref T16 item16, ref T17 item17, ref T18 item18);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19>>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12, ref T13 item13, ref T14 item14, ref T15 item15, ref T16 item16, ref T17 item17, ref T18 item18, ref T19 item19);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20>>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12, ref T13 item13, ref T14 item14, ref T15 item15, ref T16 item16, ref T17 item17, ref T18 item18, ref T19 item19, ref T20 item20);
        static void Deconstruct<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20, T21>>> value, ref T1 item1, ref T2 item2, ref T3 item3, ref T4 item4, ref T5 item5, ref T6 item6, ref T7 item7, ref T8 item8, ref T9 item9, ref T10 item10, ref T11 item11, ref T12 item12, ref T13 item13, ref T14 item14, ref T15 item15, ref T16 item16, ref T17 item17, ref T18 item18, ref T19 item19, ref T20 item20, ref T21 item21);
        static System.ValueTuple<T1> ToValueTuple<T1>(System.Tuple<T1> value);
        static System.ValueTuple<T1, T2> ToValueTuple<T1, T2>(System.Tuple<T1, T2> value);
        static System.ValueTuple<T1, T2, T3> ToValueTuple<T1, T2, T3>(System.Tuple<T1, T2, T3> value);
        static System.ValueTuple<T1, T2, T3, T4> ToValueTuple<T1, T2, T3, T4>(System.Tuple<T1, T2, T3, T4> value);
        static System.ValueTuple<T1, T2, T3, T4, T5> ToValueTuple<T1, T2, T3, T4, T5>(System.Tuple<T1, T2, T3, T4, T5> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6> ToValueTuple<T1, T2, T3, T4, T5, T6>(System.Tuple<T1, T2, T3, T4, T5, T6> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7> ToValueTuple<T1, T2, T3, T4, T5, T6, T7>(System.Tuple<T1, T2, T3, T4, T5, T6, T7> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15>>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15>>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16>>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16>>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17>>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17>>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17, T18>>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18>>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17, T18, T19>>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19>>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17, T18, T19, T20>>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20>>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20, T21>>> value);
        static System.Tuple<T1> ToTuple<T1>(System.ValueTuple<T1> value);
        static System.Tuple<T1, T2> ToTuple<T1, T2>(System.ValueTuple<T1, T2> value);
        static System.Tuple<T1, T2, T3> ToTuple<T1, T2, T3>(System.ValueTuple<T1, T2, T3> value);
        static System.Tuple<T1, T2, T3, T4> ToTuple<T1, T2, T3, T4>(System.ValueTuple<T1, T2, T3, T4> value);
        static System.Tuple<T1, T2, T3, T4, T5> ToTuple<T1, T2, T3, T4, T5>(System.ValueTuple<T1, T2, T3, T4, T5> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6> ToTuple<T1, T2, T3, T4, T5, T6>(System.ValueTuple<T1, T2, T3, T4, T5, T6> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7> ToTuple<T1, T2, T3, T4, T5, T6, T7>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15>>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16>>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17>>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17, T18>>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17, T18, T19>>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17, T18, T19, T20>>> value);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, System.Tuple<T8, T9, T10, T11, T12, T13, T14, System.Tuple<T15, T16, T17, T18, T19, T20, T21>>> ToTuple<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21>(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8, T9, T10, T11, T12, T13, T14, System.ValueTuple<T15, T16, T17, T18, T19, T20, T21>>> value);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLong<T1, T2, T3, T4, T5, T6, T7, TRest>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
        static System.Tuple<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLongRef<T1, T2, T3, T4, T5, T6, T7, TRest>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    }

    class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type
    {
        static System.Reflection.BindingFlags DefaultLookup = 28;
        static string DefaultTypeNameWhenMissingMetadata = "UnknownType";
        static /*0x0*/ System.Reflection.Binder s_defaultBinder;
        static /*0x8*/ char Delimiter;
        static /*0x10*/ System.Type[] EmptyTypes;
        static /*0x18*/ object Missing;
        static /*0x20*/ System.Reflection.MemberFilter FilterAttribute;
        static /*0x28*/ System.Reflection.MemberFilter FilterName;
        static /*0x30*/ System.Reflection.MemberFilter FilterNameIgnoreCase;
        /*0x10*/ System.RuntimeTypeHandle _impl;

        static /*0x224c544*/ Type();
        static /*0x2247928*/ int BinarySearch(System.Array array, object value);
        static /*0x2247684*/ bool IsIntegerType(System.Type t);
        static /*0x22494d0*/ bool FilterAttributeImpl(System.Reflection.MemberInfo m, object filterCriteria);
        static /*0x2249830*/ bool FilterNameImpl(System.Reflection.MemberInfo m, object filterCriteria);
        static /*0x22499b8*/ bool FilterNameIgnoreCaseImpl(System.Reflection.MemberInfo m, object filterCriteria);
        static /*0x224b098*/ System.RuntimeTypeHandle GetTypeHandle(object o);
        static /*0x224b114*/ System.Type[] GetTypeArray(object[] args);
        static /*0x224b270*/ System.TypeCode GetTypeCode(System.Type type);
        static /*0x224b3d0*/ System.Type GetTypeFromCLSID(System.Guid clsid);
        static /*0x224b4bc*/ System.Type GetTypeFromCLSID(System.Guid clsid, bool throwOnError);
        static /*0x224b52c*/ System.Type GetTypeFromCLSID(System.Guid clsid, string server);
        static /*0x224b59c*/ System.Type GetTypeFromProgID(string progID);
        static /*0x224b668*/ System.Type GetTypeFromProgID(string progID, bool throwOnError);
        static /*0x224b6d0*/ System.Type GetTypeFromProgID(string progID, string server);
        static /*0x224bb60*/ System.Type MakeGenericSignatureType(System.Type genericTypeDefinition, System.Type[] typeArguments);
        static /*0x224bbd4*/ System.Type MakeGenericMethodParameter(int position);
        static /*0x224be84*/ System.Reflection.Binder get_DefaultBinder();
        static /*0x2238890*/ System.Type GetTypeFromHandle(System.RuntimeTypeHandle handle);
        static /*0x224c0a4*/ System.Type internal_from_handle(nint handle);
        static /*0x224c11c*/ System.Type GetType(string typeName, bool throwOnError, bool ignoreCase);
        static /*0x224c1a8*/ System.Type GetType(string typeName, bool throwOnError);
        static /*0x224c228*/ System.Type GetType(string typeName);
        static /*0x224c2a4*/ System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver);
        static /*0x224c2cc*/ System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError);
        static /*0x224c2f4*/ System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError, bool ignoreCase);
        static /*0x2247678*/ bool op_Equality(System.Type left, System.Type right);
        static /*0x224273c*/ bool op_Inequality(System.Type left, System.Type right);
        static /*0x224c31c*/ System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
        static /*0x224b43c*/ System.Type GetTypeFromCLSID(System.Guid clsid, string server, bool throwOnError);
        static /*0x224b5f8*/ System.Type GetTypeFromProgID(string progID, string server, bool throwOnError);
        /*0x2249b54*/ Type();
        /*0x22472ec*/ bool IsEnumDefined(object value);
        /*0x2247a74*/ string GetEnumName(object value);
        /*0x2247c70*/ string[] GetEnumNames();
        /*0x2247904*/ System.Array GetEnumRawConstantValues();
        /*0x2247d18*/ void GetEnumData(ref string[] enumNames, ref System.Array enumValues);
        /*0x22480d8*/ bool get_IsSerializable();
        /*0x22482a0*/ bool get_ContainsGenericParameters();
        /*0x22483a8*/ System.Type GetRootElementType();
        /*0x22483f8*/ bool get_IsVisible();
        /*0x2248620*/ System.Type[] FindInterfaces(System.Reflection.TypeFilter filter, object filterCriteria);
        /*0x224882c*/ System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);
        /*0x2249068*/ bool IsSubclassOf(System.Type c);
        /*0x2249120*/ bool IsAssignableFrom(System.Type c);
        /*0x2249388*/ bool ImplementInterface(System.Type ifaceType);
        /*0x2249b5c*/ System.Reflection.MemberTypes get_MemberType();
        /*0x2249b64*/ System.Type GetType();
        string get_Namespace();
        string get_AssemblyQualifiedName();
        string get_FullName();
        System.Reflection.Assembly get_Assembly();
        System.Reflection.Module get_Module();
        /*0x2248584*/ bool get_IsNested();
        /*0x2249b6c*/ System.Type get_DeclaringType();
        /*0x2249b74*/ System.Reflection.MethodBase get_DeclaringMethod();
        /*0x2249b7c*/ System.Type get_ReflectedType();
        System.Type get_UnderlyingSystemType();
        /*0x2249b84*/ bool get_IsTypeDefinition();
        /*0x2249bac*/ bool get_IsArray();
        bool IsArrayImpl();
        /*0x2249bbc*/ bool get_IsByRef();
        bool IsByRefImpl();
        /*0x2249bcc*/ bool get_IsPointer();
        bool IsPointerImpl();
        /*0x2249bdc*/ bool get_IsConstructedGenericType();
        /*0x2249c04*/ bool get_IsGenericParameter();
        /*0x2249c0c*/ bool get_IsGenericTypeParameter();
        /*0x2249c58*/ bool get_IsGenericMethodParameter();
        /*0x2249ca4*/ bool get_IsGenericType();
        /*0x2249cac*/ bool get_IsGenericTypeDefinition();
        /*0x2249cb4*/ bool get_IsSZArray();
        /*0x2249cdc*/ bool get_IsVariableBoundArray();
        /*0x2249d24*/ bool get_IsByRefLike();
        /*0x2248398*/ bool get_HasElementType();
        bool HasElementTypeImpl();
        System.Type GetElementType();
        /*0x2249d74*/ int GetArrayRank();
        /*0x2249dc4*/ System.Type GetGenericTypeDefinition();
        /*0x2249e14*/ System.Type[] get_GenericTypeArguments();
        /*0x2249ee0*/ System.Type[] GetGenericArguments();
        /*0x2249f30*/ int get_GenericParameterPosition();
        /*0x2249f80*/ System.Reflection.GenericParameterAttributes get_GenericParameterAttributes();
        /*0x2249fc0*/ System.Type[] GetGenericParameterConstraints();
        /*0x224a040*/ System.Reflection.TypeAttributes get_Attributes();
        System.Reflection.TypeAttributes GetAttributeFlagsImpl();
        /*0x224a050*/ bool get_IsAbstract();
        /*0x224a070*/ bool get_IsImport();
        /*0x224a090*/ bool get_IsSealed();
        /*0x224a0b0*/ bool get_IsSpecialName();
        /*0x224a0d0*/ bool get_IsClass();
        /*0x224a118*/ bool get_IsNestedAssembly();
        /*0x224a140*/ bool get_IsNestedFamANDAssem();
        /*0x224a168*/ bool get_IsNestedFamily();
        /*0x224a190*/ bool get_IsNestedFamORAssem();
        /*0x224a1b8*/ bool get_IsNestedPrivate();
        /*0x224855c*/ bool get_IsNestedPublic();
        /*0x224a1e0*/ bool get_IsNotPublic();
        /*0x22485f8*/ bool get_IsPublic();
        /*0x224a204*/ bool get_IsAutoLayout();
        /*0x224a228*/ bool get_IsExplicitLayout();
        /*0x224a250*/ bool get_IsLayoutSequential();
        /*0x224a278*/ bool get_IsAnsiClass();
        /*0x224a29c*/ bool get_IsAutoClass();
        /*0x224a2c4*/ bool get_IsUnicodeClass();
        /*0x224a2ec*/ bool get_IsCOMObject();
        bool IsCOMObjectImpl();
        /*0x224a2fc*/ bool get_IsContextful();
        /*0x224a30c*/ bool IsContextfulImpl();
        /*0x224a39c*/ bool get_IsCollectible();
        /*0x224a3a4*/ bool get_IsEnum();
        /*0x224a430*/ bool get_IsMarshalByRef();
        /*0x224a440*/ bool IsMarshalByRefImpl();
        /*0x224271c*/ bool get_IsPrimitive();
        bool IsPrimitiveImpl();
        /*0x224272c*/ bool get_IsValueType();
        /*0x224a4d0*/ bool IsValueTypeImpl();
        /*0x224a55c*/ bool get_IsSignatureType();
        /*0x224a564*/ bool get_IsSecurityCritical();
        /*0x224a58c*/ bool get_IsSecuritySafeCritical();
        /*0x224a5b4*/ bool get_IsSecurityTransparent();
        /*0x224a5dc*/ System.Runtime.InteropServices.StructLayoutAttribute get_StructLayoutAttribute();
        /*0x224a61c*/ System.Reflection.ConstructorInfo get_TypeInitializer();
        /*0x224a698*/ System.Reflection.ConstructorInfo GetConstructor(System.Type[] types);
        /*0x224a6b0*/ System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224a6c0*/ System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224a7f0*/ System.Reflection.ConstructorInfo[] GetConstructors();
        System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
        /*0x224a804*/ System.Reflection.EventInfo GetEvent(string name);
        System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x224a818*/ System.Reflection.EventInfo[] GetEvents();
        System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
        /*0x224a82c*/ System.Reflection.FieldInfo GetField(string name);
        System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x224a840*/ System.Reflection.FieldInfo[] GetFields();
        System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
        /*0x224a854*/ System.Reflection.MemberInfo[] GetMember(string name);
        /*0x224a868*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x224a880*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
        /*0x224a8d0*/ System.Reflection.MemberInfo[] GetMembers();
        System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
        /*0x224a8e4*/ System.Reflection.MethodInfo GetMethod(string name);
        /*0x224a8ec*/ System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x224a964*/ System.Reflection.MethodInfo GetMethod(string name, System.Type[] types);
        /*0x224a97c*/ System.Reflection.MethodInfo GetMethod(string name, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224a994*/ System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224a9a4*/ System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224ab04*/ System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Type[] types);
        /*0x224ab30*/ System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224ab5c*/ System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224ab80*/ System.Reflection.MethodInfo GetMethod(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224ad48*/ System.Reflection.MethodInfo GetMethodImpl(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224ad88*/ System.Reflection.MethodInfo[] GetMethods();
        System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
        /*0x224ad9c*/ System.Type GetNestedType(string name);
        System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x224adb0*/ System.Type[] GetNestedTypes();
        System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
        /*0x224adc4*/ System.Reflection.PropertyInfo GetProperty(string name);
        /*0x224adcc*/ System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x224ae44*/ System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType);
        /*0x224af44*/ System.Reflection.PropertyInfo GetProperty(string name, System.Type[] types);
        /*0x224af5c*/ System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types);
        /*0x224af74*/ System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224af8c*/ System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x224b01c*/ System.Reflection.PropertyInfo[] GetProperties();
        System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
        /*0x224b030*/ System.Reflection.MemberInfo[] GetDefaultMembers();
        /*0x224b058*/ System.RuntimeTypeHandle get_TypeHandle();
        /*0x224b2e8*/ System.TypeCode GetTypeCodeImpl();
        System.Guid get_GUID();
        System.Type get_BaseType();
        /*0x224b738*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);
        /*0x224b764*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);
        object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
        /*0x224b790*/ System.Type GetInterface(string name);
        System.Type GetInterface(string name, bool ignoreCase);
        System.Type[] GetInterfaces();
        /*0x224b7a4*/ System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType);
        /*0x224b7f4*/ bool IsInstanceOfType(object o);
        /*0x224b830*/ bool IsEquivalentTo(System.Type other);
        /*0x224b894*/ System.Type GetEnumUnderlyingType();
        /*0x224b984*/ System.Array GetEnumValues();
        /*0x224ba10*/ System.Type MakeArrayType();
        /*0x224ba50*/ System.Type MakeArrayType(int rank);
        /*0x224ba90*/ System.Type MakeByRefType();
        /*0x224bad0*/ System.Type MakeGenericType(System.Type[] typeArguments);
        /*0x224bb20*/ System.Type MakePointerType();
        /*0x224bc9c*/ string ToString();
        /*0x224bd00*/ bool Equals(object o);
        /*0x224bd9c*/ int GetHashCode();
        /*0x224bde4*/ bool Equals(System.Type o);
        /*0x224bf5c*/ System.Type InternalResolve();
        /*0x224bf6c*/ System.Type RuntimeResolve();
        /*0x224bfac*/ bool get_IsUserType();
        /*0x224bfb4*/ System.Reflection.MethodInfo GetMethod(System.Reflection.MethodInfo fromNoninstanciated);
        /*0x224c004*/ System.Reflection.ConstructorInfo GetConstructor(System.Reflection.ConstructorInfo fromNoninstanciated);
        /*0x224c054*/ System.Reflection.FieldInfo GetField(System.Reflection.FieldInfo fromNoninstanciated);
        /*0x224c0a8*/ System.RuntimeTypeHandle GetTypeHandleInternal();
        /*0x224c0b8*/ bool HasProxyAttributeImpl();
        /*0x224c0c0*/ bool get_IsSzArray();
        /*0x224c0c8*/ string FormatTypeName();
        /*0x224c0dc*/ string FormatTypeName(bool serialization);
        /*0x22492c4*/ bool get_IsInterface();
        /*0x224c3a8*/ string get_FullNameOrDefault();
        /*0x2248214*/ bool IsRuntimeImplemented();
        /*0x224c4c4*/ string InternalGetNameIfAvailable(ref System.Type rootCauseForFailure);
        /*0x224c4a0*/ string get_InternalNameIfAvailable();
        /*0x224c4d4*/ string get_NameOrDefault();
        /*0x224c704*/ void System.Runtime.InteropServices._Type.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
        /*0x224c73c*/ void System.Runtime.InteropServices._Type.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
        /*0x224c774*/ void System.Runtime.InteropServices._Type.GetTypeInfoCount(ref uint pcTInfo);
        /*0x224c7ac*/ void System.Runtime.InteropServices._Type.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
    }

    class TypeAccessException : System.TypeLoadException
    {
        /*0x224c7e4*/ TypeAccessException();
        /*0x224c840*/ TypeAccessException(string message);
        /*0x224c864*/ TypeAccessException(string message, System.Exception inner);
        /*0x224c888*/ TypeAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    enum TypeCode
    {
        Empty = 0,
        Object = 1,
        DBNull = 2,
        Boolean = 3,
        Char = 4,
        SByte = 5,
        Byte = 6,
        Int16 = 7,
        UInt16 = 8,
        Int32 = 9,
        UInt32 = 10,
        Int64 = 11,
        UInt64 = 12,
        Single = 13,
        Double = 14,
        Decimal = 15,
        DateTime = 16,
        String = 18,
    }

    class TypeInitializationException : System.SystemException
    {
        /*0x90*/ string _typeName;

        /*0x224c890*/ TypeInitializationException();
        /*0x224c8e8*/ TypeInitializationException(string fullTypeName, System.Exception innerException);
        /*0x224c9a0*/ TypeInitializationException(string message);
        /*0x224c968*/ TypeInitializationException(string fullTypeName, string message, System.Exception innerException);
        /*0x224c9c0*/ TypeInitializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x224ca44*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x224cb4c*/ string get_TypeName();
    }

    class TypeUnloadedException : System.SystemException
    {
        /*0x224cba0*/ TypeUnloadedException();
        /*0x224cbf8*/ TypeUnloadedException(string message);
        /*0x224cc18*/ TypeUnloadedException(string message, System.Exception innerException);
        /*0x224cc38*/ TypeUnloadedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct UInt16 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<ushort>, System.IEquatable<ushort>, System.ISpanFormattable
    {
        static ushort MaxValue = 65535;
        static ushort MinValue = 0;
        /*0x10*/ ushort m_value;

        static /*0x224d0dc*/ ushort Parse(string s);
        static /*0x224d2f4*/ ushort Parse(string s, System.Globalization.NumberStyles style);
        static /*0x224d388*/ ushort Parse(string s, System.IFormatProvider provider);
        static /*0x224d414*/ ushort Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x224d4b8*/ ushort Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x224d160*/ ushort Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info);
        static /*0x224d50c*/ bool TryParse(string s, ref ushort result);
        static /*0x224d648*/ bool TryParse(System.ReadOnlySpan<char> s, ref ushort result);
        static /*0x224d684*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref ushort result);
        static /*0x224d72c*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref ushort result);
        static /*0x224d58c*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.Globalization.NumberFormatInfo info, ref ushort result);
        /*0x224cc3c*/ int CompareTo(object value);
        /*0x224ccfc*/ int CompareTo(ushort value);
        /*0x224cd08*/ bool Equals(object obj);
        /*0x224cd80*/ bool Equals(ushort obj);
        /*0x224cd90*/ int GetHashCode();
        /*0x224cd98*/ string ToString();
        /*0x224ce30*/ string ToString(System.IFormatProvider provider);
        /*0x224cecc*/ string ToString(string format);
        /*0x224cf80*/ string ToString(string format, System.IFormatProvider provider);
        /*0x224d038*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x224d788*/ System.TypeCode GetTypeCode();
        /*0x224d790*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x224d7ec*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x224d848*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x224d8a4*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x224d900*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x224d95c*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x224d964*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x224d9c0*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x224da1c*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x224da78*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x224dad4*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x224db30*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x224db8c*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x224dbe8*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x224dc74*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct UInt32 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<uint>, System.IEquatable<uint>, System.ISpanFormattable
    {
        static uint MaxValue = 4294967295;
        static uint MinValue = 0;
        /*0x10*/ uint m_value;

        static /*0x224e13c*/ uint Parse(string s);
        static /*0x224e200*/ uint Parse(string s, System.Globalization.NumberStyles style);
        static /*0x224e2dc*/ uint Parse(string s, System.IFormatProvider provider);
        static /*0x224e3b0*/ uint Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x224e494*/ uint Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x224e534*/ bool TryParse(string s, ref uint result);
        static /*0x224e608*/ bool TryParse(System.ReadOnlySpan<char> s, ref uint result);
        static /*0x224e690*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref uint result);
        static /*0x224e788*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref uint result);
        /*0x224dd20*/ int CompareTo(object value);
        /*0x224ddf0*/ int CompareTo(uint value);
        /*0x224de0c*/ bool Equals(object obj);
        /*0x224de84*/ bool Equals(uint obj);
        /*0x224de94*/ int GetHashCode();
        /*0x224de9c*/ string ToString();
        /*0x224df34*/ string ToString(System.IFormatProvider provider);
        /*0x224dfd0*/ string ToString(string format);
        /*0x224e084*/ string ToString(string format, System.IFormatProvider provider);
        /*0x223b3e8*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x224e830*/ System.TypeCode GetTypeCode();
        /*0x224e838*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x224e894*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x224e8f0*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x224e94c*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x224e9a8*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x224ea04*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x224ea60*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x224eabc*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x224eac4*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x224eb20*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x224eb7c*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x224ebd8*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x224ec34*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x224ec90*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x224ed1c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    struct UInt64 : System.IComparable, System.IConvertible, System.IFormattable, System.IComparable<ulong>, System.IEquatable<ulong>, System.ISpanFormattable
    {
        static ulong MaxValue = 18446744073709551615;
        static ulong MinValue = 0;
        /*0x10*/ ulong m_value;

        static /*0x224f28c*/ ulong Parse(string s);
        static /*0x224f350*/ ulong Parse(string s, System.Globalization.NumberStyles style);
        static /*0x224f42c*/ ulong Parse(string s, System.IFormatProvider provider);
        static /*0x224f500*/ ulong Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x224f5e4*/ ulong Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x224f684*/ bool TryParse(string s, ref ulong result);
        static /*0x224f758*/ bool TryParse(System.ReadOnlySpan<char> s, ref ulong result);
        static /*0x224f7e0*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref ulong result);
        static /*0x224f8d8*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref ulong result);
        /*0x224edc8*/ int CompareTo(object value);
        /*0x224ee98*/ int CompareTo(ulong value);
        /*0x224eeb4*/ bool Equals(object obj);
        /*0x224ef2c*/ bool Equals(ulong obj);
        /*0x224ef3c*/ int GetHashCode();
        /*0x224ef48*/ string ToString();
        /*0x224efe0*/ string ToString(System.IFormatProvider provider);
        /*0x224f07c*/ string ToString(string format);
        /*0x224f130*/ string ToString(string format, System.IFormatProvider provider);
        /*0x224f1e8*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x224f980*/ System.TypeCode GetTypeCode();
        /*0x224f988*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x224f9e4*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x224fa40*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x224fa9c*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x224faf8*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x224fb54*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x224fbb0*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x224fc0c*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x224fc68*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x224fcc4*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x224fccc*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x224fd28*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x224fd84*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x224fde0*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x224fe6c*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);
    }

    class UnauthorizedAccessException : System.SystemException
    {
        /*0x224ff18*/ UnauthorizedAccessException();
        /*0x224ff74*/ UnauthorizedAccessException(string message);
        /*0x224ff98*/ UnauthorizedAccessException(string message, System.Exception inner);
        /*0x224ffbc*/ UnauthorizedAccessException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class UnhandledExceptionEventArgs : System.EventArgs
    {
        /*0x10*/ object _exception;
        /*0x18*/ bool _isTerminating;

        /*0x224ffc4*/ UnhandledExceptionEventArgs(object exception, bool isTerminating);
        /*0x2250038*/ object get_ExceptionObject();
        /*0x2250040*/ bool get_IsTerminating();
    }

    class UnhandledExceptionEventHandler : System.MulticastDelegate
    {
        /*0x2250048*/ UnhandledExceptionEventHandler(object object, nint method);
        /*0x2250178*/ void Invoke(object sender, System.UnhandledExceptionEventArgs e);
        /*0x225018c*/ System.IAsyncResult BeginInvoke(object sender, System.UnhandledExceptionEventArgs e, System.AsyncCallback callback, object object);
        /*0x22501b4*/ void EndInvoke(System.IAsyncResult result);
    }

    interface IValueTupleInternal : System.Runtime.CompilerServices.ITuple
    {
        int GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToStringEnd();
    }

    struct ValueTuple : System.IEquatable<System.ValueTuple>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        static /*0x2250598*/ System.ValueTuple Create();
        static System.ValueTuple<T1> Create<T1>(T1 item1);
        static System.ValueTuple<T1, T2> Create<T1, T2>(T1 item1, T2 item2);
        static System.ValueTuple<T1, T2, T3> Create<T1, T2, T3>(T1 item1, T2 item2, T3 item3);
        static System.ValueTuple<T1, T2, T3, T4> Create<T1, T2, T3, T4>(T1 item1, T2 item2, T3 item3, T4 item4);
        static System.ValueTuple<T1, T2, T3, T4, T5> Create<T1, T2, T3, T4, T5>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6> Create<T1, T2, T3, T4, T5, T6>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7> Create<T1, T2, T3, T4, T5, T6, T7>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
        static System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, System.ValueTuple<T8>> Create<T1, T2, T3, T4, T5, T6, T7, T8>(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
        static /*0x22505a0*/ int CombineHashCodes(int h1, int h2);
        static /*0x225061c*/ int CombineHashCodes(int h1, int h2, int h3);
        static /*0x225069c*/ int CombineHashCodes(int h1, int h2, int h3, int h4);
        static /*0x225072c*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
        static /*0x22507c4*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
        static /*0x225086c*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
        static /*0x225091c*/ int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
        /*0x22501c0*/ bool Equals(object obj);
        /*0x225021c*/ bool Equals(System.ValueTuple other);
        /*0x2250224*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x2250280*/ int System.IComparable.CompareTo(object other);
        /*0x2250398*/ int CompareTo(System.ValueTuple other);
        /*0x22503a0*/ int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x22504b8*/ int GetHashCode();
        /*0x22504c0*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x22504c8*/ int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x22504d0*/ string ToString();
        /*0x2250510*/ string System.IValueTupleInternal.ToStringEnd();
        /*0x2250550*/ int System.Runtime.CompilerServices.ITuple.get_Length();
        /*0x2250558*/ object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    struct ValueTuple<T1> : System.IEquatable<System.ValueTuple<T1>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;

        ValueTuple(T1 item1);
        bool Equals(object obj);
        bool Equals(System.ValueTuple<T1> other);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object other);
        int CompareTo(System.ValueTuple<T1> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.IValueTupleInternal.ToStringEnd();
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    struct ValueTuple<T1, T2> : System.IEquatable<System.ValueTuple<T1, T2>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;

        ValueTuple(T1 item1, T2 item2);
        bool Equals(object obj);
        bool Equals(System.ValueTuple<T1, T2> other);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object other);
        int CompareTo(System.ValueTuple<T1, T2> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.IValueTupleInternal.ToStringEnd();
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    struct ValueTuple<T1, T2, T3> : System.IEquatable<System.ValueTuple<T1, T2, T3>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;

        ValueTuple(T1 item1, T2 item2, T3 item3);
        bool Equals(object obj);
        bool Equals(System.ValueTuple<T1, T2, T3> other);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object other);
        int CompareTo(System.ValueTuple<T1, T2, T3> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.IValueTupleInternal.ToStringEnd();
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    struct ValueTuple<T1, T2, T3, T4> : System.IEquatable<System.ValueTuple<T1, T2, T3, T4>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;

        ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4);
        bool Equals(object obj);
        bool Equals(System.ValueTuple<T1, T2, T3, T4> other);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object other);
        int CompareTo(System.ValueTuple<T1, T2, T3, T4> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.IValueTupleInternal.ToStringEnd();
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    struct ValueTuple<T1, T2, T3, T4, T5> : System.IEquatable<System.ValueTuple<T1, T2, T3, T4, T5>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4, T5>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
        /*0x0*/ T5 Item5;

        ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
        bool Equals(object obj);
        bool Equals(System.ValueTuple<T1, T2, T3, T4, T5> other);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object other);
        int CompareTo(System.ValueTuple<T1, T2, T3, T4, T5> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.IValueTupleInternal.ToStringEnd();
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    struct ValueTuple<T1, T2, T3, T4, T5, T6> : System.IEquatable<System.ValueTuple<T1, T2, T3, T4, T5, T6>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4, T5, T6>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
        /*0x0*/ T5 Item5;
        /*0x0*/ T6 Item6;

        ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
        bool Equals(object obj);
        bool Equals(System.ValueTuple<T1, T2, T3, T4, T5, T6> other);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object other);
        int CompareTo(System.ValueTuple<T1, T2, T3, T4, T5, T6> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.IValueTupleInternal.ToStringEnd();
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    struct ValueTuple<T1, T2, T3, T4, T5, T6, T7> : System.IEquatable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
        /*0x0*/ T5 Item5;
        /*0x0*/ T6 Item6;
        /*0x0*/ T7 Item7;

        ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
        bool Equals(object obj);
        bool Equals(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7> other);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object other);
        int CompareTo(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.IValueTupleInternal.ToStringEnd();
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    struct ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> : System.IEquatable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, System.Collections.IStructuralEquatable, System.Collections.IStructuralComparable, System.IComparable, System.IComparable<System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest>>, System.IValueTupleInternal, System.Runtime.CompilerServices.ITuple
    {
        /*0x0*/ T1 Item1;
        /*0x0*/ T2 Item2;
        /*0x0*/ T3 Item3;
        /*0x0*/ T4 Item4;
        /*0x0*/ T5 Item5;
        /*0x0*/ T6 Item6;
        /*0x0*/ T7 Item7;
        /*0x0*/ TRest Rest;

        ValueTuple(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
        bool Equals(object obj);
        bool Equals(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other);
        bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        int System.IComparable.CompareTo(object other);
        int CompareTo(System.ValueTuple<T1, T2, T3, T4, T5, T6, T7, TRest> other);
        int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        int GetHashCode();
        int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        int GetHashCodeCore(System.Collections.IEqualityComparer comparer);
        int System.IValueTupleInternal.GetHashCode(System.Collections.IEqualityComparer comparer);
        string ToString();
        string System.IValueTupleInternal.ToStringEnd();
        int System.Runtime.CompilerServices.ITuple.get_Length();
        object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    }

    class Version : System.ICloneable, System.IComparable, System.IComparable<System.Version>, System.IEquatable<System.Version>, System.ISpanFormattable
    {
        /*0x10*/ int _Major;
        /*0x14*/ int _Minor;
        /*0x18*/ int _Build;
        /*0x1c*/ int _Revision;

        static /*0x2250cfc*/ System.Version Parse(string input);
        static /*0x2251a1c*/ System.Version Parse(System.ReadOnlySpan<char> input);
        static /*0x2251a24*/ bool TryParse(string input, ref System.Version result);
        static /*0x2251ab8*/ bool TryParse(System.ReadOnlySpan<char> input, ref System.Version result);
        static /*0x2251548*/ System.Version ParseVersion(System.ReadOnlySpan<char> input, bool throwOnFailure);
        static /*0x2251ae0*/ bool TryParseComponent(System.ReadOnlySpan<char> component, string componentName, bool throwOnFailure, ref int parsedComponent);
        static /*0x2250f44*/ bool op_Equality(System.Version v1, System.Version v2);
        static /*0x2251a90*/ bool op_Inequality(System.Version v1, System.Version v2);
        static /*0x2251bf8*/ bool op_LessThan(System.Version v1, System.Version v2);
        static /*0x2251c5c*/ bool op_LessThanOrEqual(System.Version v1, System.Version v2);
        static /*0x2251cc4*/ bool op_GreaterThan(System.Version v1, System.Version v2);
        static /*0x2251cd4*/ bool op_GreaterThanOrEqual(System.Version v1, System.Version v2);
        /*0x22509dc*/ Version(int major, int minor, int build, int revision);
        /*0x2250b00*/ Version(int major, int minor, int build);
        /*0x2250bf8*/ Version(int major, int minor);
        /*0x2250cb8*/ Version(string version);
        /*0x2250d98*/ Version();
        /*0x2250dbc*/ Version(System.Version version);
        /*0x2250df8*/ object Clone();
        /*0x2250e58*/ int get_Major();
        /*0x2250e60*/ int get_Minor();
        /*0x2250e68*/ int get_Build();
        /*0x2250e70*/ int get_Revision();
        /*0x2250e78*/ short get_MajorRevision();
        /*0x2250e80*/ short get_MinorRevision();
        /*0x2250e88*/ int CompareTo(object version);
        /*0x2250f58*/ int CompareTo(System.Version value);
        /*0x2250fc0*/ bool Equals(object obj);
        /*0x2251024*/ bool Equals(System.Version obj);
        /*0x2251084*/ int GetHashCode();
        /*0x22510a0*/ string ToString();
        /*0x22510f0*/ string ToString(int fieldCount);
        /*0x22513c8*/ bool TryFormat(System.Span<char> destination, ref int charsWritten);
        /*0x22513f4*/ bool TryFormat(System.Span<char> destination, int fieldCount, ref int charsWritten);
        /*0x225151c*/ bool System.ISpanFormattable.TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x22510c8*/ int get_DefaultFormatFieldCount();
        /*0x225117c*/ System.Text.StringBuilder ToCachedStringBuilder(int fieldCount);
    }

    struct Void
    {
    }

    struct MutableDecimal
    {
        static uint SignMask = 2147483648;
        static uint ScaleMask = 16711680;
        static int ScaleShift = 16;
        /*0x10*/ uint Flags;
        /*0x14*/ uint High;
        /*0x18*/ uint Low;
        /*0x1c*/ uint Mid;

        /*0x2251ce4*/ bool get_IsNegative();
        /*0x2251cf0*/ void set_IsNegative(bool value);
        /*0x2251d0c*/ int get_Scale();
        /*0x2251d14*/ void set_Scale(int value);
    }

    class NotImplemented
    {
        static /*0x2251d28*/ System.Exception get_ByDesign();
        static /*0x2251d84*/ System.Exception ByDesignWithMessage(string message);
        static /*0x2251de8*/ System.Exception ActiveIssue(string issue);
    }

    interface IServiceProvider
    {
        object GetService(System.Type serviceType);
    }

    class ConsoleCancelEventHandler : System.MulticastDelegate
    {
        /*0x2251e44*/ ConsoleCancelEventHandler(object object, nint method);
        /*0x2251f74*/ void Invoke(object sender, System.ConsoleCancelEventArgs e);
        /*0x2251f88*/ System.IAsyncResult BeginInvoke(object sender, System.ConsoleCancelEventArgs e, System.AsyncCallback callback, object object);
        /*0x2251fb0*/ void EndInvoke(System.IAsyncResult result);
    }

    class ConsoleCancelEventArgs : System.EventArgs
    {
        /*0x10*/ System.ConsoleSpecialKey _type;
        /*0x14*/ bool <Cancel>k__BackingField;

        /*0x2251fbc*/ ConsoleCancelEventArgs(System.ConsoleSpecialKey type);
        /*0x2252044*/ ConsoleCancelEventArgs();
        /*0x2252028*/ bool get_Cancel();
        /*0x2252030*/ void set_Cancel(bool value);
        /*0x225203c*/ System.ConsoleSpecialKey get_SpecialKey();
    }

    enum ConsoleColor
    {
        Black = 0,
        DarkBlue = 1,
        DarkGreen = 2,
        DarkCyan = 3,
        DarkRed = 4,
        DarkMagenta = 5,
        DarkYellow = 6,
        Gray = 7,
        DarkGray = 8,
        Blue = 9,
        Green = 10,
        Cyan = 11,
        Red = 12,
        Magenta = 13,
        Yellow = 14,
        White = 15,
    }

    enum ConsoleKey
    {
        Backspace = 8,
        Tab = 9,
        Clear = 12,
        Enter = 13,
        Pause = 19,
        Escape = 27,
        Spacebar = 32,
        PageUp = 33,
        PageDown = 34,
        End = 35,
        Home = 36,
        LeftArrow = 37,
        UpArrow = 38,
        RightArrow = 39,
        DownArrow = 40,
        Select = 41,
        Print = 42,
        Execute = 43,
        PrintScreen = 44,
        Insert = 45,
        Delete = 46,
        Help = 47,
        D0 = 48,
        D1 = 49,
        D2 = 50,
        D3 = 51,
        D4 = 52,
        D5 = 53,
        D6 = 54,
        D7 = 55,
        D8 = 56,
        D9 = 57,
        A = 65,
        B = 66,
        C = 67,
        D = 68,
        E = 69,
        F = 70,
        G = 71,
        H = 72,
        I = 73,
        J = 74,
        K = 75,
        L = 76,
        M = 77,
        N = 78,
        O = 79,
        P = 80,
        Q = 81,
        R = 82,
        S = 83,
        T = 84,
        U = 85,
        V = 86,
        W = 87,
        X = 88,
        Y = 89,
        Z = 90,
        LeftWindows = 91,
        RightWindows = 92,
        Applications = 93,
        Sleep = 95,
        NumPad0 = 96,
        NumPad1 = 97,
        NumPad2 = 98,
        NumPad3 = 99,
        NumPad4 = 100,
        NumPad5 = 101,
        NumPad6 = 102,
        NumPad7 = 103,
        NumPad8 = 104,
        NumPad9 = 105,
        Multiply = 106,
        Add = 107,
        Separator = 108,
        Subtract = 109,
        Decimal = 110,
        Divide = 111,
        F1 = 112,
        F2 = 113,
        F3 = 114,
        F4 = 115,
        F5 = 116,
        F6 = 117,
        F7 = 118,
        F8 = 119,
        F9 = 120,
        F10 = 121,
        F11 = 122,
        F12 = 123,
        F13 = 124,
        F14 = 125,
        F15 = 126,
        F16 = 127,
        F17 = 128,
        F18 = 129,
        F19 = 130,
        F20 = 131,
        F21 = 132,
        F22 = 133,
        F23 = 134,
        F24 = 135,
        BrowserBack = 166,
        BrowserForward = 167,
        BrowserRefresh = 168,
        BrowserStop = 169,
        BrowserSearch = 170,
        BrowserFavorites = 171,
        BrowserHome = 172,
        VolumeMute = 173,
        VolumeDown = 174,
        VolumeUp = 175,
        MediaNext = 176,
        MediaPrevious = 177,
        MediaStop = 178,
        MediaPlay = 179,
        LaunchMail = 180,
        LaunchMediaSelect = 181,
        LaunchApp1 = 182,
        LaunchApp2 = 183,
        Oem1 = 186,
        OemPlus = 187,
        OemComma = 188,
        OemMinus = 189,
        OemPeriod = 190,
        Oem2 = 191,
        Oem3 = 192,
        Oem4 = 219,
        Oem5 = 220,
        Oem6 = 221,
        Oem7 = 222,
        Oem8 = 223,
        Oem102 = 226,
        Process = 229,
        Packet = 231,
        Attention = 246,
        CrSel = 247,
        ExSel = 248,
        EraseEndOfFile = 249,
        Play = 250,
        Zoom = 251,
        NoName = 252,
        Pa1 = 253,
        OemClear = 254,
    }

    struct ConsoleKeyInfo
    {
        /*0x10*/ char _keyChar;
        /*0x14*/ System.ConsoleKey _key;
        /*0x18*/ System.ConsoleModifiers _mods;

        static /*0x2252208*/ bool op_Equality(System.ConsoleKeyInfo a, System.ConsoleKeyInfo b);
        static /*0x225223c*/ bool op_Inequality(System.ConsoleKeyInfo a, System.ConsoleKeyInfo b);
        /*0x225207c*/ ConsoleKeyInfo(char keyChar, System.ConsoleKey key, bool shift, bool alt, bool control);
        /*0x2252124*/ char get_KeyChar();
        /*0x225212c*/ System.ConsoleKey get_Key();
        /*0x2252134*/ System.ConsoleModifiers get_Modifiers();
        /*0x225213c*/ bool Equals(object value);
        /*0x22521d4*/ bool Equals(System.ConsoleKeyInfo obj);
        /*0x2252270*/ int GetHashCode();
    }

    enum ConsoleModifiers
    {
        Alt = 1,
        Shift = 2,
        Control = 4,
    }

    enum ConsoleSpecialKey
    {
        ControlC = 0,
        ControlBreak = 1,
    }

    class DecimalDecCalc
    {
        static /*0x2252284*/ uint D32DivMod1E9(uint hi32, ref uint lo32);
        static /*0x22522c0*/ uint DecDivMod1E9(ref System.MutableDecimal value);
        static /*0x225233c*/ void DecAddInt32(ref System.MutableDecimal value, uint i);
        static /*0x225237c*/ bool D32AddCarry(ref uint value, uint i);
        static /*0x22523a0*/ void DecMul10(ref System.MutableDecimal value);
        static /*0x2252400*/ void DecShiftLeft(ref System.MutableDecimal value);
        static /*0x2252420*/ void DecAdd(ref System.MutableDecimal value, System.MutableDecimal d);
    }

    class Pinnable<T>
    {
        /*0x0*/ T Data;

        Pinnable();
    }

    struct SequencePosition : System.IEquatable<System.SequencePosition>
    {
        /*0x10*/ object _object;
        /*0x18*/ int _integer;

        /*0x2252488*/ SequencePosition(object object, int integer);
        /*0x2252494*/ object GetObject();
        /*0x225249c*/ int GetInteger();
        /*0x22524a4*/ bool Equals(System.SequencePosition other);
        /*0x22524c4*/ bool Equals(object obj);
        /*0x2252550*/ int GetHashCode();
    }

    class ThrowHelper
    {
        static /*0x22525d0*/ void ThrowArgumentNullException(System.ExceptionArgument argument);
        static /*0x22525f4*/ System.Exception CreateArgumentNullException(System.ExceptionArgument argument);
        static /*0x22526a0*/ void ThrowArrayTypeMismatchException();
        static /*0x22526c4*/ System.Exception CreateArrayTypeMismatchException();
        static /*0x2252720*/ void ThrowArgumentException_InvalidTypeWithPointersNotSupported(System.Type type);
        static /*0x2252744*/ System.Exception CreateArgumentException_InvalidTypeWithPointersNotSupported(System.Type type);
        static /*0x22527dc*/ void ThrowArgumentException_DestinationTooShort();
        static /*0x2252800*/ System.Exception CreateArgumentException_DestinationTooShort();
        static /*0x2252874*/ void ThrowIndexOutOfRangeException();
        static /*0x2252898*/ System.Exception CreateIndexOutOfRangeException();
        static /*0x22528f4*/ void ThrowArgumentOutOfRangeException();
        static /*0x2252918*/ System.Exception CreateArgumentOutOfRangeException();
        static /*0x2252974*/ void ThrowArgumentOutOfRangeException(System.ExceptionArgument argument);
        static /*0x2252998*/ System.Exception CreateArgumentOutOfRangeException(System.ExceptionArgument argument);
        static /*0x2252a44*/ void ThrowArgumentOutOfRangeException_PrecisionTooLarge();
        static /*0x2252a68*/ System.Exception CreateArgumentOutOfRangeException_PrecisionTooLarge();
        static /*0x2252b40*/ void ThrowArgumentOutOfRangeException_SymbolDoesNotFit();
        static /*0x2252b64*/ System.Exception CreateArgumentOutOfRangeException_SymbolDoesNotFit();
        static /*0x2252bf0*/ void ThrowInvalidOperationException();
        static /*0x2252c14*/ System.Exception CreateInvalidOperationException();
        static /*0x2252c70*/ void ThrowInvalidOperationException_OutstandingReferences();
        static /*0x2252c94*/ System.Exception CreateInvalidOperationException_OutstandingReferences();
        static /*0x2252d08*/ void ThrowInvalidOperationException_UnexpectedSegmentType();
        static /*0x2252d2c*/ System.Exception CreateInvalidOperationException_UnexpectedSegmentType();
        static /*0x2252da0*/ void ThrowInvalidOperationException_EndPositionNotReached();
        static /*0x2252dc4*/ System.Exception CreateInvalidOperationException_EndPositionNotReached();
        static /*0x2252e38*/ void ThrowArgumentOutOfRangeException_PositionOutOfRange();
        static /*0x2252e5c*/ System.Exception CreateArgumentOutOfRangeException_PositionOutOfRange();
        static /*0x2252ed0*/ void ThrowArgumentOutOfRangeException_OffsetOutOfRange();
        static /*0x2252ef4*/ System.Exception CreateArgumentOutOfRangeException_OffsetOutOfRange();
        static /*0x2252f68*/ void ThrowObjectDisposedException_ArrayMemoryPoolBuffer();
        static /*0x2252f8c*/ System.Exception CreateObjectDisposedException_ArrayMemoryPoolBuffer();
        static /*0x2253000*/ void ThrowFormatException_BadFormatSpecifier();
        static /*0x2253024*/ System.Exception CreateFormatException_BadFormatSpecifier();
        static /*0x2253098*/ void ThrowArgumentException_OverlapAlignmentMismatch();
        static /*0x22530bc*/ System.Exception CreateArgumentException_OverlapAlignmentMismatch();
        static /*0x2253130*/ void ThrowNotSupportedException();
        static /*0x2253154*/ System.Exception CreateThrowNotSupportedException();
        static /*0x22531b0*/ bool TryFormatThrowFormatException(ref int bytesWritten);
        static bool TryParseThrowFormatException<T>(ref T value, ref int bytesConsumed);
        static void ThrowArgumentValidationException<T>(System.Buffers.ReadOnlySequenceSegment<T> startSegment, int startIndex, System.Buffers.ReadOnlySequenceSegment<T> endSegment);
        static System.Exception CreateArgumentValidationException<T>(System.Buffers.ReadOnlySequenceSegment<T> startSegment, int startIndex, System.Buffers.ReadOnlySequenceSegment<T> endSegment);
        static /*0x22531bc*/ void ThrowArgumentValidationException(System.Array array, int start);
        static /*0x22531e0*/ System.Exception CreateArgumentValidationException(System.Array array, int start);
        static /*0x2253274*/ void ThrowStartOrEndArgumentValidationException(long start);
        static /*0x2253298*/ System.Exception CreateStartOrEndArgumentValidationException(long start);
        static /*0x22532ac*/ void ThrowWrongKeyTypeArgumentException(object key, System.Type targetType);
        static /*0x2253384*/ void ThrowWrongValueTypeArgumentException(object value, System.Type targetType);
        static /*0x225345c*/ void ThrowKeyNotFoundException();
        static /*0x225349c*/ void ThrowArgumentException(System.ExceptionResource resource);
        static /*0x2253780*/ void ThrowArgumentException(System.ExceptionResource resource, System.ExceptionArgument argument);
        static /*0x2253970*/ void ThrowArgumentOutOfRangeException(System.ExceptionArgument argument, System.ExceptionResource resource);
        static /*0x2253a14*/ void ThrowInvalidOperationException(System.ExceptionResource resource);
        static /*0x2253a6c*/ void ThrowSerializationException(System.ExceptionResource resource);
        static /*0x2253ac4*/ void ThrowSecurityException(System.ExceptionResource resource);
        static /*0x2253b1c*/ void ThrowNotSupportedException(System.ExceptionResource resource);
        static /*0x2253b74*/ void ThrowUnauthorizedAccessException(System.ExceptionResource resource);
        static /*0x2253bc8*/ void ThrowObjectDisposedException(string objectName, System.ExceptionResource resource);
        static /*0x2253c2c*/ void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
        static /*0x2253c7c*/ void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
        static /*0x2253ccc*/ void ThrowInvalidOperationException_InvalidOperation_EnumNotStarted();
        static /*0x2253d1c*/ void ThrowInvalidOperationException_InvalidOperation_EnumEnded();
        static /*0x2253d6c*/ void ThrowInvalidOperationException_InvalidOperation_NoValue();
        static /*0x2253dbc*/ System.ArgumentOutOfRangeException GetArgumentOutOfRangeException(System.ExceptionArgument argument, string resource);
        static /*0x2253e40*/ void ThrowArgumentOutOfRange_IndexException();
        static /*0x2253e78*/ void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
        static /*0x2253eb0*/ void ThrowArgumentException_Argument_InvalidArrayType();
        static /*0x2253f00*/ System.ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
        static /*0x2253f98*/ void ThrowAddingDuplicateWithKeyArgumentException(object key);
        static /*0x2253fbc*/ System.Collections.Generic.KeyNotFoundException GetKeyNotFoundException(object key);
        static /*0x225403c*/ void ThrowKeyNotFoundException(object key);
        static /*0x2254044*/ void ThrowInvalidTypeWithPointersNotSupported(System.Type targetType);
        static /*0x22540ac*/ void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
        static /*0x22540dc*/ System.InvalidOperationException GetInvalidOperationException(string str);
        static /*0x2254140*/ void ThrowArraySegmentCtorValidationFailedExceptions(System.Array array, int offset, int count);
        static /*0x2254164*/ System.Exception GetArraySegmentCtorValidationFailedException(System.Array array, int offset, int count);
        static /*0x22542c8*/ System.ArgumentException GetArgumentException(System.ExceptionResource resource);
        static /*0x2254194*/ System.ArgumentNullException GetArgumentNullException(System.ExceptionArgument argument);
        static void IfNullAndNullsAreIllegalThenThrow<T>(object value, System.ExceptionArgument argName);
        static /*0x22537ec*/ string GetArgumentName(System.ExceptionArgument argument);
        static /*0x2254208*/ System.ArgumentOutOfRangeException GetArgumentOutOfRangeException(System.ExceptionArgument argument, System.ExceptionResource resource);
        static /*0x2254374*/ void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
        static /*0x22543a0*/ void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
        static /*0x22534f4*/ string GetResourceName(System.ExceptionResource resource);
        static /*0x22543cc*/ void ThrowValueArgumentOutOfRange_NeedNonNegNumException();
    }

    class AppDomainUnloadedException : System.SystemException
    {
        static int COR_E_APPDOMAINUNLOADED = -2146234348;

        /*0x22543f8*/ AppDomainUnloadedException();
        /*0x2254454*/ AppDomainUnloadedException(string message);
        /*0x2254478*/ AppDomainUnloadedException(string message, System.Exception innerException);
        /*0x225449c*/ AppDomainUnloadedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class ApplicationId
    {
        /*0x10*/ byte[] _publicKeyToken;
        /*0x18*/ string <Culture>k__BackingField;
        /*0x20*/ string <Name>k__BackingField;
        /*0x28*/ string <ProcessorArchitecture>k__BackingField;
        /*0x30*/ System.Version <Version>k__BackingField;

        static /*0x2254a28*/ char HexDigit(int num);
        static /*0x225491c*/ string EncodeHexString(byte[] sArray);
        /*0x22544a4*/ ApplicationId(byte[] publicKeyToken, string name, System.Version version, string processorArchitecture, string culture);
        /*0x2254658*/ string get_Culture();
        /*0x2254660*/ string get_Name();
        /*0x2254668*/ string get_ProcessorArchitecture();
        /*0x2254670*/ System.Version get_Version();
        /*0x2254678*/ byte[] get_PublicKeyToken();
        /*0x22546f0*/ System.ApplicationId Copy();
        /*0x2254780*/ string ToString();
        /*0x2254a40*/ bool Equals(object o);
        /*0x2254b68*/ int GetHashCode();
    }

    class CannotUnloadAppDomainException : System.SystemException
    {
        static int COR_E_CANNOTUNLOADAPPDOMAIN = -2146234347;

        /*0x2254bb0*/ CannotUnloadAppDomainException();
        /*0x2254c0c*/ CannotUnloadAppDomainException(string message);
        /*0x2254c30*/ CannotUnloadAppDomainException(string message, System.Exception innerException);
        /*0x2254c54*/ CannotUnloadAppDomainException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    enum LoaderOptimization
    {
        DisallowBindings = 4,
        DomainMask = 3,
        MultiDomain = 2,
        MultiDomainHost = 3,
        NotSpecified = 0,
        SingleDomain = 1,
    }

    class LoaderOptimizationAttribute : System.Attribute
    {
        /*0x10*/ byte _val;

        /*0x2254c5c*/ LoaderOptimizationAttribute(byte value);
        /*0x2254c8c*/ LoaderOptimizationAttribute(System.LoaderOptimization value);
        /*0x2254cb4*/ System.LoaderOptimization get_Value();
    }

    class OperatingSystem : System.Runtime.Serialization.ISerializable, System.ICloneable
    {
        /*0x10*/ System.Version _version;
        /*0x18*/ System.PlatformID _platform;
        /*0x20*/ string _servicePack;
        /*0x28*/ string _versionString;

        /*0x2254cbc*/ OperatingSystem(System.PlatformID platform, System.Version version);
        /*0x2254cc4*/ OperatingSystem(System.PlatformID platform, System.Version version, string servicePack);
        /*0x2254e04*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2254e44*/ System.PlatformID get_Platform();
        /*0x2254e4c*/ string get_ServicePack();
        /*0x2254ea0*/ System.Version get_Version();
        /*0x2254ea8*/ object Clone();
        /*0x2254f24*/ string ToString();
        /*0x2254f28*/ string get_VersionString();
    }

    class InsufficientMemoryException : System.OutOfMemoryException
    {
        /*0x22550f4*/ InsufficientMemoryException();
        /*0x2255174*/ InsufficientMemoryException(string message);
        /*0x2255198*/ InsufficientMemoryException(string message, System.Exception innerException);
        /*0x22551e0*/ InsufficientMemoryException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class MissingFieldException : System.MissingMemberException, System.Runtime.Serialization.ISerializable
    {
        /*0x22551f0*/ MissingFieldException();
        /*0x2255270*/ MissingFieldException(string message);
        /*0x2255294*/ MissingFieldException(string message, System.Exception inner);
        /*0x22552dc*/ MissingFieldException(string className, string fieldName);
        /*0x2255360*/ MissingFieldException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x22554ec*/ string get_Message();
    }

    class MissingMemberException : System.MemberAccessException
    {
        /*0x90*/ string ClassName;
        /*0x98*/ string MemberName;
        /*0xa0*/ byte[] Signature;

        static /*0x22558c0*/ string FormatSignature(byte[] signature);
        /*0x2255304*/ MissingMemberException();
        /*0x225524c*/ MissingMemberException(string message);
        /*0x22552b8*/ MissingMemberException(string message, System.Exception inner);
        /*0x225572c*/ MissingMemberException(string className, string memberName);
        /*0x2255364*/ MissingMemberException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2255758*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2255600*/ string get_Message();
    }

    class OutOfMemoryException : System.SystemException
    {
        /*0x2255908*/ OutOfMemoryException();
        /*0x2255150*/ OutOfMemoryException(string message);
        /*0x22551bc*/ OutOfMemoryException(string message, System.Exception innerException);
        /*0x22551e8*/ OutOfMemoryException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class Array : System.Collections.ICollection, System.Collections.IEnumerable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable, System.ICloneable
    {
        static /*0x2255964*/ System.Array CreateInstance(System.Type elementType, long[] lengths);
        static System.Collections.ObjectModel.ReadOnlyCollection<T> AsReadOnly<T>(T[] array);
        static void Resize<T>(ref T[] array, int newSize);
        static /*0x2256d58*/ int CombineHashCodes(int h1, int h2);
        static /*0x2256ed8*/ int BinarySearch(System.Array array, object value);
        static TOutput[] ConvertAll<TInput, TOutput>(TInput[] array, System.Converter<TInput, TOutput> converter);
        static /*0x2257418*/ void Copy(System.Array sourceArray, System.Array destinationArray, long length);
        static /*0x2257558*/ void Copy(System.Array sourceArray, long sourceIndex, System.Array destinationArray, long destinationIndex, long length);
        static void ForEach<T>(T[] array, System.Action<T> action);
        static /*0x2257be8*/ int BinarySearch(System.Array array, int index, int length, object value);
        static /*0x2257bf0*/ int BinarySearch(System.Array array, object value, System.Collections.IComparer comparer);
        static /*0x2256f6c*/ int BinarySearch(System.Array array, int index, int length, object value, System.Collections.IComparer comparer);
        static /*0x2257c90*/ int GetMedian(int low, int hi);
        static int BinarySearch<T>(T[] array, T value);
        static int BinarySearch<T>(T[] array, T value, System.Collections.Generic.IComparer<T> comparer);
        static int BinarySearch<T>(T[] array, int index, int length, T value);
        static int BinarySearch<T>(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer);
        static /*0x2256114*/ int IndexOf(System.Array array, object value);
        static /*0x2257f40*/ int IndexOf(System.Array array, object value, int startIndex);
        static /*0x2257c9c*/ int IndexOf(System.Array array, object value, int startIndex, int count);
        static int IndexOf<T>(T[] array, T value);
        static int IndexOf<T>(T[] array, T value, int startIndex);
        static int IndexOf<T>(T[] array, T value, int startIndex, int count);
        static /*0x2257fe0*/ int LastIndexOf(System.Array array, object value);
        static /*0x225832c*/ int LastIndexOf(System.Array array, object value, int startIndex);
        static /*0x225806c*/ int LastIndexOf(System.Array array, object value, int startIndex, int count);
        static int LastIndexOf<T>(T[] array, T value);
        static int LastIndexOf<T>(T[] array, T value, int startIndex);
        static int LastIndexOf<T>(T[] array, T value, int startIndex, int count);
        static /*0x2258388*/ void Reverse(System.Array array);
        static /*0x2258410*/ void Reverse(System.Array array, int index, int length);
        static void Reverse<T>(T[] array);
        static void Reverse<T>(T[] array, int index, int length);
        static /*0x2258b40*/ void Sort(System.Array array);
        static /*0x2258e24*/ void Sort(System.Array array, int index, int length);
        static /*0x2258e38*/ void Sort(System.Array array, System.Collections.IComparer comparer);
        static /*0x2258ecc*/ void Sort(System.Array array, int index, int length, System.Collections.IComparer comparer);
        static /*0x2258ee0*/ void Sort(System.Array keys, System.Array items);
        static /*0x2258f74*/ void Sort(System.Array keys, System.Array items, System.Collections.IComparer comparer);
        static /*0x2259014*/ void Sort(System.Array keys, System.Array items, int index, int length);
        static /*0x2258bd0*/ void Sort(System.Array keys, System.Array items, int index, int length, System.Collections.IComparer comparer);
        static void Sort<T>(T[] array);
        static void Sort<T>(T[] array, int index, int length);
        static void Sort<T>(T[] array, System.Collections.Generic.IComparer<T> comparer);
        static void Sort<T>(T[] array, int index, int length, System.Collections.Generic.IComparer<T> comparer);
        static void Sort<T>(T[] array, System.Comparison<T> comparison);
        static void Sort<TKey, TValue>(TKey[] keys, TValue[] items);
        static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length);
        static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, System.Collections.Generic.IComparer<TKey> comparer);
        static void Sort<TKey, TValue>(TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer<TKey> comparer);
        static bool Exists<T>(T[] array, System.Predicate<T> match);
        static void Fill<T>(T[] array, T value);
        static void Fill<T>(T[] array, T value, int startIndex, int count);
        static T Find<T>(T[] array, System.Predicate<T> match);
        static T[] FindAll<T>(T[] array, System.Predicate<T> match);
        static int FindIndex<T>(T[] array, System.Predicate<T> match);
        static int FindIndex<T>(T[] array, int startIndex, System.Predicate<T> match);
        static int FindIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match);
        static T FindLast<T>(T[] array, System.Predicate<T> match);
        static int FindLastIndex<T>(T[] array, System.Predicate<T> match);
        static int FindLastIndex<T>(T[] array, int startIndex, System.Predicate<T> match);
        static int FindLastIndex<T>(T[] array, int startIndex, int count, System.Predicate<T> match);
        static bool TrueForAll<T>(T[] array, System.Predicate<T> match);
        static /*0x2259280*/ bool FastCopy(System.Array source, int source_idx, System.Array dest, int dest_idx, int length);
        static /*0x2259284*/ System.Array CreateInstanceImpl(System.Type elementType, int[] lengths, int[] bounds);
        static /*0x22592c0*/ System.Array UnsafeCreateInstance(System.Type elementType, int[] lengths, int[] lowerBounds);
        static /*0x22596e8*/ System.Array UnsafeCreateInstance(System.Type elementType, int length1, int length2);
        static /*0x2259774*/ System.Array UnsafeCreateInstance(System.Type elementType, int[] lengths);
        static /*0x2259778*/ System.Array CreateInstance(System.Type elementType, int length);
        static /*0x22596ec*/ System.Array CreateInstance(System.Type elementType, int length1, int length2);
        static /*0x22597f0*/ System.Array CreateInstance(System.Type elementType, int length1, int length2, int length3);
        static /*0x2255ae8*/ System.Array CreateInstance(System.Type elementType, int[] lengths);
        static /*0x22592c4*/ System.Array CreateInstance(System.Type elementType, int[] lengths, int[] lowerBounds);
        static /*0x22561e0*/ void Clear(System.Array array, int index, int length);
        static /*0x2259890*/ void ClearInternal(System.Array a, int index, int count);
        static /*0x225748c*/ void Copy(System.Array sourceArray, System.Array destinationArray, int length);
        static /*0x22564b4*/ void Copy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length);
        static /*0x2259894*/ System.ArrayTypeMismatchException CreateArrayTypeMismatchException();
        static /*0x22598f0*/ bool CanAssignArrayElement(System.Type source, System.Type target);
        static /*0x22599b4*/ void ConstrainedCopy(System.Array sourceArray, int sourceIndex, System.Array destinationArray, int destinationIndex, int length);
        static T[] Empty<T>();
        static int IndexOfImpl<T>(T[] array, T value, int startIndex, int count);
        static int LastIndexOfImpl<T>(T[] array, T value, int startIndex, int count);
        static /*0x225901c*/ void SortImpl(System.Array keys, System.Array items, int index, int length, System.Collections.IComparer comparer);
        static T UnsafeLoad<T>(T[] array, int index);
        static void UnsafeStore<T>(T[] array, int index, T value);
        static R UnsafeMov<S, R>(S instance);
        /*0x22591a8*/ Array();
        /*0x2255dac*/ int System.Collections.ICollection.get_Count();
        /*0x2255db0*/ bool System.Collections.IList.get_IsReadOnly();
        /*0x2255db8*/ object System.Collections.IList.get_Item(int index);
        /*0x2255f28*/ void System.Collections.IList.set_Item(int index, object value);
        /*0x22560ac*/ int System.Collections.IList.Add(object value);
        /*0x22560fc*/ bool System.Collections.IList.Contains(object value);
        /*0x22561a4*/ void System.Collections.IList.Clear();
        /*0x2256308*/ int System.Collections.IList.IndexOf(object value);
        /*0x225630c*/ void System.Collections.IList.Insert(int index, object value);
        /*0x225635c*/ void System.Collections.IList.Remove(object value);
        /*0x22563ac*/ void System.Collections.IList.RemoveAt(int index);
        /*0x22563fc*/ void CopyTo(System.Array array, int index);
        /*0x2254650*/ object Clone();
        /*0x22569e4*/ int System.Collections.IStructuralComparable.CompareTo(object other, System.Collections.IComparer comparer);
        /*0x2256bc8*/ bool System.Collections.IStructuralEquatable.Equals(object other, System.Collections.IEqualityComparer comparer);
        /*0x2256d64*/ int System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer comparer);
        /*0x225762c*/ void CopyTo(System.Array array, long index);
        /*0x22576a0*/ long get_LongLength();
        /*0x2257708*/ long GetLongLength(int dimension);
        /*0x225771c*/ object GetValue(long index);
        /*0x2257790*/ object GetValue(long index1, long index2);
        /*0x22578c0*/ object GetValue(long index1, long index2, long index3);
        /*0x2257a34*/ object GetValue(long[] indices);
        /*0x2257bcc*/ bool get_IsFixedSize();
        /*0x2257bd4*/ bool get_IsReadOnly();
        /*0x2257bdc*/ bool get_IsSynchronized();
        /*0x2257be4*/ object get_SyncRoot();
        /*0x2258668*/ void SetValue(object value, long index);
        /*0x22586dc*/ void SetValue(object value, long index1, long index2);
        /*0x225881c*/ void SetValue(object value, long index1, long index2, long index3);
        /*0x2258998*/ void SetValue(object value, long[] indices);
        /*0x2259104*/ System.Collections.IEnumerator GetEnumerator();
        /*0x22591b0*/ int InternalArray__ICollection_get_Count();
        /*0x22591b4*/ bool InternalArray__ICollection_get_IsReadOnly();
        /*0x22591bc*/ ref byte GetRawSzArrayData();
        System.Collections.Generic.IEnumerator<T> InternalArray__IEnumerable_GetEnumerator<T>();
        /*0x22591d0*/ void InternalArray__ICollection_Clear();
        void InternalArray__ICollection_Add<T>(T item);
        bool InternalArray__ICollection_Remove<T>(T item);
        bool InternalArray__ICollection_Contains<T>(T item);
        void InternalArray__ICollection_CopyTo<T>(T[] array, int arrayIndex);
        T InternalArray__IReadOnlyList_get_Item<T>(int index);
        /*0x2259220*/ int InternalArray__IReadOnlyCollection_get_Count();
        void InternalArray__Insert<T>(int index, T item);
        /*0x2259224*/ void InternalArray__RemoveAt(int index);
        int InternalArray__IndexOf<T>(T item);
        T InternalArray__get_Item<T>(int index);
        void InternalArray__set_Item<T>(int index, T item);
        void GetGenericValueImpl<T>(int pos, ref T value);
        void SetGenericValueImpl<T>(int pos, ref T value);
        /*0x2253214*/ int get_Length();
        /*0x22564b0*/ int get_Rank();
        /*0x2259274*/ int GetRank();
        /*0x2257704*/ int GetLength(int dimension);
        /*0x22561dc*/ int GetLowerBound(int dimension);
        /*0x2257bc8*/ object GetValue(int[] indices);
        /*0x2258b3c*/ void SetValue(object value, int[] indices);
        /*0x2259278*/ object GetValueImpl(int pos);
        /*0x225927c*/ void SetValueImpl(object value, int pos);
        /*0x2259288*/ int GetUpperBound(int dimension);
        /*0x2255dbc*/ object GetValue(int index);
        /*0x2257838*/ object GetValue(int index1, int index2);
        /*0x2257994*/ object GetValue(int index1, int index2, int index3);
        /*0x2255f38*/ void SetValue(object value, int index);
        /*0x2258784*/ void SetValue(object value, int index1, int index2);
        /*0x22588f0*/ void SetValue(object value, int index1, int index2, int index3);
        /*0x22599b8*/ void Initialize();

        class ArrayEnumerator : System.Collections.IEnumerator, System.ICloneable
        {
            /*0x10*/ System.Array _array;
            /*0x18*/ int _index;
            /*0x1c*/ int _endIndex;

            /*0x2259164*/ ArrayEnumerator(System.Array array);
            /*0x2259abc*/ bool MoveNext();
            /*0x2259ae4*/ void Reset();
            /*0x2259af0*/ object Clone();
            /*0x2259af8*/ object get_Current();
        }

        class RawData
        {
            /*0x10*/ nint Bounds;
            /*0x18*/ nint Count;
            /*0x20*/ byte Data;
        }

        struct InternalEnumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
        {
            /*0x0*/ System.Array array;
            /*0x0*/ int idx;

            InternalEnumerator(System.Array array);
            void Dispose();
            bool MoveNext();
            T get_Current();
            void System.Collections.IEnumerator.Reset();
            object System.Collections.IEnumerator.get_Current();
        }

        class EmptyInternalEnumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
        {
            static /*0x0*/ System.Array.EmptyInternalEnumerator<T> Value;

            static EmptyInternalEnumerator();
            EmptyInternalEnumerator();
            void Dispose();
            bool MoveNext();
            T get_Current();
            object System.Collections.IEnumerator.get_Current();
            void System.Collections.IEnumerator.Reset();
        }

        struct SorterObjectArray
        {
            /*0x10*/ object[] keys;
            /*0x18*/ object[] items;
            /*0x20*/ System.Collections.IComparer comparer;

            /*0x22599bc*/ SorterObjectArray(object[] keys, object[] items, System.Collections.IComparer comparer);
            /*0x2259c0c*/ void SwapIfGreaterWithItems(int a, int b);
            /*0x2259e3c*/ void Swap(int i, int j);
            /*0x2259a38*/ void Sort(int left, int length);
            /*0x2259fa0*/ void IntrospectiveSort(int left, int length);
            /*0x225a0f0*/ void IntroSort(int lo, int hi, int depthLimit);
            /*0x225a540*/ int PickPivotAndPartition(int lo, int hi);
            /*0x225a4a0*/ void Heapsort(int lo, int hi);
            /*0x225a76c*/ void DownHeap(int i, int n, int lo);
            /*0x225a204*/ void InsertionSort(int lo, int hi);
        }

        struct SorterGenericArray
        {
            /*0x10*/ System.Array keys;
            /*0x18*/ System.Array items;
            /*0x20*/ System.Collections.IComparer comparer;

            /*0x2259a3c*/ SorterGenericArray(System.Array keys, System.Array items, System.Collections.IComparer comparer);
            /*0x225aac8*/ void SwapIfGreaterWithItems(int a, int b);
            /*0x225ac70*/ void Swap(int i, int j);
            /*0x2259ab8*/ void Sort(int left, int length);
            /*0x225ad3c*/ void IntrospectiveSort(int left, int length);
            /*0x225ae90*/ void IntroSort(int lo, int hi, int depthLimit);
            /*0x225b208*/ int PickPivotAndPartition(int lo, int hi);
            /*0x225b168*/ void Heapsort(int lo, int hi);
            /*0x225b418*/ void DownHeap(int i, int n, int lo);
            /*0x225afa4*/ void InsertionSort(int lo, int hi);
        }
    }

    struct ByReference<T>
    {
        /*0x0*/ nint _value;

        ByReference(ref T value);
        ref T get_Value();
    }

    class MonoTODOAttribute : System.Attribute
    {
        /*0x10*/ string comment;

        /*0x225b6bc*/ MonoTODOAttribute();
        /*0x225b6c4*/ MonoTODOAttribute(string comment);
        /*0x225b6ec*/ string get_Comment();
    }

    class MonoDocumentationNoteAttribute : System.MonoTODOAttribute
    {
        /*0x225b6f4*/ MonoDocumentationNoteAttribute(string comment);
    }

    class MonoExtensionAttribute : System.MonoTODOAttribute
    {
        /*0x225b71c*/ MonoExtensionAttribute(string comment);
    }

    class MonoInternalNoteAttribute : System.MonoTODOAttribute
    {
        /*0x225b744*/ MonoInternalNoteAttribute(string comment);
    }

    class MonoLimitationAttribute : System.MonoTODOAttribute
    {
        /*0x225b76c*/ MonoLimitationAttribute(string comment);
    }

    class MonoNotSupportedAttribute : System.MonoTODOAttribute
    {
        /*0x225b794*/ MonoNotSupportedAttribute(string comment);
    }

    class AppContext
    {
        static /*0x0*/ System.Collections.Generic.Dictionary<string, System.AppContext.SwitchValueState> s_switchMap;
        static /*0x8*/ bool s_defaultsInitialized;

        static /*0x225c19c*/ AppContext();
        static /*0x225b7bc*/ string get_BaseDirectory();
        static /*0x225b84c*/ string get_TargetFrameworkName();
        static /*0x225b878*/ object GetData(string name);
        static /*0x225b8a0*/ void InitializeDefaultSwitchValues();
        static /*0x225ba18*/ bool TryGetSwitch(string switchName, ref bool isEnabled);
        static /*0x225be20*/ void SetSwitch(string switchName, bool isEnabled);
        static /*0x225c06c*/ void DefineSwitchDefault(string switchName, bool isEnabled);
        static /*0x225c104*/ void DefineSwitchOverride(string switchName, bool isEnabled);

        enum SwitchValueState
        {
            HasFalseValue = 1,
            HasTrueValue = 2,
            HasLookedForOverride = 4,
            UnknownValue = 8,
        }
    }

    class AppContextSwitches
    {
        static /*0x0*/ bool ThrowExceptionIfDisposedCancellationTokenSource;
        static /*0x1*/ bool SetActorAsReferenceWhenCopyingClaimsIdentity;
        static /*0x2*/ bool NoAsyncCurrentCulture;
        static /*0x3*/ bool EnforceJapaneseEraYearRanges;
        static /*0x4*/ bool FormatJapaneseFirstYearAsANumber;
        static /*0x5*/ bool EnforceLegacyJapaneseDateParsing;
    }

    class __Filters
    {
        static /*0x0*/ System.__Filters Instance;

        static /*0x225c8e8*/ __Filters();
        /*0x225c8e0*/ __Filters();
        /*0x225c238*/ bool FilterAttribute(System.Reflection.MemberInfo m, object filterCriteria);
        /*0x225c5a4*/ bool FilterName(System.Reflection.MemberInfo m, object filterCriteria);
        /*0x225c738*/ bool FilterIgnoreCase(System.Reflection.MemberInfo m, object filterCriteria);
    }

    class __HResults
    {
        static int RO_E_CLOSED = -2147483629;
        static int E_BOUNDS = -2147483637;
        static int E_CHANGED_STATE = -2147483636;
        static int E_FAIL = -2147467259;
        static int E_POINTER = -2147467261;
        static int E_NOTIMPL = -2147467263;
        static int REGDB_E_CLASSNOTREG = -2147221164;
        static int COR_E_AMBIGUOUSMATCH = -2147475171;
        static int COR_E_APPDOMAINUNLOADED = -2146234348;
        static int COR_E_APPLICATION = -2146232832;
        static int COR_E_ARGUMENT = -2147024809;
        static int COR_E_ARGUMENTOUTOFRANGE = -2146233086;
        static int COR_E_ARITHMETIC = -2147024362;
        static int COR_E_ARRAYTYPEMISMATCH = -2146233085;
        static int COR_E_BADIMAGEFORMAT = -2147024885;
        static int COR_E_TYPEUNLOADED = -2146234349;
        static int COR_E_CANNOTUNLOADAPPDOMAIN = -2146234347;
        static int COR_E_COMEMULATE = -2146233035;
        static int COR_E_CONTEXTMARSHAL = -2146233084;
        static int COR_E_DATAMISALIGNED = -2146233023;
        static int COR_E_TIMEOUT = -2146233083;
        static int COR_E_CUSTOMATTRIBUTEFORMAT = -2146232827;
        static int COR_E_DIVIDEBYZERO = -2147352558;
        static int COR_E_DUPLICATEWAITOBJECT = -2146233047;
        static int COR_E_EXCEPTION = -2146233088;
        static int COR_E_EXECUTIONENGINE = -2146233082;
        static int COR_E_FIELDACCESS = -2146233081;
        static int COR_E_FORMAT = -2146233033;
        static int COR_E_INDEXOUTOFRANGE = -2146233080;
        static int COR_E_INSUFFICIENTMEMORY = -2146233027;
        static int COR_E_INSUFFICIENTEXECUTIONSTACK = -2146232968;
        static int COR_E_INVALIDCAST = -2147467262;
        static int COR_E_INVALIDCOMOBJECT = -2146233049;
        static int COR_E_INVALIDFILTERCRITERIA = -2146232831;
        static int COR_E_INVALIDOLEVARIANTTYPE = -2146233039;
        static int COR_E_INVALIDOPERATION = -2146233079;
        static int COR_E_INVALIDPROGRAM = -2146233030;
        static int COR_E_KEYNOTFOUND = -2146232969;
        static int COR_E_MARSHALDIRECTIVE = -2146233035;
        static int COR_E_MEMBERACCESS = -2146233062;
        static int COR_E_METHODACCESS = -2146233072;
        static int COR_E_MISSINGFIELD = -2146233071;
        static int COR_E_MISSINGMANIFESTRESOURCE = -2146233038;
        static int COR_E_MISSINGMEMBER = -2146233070;
        static int COR_E_MISSINGMETHOD = -2146233069;
        static int COR_E_MISSINGSATELLITEASSEMBLY = -2146233034;
        static int COR_E_MULTICASTNOTSUPPORTED = -2146233068;
        static int COR_E_NOTFINITENUMBER = -2146233048;
        static int COR_E_PLATFORMNOTSUPPORTED = -2146233031;
        static int COR_E_NOTSUPPORTED = -2146233067;
        static int COR_E_NULLREFERENCE = -2147467261;
        static int COR_E_OBJECTDISPOSED = -2146232798;
        static int COR_E_OPERATIONCANCELED = -2146233029;
        static int COR_E_OUTOFMEMORY = -2147024882;
        static int COR_E_OVERFLOW = -2146233066;
        static int COR_E_RANK = -2146233065;
        static int COR_E_REFLECTIONTYPELOAD = -2146232830;
        static int COR_E_RUNTIMEWRAPPED = -2146233026;
        static int COR_E_SAFEARRAYRANKMISMATCH = -2146233032;
        static int COR_E_SAFEARRAYTYPEMISMATCH = -2146233037;
        static int COR_E_SAFEHANDLEMISSINGATTRIBUTE = -2146232797;
        static int COR_E_SECURITY = -2146233078;
        static int COR_E_SERIALIZATION = -2146233076;
        static int COR_E_SEMAPHOREFULL = -2146233045;
        static int COR_E_WAITHANDLECANNOTBEOPENED = -2146233044;
        static int COR_E_ABANDONEDMUTEX = -2146233043;
        static int COR_E_STACKOVERFLOW = -2147023895;
        static int COR_E_SYNCHRONIZATIONLOCK = -2146233064;
        static int COR_E_SYSTEM = -2146233087;
        static int COR_E_TARGET = -2146232829;
        static int COR_E_TARGETINVOCATION = -2146232828;
        static int COR_E_TARGETPARAMCOUNT = -2147352562;
        static int COR_E_THREADABORTED = -2146233040;
        static int COR_E_THREADINTERRUPTED = -2146233063;
        static int COR_E_THREADSTATE = -2146233056;
        static int COR_E_THREADSTOP = -2146233055;
        static int COR_E_THREADSTART = -2146233051;
        static int COR_E_TYPEACCESS = -2146233021;
        static int COR_E_TYPEINITIALIZATION = -2146233036;
        static int COR_E_TYPELOAD = -2146233054;
        static int COR_E_ENTRYPOINTNOTFOUND = -2146233053;
        static int COR_E_DLLNOTFOUND = -2146233052;
        static int COR_E_UNAUTHORIZEDACCESS = -2147024891;
        static int COR_E_UNSUPPORTEDFORMAT = -2146233053;
        static int COR_E_VERIFICATION = -2146233075;
        static int COR_E_HOSTPROTECTION = -2146232768;
        static int CORSEC_E_MIN_GRANT_FAIL = -2146233321;
        static int CORSEC_E_NO_EXEC_PERM = -2146233320;
        static int CORSEC_E_POLICY_EXCEPTION = -2146233322;
        static int CORSEC_E_XMLSYNTAX = -2146233320;
        static int NTE_FAIL = -2146893792;
        static int CORSEC_E_CRYPTO = -2146233296;
        static int CORSEC_E_CRYPTO_UNEX_OPER = -2146233295;
        static int DISP_E_OVERFLOW = -2147352566;
        static int FUSION_E_REF_DEF_MISMATCH = -2146234304;
        static int FUSION_E_INVALID_NAME = -2146234297;
        static int TYPE_E_TYPEMISMATCH = -2147316576;
    }

    class LocalDataStoreHolder
    {
        /*0x10*/ System.LocalDataStore m_Store;

        /*0x225c94c*/ LocalDataStoreHolder(System.LocalDataStore store);
        /*0x225c974*/ void Finalize();
        /*0x225ca2c*/ System.LocalDataStore get_Store();
    }

    class LocalDataStoreElement
    {
        /*0x10*/ object m_value;
        /*0x18*/ long m_cookie;

        /*0x225ca34*/ LocalDataStoreElement(long cookie);
        /*0x225ca5c*/ object get_Value();
        /*0x225ca64*/ void set_Value(object value);
        /*0x225ca6c*/ long get_Cookie();
    }

    class LocalDataStore
    {
        /*0x10*/ System.LocalDataStoreElement[] m_DataTable;
        /*0x18*/ System.LocalDataStoreMgr m_Manager;

        /*0x225ca74*/ LocalDataStore(System.LocalDataStoreMgr mgr, int InitialCapacity);
        /*0x225ca10*/ void Dispose();
        /*0x225cbe8*/ object GetData(System.LocalDataStoreSlot slot);
        /*0x225cd3c*/ void SetData(System.LocalDataStoreSlot slot, object data);
        /*0x225d0c8*/ void FreeData(int slot, long cookie);
        /*0x225ce20*/ System.LocalDataStoreElement PopulateElement(System.LocalDataStoreSlot slot);
    }

    class LocalDataStoreSlot
    {
        /*0x10*/ System.LocalDataStoreMgr m_mgr;
        /*0x18*/ int m_slot;
        /*0x20*/ long m_cookie;

        /*0x225d12c*/ LocalDataStoreSlot(System.LocalDataStoreMgr mgr, int slot, long cookie);
        /*0x225d3c8*/ LocalDataStoreSlot();
        /*0x225d16c*/ System.LocalDataStoreMgr get_Manager();
        /*0x225d174*/ int get_Slot();
        /*0x225d17c*/ long get_Cookie();
        /*0x225d184*/ void Finalize();
    }

    class LocalDataStoreMgr
    {
        static int InitialSlotTableSize = 64;
        static int SlotTableDoubleThreshold = 512;
        static int LargeSlotTableSizeIncrease = 128;
        /*0x10*/ bool[] m_SlotInfoTable;
        /*0x18*/ int m_FirstAvailableSlot;
        /*0x20*/ System.Collections.Generic.List<System.LocalDataStore> m_ManagedLocalDataStores;
        /*0x28*/ System.Collections.Generic.Dictionary<string, System.LocalDataStoreSlot> m_KeyToSlotMap;
        /*0x30*/ long m_CookieGenerator;

        /*0x225db48*/ LocalDataStoreMgr();
        /*0x225d400*/ System.LocalDataStoreHolder CreateLocalDataStore();
        /*0x225cae4*/ void DeleteLocalDataStore(System.LocalDataStore store);
        /*0x225d5c0*/ System.LocalDataStoreSlot AllocateDataSlot();
        /*0x225d80c*/ System.LocalDataStoreSlot AllocateNamedDataSlot(string name);
        /*0x225d928*/ System.LocalDataStoreSlot GetNamedDataSlot(string name);
        /*0x225da44*/ void FreeNamedDataSlot(string name);
        /*0x225d230*/ void FreeDataSlot(int slot, long cookie);
        /*0x225ccc0*/ void ValidateSlot(System.LocalDataStoreSlot slot);
        /*0x225d110*/ int GetSlotTableLength();
    }

    class Activator : System.Runtime.InteropServices._Activator
    {
        static int LookupMask = 255;
        static System.Reflection.BindingFlags ConLookup = 20;
        static System.Reflection.BindingFlags ConstructorDefault = 532;

        static /*0x225dc3c*/ object CreateInstance(System.Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);
        static /*0x225dc44*/ object CreateInstance(System.Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        static /*0x225de78*/ object CreateInstance(System.Type type, object[] args);
        static /*0x225de90*/ object CreateInstance(System.Type type, object[] args, object[] activationAttributes);
        static /*0x225dea8*/ object CreateInstance(System.Type type);
        static /*0x225dec0*/ System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName);
        static /*0x225e1a0*/ System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes);
        static /*0x225deb4*/ object CreateInstance(System.Type type, bool nonPublic);
        static /*0x225e220*/ object CreateInstance(System.Type type, bool nonPublic, bool wrapExceptions);
        static T CreateInstance<T>();
        static /*0x225e3d8*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
        static /*0x225e40c*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes);
        static /*0x225e460*/ System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);
        static /*0x225e508*/ System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        static /*0x225df34*/ System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyString, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo, ref System.Threading.StackCrawlMark stackMark);
        static /*0x225e5ac*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);
        static /*0x225e440*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        static /*0x225e5bc*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFromInternal(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);
        static /*0x225e6b8*/ System.Runtime.Remoting.ObjectHandle CreateInstance(System.AppDomain domain, string assemblyName, string typeName);
        static /*0x225e714*/ System.Runtime.Remoting.ObjectHandle CreateInstance(System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        static /*0x225e780*/ System.Runtime.Remoting.ObjectHandle CreateInstance(System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        static /*0x225e7f8*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(System.AppDomain domain, string assemblyFile, string typeName);
        static /*0x225e854*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        static /*0x225e8c0*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        static /*0x225e938*/ System.Runtime.Remoting.ObjectHandle CreateInstance(System.ActivationContext activationContext);
        static /*0x225e9d0*/ System.Runtime.Remoting.ObjectHandle CreateInstance(System.ActivationContext activationContext, string[] activationCustomData);
        static /*0x225ea70*/ System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
        static /*0x225ea7c*/ System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
        static /*0x225ec84*/ object GetObject(System.Type type, string url);
        static /*0x225ec8c*/ object GetObject(System.Type type, string url, object state);
        static /*0x225ed80*/ void Log(bool test, string title, string success, string failure);
        /*0x225dc34*/ Activator();
        /*0x225ed84*/ void System.Runtime.InteropServices._Activator.GetTypeInfoCount(ref uint pcTInfo);
        /*0x225edc4*/ void System.Runtime.InteropServices._Activator.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
        /*0x225ee04*/ void System.Runtime.InteropServices._Activator.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
        /*0x225ee44*/ void System.Runtime.InteropServices._Activator.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
    }

    class Attribute : System.Runtime.InteropServices._Attribute
    {
        static /*0x225ee84*/ System.Attribute[] InternalGetCustomAttributes(System.Reflection.PropertyInfo element, System.Type type, bool inherit);
        static /*0x225ef30*/ System.Attribute[] InternalGetCustomAttributes(System.Reflection.EventInfo element, System.Type type, bool inherit);
        static /*0x225efdc*/ System.Attribute[] InternalParamGetCustomAttributes(System.Reflection.ParameterInfo parameter, System.Type attributeType, bool inherit);
        static /*0x225f504*/ bool InternalIsDefined(System.Reflection.PropertyInfo element, System.Type attributeType, bool inherit);
        static /*0x225f574*/ bool InternalIsDefined(System.Reflection.EventInfo element, System.Type attributeType, bool inherit);
        static /*0x225f5e4*/ bool InternalParamIsDefined(System.Reflection.ParameterInfo parameter, System.Type attributeType, bool inherit);
        static /*0x225f7fc*/ System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, System.Type type);
        static /*0x225f804*/ System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, System.Type type, bool inherit);
        static /*0x225fb0c*/ System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element);
        static /*0x225fb14*/ System.Attribute[] GetCustomAttributes(System.Reflection.MemberInfo element, bool inherit);
        static /*0x225fd5c*/ bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType);
        static /*0x225fd64*/ bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit);
        static /*0x2260050*/ System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType);
        static /*0x2260058*/ System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit);
        static /*0x22600ec*/ System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element);
        static /*0x22602d8*/ System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, System.Type attributeType);
        static /*0x22602e0*/ System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit);
        static /*0x22600f4*/ System.Attribute[] GetCustomAttributes(System.Reflection.ParameterInfo element, bool inherit);
        static /*0x22605b4*/ bool IsDefined(System.Reflection.ParameterInfo element, System.Type attributeType);
        static /*0x22605bc*/ bool IsDefined(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit);
        static /*0x2260814*/ System.Attribute GetCustomAttribute(System.Reflection.ParameterInfo element, System.Type attributeType);
        static /*0x226081c*/ System.Attribute GetCustomAttribute(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit);
        static /*0x22608b0*/ System.Attribute[] GetCustomAttributes(System.Reflection.Module element, System.Type attributeType);
        static /*0x2260b18*/ System.Attribute[] GetCustomAttributes(System.Reflection.Module element);
        static /*0x2260b20*/ System.Attribute[] GetCustomAttributes(System.Reflection.Module element, bool inherit);
        static /*0x22608b8*/ System.Attribute[] GetCustomAttributes(System.Reflection.Module element, System.Type attributeType, bool inherit);
        static /*0x2260c80*/ bool IsDefined(System.Reflection.Module element, System.Type attributeType);
        static /*0x2260c88*/ bool IsDefined(System.Reflection.Module element, System.Type attributeType, bool inherit);
        static /*0x2260ea0*/ System.Attribute GetCustomAttribute(System.Reflection.Module element, System.Type attributeType);
        static /*0x2260ea8*/ System.Attribute GetCustomAttribute(System.Reflection.Module element, System.Type attributeType, bool inherit);
        static /*0x2260f3c*/ System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, System.Type attributeType);
        static /*0x2260f44*/ System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, System.Type attributeType, bool inherit);
        static /*0x2261180*/ System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element);
        static /*0x2261188*/ System.Attribute[] GetCustomAttributes(System.Reflection.Assembly element, bool inherit);
        static /*0x22612bc*/ bool IsDefined(System.Reflection.Assembly element, System.Type attributeType);
        static /*0x22612c4*/ bool IsDefined(System.Reflection.Assembly element, System.Type attributeType, bool inherit);
        static /*0x22614b8*/ System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType);
        static /*0x22614c0*/ System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType, bool inherit);
        static /*0x22617e0*/ bool AreFieldValuesEqual(object thisValue, object thatValue);
        /*0x2254c84*/ Attribute();
        /*0x2261554*/ bool Equals(object obj);
        /*0x22619a0*/ int GetHashCode();
        /*0x2261afc*/ object get_TypeId();
        /*0x2261b04*/ bool Match(object obj);
        /*0x2261b10*/ bool IsDefaultAttribute();
        /*0x2261b18*/ void System.Runtime.InteropServices._Attribute.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
        /*0x2261b50*/ void System.Runtime.InteropServices._Attribute.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
        /*0x2261b88*/ void System.Runtime.InteropServices._Attribute.GetTypeInfoCount(ref uint pcTInfo);
        /*0x2261bc0*/ void System.Runtime.InteropServices._Attribute.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
    }

    class Buffer
    {
        static /*0x2261bf8*/ bool InternalBlockCopy(System.Array src, int srcOffsetBytes, System.Array dst, int dstOffsetBytes, int byteCount);
        static /*0x2261bfc*/ int IndexOfByte(byte* src, byte value, int index, int count);
        static /*0x2261d0c*/ int _ByteLength(System.Array array);
        static /*0x2261d10*/ void ZeroMemory(byte* src, long len);
        static /*0x2261d34*/ void Memcpy(byte[] dest, int destIndex, byte* src, int srcIndex, int len);
        static /*0x2261dd4*/ void Memcpy(byte* pDest, int destIndex, byte[] src, int srcIndex, int len);
        static /*0x2261e08*/ void InternalMemcpy(byte* dest, byte* src, int count);
        static /*0x2261e0c*/ int ByteLength(System.Array array);
        static /*0x2261ea8*/ byte GetByte(System.Array array, int index);
        static /*0x2261f30*/ void SetByte(System.Array array, int index, byte value);
        static /*0x2261fbc*/ void BlockCopy(System.Array src, int srcOffset, System.Array dst, int dstOffset, int count);
        static /*0x226217c*/ void MemoryCopy(void* source, void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
        static /*0x2262224*/ void MemoryCopy(void* source, void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
        static /*0x2262298*/ void memcpy4(byte* dest, byte* src, int size);
        static /*0x2262324*/ void memcpy2(byte* dest, byte* src, int size);
        static /*0x22623a0*/ void memcpy1(byte* dest, byte* src, int size);
        static /*0x2261d68*/ void Memcpy(byte* dest, byte* src, int len, bool useICall);
        static /*0x22621f8*/ void Memmove(byte* dest, byte* src, uint len);
        static void Memmove<T>(ref T destination, ref T source, ulong elementCount);
    }

    class ContextBoundObject : System.MarshalByRefObject
    {
        /*0x226244c*/ ContextBoundObject();
    }

    class ContextMarshalException : System.SystemException
    {
        /*0x2262454*/ ContextMarshalException();
        /*0x22624c0*/ ContextMarshalException(string message);
        /*0x22624e8*/ ContextMarshalException(string message, System.Exception inner);
        /*0x2262510*/ ContextMarshalException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class ContextStaticAttribute : System.Attribute
    {
        /*0x2262518*/ ContextStaticAttribute();
    }

    class DefaultBinder : System.Reflection.Binder
    {
        static /*0x0*/ System.DefaultBinder.Primitives[] _primitiveConversions;

        static /*0x2267acc*/ DefaultBinder();
        static /*0x2266804*/ System.Reflection.MethodBase ExactBinding(System.Reflection.MethodBase[] match, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        static /*0x2266bcc*/ System.Reflection.PropertyInfo ExactPropertyBinding(System.Reflection.PropertyInfo[] match, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        static /*0x2265f98*/ int FindMostSpecific(System.Reflection.ParameterInfo[] p1, int[] paramOrder1, System.Type paramArrayType1, System.Reflection.ParameterInfo[] p2, int[] paramOrder2, System.Type paramArrayType2, System.Type[] types, object[] args);
        static /*0x2265c00*/ int FindMostSpecificType(System.Type c1, System.Type c2, System.Type t);
        static /*0x2264870*/ int FindMostSpecificMethod(System.Reflection.MethodBase m1, int[] paramOrder1, System.Type paramArrayType1, System.Reflection.MethodBase m2, int[] paramOrder2, System.Type paramArrayType2, System.Type[] types, object[] args);
        static /*0x2264ea8*/ int FindMostSpecificField(System.Reflection.FieldInfo cur1, System.Reflection.FieldInfo cur2);
        static /*0x22663dc*/ int FindMostSpecificProperty(System.Reflection.PropertyInfo cur1, System.Reflection.PropertyInfo cur2);
        static /*0x2266e8c*/ bool CompareMethodSigAndName(System.Reflection.MethodBase m1, System.Reflection.MethodBase m2);
        static /*0x2266ff0*/ int GetHierarchyDepth(System.Type t);
        static /*0x2266a78*/ System.Reflection.MethodBase FindMostDerivedNewSlotMeth(System.Reflection.MethodBase[] match, int cMatches);
        static /*0x2264720*/ void ReorderParams(int[] paramOrder, object[] vars);
        static /*0x22643cc*/ bool CreateParamOrder(int[] paramOrder, System.Reflection.ParameterInfo[] pars, string[] names);
        static /*0x22659c8*/ bool CanConvertPrimitive(System.RuntimeType source, System.RuntimeType target);
        static /*0x2264610*/ bool CanConvertPrimitiveObjectToType(object source, System.RuntimeType type);
        static /*0x2267084*/ bool CompareMethodSig(System.Reflection.MethodBase m1, System.Reflection.MethodBase m2);
        static /*0x2267910*/ bool CanChangePrimitive(System.Type source, System.Type target);
        static /*0x2267a4c*/ bool CanChangePrimitiveObjectToType(object source, System.Type type);
        static /*0x2267974*/ bool CanPrimitiveWiden(System.Type source, System.Type target);
        /*0x2267ac4*/ DefaultBinder();
        /*0x2262520*/ System.Reflection.MethodBase BindToMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo cultureInfo, string[] names, ref object state);
        /*0x22649f8*/ System.Reflection.FieldInfo BindToField(System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo cultureInfo);
        /*0x2264fa0*/ System.Reflection.PropertyInfo SelectProperty(System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, System.Type returnType, System.Type[] indexes, System.Reflection.ParameterModifier[] modifiers);
        /*0x22664d4*/ object ChangeType(object value, System.Type type, System.Globalization.CultureInfo cultureInfo);
        /*0x2266534*/ void ReorderArgumentArray(ref object[] args, object state);
        /*0x22671e8*/ System.Reflection.MethodBase SelectMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);

        class BinderState
        {
            /*0x10*/ int[] m_argsMap;
            /*0x18*/ int m_originalSize;
            /*0x1c*/ bool m_isParamArray;

            /*0x2267b60*/ BinderState(int[] argsMap, int originalSize, bool isParamArray);
        }

        enum Primitives
        {
            Boolean = 8,
            Char = 16,
            SByte = 32,
            Byte = 64,
            Int16 = 128,
            UInt16 = 256,
            Int32 = 512,
            UInt32 = 1024,
            Int64 = 2048,
            UInt64 = 4096,
            Single = 8192,
            Double = 16384,
            Decimal = 32768,
            DateTime = 65536,
            String = 262144,
        }

        class <>c
        {
            static /*0x0*/ System.DefaultBinder.<> <>9;
            static /*0x8*/ System.Predicate<System.Type> <>9__2_0;

            static /*0x2267ba0*/ <>c();
            /*0x2267c04*/ <>c();
            /*0x2267c0c*/ bool <SelectProperty>b__2_0(System.Type t);
        }
    }

    class Empty : System.Runtime.Serialization.ISerializable
    {
        static /*0x0*/ System.Empty Value;

        static /*0x2267eb0*/ Empty();
        /*0x2267c68*/ Empty();
        /*0x2267c70*/ string ToString();
        /*0x2267cb8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class Enum : System.IComparable, System.IFormattable, System.IConvertible
    {
        static string enumSeperator = ", ";
        static /*0x0*/ char[] enumSeperatorCharArray;

        static /*0x226cb48*/ Enum();
        static /*0x2267f14*/ System.Enum.ValuesAndNames GetCachedValuesAndNames(System.RuntimeType enumType, bool getNames);
        static /*0x2268094*/ string InternalFormattedHexString(object value);
        static /*0x226853c*/ string InternalFormat(System.RuntimeType eT, object value);
        static /*0x226872c*/ string InternalFlagsFormat(System.RuntimeType eT, object value);
        static /*0x2268928*/ ulong ToUInt64(object value);
        static /*0x2268a9c*/ int InternalCompareTo(object o1, object o2);
        static /*0x2268aa0*/ System.RuntimeType InternalGetUnderlyingType(System.RuntimeType enumType);
        static /*0x2268064*/ bool GetEnumValuesAndNames(System.RuntimeType enumType, ref ulong[] values, ref string[] names);
        static /*0x2268aa4*/ object InternalBoxEnum(System.RuntimeType enumType, long value);
        static bool TryParse<TEnum>(string value, ref TEnum result);
        static bool TryParse<TEnum>(string value, bool ignoreCase, ref TEnum result);
        static /*0x2268aa8*/ object Parse(System.Type enumType, string value);
        static /*0x2268b10*/ object Parse(System.Type enumType, string value, bool ignoreCase);
        static /*0x2268c34*/ bool TryParseEnum(System.Type enumType, string value, bool ignoreCase, ref System.Enum.EnumResult parseResult);
        static /*0x22694b0*/ System.Type GetUnderlyingType(System.Type enumType);
        static /*0x2269c18*/ System.Array GetValues(System.Type enumType);
        static /*0x2269ce0*/ ulong[] InternalGetValues(System.RuntimeType enumType);
        static /*0x2268654*/ string GetName(System.Type enumType, object value);
        static /*0x2269d48*/ string[] GetNames(System.Type enumType);
        static /*0x2269e10*/ string[] InternalGetNames(System.RuntimeType enumType);
        static /*0x2269578*/ object ToObject(System.Type enumType, object value);
        static /*0x226aef0*/ bool IsDefined(System.Type enumType, object value);
        static /*0x226afc8*/ string Format(System.Type enumType, object value, string format);
        static /*0x226a04c*/ object ToObject(System.Type enumType, sbyte value);
        static /*0x226a220*/ object ToObject(System.Type enumType, short value);
        static /*0x2269e78*/ object ToObject(System.Type enumType, int value);
        static /*0x226a79c*/ object ToObject(System.Type enumType, byte value);
        static /*0x226a970*/ object ToObject(System.Type enumType, ushort value);
        static /*0x226a5c8*/ object ToObject(System.Type enumType, uint value);
        static /*0x226a3f4*/ object ToObject(System.Type enumType, long value);
        static /*0x2269a44*/ object ToObject(System.Type enumType, ulong value);
        static /*0x226ab44*/ object ToObject(System.Type enumType, char value);
        static /*0x226ad18*/ object ToObject(System.Type enumType, bool value);
        static TEnum Parse<TEnum>(string value);
        static TEnum Parse<TEnum>(string value, bool ignoreCase);
        static /*0x226ca20*/ bool TryParse(System.Type enumType, string value, bool ignoreCase, ref object result);
        static /*0x226cad0*/ bool TryParse(System.Type enumType, string value, ref object result);
        /*0x226cb40*/ Enum();
        /*0x226b5b8*/ object get_value();
        /*0x226b5b4*/ object GetValue();
        /*0x226b5bc*/ bool InternalHasFlag(System.Enum flags);
        /*0x226b5c0*/ int get_hashcode();
        /*0x226b5c4*/ bool Equals(object obj);
        /*0x226b5cc*/ int GetHashCode();
        /*0x226b5d0*/ string ToString();
        /*0x226b69c*/ string ToString(string format, System.IFormatProvider provider);
        /*0x226b8f0*/ int CompareTo(object target);
        /*0x226b6a0*/ string ToString(string format);
        /*0x226bafc*/ string ToString(System.IFormatProvider provider);
        /*0x226bb08*/ bool HasFlag(System.Enum flag);
        /*0x226bc9c*/ System.TypeCode GetTypeCode();
        /*0x226c0a0*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x226c140*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x226c1e0*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x226c280*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x226c320*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x226c3c0*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x226c460*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x226c500*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x226c5a0*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x226c640*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x226c6e0*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x226c780*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x226c820*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x226c8c0*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x226c9b0*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);

        enum ParseFailureKind
        {
            None = 0,
            Argument = 1,
            ArgumentNull = 2,
            ArgumentWithParameter = 3,
            UnhandledException = 4,
        }

        struct EnumResult
        {
            /*0x10*/ object parsedEnum;
            /*0x18*/ bool canThrow;
            /*0x1c*/ System.Enum.ParseFailureKind m_failure;
            /*0x20*/ string m_failureMessageID;
            /*0x28*/ string m_failureParameter;
            /*0x30*/ object m_failureMessageFormatArgument;
            /*0x38*/ System.Exception m_innerException;

            /*0x2268bd0*/ void Init(bool canMethodThrow);
            /*0x2269a34*/ void SetFailure(System.Exception unhandledException);
            /*0x2269434*/ void SetFailure(System.Enum.ParseFailureKind failure, string failureParameter);
            /*0x2269470*/ void SetFailure(System.Enum.ParseFailureKind failure, string failureMessageID, object failureMessageFormatArgument);
            /*0x22692ac*/ System.Exception GetEnumParseException();
        }

        class ValuesAndNames
        {
            /*0x10*/ ulong[] Values;
            /*0x18*/ string[] Names;

            /*0x2268068*/ ValuesAndNames(ulong[] values, string[] names);
        }
    }

    class Exception : System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Exception
    {
        static int _COMPlusExceptionCode = -532462766;
        static /*0x0*/ object s_EDILock;
        /*0x10*/ string _className;
        /*0x18*/ string _message;
        /*0x20*/ System.Collections.IDictionary _data;
        /*0x28*/ System.Exception _innerException;
        /*0x30*/ string _helpURL;
        /*0x38*/ object _stackTrace;
        /*0x40*/ string _stackTraceString;
        /*0x48*/ string _remoteStackTraceString;
        /*0x50*/ int _remoteStackIndex;
        /*0x58*/ object _dynamicMethods;
        /*0x60*/ int _HResult;
        /*0x68*/ string _source;
        /*0x70*/ System.Runtime.Serialization.SafeSerializationManager _safeSerializationManager;
        /*0x78*/ System.Diagnostics.StackTrace[] captured_traces;
        /*0x80*/ nint[] native_trace_ips;
        /*0x88*/ int caught_in_unmanaged;

        static /*0x226e4a4*/ Exception();
        static /*0x226d2b0*/ bool IsImmutableAgileException(System.Exception e);
        static /*0x226e2e0*/ bool nIsTransient(int hr);
        static /*0x226e320*/ string GetMessageFromNativeResources(System.Exception.ExceptionMessageKind kind);
        static /*0x226e4a0*/ void ReportUnhandledException(System.Exception exception);
        /*0x226cc44*/ Exception();
        /*0x226cc60*/ Exception(string message);
        /*0x226cc90*/ Exception(string message, System.Exception innerException);
        /*0x226ccc8*/ Exception(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x226cbcc*/ void Init();
        /*0x226d130*/ string get_Message();
        /*0x226d244*/ System.Collections.IDictionary get_Data();
        /*0x226d208*/ string GetClassName();
        /*0x226d2c0*/ System.Exception GetBaseException();
        /*0x226d2d4*/ System.Exception get_InnerException();
        /*0x226d2dc*/ System.Reflection.MethodBase get_TargetSite();
        /*0x226d388*/ string get_StackTrace();
        /*0x226d390*/ string GetStackTrace(bool needFileInfo);
        /*0x226d3e4*/ void SetErrorCode(int hr);
        /*0x226d3ec*/ string get_HelpLink();
        /*0x226d3f4*/ void set_HelpLink(string value);
        /*0x226d3fc*/ string get_Source();
        /*0x226d50c*/ void set_Source(string value);
        /*0x226d514*/ string ToString();
        /*0x226d520*/ string ToString(bool needFileLineInfo, bool needMessage);
        /*0x226d7c8*/ void add_SerializeObjectState(System.EventHandler<System.Runtime.Serialization.SafeSerializationEventArgs> value);
        /*0x226d7e4*/ void remove_SerializeObjectState(System.EventHandler<System.Runtime.Serialization.SafeSerializationEventArgs> value);
        /*0x226d800*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x226dcb0*/ System.Exception PrepForRemoting();
        /*0x226e108*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext context);
        /*0x226e188*/ void InternalPreserveStackTrace();
        /*0x226d3dc*/ string StripFileInfo(string stackTrace, bool isRemoteStackTrace);
        /*0x226e1e4*/ string get_RemoteStackTrace();
        /*0x226e1ec*/ void RestoreExceptionDispatchInfo(System.Runtime.ExceptionServices.ExceptionDispatchInfo exceptionDispatchInfo);
        /*0x226e288*/ int get_HResult();
        /*0x226e290*/ void set_HResult(int value);
        /*0x226e298*/ string InternalToString();
        /*0x226d2b8*/ System.Type GetType();
        /*0x226e2a4*/ bool get_IsTransient();
        /*0x226e3a4*/ void SetMessage(string s);
        /*0x226e3ac*/ void SetStackTrace(string s);
        /*0x226e3b4*/ System.Exception FixRemotingException();

        enum ExceptionMessageKind
        {
            ThreadAbort = 1,
            ThreadInterrupted = 2,
            OutOfMemory = 3,
        }
    }

    enum GCCollectionMode
    {
        Default = 0,
        Forced = 1,
        Optimized = 2,
    }

    enum InternalGCCollectionMode
    {
        NonBlocking = 1,
        Blocking = 2,
        Optimized = 4,
        Compacting = 8,
    }

    enum GCNotificationStatus
    {
        Succeeded = 0,
        Failed = 1,
        Canceled = 2,
        Timeout = 3,
        NotApplicable = 4,
    }

    class GC
    {
        static /*0x0*/ object EPHEMERON_TOMBSTONE;

        static /*0x226f44c*/ GC();
        static /*0x226e51c*/ int GetCollectionCount(int generation);
        static /*0x226e520*/ int GetMaxGeneration();
        static /*0x226e524*/ void InternalCollect(int generation);
        static /*0x226e528*/ void RecordPressure(long bytesAllocated);
        static /*0x226e52c*/ void register_ephemeron_array(System.Runtime.CompilerServices.Ephemeron[] array);
        static /*0x226e530*/ object get_ephemeron_tombstone();
        static /*0x226e534*/ void GetMemoryInfo(ref uint highMemLoadThreshold, ref ulong totalPhysicalMem, ref uint lastRecordedMemLoad, ref nuint lastRecordedHeapSize, ref nuint lastRecordedFragmentation);
        static /*0x226e5cc*/ long GetAllocatedBytesForCurrentThread();
        static /*0x226e5d0*/ void AddMemoryPressure(long bytesAllocated);
        static /*0x226e6ec*/ void RemoveMemoryPressure(long bytesAllocated);
        static /*0x226e7d8*/ int GetGeneration(object obj);
        static /*0x226e7dc*/ void Collect(int generation);
        static /*0x226e89c*/ void Collect();
        static /*0x226e834*/ void Collect(int generation, System.GCCollectionMode mode);
        static /*0x226e938*/ void Collect(int generation, System.GCCollectionMode mode, bool blocking);
        static /*0x226e9a8*/ void Collect(int generation, System.GCCollectionMode mode, bool blocking, bool compacting);
        static /*0x226eab0*/ int CollectionCount(int generation);
        static /*0x226eb70*/ void KeepAlive(object obj);
        static /*0x226eb74*/ int GetGeneration(System.WeakReference wo);
        static /*0x226e8ec*/ int get_MaxGeneration();
        static /*0x226ec24*/ void WaitForPendingFinalizers();
        static /*0x226ec28*/ void _SuppressFinalize(object o);
        static /*0x226ec2c*/ void SuppressFinalize(object obj);
        static /*0x226ecd0*/ void _ReRegisterForFinalize(object o);
        static /*0x226ecd4*/ void ReRegisterForFinalize(object obj);
        static /*0x226ed78*/ long GetTotalMemory(bool forceFullCollection);
        static /*0x226ed80*/ bool _RegisterForFullGCNotification(int maxGenerationPercentage, int largeObjectHeapPercentage);
        static /*0x226edc0*/ bool _CancelFullGCNotification();
        static /*0x226ee00*/ int _WaitForFullGCApproach(int millisecondsTimeout);
        static /*0x226ee40*/ int _WaitForFullGCComplete(int millisecondsTimeout);
        static /*0x226ee80*/ void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
        static /*0x226f06c*/ void CancelFullGCNotification();
        static /*0x226f0a8*/ System.GCNotificationStatus WaitForFullGCApproach();
        static /*0x226f0e4*/ System.GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
        static /*0x226f194*/ System.GCNotificationStatus WaitForFullGCComplete();
        static /*0x226f1d0*/ System.GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
        static /*0x226f280*/ bool StartNoGCRegionWorker(long totalSize, bool hasLohSize, long lohSize, bool disallowFullBlockingGC);
        static /*0x226f2c0*/ bool TryStartNoGCRegion(long totalSize);
        static /*0x226f304*/ bool TryStartNoGCRegion(long totalSize, long lohSize);
        static /*0x226f348*/ bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
        static /*0x226f38c*/ bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
        static /*0x226f3d0*/ System.GC.EndNoGCRegionStatus EndNoGCRegionWorker();
        static /*0x226f410*/ void EndNoGCRegion();

        enum EndNoGCRegionStatus
        {
            Succeeded = 0,
            NotInProgress = 1,
            GCInduced = 2,
            AllocationExceeded = 3,
        }
    }

    interface _AppDomain
    {
        void GetTypeInfoCount(ref uint pcTInfo);
        void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
        void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
        void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        string ToString();
        bool Equals(object other);
        int GetHashCode();
        System.Type GetType();
        object InitializeLifetimeService();
        object GetLifetimeService();
        System.Security.Policy.Evidence get_Evidence();
        void add_DomainUnload(System.EventHandler value);
        void remove_DomainUnload(System.EventHandler value);
        void add_AssemblyLoad(System.AssemblyLoadEventHandler value);
        void remove_AssemblyLoad(System.AssemblyLoadEventHandler value);
        void add_ProcessExit(System.EventHandler value);
        void remove_ProcessExit(System.EventHandler value);
        void add_TypeResolve(System.ResolveEventHandler value);
        void remove_TypeResolve(System.ResolveEventHandler value);
        void add_ResourceResolve(System.ResolveEventHandler value);
        void remove_ResourceResolve(System.ResolveEventHandler value);
        void add_AssemblyResolve(System.ResolveEventHandler value);
        void remove_AssemblyResolve(System.ResolveEventHandler value);
        void add_UnhandledException(System.UnhandledExceptionEventHandler value);
        void remove_UnhandledException(System.UnhandledExceptionEventHandler value);
        System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
        System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
        System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
        System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
        System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
        System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
        System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
        System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
        System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
        System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName);
        System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
        System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes);
        System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes);
        System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef);
        System.Reflection.Assembly Load(string assemblyString);
        System.Reflection.Assembly Load(byte[] rawAssembly);
        System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
        System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
        System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
        System.Reflection.Assembly Load(string assemblyString, System.Security.Policy.Evidence assemblySecurity);
        int ExecuteAssembly(string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
        int ExecuteAssembly(string assemblyFile);
        int ExecuteAssembly(string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
        string get_FriendlyName();
        string get_BaseDirectory();
        string get_RelativeSearchPath();
        bool get_ShadowCopyFiles();
        System.Reflection.Assembly[] GetAssemblies();
        void AppendPrivatePath(string path);
        void ClearPrivatePath();
        void SetShadowCopyPath(string s);
        void ClearShadowCopyPath();
        void SetCachePath(string s);
        void SetData(string name, object data);
        object GetData(string name);
        void SetAppDomainPolicy(System.Security.Policy.PolicyLevel domainPolicy);
        void SetThreadPrincipal(System.Security.Principal.IPrincipal principal);
        void SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy policy);
        void DoCallBack(System.CrossAppDomainDelegate theDelegate);
        string get_DynamicDirectory();
    }

    interface IAppDomainSetup
    {
        string get_ApplicationBase();
        void set_ApplicationBase(string value);
        string get_ApplicationName();
        void set_ApplicationName(string value);
        string get_CachePath();
        void set_CachePath(string value);
        string get_ConfigurationFile();
        void set_ConfigurationFile(string value);
        string get_DynamicBase();
        void set_DynamicBase(string value);
        string get_LicenseFile();
        void set_LicenseFile(string value);
        string get_PrivateBinPath();
        void set_PrivateBinPath(string value);
        string get_PrivateBinPathProbe();
        void set_PrivateBinPathProbe(string value);
        string get_ShadowCopyDirectories();
        void set_ShadowCopyDirectories(string value);
        string get_ShadowCopyFiles();
        void set_ShadowCopyFiles(string value);
    }

    class ResId
    {
        static string Arg_ArrayLengthsDiffer = "Arg_ArrayLengthsDiffer";
        static string Argument_InvalidNumberOfMembers = "Argument_InvalidNumberOfMembers";
        static string Argument_UnequalMembers = "Argument_UnequalMembers";
        static string Argument_SpecifyValueSize = "Argument_SpecifyValueSize";
        static string Argument_UnmatchingSymScope = "Argument_UnmatchingSymScope";
        static string Argument_NotInExceptionBlock = "Argument_NotInExceptionBlock";
        static string Argument_NotExceptionType = "Argument_NotExceptionType";
        static string Argument_InvalidLabel = "Argument_InvalidLabel";
        static string Argument_UnclosedExceptionBlock = "Argument_UnclosedExceptionBlock";
        static string Argument_MissingDefaultConstructor = "Argument_MissingDefaultConstructor";
        static string Argument_TooManyFinallyClause = "Argument_TooManyFinallyClause";
        static string Argument_NotInTheSameModuleBuilder = "Argument_NotInTheSameModuleBuilder";
        static string Argument_BadCurrentLocalVariable = "Argument_BadCurrentLocalVariable";
        static string Argument_DuplicateModuleName = "Argument_DuplicateModuleName";
        static string Argument_BadPersistableModuleInTransientAssembly = "Argument_BadPersistableModuleInTransientAssembly";
        static string Argument_HasToBeArrayClass = "Argument_HasToBeArrayClass";
        static string Argument_InvalidDirectory = "Argument_InvalidDirectory";
        static string MissingType = "MissingType";
        static string MissingModule = "MissingModule";
        static string ArgumentOutOfRange_Index = "ArgumentOutOfRange_Index";
        static string ArgumentOutOfRange_Range = "ArgumentOutOfRange_Range";
        static string ExecutionEngine_YoureHosed = "ExecutionEngine_YoureHosed";
        static string Format_NeedSingleChar = "Format_NeedSingleChar";
        static string Format_StringZeroLength = "Format_StringZeroLength";
        static string InvalidOperation_EnumEnded = "InvalidOperation_EnumEnded";
        static string InvalidOperation_EnumFailedVersion = "InvalidOperation_EnumFailedVersion";
        static string InvalidOperation_EnumNotStarted = "InvalidOperation_EnumNotStarted";
        static string InvalidOperation_EnumOpCantHappen = "InvalidOperation_EnumOpCantHappen";
        static string InvalidOperation_InternalState = "InvalidOperation_InternalState";
        static string InvalidOperation_ModifyRONumFmtInfo = "InvalidOperation_ModifyRONumFmtInfo";
        static string InvalidOperation_MethodBaked = "InvalidOperation_MethodBaked";
        static string InvalidOperation_NotADebugModule = "InvalidOperation_NotADebugModule";
        static string InvalidOperation_MethodHasBody = "InvalidOperation_MethodHasBody";
        static string InvalidOperation_OpenLocalVariableScope = "InvalidOperation_OpenLocalVariableScope";
        static string InvalidOperation_TypeHasBeenCreated = "InvalidOperation_TypeHasBeenCreated";
        static string InvalidOperation_RefedAssemblyNotSaved = "InvalidOperation_RefedAssemblyNotSaved";
        static string InvalidOperation_AssemblyHasBeenSaved = "InvalidOperation_AssemblyHasBeenSaved";
        static string InvalidOperation_ModuleHasBeenSaved = "InvalidOperation_ModuleHasBeenSaved";
        static string InvalidOperation_CannotAlterAssembly = "InvalidOperation_CannotAlterAssembly";
        static string NotSupported_CannotSaveModuleIndividually = "NotSupported_CannotSaveModuleIndividually";
        static string NotSupported_Constructor = "NotSupported_Constructor";
        static string NotSupported_Method = "NotSupported_Method";
        static string NotSupported_NYI = "NotSupported_NYI";
        static string NotSupported_DynamicModule = "NotSupported_DynamicModule";
        static string NotSupported_NotDynamicModule = "NotSupported_NotDynamicModule";
        static string NotSupported_NotAllTypesAreBaked = "NotSupported_NotAllTypesAreBaked";
        static string NotSupported_SortedListNestedWrite = "NotSupported_SortedListNestedWrite";
        static string Serialization_ArrayInvalidLength = "Serialization_ArrayInvalidLength";
        static string Serialization_ArrayNoLength = "Serialization_ArrayNoLength";
        static string Serialization_CannotGetType = "Serialization_CannotGetType";
        static string Serialization_InsufficientState = "Serialization_InsufficientState";
        static string Serialization_InvalidID = "Serialization_InvalidID";
        static string Serialization_MalformedArray = "Serialization_MalformedArray";
        static string Serialization_MultipleMembers = "Serialization_MultipleMembers";
        static string Serialization_NoID = "Serialization_NoID";
        static string Serialization_NoType = "Serialization_NoType";
        static string Serialization_NoBaseType = "Serialization_NoBaseType";
        static string Serialization_NullSignature = "Serialization_NullSignature";
        static string Serialization_UnknownMember = "Serialization_UnknownMember";
        static string Serialization_BadParameterInfo = "Serialization_BadParameterInfo";
        static string Serialization_NoParameterInfo = "Serialization_NoParameterInfo";
        static string WeakReference_NoLongerValid = "WeakReference_NoLongerValid";
        static string Loader_InvalidPath = "Loader_InvalidPath";
    }

    class CtorDelegate : System.MulticastDelegate
    {
        /*0x226f498*/ CtorDelegate(object object, nint method);
        /*0x226f5c4*/ void Invoke(object instance);
        /*0x226f5d8*/ System.IAsyncResult BeginInvoke(object instance, System.AsyncCallback callback, object object);
        /*0x226f5f8*/ void EndInvoke(System.IAsyncResult result);
    }

    enum TypeNameFormatFlags
    {
        FormatBasic = 0,
        FormatNamespace = 1,
        FormatFullInst = 2,
        FormatAssembly = 4,
        FormatSignature = 8,
        FormatNoVersion = 16,
        FormatAngleBrackets = 64,
        FormatStubInfo = 128,
        FormatGenericParam = 256,
        FormatSerialization = 259,
    }

    enum TypeNameKind
    {
        Name = 0,
        ToString = 1,
        SerializationName = 2,
        FullName = 3,
    }

    class RuntimeType : System.Reflection.TypeInfo, System.Runtime.Serialization.ISerializable, System.ICloneable
    {
        static System.Reflection.BindingFlags MemberBindingMask = 255;
        static System.Reflection.BindingFlags InvocationMask = 65280;
        static System.Reflection.BindingFlags BinderNonCreateInstance = 15616;
        static System.Reflection.BindingFlags BinderGetSetProperty = 12288;
        static System.Reflection.BindingFlags BinderSetInvokeProperty = 8448;
        static System.Reflection.BindingFlags BinderGetSetField = 3072;
        static System.Reflection.BindingFlags BinderSetInvokeField = 2304;
        static System.Reflection.BindingFlags BinderNonFieldGetSet = 16773888;
        static System.Reflection.BindingFlags ClassicBindingMask = 61696;
        static int GenericParameterCountAny = -1;
        static /*0x0*/ System.RuntimeType ValueType;
        static /*0x8*/ System.RuntimeType EnumType;
        static /*0x10*/ System.RuntimeType ObjectType;
        static /*0x18*/ System.RuntimeType StringType;
        static /*0x20*/ System.RuntimeType DelegateType;
        static /*0x28*/ System.Type[] s_SICtorParamTypes;
        static /*0x30*/ System.Func<System.Type, System.Type[], System.Type> MakeTypeBuilderInstantiation;
        static /*0x38*/ System.RuntimeType s_typedRef;
        /*0x18*/ System.MonoTypeInfo type_info;
        /*0x20*/ object GenericCache;
        /*0x28*/ System.Reflection.RuntimeConstructorInfo m_serializationCtor;

        static /*0x227a9dc*/ RuntimeType();
        static /*0x226f604*/ System.RuntimeType GetType(string typeName, bool throwOnError, bool ignoreCase, bool reflectionOnly, ref System.Threading.StackCrawlMark stackMark);
        static /*0x226f670*/ void ThrowIfTypeNeverValidGenericArgument(System.RuntimeType type);
        static /*0x226f7d4*/ void SanityCheckGenericArguments(System.RuntimeType[] genericArguments, System.RuntimeType[] genericParamters);
        static /*0x226f9f8*/ void SplitName(string fullname, ref string name, ref string ns);
        static /*0x226fae4*/ System.Reflection.BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic);
        static /*0x226fb20*/ void FilterHelper(System.Reflection.BindingFlags bindingFlags, ref string name, bool allowPrefixLookup, ref bool prefixLookup, ref bool ignoreCase, ref System.RuntimeType.MemberListType listType);
        static /*0x226fc40*/ void FilterHelper(System.Reflection.BindingFlags bindingFlags, ref string name, ref bool ignoreCase, ref System.RuntimeType.MemberListType listType);
        static /*0x226fccc*/ bool FilterApplyPrefixLookup(System.Reflection.MemberInfo memberInfo, string name, bool ignoreCase);
        static /*0x226fd30*/ bool FilterApplyBase(System.Reflection.MemberInfo memberInfo, System.Reflection.BindingFlags bindingFlags, bool isPublic, bool isNonProtectedInternal, bool isStatic, string name, bool prefixLookup);
        static /*0x226ff1c*/ bool FilterApplyType(System.Type type, System.Reflection.BindingFlags bindingFlags, string name, bool prefixLookup, string ns);
        static /*0x2270034*/ bool FilterApplyMethodInfo(System.Reflection.RuntimeMethodInfo method, System.Reflection.BindingFlags bindingFlags, System.Reflection.CallingConventions callConv, System.Type[] argumentTypes);
        static /*0x2270318*/ bool FilterApplyConstructorInfo(System.Reflection.RuntimeConstructorInfo constructor, System.Reflection.BindingFlags bindingFlags, System.Reflection.CallingConventions callConv, System.Type[] argumentTypes);
        static /*0x22700bc*/ bool FilterApplyMethodBase(System.Reflection.MethodBase methodBase, System.Reflection.BindingFlags methodFlags, System.Reflection.BindingFlags bindingFlags, System.Reflection.CallingConventions callConv, System.Type[] argumentTypes);
        static /*0x2269428*/ bool op_Equality(System.RuntimeType left, System.RuntimeType right);
        static /*0x227068c*/ bool op_Inequality(System.RuntimeType left, System.RuntimeType right);
        static /*0x2278e44*/ object IsConvertibleToPrimitiveType(object value, System.Type targetType);
        static /*0x22798c4*/ System.Type MakePointerType(System.Type type);
        static /*0x2279bb0*/ object CreateInstanceForAnotherGenericParameter(System.Type genericType, System.RuntimeType genericArgument);
        static /*0x2275580*/ System.Type MakeGenericType(System.Type gt, System.Type[] types);
        static /*0x2279f8c*/ void GetInterfaceMapData(System.Type t, System.Type iface, ref System.Reflection.MethodInfo[] targets, ref System.Reflection.MethodInfo[] methods);
        static /*0x2279f90*/ void GetGUID(System.Type type, byte[] guid);
        static /*0x227a044*/ System.Type GetTypeFromCLSIDImpl(System.Guid clsid, string server, bool throwOnError);
        static /*0x227a0e8*/ System.TypeCode GetTypeCodeImplInternal(System.Type type);
        static /*0x227a0ec*/ System.Type GetTypeFromProgIDImpl(string progID, string server, bool throwOnError);
        static /*0x2278a80*/ object CreateInstanceInternal(System.Type type);
        static /*0x227a180*/ int get_core_clr_security_level();
        /*0x22703a0*/ RuntimeType();
        /*0x2278200*/ RuntimeType(object obj);
        /*0x22703e8*/ bool IsSpecialSerializableType();
        /*0x2270698*/ System.RuntimeType.ListBuilder<System.Reflection.MethodInfo> GetMethodCandidates(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.CallingConventions callConv, System.Type[] types, int genericParamCount, bool allowPrefixLookup);
        /*0x2270bdc*/ System.RuntimeType.ListBuilder<System.Reflection.ConstructorInfo> GetConstructorCandidates(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.CallingConventions callConv, System.Type[] types, bool allowPrefixLookup);
        /*0x2271090*/ System.RuntimeType.ListBuilder<System.Reflection.PropertyInfo> GetPropertyCandidates(string name, System.Reflection.BindingFlags bindingAttr, System.Type[] types, bool allowPrefixLookup);
        /*0x2271588*/ System.RuntimeType.ListBuilder<System.Reflection.EventInfo> GetEventCandidates(string name, System.Reflection.BindingFlags bindingAttr, bool allowPrefixLookup);
        /*0x2271a04*/ System.RuntimeType.ListBuilder<System.Reflection.FieldInfo> GetFieldCandidates(string name, System.Reflection.BindingFlags bindingAttr, bool allowPrefixLookup);
        /*0x2271ec4*/ System.RuntimeType.ListBuilder<System.Type> GetNestedTypeCandidates(string fullname, System.Reflection.BindingFlags bindingAttr, bool allowPrefixLookup);
        /*0x2272410*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
        /*0x227249c*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
        /*0x2272534*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
        /*0x22725b8*/ System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
        /*0x2272638*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
        /*0x22726b8*/ System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
        /*0x2272738*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
        /*0x2272a14*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x2272c40*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x2272ee4*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x22730b4*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
        /*0x22733c8*/ System.Type GetInterface(string fullname, bool ignoreCase);
        /*0x2273768*/ System.Type GetNestedType(string fullname, System.Reflection.BindingFlags bindingAttr);
        /*0x2273968*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
        /*0x2273e58*/ System.Reflection.Module get_Module();
        /*0x2273e60*/ System.Reflection.RuntimeModule GetRuntimeModule();
        /*0x2273e68*/ System.Reflection.Assembly get_Assembly();
        /*0x2273e70*/ System.Reflection.RuntimeAssembly GetRuntimeAssembly();
        /*0x2273e78*/ System.RuntimeTypeHandle get_TypeHandle();
        /*0x2273e9c*/ System.RuntimeTypeHandle GetTypeHandleInternal();
        /*0x2273ec0*/ bool IsInstanceOfType(object o);
        /*0x2273ec8*/ bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo);
        /*0x2273f7c*/ bool IsAssignableFrom(System.Type c);
        /*0x2274054*/ bool IsEquivalentTo(System.Type other);
        /*0x2274104*/ System.Type get_BaseType();
        /*0x22704ac*/ System.RuntimeType GetBaseType();
        /*0x2274108*/ System.Type get_UnderlyingSystemType();
        /*0x227410c*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
        /*0x2274114*/ bool IsContextfulImpl();
        /*0x227411c*/ bool IsByRefImpl();
        /*0x2274124*/ bool IsPrimitiveImpl();
        /*0x227412c*/ bool IsPointerImpl();
        /*0x2274134*/ bool IsCOMObjectImpl();
        /*0x2274140*/ bool HasProxyAttributeImpl();
        /*0x2274148*/ bool IsDelegate();
        /*0x22741e0*/ bool IsValueTypeImpl();
        /*0x2274300*/ bool get_IsEnum();
        /*0x2274374*/ bool HasElementTypeImpl();
        /*0x227437c*/ System.Reflection.GenericParameterAttributes get_GenericParameterAttributes();
        /*0x2274448*/ bool get_IsSzArray();
        /*0x2274450*/ bool IsArrayImpl();
        /*0x2274458*/ int GetArrayRank();
        /*0x22744e4*/ System.Type GetElementType();
        /*0x22744ec*/ string[] GetEnumNames();
        /*0x227460c*/ System.Array GetEnumValues();
        /*0x2274784*/ System.Type GetEnumUnderlyingType();
        /*0x2274858*/ bool IsEnumDefined(object value);
        /*0x2274d84*/ string GetEnumName(object value);
        /*0x2274f74*/ System.RuntimeType[] GetGenericArgumentsInternal();
        /*0x2274fec*/ System.Type[] GetGenericArguments();
        /*0x227507c*/ System.Type MakeGenericType(System.Type[] instantiation);
        /*0x22755ec*/ bool get_IsGenericTypeDefinition();
        /*0x22755f4*/ bool get_IsGenericParameter();
        /*0x22755fc*/ int get_GenericParameterPosition();
        /*0x2275688*/ System.Type GetGenericTypeDefinition();
        /*0x2275714*/ bool get_IsGenericType();
        /*0x227571c*/ bool get_IsConstructedGenericType();
        /*0x2275764*/ System.Reflection.MemberInfo[] GetDefaultMembers();
        /*0x22758f0*/ object InvokeMember(string name, System.Reflection.BindingFlags bindingFlags, System.Reflection.Binder binder, object target, object[] providedArgs, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParams);
        /*0x2276abc*/ bool Equals(object obj);
        /*0x2276ac8*/ object Clone();
        /*0x2276acc*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x2276ebc*/ object[] GetCustomAttributes(bool inherit);
        /*0x2276f5c*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
        /*0x22770f8*/ bool IsDefined(System.Type attributeType, bool inherit);
        /*0x2277294*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
        /*0x227729c*/ string FormatTypeName(bool serialization);
        /*0x2277484*/ System.Reflection.MemberTypes get_MemberType();
        /*0x22774c8*/ System.Type get_ReflectedType();
        /*0x22774d8*/ int get_MetadataToken();
        /*0x22774e0*/ void CreateInstanceCheckThis();
        /*0x2277700*/ object CreateInstanceImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, ref System.Threading.StackCrawlMark stackMark);
        /*0x2278098*/ object CreateInstanceDefaultCtor(bool publicOnly, bool skipCheckThis, bool fillCache, bool wrapExceptions, ref System.Threading.StackCrawlMark stackMark);
        /*0x2278248*/ System.Reflection.RuntimeConstructorInfo GetDefaultConstructor();
        /*0x22783e0*/ System.Reflection.MethodInfo GetCorrespondingInflatedMethod(System.Reflection.MethodInfo generic);
        /*0x22783e4*/ System.Reflection.ConstructorInfo GetCorrespondingInflatedConstructor(System.Reflection.ConstructorInfo generic);
        /*0x22783e8*/ System.Reflection.MethodInfo GetMethod(System.Reflection.MethodInfo fromNoninstanciated);
        /*0x227846c*/ System.Reflection.ConstructorInfo GetConstructor(System.Reflection.ConstructorInfo fromNoninstanciated);
        /*0x2278530*/ System.Reflection.FieldInfo GetField(System.Reflection.FieldInfo fromNoninstanciated);
        /*0x2275804*/ string GetDefaultMemberName();
        /*0x22785bc*/ System.Reflection.RuntimeConstructorInfo GetSerializationCtor();
        /*0x22781c4*/ object CreateInstanceSlow(bool publicOnly, bool wrapExceptions, bool skipCheckThis, bool fillCache);
        /*0x22787a0*/ object CreateInstanceMono(bool nonPublic, bool wrapExceptions);
        /*0x2278a84*/ object CheckValue(object value, System.Reflection.Binder binder, System.Globalization.CultureInfo culture, System.Reflection.BindingFlags invokeAttr);
        /*0x2278be8*/ object TryConvertToType(object value, ref bool failed);
        /*0x227742c*/ string GetCachedName(System.TypeNameKind kind);
        /*0x22797d8*/ System.Type make_array_type(int rank);
        /*0x22797dc*/ System.Type MakeArrayType();
        /*0x22797e4*/ System.Type MakeArrayType(int rank);
        /*0x2279834*/ System.Type make_byref_type();
        /*0x2279838*/ System.Type MakeByRefType();
        /*0x22798c8*/ System.Type MakePointerType();
        /*0x22799b0*/ System.Runtime.InteropServices.StructLayoutAttribute get_StructLayoutAttribute();
        /*0x22799b8*/ bool get_ContainsGenericParameters();
        /*0x2279ab4*/ System.Type[] GetGenericParameterConstraints();
        /*0x2279cc4*/ nint GetMethodsByName_native(nint namePtr, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x22708f0*/ System.Reflection.RuntimeMethodInfo[] GetMethodsByName(string name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType, System.RuntimeType reflectedType);
        /*0x2279cc8*/ nint GetPropertiesByName_native(nint name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x2279ccc*/ nint GetConstructors_native(System.Reflection.BindingFlags bindingAttr);
        /*0x2270e58*/ System.Reflection.RuntimeConstructorInfo[] GetConstructors_internal(System.Reflection.BindingFlags bindingAttr, System.RuntimeType reflectedType);
        /*0x227129c*/ System.Reflection.RuntimePropertyInfo[] GetPropertiesByName(string name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType, System.RuntimeType reflectedType);
        /*0x2279cd0*/ System.Reflection.InterfaceMapping GetInterfaceMap(System.Type ifaceType);
        /*0x2279f94*/ System.Guid get_GUID();
        /*0x227a040*/ void GetPacking(ref int packing, ref int size);
        /*0x227a094*/ System.TypeCode GetTypeCodeImpl();
        /*0x227a13c*/ string ToString();
        /*0x2278090*/ bool IsGenericCOMObjectImpl();
        /*0x227a154*/ System.Reflection.MethodBase get_DeclaringMethod();
        /*0x227a148*/ string getFullName(bool full_name, bool assembly_qualified);
        /*0x2274fe4*/ System.Type[] GetGenericArgumentsInternal(bool runtimeArray);
        /*0x2274404*/ System.Reflection.GenericParameterAttributes GetGenericParameterAttributes();
        /*0x2275684*/ int GetGenericParameterPosition();
        /*0x227a158*/ nint GetEvents_native(nint name, System.RuntimeType.MemberListType listType);
        /*0x227a15c*/ nint GetFields_native(nint name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x2271bd8*/ System.Reflection.RuntimeFieldInfo[] GetFields_internal(string name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType, System.RuntimeType reflectedType);
        /*0x2271758*/ System.Reflection.RuntimeEventInfo[] GetEvents_internal(string name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType, System.RuntimeType reflectedType);
        /*0x227a160*/ System.Type[] GetInterfaces();
        /*0x227a164*/ nint GetNestedTypes_native(nint name, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x2272080*/ System.RuntimeType[] GetNestedTypes_internal(string displayName, System.Reflection.BindingFlags bindingAttr, System.RuntimeType.MemberListType listType);
        /*0x227a168*/ string get_AssemblyQualifiedName();
        /*0x227a174*/ System.Type get_DeclaringType();
        /*0x227a178*/ string get_Name();
        /*0x227a17c*/ string get_Namespace();
        /*0x227a188*/ int GetHashCode();
        /*0x227a254*/ string get_FullName();
        /*0x227a31c*/ bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other);
        /*0x227a374*/ bool get_IsSZArray();
        /*0x227a3cc*/ bool get_IsUserType();
        /*0x227a3d4*/ bool IsSubclassOf(System.Type type);
        /*0x227a4cc*/ bool get_IsByRefLike();
        /*0x227a4d4*/ bool get_IsTypeDefinition();
        /*0x227a4dc*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConv, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x227a7cc*/ System.Reflection.MethodInfo GetMethodImpl(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConv, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x227a50c*/ System.Reflection.MethodInfo GetMethodImplCommon(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConv, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
        /*0x227a7d0*/ System.RuntimeType.ListBuilder<System.Reflection.MethodInfo> GetMethodCandidates(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.CallingConventions callConv, System.Type[] types, bool allowPrefixLookup);

        enum MemberListType
        {
            All = 0,
            CaseSensitive = 1,
            CaseInsensitive = 2,
            HandleToInfo = 3,
        }

        struct ListBuilder<T>
        {
            /*0x0*/ T[] _items;
            /*0x0*/ T _item;
            /*0x0*/ int _count;
            /*0x0*/ int _capacity;

            ListBuilder(int capacity);
            T get_Item(int index);
            T[] ToArray();
            void CopyTo(object[] array, int index);
            int get_Count();
            void Add(T item);
        }
    }

    class ReflectionOnlyType : System.RuntimeType
    {
        /*0x227ad64*/ ReflectionOnlyType();
        /*0x227ada8*/ System.RuntimeTypeHandle get_TypeHandle();
    }

    class SharedStatics
    {
        static /*0x0*/ System.SharedStatics _sharedStatics;
        /*0x10*/ string _Remoting_Identity_IDGuid;
        /*0x18*/ System.Security.Util.Tokenizer.StringMaker _maker;
        /*0x20*/ int _Remoting_Identity_IDSeqNum;
        /*0x28*/ long _memFailPointReservedMemory;

        static /*0x227b4d0*/ SharedStatics();
        static /*0x227ae10*/ string get_Remoting_Identity_IDGuid();
        static /*0x227b06c*/ System.Security.Util.Tokenizer.StringMaker GetSharedStringMaker();
        static /*0x227b23c*/ void ReleaseSharedStringMaker(ref System.Security.Util.Tokenizer.StringMaker maker);
        static /*0x227b38c*/ int Remoting_Identity_GetNextSeqNum();
        static /*0x227b3f4*/ long AddMemoryFailPointReservation(long size);
        static /*0x227b464*/ ulong get_MemoryFailPointReservedMemory();
        /*0x227ae08*/ SharedStatics();
    }

    enum ExceptionArgument
    {
        obj = 0,
        dictionary = 1,
        dictionaryCreationThreshold = 2,
        array = 3,
        info = 4,
        key = 5,
        collection = 6,
        list = 7,
        match = 8,
        converter = 9,
        queue = 10,
        stack = 11,
        capacity = 12,
        index = 13,
        startIndex = 14,
        value = 15,
        count = 16,
        arrayIndex = 17,
        name = 18,
        mode = 19,
        item = 20,
        options = 21,
        view = 22,
        sourceBytesToCopy = 23,
        start = 24,
        pointer = 25,
        ownedMemory = 26,
        text = 27,
        length = 28,
        comparer = 29,
        comparable = 30,
        exceptions = 31,
        exception = 32,
        action = 33,
        comparison = 34,
        startSegment = 35,
        endSegment = 36,
        endIndex = 37,
        task = 38,
        source = 39,
        state = 40,
        culture = 41,
        destination = 42,
        byteOffset = 43,
        minimumBufferSize = 44,
        offset = 45,
        values = 46,
        comparisonType = 47,
        s = 48,
        input = 49,
        format = 50,
    }

    enum ExceptionResource
    {
        Argument_ImplementIComparable = 0,
        Argument_InvalidType = 1,
        Argument_InvalidArgumentForComparison = 2,
        Argument_InvalidRegistryKeyPermissionCheck = 3,
        ArgumentOutOfRange_NeedNonNegNum = 4,
        Arg_ArrayPlusOffTooSmall = 5,
        Arg_NonZeroLowerBound = 6,
        Arg_RankMultiDimNotSupported = 7,
        Arg_RegKeyDelHive = 8,
        Arg_RegKeyStrLenBug = 9,
        Arg_RegSetStrArrNull = 10,
        Arg_RegSetMismatchedKind = 11,
        Arg_RegSubKeyAbsent = 12,
        Arg_RegSubKeyValueAbsent = 13,
        Argument_AddingDuplicate = 14,
        Serialization_InvalidOnDeser = 15,
        Serialization_MissingKeys = 16,
        Serialization_NullKey = 17,
        Argument_InvalidArrayType = 18,
        NotSupported_KeyCollectionSet = 19,
        NotSupported_ValueCollectionSet = 20,
        ArgumentOutOfRange_SmallCapacity = 21,
        ArgumentOutOfRange_Index = 22,
        Argument_InvalidOffLen = 23,
        Argument_ItemNotExist = 24,
        ArgumentOutOfRange_Count = 25,
        ArgumentOutOfRange_InvalidThreshold = 26,
        ArgumentOutOfRange_ListInsert = 27,
        NotSupported_ReadOnlyCollection = 28,
        InvalidOperation_CannotRemoveFromStackOrQueue = 29,
        InvalidOperation_EmptyQueue = 30,
        InvalidOperation_EnumOpCantHappen = 31,
        InvalidOperation_EnumFailedVersion = 32,
        InvalidOperation_EmptyStack = 33,
        ArgumentOutOfRange_BiggerThanCollection = 34,
        InvalidOperation_EnumNotStarted = 35,
        InvalidOperation_EnumEnded = 36,
        NotSupported_SortedListNestedWrite = 37,
        InvalidOperation_NoValue = 38,
        InvalidOperation_RegRemoveSubKey = 39,
        Security_RegistryPermission = 40,
        UnauthorizedAccess_RegistryNoWrite = 41,
        ObjectDisposed_RegKeyClosed = 42,
        NotSupported_InComparableType = 43,
        Argument_InvalidRegistryOptionsCheck = 44,
        Argument_InvalidRegistryViewCheck = 45,
        TaskT_TransitionToFinal_AlreadyCompleted = 46,
        TaskCompletionSourceT_TrySetException_NullException = 47,
        TaskCompletionSourceT_TrySetException_NoExceptions = 48,
        NotSupported_StringComparison = 49,
        InvalidOperation_NullArray = 50,
    }

    struct TypedReference
    {
        /*0x10*/ System.RuntimeTypeHandle type;
        /*0x18*/ nint Value;
        /*0x20*/ nint Type;

        static /*0x227b534*/ System.TypedReference MakeTypedReference(object target, System.Reflection.FieldInfo[] flds);
        static /*0x227b98c*/ void InternalMakeTypedReference(void* result, object target, nint[] flds, System.RuntimeType lastFieldType);
        static /*0x227baa0*/ object ToObject(System.TypedReference value);
        static /*0x227baa4*/ object InternalToObject(void* value);
        static /*0x227bb28*/ System.Type GetTargetType(System.TypedReference value);
        static /*0x227bb84*/ System.RuntimeTypeHandle TargetTypeToken(System.TypedReference value);
        static /*0x227bbf8*/ void SetTypedReference(System.TypedReference target, object value);
        /*0x227b990*/ int GetHashCode();
        /*0x227ba40*/ bool Equals(object o);
        /*0x227baa8*/ bool get_IsNull();
    }

    class TypeLoadException : System.SystemException, System.Runtime.Serialization.ISerializable
    {
        /*0x90*/ string ClassName;
        /*0x98*/ string AssemblyName;
        /*0xa0*/ string MessageArg;
        /*0xa8*/ int ResourceId;

        /*0x2275584*/ TypeLoadException();
        /*0x22798a0*/ TypeLoadException(string message);
        /*0x227bc48*/ TypeLoadException(string message, System.Exception inner);
        /*0x227bde8*/ TypeLoadException(string className, string assemblyName);
        /*0x227be30*/ TypeLoadException(string className, string assemblyName, string messageArg, int resourceId);
        /*0x227be88*/ TypeLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x227bc6c*/ string get_Message();
        /*0x227bc84*/ void SetMessageField();
        /*0x227bd94*/ string get_TypeName();
        /*0x227bfd0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class UnitySerializationHolder : System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
    {
        static int EmptyUnity = 1;
        static int NullUnity = 2;
        static int MissingUnity = 3;
        static int RuntimeTypeUnity = 4;
        static int ModuleUnity = 5;
        static int AssemblyUnity = 6;
        static int GenericParameterTypeUnity = 7;
        static int PartialInstantiationTypeUnity = 8;
        static int Pointer = 1;
        static int Array = 2;
        static int SzArray = 3;
        static int ByRef = 4;
        /*0x10*/ System.Type[] m_instantiation;
        /*0x18*/ int[] m_elementTypes;
        /*0x20*/ int m_genericParameterPosition;
        /*0x28*/ System.Type m_declaringType;
        /*0x30*/ System.Reflection.MethodBase m_declaringMethod;
        /*0x38*/ string m_data;
        /*0x40*/ string m_assemblyName;
        /*0x48*/ int m_unityType;

        static /*0x227c1a0*/ void GetUnitySerializationInfo(System.Runtime.Serialization.SerializationInfo info, System.Reflection.Missing missing);
        static /*0x227c258*/ System.RuntimeType AddElementTypes(System.Runtime.Serialization.SerializationInfo info, System.RuntimeType type);
        static /*0x227c71c*/ void GetUnitySerializationInfo(System.Runtime.Serialization.SerializationInfo info, int unityType);
        static /*0x2276b30*/ void GetUnitySerializationInfo(System.Runtime.Serialization.SerializationInfo info, System.RuntimeType type);
        static /*0x2267d20*/ void GetUnitySerializationInfo(System.Runtime.Serialization.SerializationInfo info, int unityType, string data, System.Reflection.RuntimeAssembly assembly);
        /*0x227c870*/ UnitySerializationHolder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x227c624*/ System.Type MakeElementTypes(System.Type type);
        /*0x227cc70*/ void ThrowInsufficientInformation(string field);
        /*0x227cd10*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x227cd70*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
    }

    struct UnSafeCharBuffer
    {
        /*0x10*/ char* m_buffer;
        /*0x18*/ int m_totalSize;
        /*0x1c*/ int m_length;

        /*0x227d288*/ UnSafeCharBuffer(char* buffer, int bufferSize);
        /*0x227d294*/ void AppendString(string stringToAppend);
        /*0x227d354*/ int get_Length();
    }

    class AppContextDefaultValues
    {
        static string SwitchNoAsyncCurrentCulture = "Switch.System.Globalization.NoAsyncCurrentCulture";
        static string SwitchThrowExceptionIfDisposedCancellationTokenSource = "Switch.System.Threading.ThrowExceptionIfDisposedCancellationTokenSource";
        static string SwitchPreserveEventListnerObjectIdentity = "Switch.System.Diagnostics.EventSource.PreserveEventListnerObjectIdentity";
        static string SwitchUseLegacyPathHandling = "Switch.System.IO.UseLegacyPathHandling";
        static string SwitchBlockLongPaths = "Switch.System.IO.BlockLongPaths";
        static string SwitchDoNotAddrOfCspParentWindowHandle = "Switch.System.Security.Cryptography.DoNotAddrOfCspParentWindowHandle";
        static string SwitchSetActorAsReferenceWhenCopyingClaimsIdentity = "Switch.System.Security.ClaimsIdentity.SetActorAsReferenceWhenCopyingClaimsIdentity";
        static /*0x0*/ string SwitchEnforceJapaneseEraYearRanges;
        static /*0x8*/ string SwitchFormatJapaneseFirstYearAsANumber;
        static /*0x10*/ string SwitchEnforceLegacyJapaneseDateParsing;

        static /*0x227d36c*/ AppContextDefaultValues();
        static /*0x227d35c*/ void PopulateDefaultValues();
        static /*0x227d360*/ bool TryGetSwitchOverride(string switchName, ref bool overrideValue);
    }

    class AppDomain : System.MarshalByRefObject, System.Security.IEvidenceFactory, System._AppDomain
    {
        static /*0x0*/ string _process_guid;
        static /*0x8*/ System.AppDomain default_domain;
        [ThreadStatic] static System.Collections.Generic.Dictionary<string, object> type_resolve_in_progress;
        [ThreadStatic] static System.Collections.Generic.Dictionary<string, object> assembly_resolve_in_progress;
        [ThreadStatic] static System.Collections.Generic.Dictionary<string, object> assembly_resolve_in_progress_refonly;
        [ThreadStatic] static object _principal;
        /*0x18*/ nint _mono_app_domain;
        /*0x20*/ object _evidence;
        /*0x28*/ object _granted;
        /*0x30*/ int _principalPolicy;
        /*0x38*/ System.AssemblyLoadEventHandler AssemblyLoad;
        /*0x40*/ System.ResolveEventHandler AssemblyResolve;
        /*0x48*/ System.EventHandler DomainUnload;
        /*0x50*/ System.EventHandler ProcessExit;
        /*0x58*/ System.ResolveEventHandler ResourceResolve;
        /*0x60*/ System.ResolveEventHandler TypeResolve;
        /*0x68*/ System.UnhandledExceptionEventHandler UnhandledException;
        /*0x70*/ System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> FirstChanceException;
        /*0x78*/ object _domain_manager;
        /*0x80*/ System.ResolveEventHandler ReflectionOnlyAssemblyResolve;
        /*0x88*/ object _activation;
        /*0x90*/ object _applicationIdentity;
        /*0x98*/ System.Collections.Generic.List<string> compatibility_switch;

        static /*0x227d414*/ bool IsAppXModel();
        static /*0x227d41c*/ bool IsAppXDesignMode();
        static /*0x227d424*/ void CheckReflectionOnlyLoadSupported();
        static /*0x227d428*/ void CheckLoadFromSupported();
        static /*0x227db98*/ System.AppDomain getCurDomain();
        static /*0x227db9c*/ System.AppDomain get_CurrentDomain();
        static /*0x227dba0*/ System.AppDomain getRootDomain();
        static /*0x227d7d0*/ System.AppDomain get_DefaultDomain();
        static /*0x227f004*/ System.AppDomain InternalSetDomainByID(int domain_id);
        static /*0x227f008*/ System.AppDomain InternalSetDomain(System.AppDomain context);
        static /*0x227f00c*/ void InternalPushDomainRef(System.AppDomain domain);
        static /*0x227f010*/ void InternalPushDomainRefByID(int domain_id);
        static /*0x227f014*/ void InternalPopDomainRef();
        static /*0x227f018*/ System.Runtime.Remoting.Contexts.Context InternalSetContext(System.Runtime.Remoting.Contexts.Context context);
        static /*0x227f01c*/ System.Runtime.Remoting.Contexts.Context InternalGetContext();
        static /*0x227f020*/ System.Runtime.Remoting.Contexts.Context InternalGetDefaultContext();
        static /*0x227f024*/ string InternalGetProcessGuid(string newguid);
        static /*0x227f028*/ object InvokeInDomain(System.AppDomain domain, System.Reflection.MethodInfo method, object obj, object[] args);
        static /*0x227f1b8*/ object InvokeInDomainByID(int domain_id, System.Reflection.MethodInfo method, object obj, object[] args);
        static /*0x227f348*/ string GetProcessGuid();
        static /*0x227f3f8*/ System.AppDomain CreateDomain(string friendlyName);
        static /*0x227f6dc*/ System.AppDomain CreateDomain(string friendlyName, System.Security.Policy.Evidence securityInfo);
        static /*0x227f6e4*/ System.AppDomain createDomain(string friendlyName, System.AppDomainSetup info);
        static /*0x227f404*/ System.AppDomain CreateDomain(string friendlyName, System.Security.Policy.Evidence securityInfo, System.AppDomainSetup info);
        static /*0x227f6e8*/ System.AppDomain CreateDomain(string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
        static /*0x227f724*/ System.AppDomainSetup CreateDomainSetup(string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);
        static /*0x227f7e8*/ bool InternalIsFinalizingForUnload(int domain_id);
        static /*0x227f7f4*/ void InternalUnload(int domain_id);
        static /*0x227f7f8*/ void Unload(System.AppDomain domain);
        static /*0x227f8a4*/ int GetCurrentThreadId();
        static /*0x227f8b0*/ void ValidateAssemblyName(string name);
        static /*0x2281108*/ System.AppDomain CreateDomain(string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, System.AppDomainInitializer adInit, string[] adInitArgs);
        static /*0x228148c*/ bool get_MonitoringIsEnabled();
        static /*0x2281494*/ void set_MonitoringIsEnabled(bool value);
        static /*0x2281514*/ long get_MonitoringSurvivedProcessMemorySize();
        static /*0x22819bc*/ System.AppDomain CreateDomain(string friendlyName, System.Security.Policy.Evidence securityInfo, System.AppDomainSetup info, System.Security.PermissionSet grantSet, System.Security.Policy.StrongName[] fullTrustAssemblies);
        /*0x227d42c*/ AppDomain();
        /*0x227d434*/ System.AppDomainSetup getSetup();
        /*0x227d438*/ System.AppDomainSetup get_SetupInformationNoCopy();
        /*0x227d43c*/ System.AppDomainSetup get_SetupInformation();
        /*0x227d4b0*/ string get_BaseDirectory();
        /*0x227d4cc*/ string get_RelativeSearchPath();
        /*0x227d4e8*/ string get_DynamicDirectory();
        /*0x227d588*/ bool get_ShadowCopyFiles();
        /*0x227d5e4*/ string getFriendlyName();
        /*0x227d5e8*/ string get_FriendlyName();
        /*0x227d5ec*/ System.Security.Policy.Evidence get_Evidence();
        /*0x227d8ac*/ System.Security.Principal.IPrincipal get_DefaultPrincipal();
        /*0x227da70*/ System.Security.PermissionSet get_GrantedPermissionSet();
        /*0x227dae8*/ System.Security.PermissionSet get_PermissionSet();
        /*0x227dba4*/ void AppendPrivatePath(string path);
        /*0x227dcdc*/ void ClearPrivatePath();
        /*0x227dd3c*/ void ClearShadowCopyPath();
        /*0x227dd9c*/ System.Runtime.Remoting.ObjectHandle InternalCreateInstanceWithNoSecurity(string assemblyName, string typeName);
        /*0x227de04*/ System.Runtime.Remoting.ObjectHandle InternalCreateInstanceWithNoSecurity(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        /*0x227de9c*/ System.Runtime.Remoting.ObjectHandle InternalCreateInstanceFromWithNoSecurity(string assemblyName, string typeName);
        /*0x227df04*/ System.Runtime.Remoting.ObjectHandle InternalCreateInstanceFromWithNoSecurity(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        /*0x227dda0*/ System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName);
        /*0x227df9c*/ System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes);
        /*0x227de14*/ System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        /*0x227e004*/ object CreateInstanceAndUnwrap(string assemblyName, string typeName);
        /*0x227e01c*/ object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes);
        /*0x227e034*/ object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        /*0x227e060*/ System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        /*0x227e0e8*/ object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        /*0x227e114*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        /*0x227e19c*/ object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
        /*0x227dea0*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
        /*0x227e1c8*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes);
        /*0x227df14*/ System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        /*0x227e230*/ object CreateInstanceFromAndUnwrap(string assemblyName, string typeName);
        /*0x227e248*/ object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes);
        /*0x227e260*/ object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);
        /*0x227e28c*/ void DoCallBack(System.CrossAppDomainDelegate callBackDelegate);
        /*0x227e2a4*/ int ExecuteAssembly(string assemblyFile);
        /*0x227e308*/ int ExecuteAssembly(string assemblyFile, System.Security.Policy.Evidence assemblySecurity);
        /*0x227e2d0*/ int ExecuteAssembly(string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);
        /*0x227e420*/ int ExecuteAssembly(string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
        /*0x227e460*/ int ExecuteAssembly(string assemblyFile, string[] args);
        /*0x227e498*/ int ExecuteAssembly(string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
        /*0x227e334*/ int ExecuteAssemblyInternal(System.Reflection.Assembly a, string[] args);
        /*0x227e4d8*/ int ExecuteAssembly(System.Reflection.Assembly a, string[] args);
        /*0x227e4dc*/ System.Reflection.Assembly[] GetAssemblies(bool refOnly);
        /*0x227e4e4*/ System.Reflection.Assembly[] GetAssemblies();
        /*0x227e4ec*/ object GetData(string name);
        /*0x227e4f0*/ System.Type GetType();
        /*0x227e4f8*/ object InitializeLifetimeService();
        /*0x227e500*/ System.Reflection.Assembly LoadAssembly(string assemblyRef, System.Security.Policy.Evidence securityEvidence, bool refOnly, ref System.Threading.StackCrawlMark stackMark);
        /*0x227e508*/ System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef);
        /*0x227e8f0*/ System.Reflection.Assembly LoadSatellite(System.Reflection.AssemblyName assemblyRef, bool throwOnError, ref System.Threading.StackCrawlMark stackMark);
        /*0x227e510*/ System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
        /*0x227e9fc*/ System.Reflection.Assembly Load(string assemblyString);
        /*0x227eb30*/ System.Reflection.Assembly Load(string assemblyString, System.Security.Policy.Evidence assemblySecurity);
        /*0x227ea20*/ System.Reflection.Assembly Load(string assemblyString, System.Security.Policy.Evidence assemblySecurity, bool refonly, ref System.Threading.StackCrawlMark stackMark);
        /*0x227eb50*/ System.Reflection.Assembly Load(byte[] rawAssembly);
        /*0x227eb68*/ System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
        /*0x227eb74*/ System.Reflection.Assembly LoadAssemblyRaw(byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence, bool refonly);
        /*0x227eb60*/ System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
        /*0x227eb7c*/ System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence, bool refonly);
        /*0x227ec04*/ void SetAppDomainPolicy(System.Security.Policy.PolicyLevel domainPolicy);
        /*0x227ed88*/ void SetCachePath(string path);
        /*0x227eda8*/ void SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy policy);
        /*0x227ee4c*/ void SetShadowCopyFiles();
        /*0x227eea4*/ void SetShadowCopyPath(string path);
        /*0x227eec4*/ void SetThreadPrincipal(System.Security.Principal.IPrincipal principal);
        /*0x227ed74*/ bool IsFinalizingForUnload();
        /*0x227f7ec*/ int getDomainID();
        /*0x227f85c*/ void SetData(string name, object data);
        /*0x227f860*/ void SetData(string name, object data, System.Security.IPermission permission);
        /*0x227f864*/ void SetDynamicBase(string path);
        /*0x227f8ac*/ string ToString();
        /*0x227f9f8*/ void DoAssemblyLoad(System.Reflection.Assembly assembly);
        /*0x227fa90*/ System.Reflection.Assembly DoAssemblyResolve(string name, System.Reflection.Assembly requestingAssembly, bool refonly);
        /*0x227fda0*/ System.Reflection.Assembly DoTypeResolve(string name);
        /*0x2280070*/ System.Reflection.Assembly DoResourceResolve(string name, System.Reflection.Assembly requesting);
        /*0x22801a8*/ void DoDomainUnload();
        /*0x22801cc*/ void DoUnhandledException(System.Exception e);
        /*0x22801d0*/ void DoUnhandledException(System.UnhandledExceptionEventArgs args);
        /*0x22801f8*/ byte[] GetMarshalledDomainObjRef();
        /*0x22802d0*/ void ProcessMessageInDomain(byte[] arrRequest, System.Runtime.Remoting.Messaging.CADMethodCallMessage cadMsg, ref byte[] arrResponse, ref System.Runtime.Remoting.Messaging.CADMethodReturnMessage cadMrm);
        /*0x2280400*/ void add_AssemblyLoad(System.AssemblyLoadEventHandler value);
        /*0x228049c*/ void remove_AssemblyLoad(System.AssemblyLoadEventHandler value);
        /*0x2280538*/ void add_AssemblyResolve(System.ResolveEventHandler value);
        /*0x22805d4*/ void remove_AssemblyResolve(System.ResolveEventHandler value);
        /*0x2280670*/ void add_DomainUnload(System.EventHandler value);
        /*0x228070c*/ void remove_DomainUnload(System.EventHandler value);
        /*0x22807a8*/ void add_ProcessExit(System.EventHandler value);
        /*0x2280844*/ void remove_ProcessExit(System.EventHandler value);
        /*0x22808e0*/ void add_ResourceResolve(System.ResolveEventHandler value);
        /*0x228097c*/ void remove_ResourceResolve(System.ResolveEventHandler value);
        /*0x2280a18*/ void add_TypeResolve(System.ResolveEventHandler value);
        /*0x2280ab4*/ void remove_TypeResolve(System.ResolveEventHandler value);
        /*0x2280b50*/ void add_UnhandledException(System.UnhandledExceptionEventHandler value);
        /*0x2280bec*/ void remove_UnhandledException(System.UnhandledExceptionEventHandler value);
        /*0x2280c88*/ void add_FirstChanceException(System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> value);
        /*0x2280d38*/ void remove_FirstChanceException(System.EventHandler<System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs> value);
        /*0x2280de8*/ bool get_IsHomogenous();
        /*0x2280df0*/ bool get_IsFullyTrusted();
        /*0x2280df8*/ System.AppDomainManager get_DomainManager();
        /*0x2280e70*/ void add_ReflectionOnlyAssemblyResolve(System.ResolveEventHandler value);
        /*0x2280f0c*/ void remove_ReflectionOnlyAssemblyResolve(System.ResolveEventHandler value);
        /*0x2280fa8*/ System.ActivationContext get_ActivationContext();
        /*0x2281004*/ System.ApplicationIdentity get_ApplicationIdentity();
        /*0x2281060*/ int get_Id();
        /*0x2281068*/ string ApplyPolicy(string assemblyName);
        /*0x2281164*/ int ExecuteAssemblyByName(string assemblyName);
        /*0x22811c8*/ int ExecuteAssemblyByName(string assemblyName, System.Security.Policy.Evidence assemblySecurity);
        /*0x2281190*/ int ExecuteAssemblyByName(string assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
        /*0x22811f4*/ int ExecuteAssemblyByName(System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, string[] args);
        /*0x228122c*/ int ExecuteAssemblyByName(string assemblyName, string[] args);
        /*0x2281264*/ int ExecuteAssemblyByName(System.Reflection.AssemblyName assemblyName, string[] args);
        /*0x228129c*/ bool IsDefaultAppDomain();
        /*0x22812b8*/ System.Reflection.Assembly[] ReflectionOnlyGetAssemblies();
        /*0x22812c0*/ System.Nullable<bool> IsCompatibilitySwitchSet(string value);
        /*0x228139c*/ void SetCompatibilitySwitch(string value);
        /*0x22814d4*/ long get_MonitoringSurvivedMemorySize();
        /*0x2281554*/ long get_MonitoringTotalAllocatedMemorySize();
        /*0x2281594*/ System.TimeSpan get_MonitoringTotalProcessorTime();
        /*0x22815d4*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
        /*0x2281614*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
        /*0x2281654*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);
        /*0x2281694*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);
        /*0x22816d4*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes, System.Security.SecurityContextSource securityContextSource);
        /*0x2281714*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);
        /*0x2281754*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
        /*0x2281794*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
        /*0x22817d4*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
        /*0x2281814*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
        /*0x2281854*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);
        /*0x2281894*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);
        /*0x22818d4*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
        /*0x2281914*/ System.Security.Policy.ApplicationTrust get_ApplicationTrust();
        /*0x228194c*/ System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName);
        /*0x2281984*/ System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
        /*0x22819f4*/ void System._AppDomain.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
        /*0x2281a2c*/ void System._AppDomain.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
        /*0x2281a64*/ void System._AppDomain.GetTypeInfoCount(ref uint pcTInfo);
        /*0x2281a9c*/ void System._AppDomain.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
    }

    class Array_ReferenceSources
    {
        static int MaxArrayLength = 2146435071;
        static int MaxByteArrayLength = 2147483591;
    }

    enum BCLDebugLogLevel
    {
        Trace = 0,
        Status = 20,
        Warning = 40,
        Error = 50,
        Panic = 100,
    }

    class BCLDebug
    {
        static /*0x1eeb944*/ void Assert(bool condition, string message);
        static /*0x1eeb948*/ void Correctness(bool expr, string msg);
        static /*0x1eeb94c*/ void Log(string message);
        static /*0x1eeb950*/ void Log(string switchName, string message);
        static /*0x1eeb954*/ void Log(string switchName, System.BCLDebugLogLevel level, object[] messages);
        static /*0x1eeb958*/ void Perf(bool expr, string msg);
        static /*0x1eeb95c*/ void Trace(string switchName, object[] messages);
        static /*0x1eeb960*/ bool CheckEnabled(string switchName);
    }

    class CLRConfig
    {
        static /*0x1eeb968*/ bool CheckLegacyManagedDeflateStream();
        static /*0x1eeb970*/ bool CheckThrowUnobservedTaskExceptions();
        /*0x1eeb974*/ CLRConfig();
    }

    class CompatibilitySwitches
    {
        static /*0x0*/ bool IsAppEarlierThanSilverlight4;
        static /*0x1*/ bool IsAppEarlierThanWindowsPhone8;
    }

    class Environment
    {
        static string mono_corlib_version = "1A5E0066-58DC-428A-B21C-0AD6CDAE2789";
        static /*0x0*/ string nl;
        static /*0x8*/ System.OperatingSystem os;
        static /*0x10*/ System.PlatformID <Platform>k__BackingField;

        static /*0x1eeb97c*/ string GetResourceString(string key);
        static /*0x1eeb980*/ string GetResourceString(string key, System.Globalization.CultureInfo culture);
        static /*0x1eeb984*/ string GetResourceString(string key, object[] values);
        static /*0x1eeb9f4*/ string GetRuntimeResourceString(string key);
        static /*0x1eeb9f8*/ string GetRuntimeResourceString(string key, object[] values);
        static /*0x1eeba68*/ string GetResourceStringEncodingName(int codePage);
        static /*0x1eebbe4*/ bool get_IsWindows8OrAbove();
        static /*0x1eebbec*/ string get_CommandLine();
        static /*0x1eebe2c*/ string get_CurrentDirectory();
        static /*0x1eebe34*/ void set_CurrentDirectory(string value);
        static /*0x1eebe3c*/ int get_CurrentManagedThreadId();
        static /*0x1eebe5c*/ int get_ExitCode();
        static /*0x1eebe60*/ void set_ExitCode(int value);
        static /*0x1eebe64*/ bool get_HasShutdownStarted();
        static /*0x1eebe68*/ string get_MachineName();
        static /*0x1eebe6c*/ string GetNewLine();
        static /*0x1eebe70*/ string get_NewLine();
        static /*0x1eebed8*/ System.PlatformID get_Platform();
        static /*0x1eebedc*/ string GetOSVersionString();
        static /*0x1eebee0*/ System.OperatingSystem get_OSVersion();
        static /*0x1eebf9c*/ System.Version CreateVersionFromString(string info);
        static /*0x1eec1b8*/ string get_StackTrace();
        static /*0x1eec224*/ string get_SystemDirectory();
        static /*0x1eec238*/ int get_TickCount();
        static /*0x1eec23c*/ string get_UserDomainName();
        static /*0x1eec240*/ bool get_UserInteractive();
        static /*0x1eec248*/ string get_UserName();
        static /*0x1eec24c*/ System.Version get_Version();
        static /*0x1eec2c0*/ long get_WorkingSet();
        static /*0x1eec2c8*/ void Exit(int exitCode);
        static /*0x1eec2cc*/ void _Exit(int exitCode);
        static /*0x1eec2d0*/ string ExpandEnvironmentVariables(string name);
        static /*0x1eebe28*/ string[] GetCommandLineArgs();
        static /*0x1eec6a4*/ string internalGetEnvironmentVariable_native(nint variable);
        static /*0x1eec6a8*/ string internalGetEnvironmentVariable(string variable);
        static /*0x1eec598*/ string GetEnvironmentVariable(string variable);
        static /*0x1eec5b4*/ System.Collections.Hashtable GetEnvironmentVariablesNoCase();
        static /*0x1eec774*/ System.Collections.IDictionary GetEnvironmentVariables();
        static /*0x1eec230*/ string GetFolderPath(System.Environment.SpecialFolder folder);
        static /*0x1eec874*/ string GetWindowsFolderPath(int folder);
        static /*0x1eec840*/ string GetFolderPath(System.Environment.SpecialFolder folder, System.Environment.SpecialFolderOption option);
        static /*0x1eecd18*/ string ReadXdgUserDir(string config_dir, string home_dir, string key, string fallback);
        static /*0x1eec878*/ string UnixGetFolderPath(System.Environment.SpecialFolder folder, System.Environment.SpecialFolderOption option);
        static /*0x1eed190*/ string[] GetLogicalDrives();
        static /*0x1eed198*/ string GetEnvironmentVariable(string variable, System.EnvironmentVariableTarget target);
        static /*0x1eed1a8*/ System.Collections.IDictionary GetEnvironmentVariables(System.EnvironmentVariableTarget target);
        static /*0x1eed218*/ void SetEnvironmentVariable(string variable, string value);
        static /*0x1eed404*/ void SetEnvironmentVariable(string variable, string value, System.EnvironmentVariableTarget target);
        static /*0x1eed410*/ void InternalSetEnvironmentVariable(char* variable, int variable_length, char* value, int value_length);
        static /*0x1eed394*/ void InternalSetEnvironmentVariable(string variable, string value);
        static /*0x1eed414*/ void FailFast(string message);
        static /*0x1eed424*/ void FailFast(string message, uint exitCode);
        static /*0x1eed430*/ void FailFast(string message, System.Exception exception);
        static /*0x1eed420*/ void FailFast(string message, System.Exception exception, string errorSource);
        static /*0x1eed438*/ bool GetIs64BitOperatingSystem();
        static /*0x1eed43c*/ bool get_Is64BitOperatingSystem();
        static /*0x1eed440*/ int get_SystemPageSize();
        static /*0x1eed448*/ bool get_Is64BitProcess();
        static /*0x1eed458*/ int get_ProcessorCount();
        static /*0x1eec59c*/ bool get_IsRunningOnWindows();
        static /*0x1eed194*/ string[] GetLogicalDrivesInternal();
        static /*0x1eec770*/ string[] GetEnvironmentVariableNames();
        static /*0x1eed45c*/ string GetMachineConfigPath();
        static /*0x1eed18c*/ string internalGetHome();
        static /*0x1eed444*/ int GetPageSize();
        static /*0x1eed460*/ string get_bundled_machine_config();
        static /*0x1eed464*/ string GetBundledMachineConfig();
        static /*0x1eed468*/ bool get_IsUnix();
        static /*0x1eed4a0*/ bool get_IsMacOS();
        static /*0x1eed4b8*/ bool get_IsCLRHosted();
        static /*0x1eed4c0*/ void TriggerCodeContractFailure(System.Diagnostics.Contracts.ContractFailureKind failureKind, string message, string condition, string exceptionAsString);
        static /*0x1eed4c4*/ string GetStackTrace(System.Exception e, bool needFileInfo);
        static /*0x1eed55c*/ bool get_IsWinRTSupported();

        enum SpecialFolder
        {
            MyDocuments = 5,
            Desktop = 0,
            MyComputer = 17,
            Programs = 2,
            Personal = 5,
            Favorites = 6,
            Startup = 7,
            Recent = 8,
            SendTo = 9,
            StartMenu = 11,
            MyMusic = 13,
            DesktopDirectory = 16,
            Templates = 21,
            ApplicationData = 26,
            LocalApplicationData = 28,
            InternetCache = 32,
            Cookies = 33,
            History = 34,
            CommonApplicationData = 35,
            System = 37,
            ProgramFiles = 38,
            MyPictures = 39,
            CommonProgramFiles = 43,
            MyVideos = 14,
            NetworkShortcuts = 19,
            Fonts = 20,
            CommonStartMenu = 22,
            CommonPrograms = 23,
            CommonStartup = 24,
            CommonDesktopDirectory = 25,
            PrinterShortcuts = 27,
            Windows = 36,
            UserProfile = 40,
            SystemX86 = 41,
            ProgramFilesX86 = 42,
            CommonProgramFilesX86 = 44,
            CommonTemplates = 45,
            CommonDocuments = 46,
            CommonAdminTools = 47,
            AdminTools = 48,
            CommonMusic = 53,
            CommonPictures = 54,
            CommonVideos = 55,
            Resources = 56,
            LocalizedResources = 57,
            CommonOemLinks = 58,
            CDBurning = 59,
        }

        enum SpecialFolderOption
        {
            None = 0,
            DoNotVerify = 16384,
            Create = 32768,
        }
    }

    interface IRuntimeMethodInfo
    {
        System.RuntimeMethodHandleInternal get_Value();
    }

    struct RuntimeMethodHandleInternal
    {
        /*0x10*/ nint m_handle;

        static /*0x1eed564*/ System.RuntimeMethodHandleInternal get_EmptyHandle();
        /*0x1eed594*/ RuntimeMethodHandleInternal(nint value);
        /*0x1eed56c*/ bool IsNullHandle();
        /*0x1eed58c*/ nint get_Value();
    }

    class MonoTypeInfo
    {
        /*0x10*/ string full_name;
        /*0x18*/ System.Reflection.RuntimeConstructorInfo default_ctor;

        /*0x1eed59c*/ MonoTypeInfo();
    }

    class TypeNameParser
    {
        static /*0x1eed5a4*/ System.Type GetType(string typeName, System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError, bool ignoreCase, ref System.Threading.StackCrawlMark stackMark);
        /*0x1eed5fc*/ TypeNameParser();
    }

    class ActivationContext : System.IDisposable, System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ System.ApplicationIdentity _appid;
        /*0x18*/ System.ActivationContext.ContextForm _form;
        /*0x1c*/ bool _disposed;

        static /*0x1eed668*/ System.ActivationContext CreatePartialActivationContext(System.ApplicationIdentity identity);
        static /*0x1eed71c*/ System.ActivationContext CreatePartialActivationContext(System.ApplicationIdentity identity, string[] manifestPaths);
        /*0x1eed604*/ ActivationContext(System.ApplicationIdentity identity);
        /*0x1eed8bc*/ ActivationContext();
        /*0x1eed62c*/ void Finalize();
        /*0x1eed658*/ System.ActivationContext.ContextForm get_Form();
        /*0x1eed660*/ System.ApplicationIdentity get_Identity();
        /*0x1eed7fc*/ void Dispose();
        /*0x1eed644*/ void Dispose(bool disposing);
        /*0x1eed864*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1eed8f4*/ byte[] get_ApplicationManifestBytes();
        /*0x1eed92c*/ byte[] get_DeploymentManifestBytes();

        enum ContextForm
        {
            Loose = 0,
            StoreBounded = 1,
        }
    }

    class AppDomainInitializer : System.MulticastDelegate
    {
        /*0x1eed964*/ AppDomainInitializer(object object, nint method);
        /*0x1eeda38*/ void Invoke(string[] args);
        /*0x1eeda4c*/ System.IAsyncResult BeginInvoke(string[] args, System.AsyncCallback callback, object object);
        /*0x1eeda6c*/ void EndInvoke(System.IAsyncResult result);
    }

    class AppDomainManager : System.MarshalByRefObject
    {
        /*0x18*/ System.Runtime.Hosting.ApplicationActivator _activator;
        /*0x20*/ System.AppDomainManagerInitializationOptions _flags;

        static /*0x1eedc20*/ System.AppDomain CreateDomainHelper(string friendlyName, System.Security.Policy.Evidence securityInfo, System.AppDomainSetup appDomainInfo);
        /*0x1eeda78*/ AppDomainManager();
        /*0x1eeda9c*/ System.Runtime.Hosting.ApplicationActivator get_ApplicationActivator();
        /*0x1eedb08*/ System.Reflection.Assembly get_EntryAssembly();
        /*0x1eedb10*/ System.Threading.HostExecutionContextManager get_HostExecutionContextManager();
        /*0x1eedb50*/ System.Security.HostSecurityManager get_HostSecurityManager();
        /*0x1eedb58*/ System.AppDomainManagerInitializationOptions get_InitializationFlags();
        /*0x1eedb60*/ void set_InitializationFlags(System.AppDomainManagerInitializationOptions value);
        /*0x1eedb68*/ System.AppDomain CreateDomain(string friendlyName, System.Security.Policy.Evidence securityInfo, System.AppDomainSetup appDomainInfo);
        /*0x1eedc28*/ void InitializeNewDomain(System.AppDomainSetup appDomainInfo);
        /*0x1eedc2c*/ bool CheckSecuritySettings(System.Security.SecurityState state);
    }

    class AppDomainSetup : System.IAppDomainSetup
    {
        /*0x10*/ string application_base;
        /*0x18*/ string application_name;
        /*0x20*/ string cache_path;
        /*0x28*/ string configuration_file;
        /*0x30*/ string dynamic_base;
        /*0x38*/ string license_file;
        /*0x40*/ string private_bin_path;
        /*0x48*/ string private_bin_path_probe;
        /*0x50*/ string shadow_copy_directories;
        /*0x58*/ string shadow_copy_files;
        /*0x60*/ bool publisher_policy;
        /*0x61*/ bool path_changed;
        /*0x64*/ int loader_optimization;
        /*0x68*/ bool disallow_binding_redirects;
        /*0x69*/ bool disallow_code_downloads;
        /*0x70*/ object _activationArguments;
        /*0x78*/ object domain_initializer;
        /*0x80*/ object application_trust;
        /*0x88*/ string[] domain_initializer_args;
        /*0x90*/ bool disallow_appbase_probe;
        /*0x98*/ byte[] configuration_bytes;
        /*0xa0*/ byte[] serialized_non_primitives;
        /*0xa8*/ string manager_assembly;
        /*0xb0*/ string manager_type;
        /*0xb8*/ string[] partial_visible_assemblies;
        /*0xc0*/ string <TargetFrameworkName>k__BackingField;

        static /*0x1eedd94*/ string GetAppBase(string appBase);
        /*0x1eedc34*/ AppDomainSetup();
        /*0x1eedc3c*/ AppDomainSetup(System.AppDomainSetup setup);
        /*0x1eedcf0*/ AppDomainSetup(System.Runtime.Hosting.ActivationArguments activationArguments);
        /*0x1eedd18*/ AppDomainSetup(System.ActivationContext activationContext);
        /*0x1eee0a0*/ string get_ApplicationBase();
        /*0x1eee0a8*/ void set_ApplicationBase(string value);
        /*0x1eee0b0*/ string get_ApplicationName();
        /*0x1eee0b8*/ void set_ApplicationName(string value);
        /*0x1eee0c0*/ string get_CachePath();
        /*0x1eee0c8*/ void set_CachePath(string value);
        /*0x1eee0d0*/ string get_ConfigurationFile();
        /*0x1eee1d8*/ void set_ConfigurationFile(string value);
        /*0x1eee1e0*/ bool get_DisallowPublisherPolicy();
        /*0x1eee1e8*/ void set_DisallowPublisherPolicy(bool value);
        /*0x1eee1f4*/ string get_DynamicBase();
        /*0x1eee2fc*/ void set_DynamicBase(string value);
        /*0x1eee400*/ string get_LicenseFile();
        /*0x1eee408*/ void set_LicenseFile(string value);
        /*0x1eee410*/ System.LoaderOptimization get_LoaderOptimization();
        /*0x1eee418*/ void set_LoaderOptimization(System.LoaderOptimization value);
        /*0x1eee420*/ string get_AppDomainManagerAssembly();
        /*0x1eee428*/ void set_AppDomainManagerAssembly(string value);
        /*0x1eee430*/ string get_AppDomainManagerType();
        /*0x1eee438*/ void set_AppDomainManagerType(string value);
        /*0x1eee440*/ string[] get_PartialTrustVisibleAssemblies();
        /*0x1eee448*/ void set_PartialTrustVisibleAssemblies(string[] value);
        /*0x1eee578*/ string get_PrivateBinPath();
        /*0x1eee580*/ void set_PrivateBinPath(string value);
        /*0x1eee590*/ string get_PrivateBinPathProbe();
        /*0x1eee598*/ void set_PrivateBinPathProbe(string value);
        /*0x1eee5a8*/ string get_ShadowCopyDirectories();
        /*0x1eee5b0*/ void set_ShadowCopyDirectories(string value);
        /*0x1eee5b8*/ string get_ShadowCopyFiles();
        /*0x1eee5c0*/ void set_ShadowCopyFiles(string value);
        /*0x1eee5c8*/ bool get_DisallowBindingRedirects();
        /*0x1eee5d0*/ void set_DisallowBindingRedirects(bool value);
        /*0x1eee5dc*/ bool get_DisallowCodeDownload();
        /*0x1eee5e4*/ void set_DisallowCodeDownload(bool value);
        /*0x1eee5f0*/ string get_TargetFrameworkName();
        /*0x1eee5f8*/ void set_TargetFrameworkName(string value);
        /*0x1eee600*/ System.Runtime.Hosting.ActivationArguments get_ActivationArguments();
        /*0x1eee92c*/ void set_ActivationArguments(System.Runtime.Hosting.ActivationArguments value);
        /*0x1eee934*/ System.AppDomainInitializer get_AppDomainInitializer();
        /*0x1eee9a0*/ void set_AppDomainInitializer(System.AppDomainInitializer value);
        /*0x1eee9a8*/ string[] get_AppDomainInitializerArguments();
        /*0x1eee9b0*/ void set_AppDomainInitializerArguments(string[] value);
        /*0x1eee9b8*/ System.Security.Policy.ApplicationTrust get_ApplicationTrust();
        /*0x1eeea48*/ void set_ApplicationTrust(System.Security.Policy.ApplicationTrust value);
        /*0x1eeea50*/ bool get_DisallowApplicationBaseProbing();
        /*0x1eeea58*/ void set_DisallowApplicationBaseProbing(bool value);
        /*0x1eeea64*/ byte[] GetConfigurationBytes();
        /*0x1eeeac4*/ void SetConfigurationBytes(byte[] value);
        /*0x1eee66c*/ void DeserializeNonPrimitives();
        /*0x1eeeacc*/ void SerializeNonPrimitives();
        /*0x1eeec40*/ void SetCompatibilitySwitches(System.Collections.Generic.IEnumerable<string> switches);
        /*0x1eeec44*/ bool get_SandboxInterop();
        /*0x1eeec7c*/ void set_SandboxInterop(bool value);
        /*0x1eeecb4*/ void SetNativeFunction(string functionName, int functionVersion, nint functionPointer);
    }

    class ApplicationIdentity : System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ string _fullName;
        /*0x18*/ string _codeBase;

        /*0x1eeecec*/ ApplicationIdentity(string applicationIdentityFullName);
        /*0x1eeedd0*/ string get_CodeBase();
        /*0x1eeedd8*/ string get_FullName();
        /*0x1eeede0*/ string ToString();
        /*0x1eeede8*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    struct ArgIterator
    {
        /*0x10*/ nint sig;
        /*0x18*/ nint args;
        /*0x20*/ int next_arg;
        /*0x24*/ int num_args;

        /*0x1eeee44*/ ArgIterator(System.RuntimeArgumentHandle arglist);
        /*0x1eeeefc*/ ArgIterator(System.RuntimeArgumentHandle arglist, void* ptr);
        /*0x1eeee40*/ void Setup(nint argsp, nint start);
        /*0x1eeefb4*/ void End();
        /*0x1eeefc0*/ bool Equals(object o);
        /*0x1eef010*/ int GetHashCode();
        /*0x1eef020*/ System.TypedReference GetNextArg();
        /*0x1eef0b8*/ void IntGetNextArg(void* res);
        /*0x1eef0bc*/ System.TypedReference GetNextArg(System.RuntimeTypeHandle rth);
        /*0x1eef158*/ void IntGetNextArgWithType(void* res, nint rth);
        /*0x1eef15c*/ System.RuntimeTypeHandle GetNextArgType();
        /*0x1eef1c0*/ nint IntGetNextArgType();
        /*0x1eef1c4*/ int GetRemainingCount();
    }

    class Console
    {
        static /*0x0*/ System.IO.TextWriter stdout;
        static /*0x8*/ System.IO.TextWriter stderr;
        static /*0x10*/ System.IO.TextReader stdin;
        static /*0x18*/ System.Text.Encoding inputEncoding;
        static /*0x20*/ System.Text.Encoding outputEncoding;
        static /*0x28*/ System.ConsoleCancelEventHandler cancel_event;

        static /*0x1eef1d0*/ Console();
        static /*0x1eef464*/ void SetupStreams(System.Text.Encoding inputEncoding, System.Text.Encoding outputEncoding);
        static /*0x1eefafc*/ System.IO.TextWriter get_Error();
        static /*0x1eefb54*/ System.IO.TextWriter get_Out();
        static /*0x1eefbac*/ System.IO.TextReader get_In();
        static /*0x1eefc04*/ System.IO.Stream Open(nint handle, System.IO.FileAccess access, int bufferSize);
        static /*0x1eefd60*/ System.IO.Stream OpenStandardError();
        static /*0x1eefa6c*/ System.IO.Stream OpenStandardError(int bufferSize);
        static /*0x1eefdb0*/ System.IO.Stream OpenStandardInput();
        static /*0x1eef94c*/ System.IO.Stream OpenStandardInput(int bufferSize);
        static /*0x1eefe00*/ System.IO.Stream OpenStandardOutput();
        static /*0x1eef9dc*/ System.IO.Stream OpenStandardOutput(int bufferSize);
        static /*0x1eefe50*/ void SetError(System.IO.TextWriter newError);
        static /*0x1eeff34*/ void SetIn(System.IO.TextReader newIn);
        static /*0x1ef0018*/ void SetOut(System.IO.TextWriter newOut);
        static /*0x1ef00fc*/ void Write(bool value);
        static /*0x1ef0170*/ void Write(char value);
        static /*0x1ef01e4*/ void Write(char[] buffer);
        static /*0x1ef0258*/ void Write(decimal value);
        static /*0x1ef02dc*/ void Write(double value);
        static /*0x1ef0358*/ void Write(int value);
        static /*0x1ef03cc*/ void Write(long value);
        static /*0x1ef0440*/ void Write(object value);
        static /*0x1ef04b4*/ void Write(float value);
        static /*0x1ef0530*/ void Write(string value);
        static /*0x1ef05a4*/ void Write(uint value);
        static /*0x1ef0618*/ void Write(ulong value);
        static /*0x1ef068c*/ void Write(string format, object arg0);
        static /*0x1ef0710*/ void Write(string format, object[] arg);
        static /*0x1ef07b4*/ void Write(char[] buffer, int index, int count);
        static /*0x1ef0840*/ void Write(string format, object arg0, object arg1);
        static /*0x1ef08cc*/ void Write(string format, object arg0, object arg1, object arg2);
        static /*0x1ef0968*/ void Write(string format, object arg0, object arg1, object arg2, object arg3);
        static /*0x1ef0b94*/ void WriteLine();
        static /*0x1ef0c00*/ void WriteLine(bool value);
        static /*0x1ef0c74*/ void WriteLine(char value);
        static /*0x1ef0ce8*/ void WriteLine(char[] buffer);
        static /*0x1ef0d5c*/ void WriteLine(decimal value);
        static /*0x1ef0de0*/ void WriteLine(double value);
        static /*0x1ef0e5c*/ void WriteLine(int value);
        static /*0x1ef0ed0*/ void WriteLine(long value);
        static /*0x1ef0f44*/ void WriteLine(object value);
        static /*0x1ef0fb8*/ void WriteLine(float value);
        static /*0x1ef1034*/ void WriteLine(string value);
        static /*0x1ef10a8*/ void WriteLine(uint value);
        static /*0x1ef111c*/ void WriteLine(ulong value);
        static /*0x1ef1190*/ void WriteLine(string format, object arg0);
        static /*0x1ef1214*/ void WriteLine(string format, object[] arg);
        static /*0x1ef12b8*/ void WriteLine(char[] buffer, int index, int count);
        static /*0x1ef1344*/ void WriteLine(string format, object arg0, object arg1);
        static /*0x1ef13d0*/ void WriteLine(string format, object arg0, object arg1, object arg2);
        static /*0x1ef146c*/ void WriteLine(string format, object arg0, object arg1, object arg2, object arg3);
        static /*0x1ef1698*/ int Read();
        static /*0x1ef1800*/ string ReadLine();
        static /*0x1ef19e0*/ System.Text.Encoding get_InputEncoding();
        static /*0x1ef1a38*/ void set_InputEncoding(System.Text.Encoding value);
        static /*0x1ef1a9c*/ System.Text.Encoding get_OutputEncoding();
        static /*0x1ef1af4*/ void set_OutputEncoding(System.Text.Encoding value);
        static /*0x1ef1b58*/ System.ConsoleColor get_BackgroundColor();
        static /*0x1ef1c6c*/ void set_BackgroundColor(System.ConsoleColor value);
        static /*0x1ef1dfc*/ int get_BufferHeight();
        static /*0x1ef1f14*/ void set_BufferHeight(int value);
        static /*0x1ef203c*/ int get_BufferWidth();
        static /*0x1ef2154*/ void set_BufferWidth(int value);
        static /*0x1ef227c*/ bool get_CapsLock();
        static /*0x1ef2394*/ int get_CursorLeft();
        static /*0x1ef24ac*/ void set_CursorLeft(int value);
        static /*0x1ef25d4*/ int get_CursorTop();
        static /*0x1ef26ec*/ void set_CursorTop(int value);
        static /*0x1ef2814*/ int get_CursorSize();
        static /*0x1ef292c*/ void set_CursorSize(int value);
        static /*0x1ef2a54*/ bool get_CursorVisible();
        static /*0x1ef2b6c*/ void set_CursorVisible(bool value);
        static /*0x1ef2c94*/ System.ConsoleColor get_ForegroundColor();
        static /*0x1ef2dac*/ void set_ForegroundColor(System.ConsoleColor value);
        static /*0x1ef2f3c*/ bool get_KeyAvailable();
        static /*0x1ef3054*/ int get_LargestWindowHeight();
        static /*0x1ef316c*/ int get_LargestWindowWidth();
        static /*0x1ef3284*/ bool get_NumberLock();
        static /*0x1ef339c*/ string get_Title();
        static /*0x1ef34b4*/ void set_Title(string value);
        static /*0x1ef35dc*/ bool get_TreatControlCAsInput();
        static /*0x1ef36f4*/ void set_TreatControlCAsInput(bool value);
        static /*0x1ef381c*/ int get_WindowHeight();
        static /*0x1ef3934*/ void set_WindowHeight(int value);
        static /*0x1ef3a5c*/ int get_WindowLeft();
        static /*0x1ef3b74*/ void set_WindowLeft(int value);
        static /*0x1ef3c9c*/ int get_WindowTop();
        static /*0x1ef3db4*/ void set_WindowTop(int value);
        static /*0x1ef3edc*/ int get_WindowWidth();
        static /*0x1ef3ff4*/ void set_WindowWidth(int value);
        static /*0x1ef411c*/ bool get_IsErrorRedirected();
        static /*0x1ef41f8*/ bool get_IsOutputRedirected();
        static /*0x1ef42d4*/ bool get_IsInputRedirected();
        static /*0x1ef43b0*/ void Beep();
        static /*0x1ef4404*/ void Beep(int frequency, int duration);
        static /*0x1ef45cc*/ void Clear();
        static /*0x1ef46e4*/ void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);
        static /*0x1ef4824*/ void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, System.ConsoleColor sourceForeColor, System.ConsoleColor sourceBackColor);
        static /*0x1ef4a1c*/ System.ConsoleKeyInfo ReadKey();
        static /*0x1ef4a74*/ System.ConsoleKeyInfo ReadKey(bool intercept);
        static /*0x1ef4bac*/ void ResetColor();
        static /*0x1ef4cc4*/ void SetBufferSize(int width, int height);
        static /*0x1ef4e0c*/ void SetCursorPosition(int left, int top);
        static /*0x1ef4f54*/ void SetWindowPosition(int left, int top);
        static /*0x1ef509c*/ void SetWindowSize(int width, int height);
        static /*0x1ef51e4*/ void add_CancelKeyPress(System.ConsoleCancelEventHandler value);
        static /*0x1ef56bc*/ void remove_CancelKeyPress(System.ConsoleCancelEventHandler value);
        static /*0x1ef59fc*/ void DoConsoleCancelEventInBackground();
        static /*0x1ef5ad4*/ void DoConsoleCancelEvent();

        class WindowsConsole
        {
            static /*0x0*/ bool ctrlHandlerAdded;
            static /*0x8*/ System.Console.WindowsConsole.WindowsCancelHandler cancelHandler;

            static /*0x1ef5e90*/ WindowsConsole();
            static /*0x1ef5ccc*/ int GetConsoleCP();
            static /*0x1ef5d34*/ int GetConsoleOutputCP();
            static /*0x1ef5da0*/ bool SetConsoleCtrlHandler(System.Console.WindowsConsole.WindowsCancelHandler handler, bool addHandler);
            static /*0x1ef5e30*/ bool DoWindowsConsoleCancelEvent(int keyCode);
            static /*0x1eef3cc*/ int GetInputCodePage();
            static /*0x1eef418*/ int GetOutputCodePage();
            static /*0x1ef564c*/ void AddCtrlHandler();
            static /*0x1ef5990*/ void RemoveCtrlHandler();

            class WindowsCancelHandler : System.MulticastDelegate
            {
                /*0x1ef5f2c*/ WindowsCancelHandler(object object, nint method);
                /*0x1ef5ff0*/ bool Invoke(int keyCode);
            }
        }

        class <>c
        {
            static /*0x0*/ System.Console.<> <>9;
            static /*0x8*/ System.Threading.WaitCallback <>9__143_0;

            static /*0x1ef6004*/ <>c();
            /*0x1ef6068*/ <>c();
            /*0x1ef6070*/ void <DoConsoleCancelEventInBackground>b__143_0(object _);
        }
    }

    class ConsoleDriver
    {
        static /*0x0*/ System.IConsoleDriver driver;
        static /*0x8*/ bool is_console;
        static /*0x9*/ bool called_isatty;

        static /*0x1ef60bc*/ ConsoleDriver();
        static /*0x1ef6180*/ System.IConsoleDriver CreateNullConsoleDriver();
        static /*0x1ef61dc*/ System.IConsoleDriver CreateWindowsConsoleDriver();
        static /*0x1ef6238*/ System.IConsoleDriver CreateTermInfoDriver(string term);
        static /*0x1ef5330*/ bool get_Initialized();
        static /*0x1ef1ba4*/ System.ConsoleColor get_BackgroundColor();
        static /*0x1ef1cc0*/ void set_BackgroundColor(System.ConsoleColor value);
        static /*0x1ef1e48*/ int get_BufferHeight();
        static /*0x1ef1f68*/ void set_BufferHeight(int value);
        static /*0x1ef2088*/ int get_BufferWidth();
        static /*0x1ef21a8*/ void set_BufferWidth(int value);
        static /*0x1ef22c8*/ bool get_CapsLock();
        static /*0x1ef23e0*/ int get_CursorLeft();
        static /*0x1ef2500*/ void set_CursorLeft(int value);
        static /*0x1ef2860*/ int get_CursorSize();
        static /*0x1ef2980*/ void set_CursorSize(int value);
        static /*0x1ef2620*/ int get_CursorTop();
        static /*0x1ef2740*/ void set_CursorTop(int value);
        static /*0x1ef2aa0*/ bool get_CursorVisible();
        static /*0x1ef2bc0*/ void set_CursorVisible(bool value);
        static /*0x1ef2f88*/ bool get_KeyAvailable();
        static /*0x1ef2ce0*/ System.ConsoleColor get_ForegroundColor();
        static /*0x1ef2e00*/ void set_ForegroundColor(System.ConsoleColor value);
        static /*0x1ef30a0*/ int get_LargestWindowHeight();
        static /*0x1ef31b8*/ int get_LargestWindowWidth();
        static /*0x1ef32d0*/ bool get_NumberLock();
        static /*0x1ef33e8*/ string get_Title();
        static /*0x1ef3508*/ void set_Title(string value);
        static /*0x1ef3628*/ bool get_TreatControlCAsInput();
        static /*0x1ef3748*/ void set_TreatControlCAsInput(bool value);
        static /*0x1ef3868*/ int get_WindowHeight();
        static /*0x1ef3988*/ void set_WindowHeight(int value);
        static /*0x1ef3aa8*/ int get_WindowLeft();
        static /*0x1ef3bc8*/ void set_WindowLeft(int value);
        static /*0x1ef3ce8*/ int get_WindowTop();
        static /*0x1ef3e08*/ void set_WindowTop(int value);
        static /*0x1ef3f28*/ int get_WindowWidth();
        static /*0x1ef4048*/ void set_WindowWidth(int value);
        static /*0x1ef4168*/ bool get_IsErrorRedirected();
        static /*0x1ef4244*/ bool get_IsOutputRedirected();
        static /*0x1ef4320*/ bool get_IsInputRedirected();
        static /*0x1ef44e8*/ void Beep(int frequency, int duration);
        static /*0x1ef4618*/ void Clear();
        static /*0x1ef4778*/ void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);
        static /*0x1ef48d8*/ void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, System.ConsoleColor sourceForeColor, System.ConsoleColor sourceBackColor);
        static /*0x1ef53fc*/ void Init();
        static /*0x1ef17a8*/ int Read();
        static /*0x1ef1914*/ string ReadLine();
        static /*0x1ef4ad0*/ System.ConsoleKeyInfo ReadKey(bool intercept);
        static /*0x1ef4bf8*/ void ResetColor();
        static /*0x1ef4d28*/ void SetBufferSize(int width, int height);
        static /*0x1ef4e70*/ void SetCursorPosition(int left, int top);
        static /*0x1ef4fb8*/ void SetWindowPosition(int left, int top);
        static /*0x1ef5100*/ void SetWindowSize(int width, int height);
        static /*0x1eef814*/ bool get_IsConsole();
        static /*0x1ef62a4*/ bool Isatty(nint handle);
        static /*0x1ef62a8*/ int InternalKeyAvailable(int ms_timeout);
        static /*0x1ef62ac*/ bool TtySetup(string keypadXmit, string teardown, ref byte[] control_characters, ref int* address);
        static /*0x1ef62b0*/ bool SetEcho(bool wantEcho);
        static /*0x1ef62b8*/ bool SetBreak(bool wantBreak);
    }

    class ControlCharacters
    {
        static int Intr = 0;
        static int Quit = 1;
        static int Erase = 2;
        static int Kill = 3;
        static int EOF = 4;
        static int Time = 5;
        static int Min = 6;
        static int SWTC = 7;
        static int Start = 8;
        static int Stop = 9;
        static int Susp = 10;
        static int EOL = 11;
        static int Reprint = 12;
        static int Discard = 13;
        static int WErase = 14;
        static int LNext = 15;
        static int EOL2 = 16;

        /*0x1ef62c0*/ ControlCharacters();
    }

    class CrossAppDomainDelegate : System.MulticastDelegate
    {
        /*0x1ef62c8*/ CrossAppDomainDelegate(object object, nint method);
        /*0x1ef6384*/ void Invoke();
        /*0x1ef6398*/ System.IAsyncResult BeginInvoke(System.AsyncCallback callback, object object);
        /*0x1ef63b8*/ void EndInvoke(System.IAsyncResult result);
    }

    class DelegateData
    {
        /*0x10*/ System.Type target_type;
        /*0x18*/ string method_name;
        /*0x20*/ bool curried_first_arg;

        /*0x1ef63c4*/ DelegateData();
    }

    class Delegate : System.ICloneable, System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ nint method_ptr;
        /*0x18*/ nint invoke_impl;
        /*0x20*/ object m_target;
        /*0x28*/ nint method;
        /*0x30*/ nint delegate_trampoline;
        /*0x38*/ nint extra_arg;
        /*0x40*/ nint method_code;
        /*0x48*/ nint interp_method;
        /*0x50*/ nint interp_invoke_impl;
        /*0x58*/ System.Reflection.MethodInfo method_info;
        /*0x60*/ System.Reflection.MethodInfo original_method_info;
        /*0x68*/ System.DelegateData data;
        /*0x70*/ bool method_is_virtual;

        static /*0x1ef6614*/ System.Delegate CreateDelegate_internal(System.Type type, object target, System.Reflection.MethodInfo info, bool throwOnBindFailure);
        static /*0x1ef661c*/ bool arg_type_match(System.Type delArgType, System.Type argType);
        static /*0x1ef67ac*/ bool arg_type_match_this(System.Type delArgType, System.Type argType, bool boxedThis);
        static /*0x1ef68f8*/ bool return_type_match(System.Type delReturnType, System.Type returnType);
        static /*0x1ef6b0c*/ System.Delegate CreateDelegate(System.Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);
        static /*0x1ef6b18*/ System.Delegate CreateDelegate(System.Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure, bool allowClosed);
        static /*0x1ef7378*/ System.Delegate CreateDelegate(System.Type type, object firstArgument, System.Reflection.MethodInfo method);
        static /*0x1ef7384*/ System.Delegate CreateDelegate(System.Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);
        static /*0x1ef739c*/ System.Delegate CreateDelegate(System.Type type, System.Reflection.MethodInfo method);
        static /*0x1ef73b0*/ System.Delegate CreateDelegate(System.Type type, object target, string method);
        static /*0x1ef73c8*/ System.Reflection.MethodInfo GetCandidateMethod(System.Type type, System.Type target, string method, System.Reflection.BindingFlags bflags, bool ignoreCase, bool throwOnBindFailure);
        static /*0x1ef7828*/ System.Delegate CreateDelegate(System.Type type, System.Type target, string method, bool ignoreCase, bool throwOnBindFailure);
        static /*0x1ef7954*/ System.Delegate CreateDelegate(System.Type type, System.Type target, string method);
        static /*0x1ef7960*/ System.Delegate CreateDelegate(System.Type type, System.Type target, string method, bool ignoreCase);
        static /*0x1ef796c*/ System.Delegate CreateDelegate(System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
        static /*0x1ef73bc*/ System.Delegate CreateDelegate(System.Type type, object target, string method, bool ignoreCase);
        static /*0x1ef54c8*/ System.Delegate Combine(System.Delegate a, System.Delegate b);
        static /*0x1ef8424*/ System.Delegate Combine(System.Delegate[] delegates);
        static /*0x1ef5810*/ System.Delegate Remove(System.Delegate source, System.Delegate value);
        static /*0x1ef8508*/ System.Delegate RemoveAll(System.Delegate source, System.Delegate value);
        static /*0x1ef85a0*/ bool op_Equality(System.Delegate d1, System.Delegate d2);
        static /*0x1ef8568*/ bool op_Inequality(System.Delegate d1, System.Delegate d2);
        static /*0x1ef85d0*/ System.Delegate CreateDelegateNoSecurityCheck(System.RuntimeType type, object firstArgument, System.Reflection.MethodInfo method);
        static /*0x1ef85d8*/ System.MulticastDelegate AllocDelegateLike_internal(System.Delegate d);
        /*0x1ef63cc*/ Delegate(object target, string method);
        /*0x1ef64c8*/ Delegate(System.Type target, string method);
        /*0x1ef65f4*/ System.Reflection.MethodInfo get_Method();
        /*0x1ef6600*/ System.Reflection.MethodInfo GetVirtualMethod_internal();
        /*0x1ef6604*/ object get_Target();
        /*0x1ef660c*/ nint GetNativeFunctionPointer();
        /*0x1ef7a50*/ object DynamicInvoke(object[] args);
        /*0x1ef7a5c*/ void InitializeDelegateData();
        /*0x1ef7b50*/ object DynamicInvokeImpl(object[] args);
        /*0x1ef7e18*/ object Clone();
        /*0x1ef7e20*/ bool Equals(object obj);
        /*0x1ef7fc4*/ int GetHashCode();
        /*0x1ef8040*/ System.Reflection.MethodInfo GetMethodImpl();
        /*0x1ef8148*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1ef8394*/ System.Delegate[] GetInvocationList();
        /*0x1ef8488*/ System.Delegate CombineImpl(System.Delegate d);
        /*0x1ef84e4*/ System.Delegate RemoveImpl(System.Delegate d);
        /*0x1ef85c8*/ bool IsTransparentProxy();
    }

    class DelegateSerializationHolder : System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
    {
        /*0x10*/ System.Delegate _delegate;

        static /*0x1ef814c*/ void GetDelegateData(System.Delegate instance, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext ctx);
        /*0x1ef85dc*/ DelegateSerializationHolder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext ctx);
        /*0x1ef8ba0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1ef8be0*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);

        class DelegateEntry
        {
            /*0x10*/ string type;
            /*0x18*/ string assembly;
            /*0x20*/ object target;
            /*0x28*/ string targetTypeAssembly;
            /*0x30*/ string targetTypeName;
            /*0x38*/ string methodName;
            /*0x40*/ System.DelegateSerializationHolder.DelegateEntry delegateEntry;

            /*0x1ef8a60*/ DelegateEntry(System.Delegate del, string targetLabel);
            /*0x1ef87e8*/ System.Delegate DeserializeDelegate(System.Runtime.Serialization.SerializationInfo info, int index);
        }
    }

    enum AppDomainManagerInitializationOptions
    {
        None = 0,
        RegisterWithHost = 1,
    }

    class EmptyArray<T>
    {
        static /*0x0*/ T[] Value;

        static EmptyArray();
    }

    enum SByteEnum
    {
    }

    enum Int16Enum
    {
    }

    enum Int32Enum
    {
    }

    enum Int64Enum
    {
    }

    enum ByteEnum
    {
    }

    enum UInt16Enum
    {
    }

    enum UInt32Enum
    {
    }

    enum UInt64Enum
    {
    }

    enum EnvironmentVariableTarget
    {
        Process = 0,
        User = 1,
        Machine = 2,
    }

    interface IConsoleDriver
    {
        System.ConsoleColor get_BackgroundColor();
        void set_BackgroundColor(System.ConsoleColor value);
        int get_BufferHeight();
        void set_BufferHeight(int value);
        int get_BufferWidth();
        void set_BufferWidth(int value);
        bool get_CapsLock();
        int get_CursorLeft();
        void set_CursorLeft(int value);
        int get_CursorSize();
        void set_CursorSize(int value);
        int get_CursorTop();
        void set_CursorTop(int value);
        bool get_CursorVisible();
        void set_CursorVisible(bool value);
        System.ConsoleColor get_ForegroundColor();
        void set_ForegroundColor(System.ConsoleColor value);
        bool get_KeyAvailable();
        bool get_Initialized();
        int get_LargestWindowHeight();
        int get_LargestWindowWidth();
        bool get_NumberLock();
        string get_Title();
        void set_Title(string value);
        bool get_TreatControlCAsInput();
        void set_TreatControlCAsInput(bool value);
        int get_WindowHeight();
        void set_WindowHeight(int value);
        int get_WindowLeft();
        void set_WindowLeft(int value);
        int get_WindowTop();
        void set_WindowTop(int value);
        int get_WindowWidth();
        void set_WindowWidth(int value);
        void Init();
        void Beep(int frequency, int duration);
        void Clear();
        void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, System.ConsoleColor sourceForeColor, System.ConsoleColor sourceBackColor);
        System.ConsoleKeyInfo ReadKey(bool intercept);
        void ResetColor();
        void SetBufferSize(int width, int height);
        void SetCursorPosition(int left, int top);
        void SetWindowPosition(int left, int top);
        void SetWindowSize(int width, int height);
        string ReadLine();
    }

    struct IntPtr : System.Runtime.Serialization.ISerializable, System.IEquatable<nint>
    {
        static /*0x0*/ nint Zero;
        /*0x10*/ void* m_value;

        static /*0x1eed450*/ int get_Size();
        static /*0x1eeeef0*/ bool op_Equality(nint value1, nint value2);
        static /*0x1ef813c*/ bool op_Inequality(nint value1, nint value2);
        static /*0x1ef8de4*/ nint op_Explicit(int value);
        static /*0x1ef8dec*/ nint op_Explicit(long value);
        static /*0x1eeefb0*/ nint op_Explicit(void* value);
        static /*0x1ef8df0*/ int op_Explicit(nint value);
        static /*0x1ef8df4*/ long op_Explicit(nint value);
        static /*0x1ef8df8*/ void* op_Explicit(nint value);
        static /*0x1ef8dfc*/ nint Add(nint pointer, int offset);
        static /*0x1ef8e04*/ nint Subtract(nint pointer, int offset);
        static /*0x1ef8e0c*/ nint op_Addition(nint pointer, int offset);
        static /*0x1ef8e14*/ nint op_Subtraction(nint pointer, int offset);
        /*0x1ef8be8*/ IntPtr(int value);
        /*0x1ef8bf4*/ IntPtr(long value);
        /*0x1ef8bfc*/ IntPtr(void* value);
        /*0x1ef8c04*/ IntPtr(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1ef8c64*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1ef8d10*/ bool Equals(object obj);
        /*0x1eef018*/ int GetHashCode();
        /*0x1ef8d88*/ int ToInt32();
        /*0x1ef8d08*/ long ToInt64();
        /*0x1ef8d90*/ void* ToPointer();
        /*0x1ef8d98*/ string ToString();
        /*0x1ef8dc0*/ string ToString(string format);
        /*0x1eed57c*/ bool IsNull();
        /*0x1ef8e1c*/ bool System.IEquatable<System.IntPtr>.Equals(nint other);
    }

    class KnownTerminals
    {
        static /*0x1ef8e2c*/ byte[] get_linux();
        static /*0x1ef8e9c*/ byte[] get_xterm();
        static /*0x1ef8f0c*/ byte[] get_ansi();
    }

    class MarshalByRefObject
    {
        /*0x10*/ object _identity;

        /*0x1eeda94*/ MarshalByRefObject();
        /*0x1ef8f7c*/ System.Runtime.Remoting.ServerIdentity get_ObjectIdentity();
        /*0x1ef8fbc*/ void set_ObjectIdentity(System.Runtime.Remoting.ServerIdentity value);
        /*0x1ef8ffc*/ System.Runtime.Remoting.ObjRef CreateObjRef(System.Type requestedType);
        /*0x1ef903c*/ object GetLifetimeService();
        /*0x1ef907c*/ object InitializeLifetimeService();
        /*0x1ef90bc*/ System.MarshalByRefObject MemberwiseClone(bool cloneIdentity);
    }

    struct ModuleHandle
    {
        static /*0x0*/ System.ModuleHandle EmptyHandle;
        /*0x10*/ nint value;

        static /*0x1ef9ae0*/ ModuleHandle();
        static /*0x1ef99c4*/ bool op_Equality(System.ModuleHandle left, System.ModuleHandle right);
        static /*0x1ef9a50*/ bool op_Inequality(System.ModuleHandle left, System.ModuleHandle right);
        /*0x1ef90fc*/ ModuleHandle(nint v);
        /*0x1ef9104*/ nint get_Value();
        /*0x1ef910c*/ int get_MDStreamVersion();
        /*0x1ef91cc*/ void GetPEKind(ref System.Reflection.PortableExecutableKinds peKind, ref System.Reflection.ImageFileMachine machine);
        /*0x1ef92a4*/ System.RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
        /*0x1ef9460*/ System.RuntimeMethodHandle ResolveMethodHandle(int methodToken);
        /*0x1ef961c*/ System.RuntimeTypeHandle ResolveTypeHandle(int typeToken);
        /*0x1ef97d8*/ nint[] ptrs_from_handles(System.RuntimeTypeHandle[] handles);
        /*0x1ef9628*/ System.RuntimeTypeHandle ResolveTypeHandle(int typeToken, System.RuntimeTypeHandle[] typeInstantiationContext, System.RuntimeTypeHandle[] methodInstantiationContext);
        /*0x1ef946c*/ System.RuntimeMethodHandle ResolveMethodHandle(int methodToken, System.RuntimeTypeHandle[] typeInstantiationContext, System.RuntimeTypeHandle[] methodInstantiationContext);
        /*0x1ef92b0*/ System.RuntimeFieldHandle ResolveFieldHandle(int fieldToken, System.RuntimeTypeHandle[] typeInstantiationContext, System.RuntimeTypeHandle[] methodInstantiationContext);
        /*0x1ef9884*/ System.RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
        /*0x1ef9890*/ System.RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
        /*0x1ef989c*/ System.RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
        /*0x1ef98a8*/ bool Equals(object obj);
        /*0x1ef99ac*/ bool Equals(System.ModuleHandle handle);
        /*0x1ef99bc*/ int GetHashCode();
    }

    class MonoAsyncCall
    {
        /*0x10*/ object msg;
        /*0x18*/ nint cb_method;
        /*0x20*/ object cb_target;
        /*0x28*/ object state;
        /*0x30*/ object res;
        /*0x38*/ object out_args;

        /*0x1ef9b48*/ MonoAsyncCall();
    }

    class MonoCQItem
    {
        /*0x10*/ object[] array;
        /*0x18*/ byte[] array_state;
        /*0x20*/ int head;
        /*0x24*/ int tail;

        /*0x1ef9b50*/ MonoCQItem();
    }

    class MonoCustomAttrs
    {
        static /*0x0*/ System.Reflection.Assembly corlib;
        static /*0x8*/ System.AttributeUsageAttribute DefaultAttributeUsage;
        [ThreadStatic] static System.Collections.Generic.Dictionary<System.Type, System.AttributeUsageAttribute> usage_cache;

        static /*0x1efd8f4*/ MonoCustomAttrs();
        static /*0x1ef9b58*/ bool IsUserCattrProvider(object obj);
        static /*0x1ef9d28*/ System.Attribute[] GetCustomAttributesInternal(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool pseudoAttrs);
        static /*0x1ef9d30*/ object[] GetPseudoCustomAttributes(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType);
        static /*0x1efa020*/ object[] GetPseudoCustomAttributes(System.Type type);
        static /*0x1efa184*/ object[] GetCustomAttributesBase(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inheritedOnly);
        static /*0x1efa328*/ object[] GetCustomAttributes(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inherit);
        static /*0x1efb228*/ object[] GetCustomAttributes(System.Reflection.ICustomAttributeProvider obj, bool inherit);
        static /*0x1efb3a0*/ System.Reflection.CustomAttributeData[] GetCustomAttributesDataInternal(System.Reflection.ICustomAttributeProvider obj);
        static /*0x1efb3a4*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData(System.Reflection.ICustomAttributeProvider obj, bool inherit);
        static /*0x1efb67c*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inherit);
        static /*0x1efb4d0*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesDataBase(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inheritedOnly);
        static /*0x1efc9ec*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType);
        static /*0x1efccdc*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData(System.Type type);
        static /*0x1efcef4*/ bool IsDefined(System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, bool inherit);
        static /*0x1efd190*/ bool IsDefinedInternal(System.Reflection.ICustomAttributeProvider obj, System.Type AttributeType);
        static /*0x1efd194*/ System.Reflection.PropertyInfo GetBasePropertyDefinition(System.Reflection.RuntimePropertyInfo property);
        static /*0x1efd490*/ System.Reflection.EventInfo GetBaseEventDefinition(System.Reflection.RuntimeEventInfo evt);
        static /*0x1efacc8*/ System.Reflection.ICustomAttributeProvider GetBase(System.Reflection.ICustomAttributeProvider obj);
        static /*0x1efd6a8*/ System.AttributeUsageAttribute RetrieveAttributeUsageNoCache(System.Type attributeType);
        static /*0x1efb084*/ System.AttributeUsageAttribute RetrieveAttributeUsage(System.Type attributeType);

        class AttributeInfo
        {
            /*0x10*/ System.AttributeUsageAttribute _usage;
            /*0x18*/ int _inheritanceLevel;

            /*0x1efb1f8*/ AttributeInfo(System.AttributeUsageAttribute usage, int inheritanceLevel);
            /*0x1efd970*/ System.AttributeUsageAttribute get_Usage();
            /*0x1efd978*/ int get_InheritanceLevel();
        }
    }

    class MonoListItem
    {
        /*0x10*/ System.MonoListItem next;
        /*0x18*/ object data;

        /*0x1efd980*/ MonoListItem();
    }

    class MonoType : System.RuntimeType
    {
        /*0x1efd988*/ MonoType();
    }

    class MulticastDelegate : System.Delegate
    {
        /*0x78*/ System.Delegate[] delegates;

        static /*0x1efe35c*/ bool op_Equality(System.MulticastDelegate d1, System.MulticastDelegate d2);
        static /*0x1efe378*/ bool op_Inequality(System.MulticastDelegate d1, System.MulticastDelegate d2);
        /*0x1efd9e0*/ MulticastDelegate(object target, string method);
        /*0x1efd9e4*/ MulticastDelegate(System.Type target, string method);
        /*0x1efd9e8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1efd9ec*/ object DynamicInvokeImpl(object[] args);
        /*0x1efda7c*/ bool get_HasSingleTarget();
        /*0x1efda8c*/ bool Equals(object obj);
        /*0x1efdbd0*/ int GetHashCode();
        /*0x1efdbd4*/ System.Reflection.MethodInfo GetMethodImpl();
        /*0x1efdc1c*/ System.Delegate[] GetInvocationList();
        /*0x1efdce8*/ System.Delegate CombineImpl(System.Delegate follow);
        /*0x1efdf50*/ int LastIndexOf(System.Delegate[] haystack, System.Delegate[] needle);
        /*0x1efe07c*/ System.Delegate RemoveImpl(System.Delegate value);
    }

    class NullConsoleDriver : System.IConsoleDriver
    {
        static /*0x0*/ System.ConsoleKeyInfo EmptyConsoleKeyInfo;

        static /*0x1efe540*/ NullConsoleDriver();
        /*0x1ef629c*/ NullConsoleDriver();
        /*0x1efe3a8*/ System.ConsoleColor get_BackgroundColor();
        /*0x1efe3b0*/ void set_BackgroundColor(System.ConsoleColor value);
        /*0x1efe3b4*/ int get_BufferHeight();
        /*0x1efe3bc*/ void set_BufferHeight(int value);
        /*0x1efe3c0*/ int get_BufferWidth();
        /*0x1efe3c8*/ void set_BufferWidth(int value);
        /*0x1efe3cc*/ bool get_CapsLock();
        /*0x1efe3d4*/ int get_CursorLeft();
        /*0x1efe3dc*/ void set_CursorLeft(int value);
        /*0x1efe3e0*/ int get_CursorSize();
        /*0x1efe3e8*/ void set_CursorSize(int value);
        /*0x1efe3ec*/ int get_CursorTop();
        /*0x1efe3f4*/ void set_CursorTop(int value);
        /*0x1efe3f8*/ bool get_CursorVisible();
        /*0x1efe400*/ void set_CursorVisible(bool value);
        /*0x1efe404*/ System.ConsoleColor get_ForegroundColor();
        /*0x1efe40c*/ void set_ForegroundColor(System.ConsoleColor value);
        /*0x1efe410*/ bool get_KeyAvailable();
        /*0x1efe418*/ bool get_Initialized();
        /*0x1efe420*/ int get_LargestWindowHeight();
        /*0x1efe428*/ int get_LargestWindowWidth();
        /*0x1efe430*/ bool get_NumberLock();
        /*0x1efe438*/ string get_Title();
        /*0x1efe478*/ void set_Title(string value);
        /*0x1efe47c*/ bool get_TreatControlCAsInput();
        /*0x1efe484*/ void set_TreatControlCAsInput(bool value);
        /*0x1efe488*/ int get_WindowHeight();
        /*0x1efe490*/ void set_WindowHeight(int value);
        /*0x1efe494*/ int get_WindowLeft();
        /*0x1efe49c*/ void set_WindowLeft(int value);
        /*0x1efe4a0*/ int get_WindowTop();
        /*0x1efe4a8*/ void set_WindowTop(int value);
        /*0x1efe4ac*/ int get_WindowWidth();
        /*0x1efe4b4*/ void set_WindowWidth(int value);
        /*0x1efe4b8*/ void Beep(int frequency, int duration);
        /*0x1efe4bc*/ void Clear();
        /*0x1efe4c0*/ void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, System.ConsoleColor sourceForeColor, System.ConsoleColor sourceBackColor);
        /*0x1efe4c4*/ void Init();
        /*0x1efe4c8*/ string ReadLine();
        /*0x1efe4d0*/ System.ConsoleKeyInfo ReadKey(bool intercept);
        /*0x1efe52c*/ void ResetColor();
        /*0x1efe530*/ void SetBufferSize(int width, int height);
        /*0x1efe534*/ void SetCursorPosition(int left, int top);
        /*0x1efe538*/ void SetWindowPosition(int left, int top);
        /*0x1efe53c*/ void SetWindowSize(int width, int height);
    }

    class NumberFormatter
    {
        static int DefaultExpPrecision = 6;
        static int HundredMillion = 100000000;
        static long SeventeenDigitsThreshold = 10000000000000000;
        static ulong ULongDivHundredMillion = 184467440737;
        static ulong ULongModHundredMillion = 9551616;
        static int DoubleBitsExponentShift = 52;
        static int DoubleBitsExponentMask = 2047;
        static long DoubleBitsMantissaMask = 4503599627370495;
        static int DecimalBitsScaleMask = 2031616;
        static int SingleDefPrecision = 7;
        static int DoubleDefPrecision = 15;
        static int Int32DefPrecision = 10;
        static int UInt32DefPrecision = 10;
        static int Int64DefPrecision = 19;
        static int UInt64DefPrecision = 20;
        static int DecimalDefPrecision = 100;
        static int TenPowersListLength = 19;
        static double MinRoundtripVal = -1.79769313486231e+308;
        static double MaxRoundtripVal = 1.79769313486231e+308;
        static /*0x0*/ ulong* MantissaBitsTable;
        static /*0x8*/ int* TensExponentTable;
        static /*0x10*/ char* DigitLowerTable;
        static /*0x18*/ char* DigitUpperTable;
        static /*0x20*/ long* TenPowersList;
        static /*0x28*/ int* DecHexDigits;
        [ThreadStatic] static System.NumberFormatter threadNumberFormatter;
        [ThreadStatic] static System.NumberFormatter userFormatProvider;
        /*0x10*/ System.Globalization.NumberFormatInfo _nfi;
        /*0x18*/ char[] _cbuf;
        /*0x20*/ bool _NaN;
        /*0x21*/ bool _infinity;
        /*0x22*/ bool _isCustomFormat;
        /*0x23*/ bool _specifierIsUpper;
        /*0x24*/ bool _positive;
        /*0x26*/ char _specifier;
        /*0x28*/ int _precision;
        /*0x2c*/ int _defPrecision;
        /*0x30*/ int _digitsLen;
        /*0x34*/ int _offset;
        /*0x38*/ int _decPointPos;
        /*0x3c*/ uint _val1;
        /*0x40*/ uint _val2;
        /*0x44*/ uint _val3;
        /*0x48*/ uint _val4;
        /*0x4c*/ int _ind;

        static /*0x1efe5c8*/ NumberFormatter();
        static /*0x1efe5c4*/ void GetFormatterTables(ref ulong* MantissaBitsTable, ref int* TensExponentTable, ref char* DigitLowerTable, ref char* DigitUpperTable, ref long* TenPowersList, ref int* DecHexDigits);
        static /*0x1efe620*/ long GetTenPowerOf(int i);
        static /*0x1efe728*/ uint FastToDecHex(int val);
        static /*0x1efe7d0*/ uint ToDecHex(int val);
        static /*0x1efeb18*/ int FastDecHexLen(int val);
        static /*0x1efeb40*/ int DecHexLen(uint val);
        static /*0x1efeccc*/ int ScaleOrder(long hi);
        static /*0x1efee0c*/ int ParsePrecision(string format);
        static /*0x1effd70*/ uint AddOneToDecHex(uint val);
        static /*0x1effe14*/ int CountTrailingZeros(uint val);
        static /*0x1effe60*/ System.NumberFormatter GetInstance(System.IFormatProvider fp);
        static /*0x1f00038*/ string NumberToString(string format, uint value, System.IFormatProvider fp);
        static /*0x1f0028c*/ string NumberToString(string format, int value, System.IFormatProvider fp);
        static /*0x1f00330*/ string NumberToString(string format, ulong value, System.IFormatProvider fp);
        static /*0x1f003d0*/ string NumberToString(string format, long value, System.IFormatProvider fp);
        static /*0x1f00470*/ string NumberToString(string format, float value, System.IFormatProvider fp);
        static /*0x1f00744*/ string NumberToString(string format, double value, System.IFormatProvider fp);
        static /*0x1f0090c*/ string NumberToString(string format, decimal value, System.IFormatProvider fp);
        static /*0x1f02328*/ void ZeroTrimEnd(System.Text.StringBuilder sb, bool canEmpty);
        static /*0x1f02248*/ bool IsZeroOnly(System.Text.StringBuilder sb);
        static /*0x1f020ac*/ void AppendNonNegativeNumber(System.Text.StringBuilder sb, int v);
        /*0x1efee98*/ NumberFormatter(System.Threading.Thread current);
        /*0x1efe680*/ void InitDecHexDigits(uint value);
        /*0x1efe874*/ void InitDecHexDigits(ulong value);
        /*0x1efe968*/ void InitDecHexDigits(uint hi, ulong lo);
        /*0x1efebe8*/ int DecHexLen();
        /*0x1efed50*/ int InitialFloatingPrecision();
        /*0x1efef88*/ void Init(string format);
        /*0x1eff098*/ void InitHex(ulong value);
        /*0x1eff0dc*/ void Init(string format, int value, int defPrecision);
        /*0x1eff174*/ void Init(string format, uint value, int defPrecision);
        /*0x1eff1f0*/ void Init(string format, long value);
        /*0x1eff278*/ void Init(string format, ulong value);
        /*0x1eff2f8*/ void Init(string format, double value, int defPrecision);
        /*0x1eff674*/ void Init(string format, decimal value);
        /*0x1eff7b0*/ void ResetCharBuf(int size);
        /*0x1eff820*/ void Resize(int len);
        /*0x1eff878*/ void Append(char c);
        /*0x1eff8f0*/ void Append(char c, int cnt);
        /*0x1eff994*/ void Append(string s);
        /*0x1effa48*/ System.Globalization.NumberFormatInfo GetNumberFormatInstance(System.IFormatProvider fp);
        /*0x1efef48*/ void set_CurrentCulture(System.Globalization.CultureInfo value);
        /*0x1effa64*/ int get_IntegerDigits();
        /*0x1effa74*/ int get_DecimalDigits();
        /*0x1effa88*/ bool get_IsFloatingSource();
        /*0x1effa9c*/ bool get_IsZero();
        /*0x1effaac*/ bool get_IsZeroInteger();
        /*0x1effacc*/ void RoundPos(int pos);
        /*0x1effc30*/ bool RoundDecimal(int decimals);
        /*0x1effad8*/ bool RoundBits(int shift);
        /*0x1effd38*/ void RemoveTrailingZeros();
        /*0x1effc44*/ void AddOneToDecHex();
        /*0x1eff590*/ int CountTrailingZeros();
        /*0x1efffa8*/ void Release();
        /*0x1f000dc*/ string IntegerToString(string format, System.IFormatProvider fp);
        /*0x1f00618*/ string NumberToString(string format, System.Globalization.NumberFormatInfo nfi);
        /*0x1f009d4*/ string FormatCurrency(int precision, System.Globalization.NumberFormatInfo nfi);
        /*0x1f00c38*/ string FormatDecimal(int precision, System.Globalization.NumberFormatInfo nfi);
        /*0x1f0122c*/ string FormatHexadecimal(int precision);
        /*0x1f00d40*/ string FormatFixedPoint(int precision, System.Globalization.NumberFormatInfo nfi);
        /*0x1f0085c*/ string FormatRoundtrip(double origval, System.Globalization.NumberFormatInfo nfi);
        /*0x1f00588*/ string FormatRoundtrip(float origval, System.Globalization.NumberFormatInfo nfi);
        /*0x1f00e1c*/ string FormatGeneral(int precision, System.Globalization.NumberFormatInfo nfi);
        /*0x1f00f68*/ string FormatNumber(int precision, System.Globalization.NumberFormatInfo nfi);
        /*0x1f010d0*/ string FormatPercent(int precision, System.Globalization.NumberFormatInfo nfi);
        /*0x1f00cf8*/ string FormatExponential(int precision, System.Globalization.NumberFormatInfo nfi);
        /*0x1f01d90*/ string FormatExponential(int precision, System.Globalization.NumberFormatInfo nfi, int expDigits);
        /*0x1f01360*/ string FormatCustom(string format, System.Globalization.NumberFormatInfo nfi);
        /*0x1f021a8*/ void AppendIntegerString(int minLength, System.Text.StringBuilder sb);
        /*0x1f01cd4*/ void AppendIntegerString(int minLength);
        /*0x1f02228*/ void AppendDecimalString(int precision, System.Text.StringBuilder sb);
        /*0x1f01aa0*/ void AppendDecimalString(int precision);
        /*0x1f01880*/ void AppendIntegerStringWithGroupSeparator(int[] groups, string groupSeparator);
        /*0x1f01f4c*/ void AppendExponent(System.Globalization.NumberFormatInfo nfi, int exponent, int minDigits);
        /*0x1f01e7c*/ void AppendOneDigit(int start);
        /*0x1f01ab8*/ void AppendDigits(int start, int end);
        /*0x1f023f8*/ void AppendDigits(int start, int end, System.Text.StringBuilder sb);
        /*0x1f01e5c*/ void Multiply10(int count);
        /*0x1f0208c*/ void Divide10(int count);
        /*0x1f01d2c*/ System.NumberFormatter GetClone();

        class CustomInfo
        {
            /*0x10*/ bool UseGroup;
            /*0x14*/ int DecimalDigits;
            /*0x18*/ int DecimalPointPos;
            /*0x1c*/ int DecimalTailSharpDigits;
            /*0x20*/ int IntegerDigits;
            /*0x24*/ int IntegerHeadSharpDigits;
            /*0x28*/ int IntegerHeadPos;
            /*0x2c*/ bool UseExponent;
            /*0x30*/ int ExponentDigits;
            /*0x34*/ int ExponentTailSharpDigits;
            /*0x38*/ bool ExponentNegativeSignOnly;
            /*0x3c*/ int DividePlaces;
            /*0x40*/ int Percents;
            /*0x44*/ int Permilles;

            static /*0x1f03630*/ void GetActiveSection(string format, ref bool positive, bool zero, ref int offset, ref int length);
            static /*0x1f038fc*/ System.NumberFormatter.CustomInfo Parse(string format, int offset, int length, System.Globalization.NumberFormatInfo nfi);
            /*0x1f03d2c*/ CustomInfo();
            /*0x1f03d40*/ string Format(string format, int offset, int length, System.Globalization.NumberFormatInfo nfi, bool positive, System.Text.StringBuilder sb_int, System.Text.StringBuilder sb_dec, System.Text.StringBuilder sb_exp);
        }
    }

    class Object
    {
        static /*0x1f044c8*/ bool Equals(object objA, object objB);
        static /*0x1f04528*/ bool ReferenceEquals(object objA, object objB);
        static /*0x1f044fc*/ int InternalGetHashCode(object o);
        /*0x1f044b8*/ Object();
        /*0x1f044bc*/ bool Equals(object obj);
        /*0x1f044f4*/ void Finalize();
        /*0x1f044f8*/ int GetHashCode();
        /*0x1f04500*/ System.Type GetType();
        /*0x1f04504*/ object MemberwiseClone();
        /*0x1f04508*/ string ToString();
        /*0x1f04534*/ void FieldGetter(string typeName, string fieldName, ref object val);
        /*0x1f04538*/ void FieldSetter(string typeName, string fieldName, object val);
    }

    enum PlatformID
    {
        Win32S = 0,
        Win32Windows = 1,
        Win32NT = 2,
        WinCE = 3,
        Unix = 4,
        Xbox = 5,
        MacOSX = 6,
    }

    struct RuntimeArgumentHandle
    {
        /*0x10*/ nint args;
    }

    struct RuntimeFieldHandle : System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ nint value;

        static /*0x1f04a34*/ bool op_Equality(System.RuntimeFieldHandle left, System.RuntimeFieldHandle right);
        static /*0x1f04a3c*/ bool op_Inequality(System.RuntimeFieldHandle left, System.RuntimeFieldHandle right);
        static /*0x1f04a58*/ void SetValueInternal(System.Reflection.FieldInfo fi, object obj, object value);
        static /*0x1f04a5c*/ void SetValue(System.Reflection.RuntimeFieldInfo field, object obj, object value, System.RuntimeType fieldType, System.Reflection.FieldAttributes fieldAttr, System.RuntimeType declaringType, ref bool domainInitialized);
        static /*0x1f04a60*/ object GetValueDirect(System.Reflection.RuntimeFieldInfo field, System.RuntimeType fieldType, void* pTypedRef, System.RuntimeType contextType);
        static /*0x1f04a64*/ void SetValueDirect(System.Reflection.RuntimeFieldInfo field, System.RuntimeType fieldType, void* pTypedRef, object value, System.RuntimeType contextType);
        /*0x1f0453c*/ RuntimeFieldHandle(nint v);
        /*0x1f04544*/ RuntimeFieldHandle(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1f046fc*/ nint get_Value();
        /*0x1f04704*/ bool IsNullHandle();
        /*0x1f04758*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1f0491c*/ bool Equals(object obj);
        /*0x1f04a20*/ bool Equals(System.RuntimeFieldHandle handle);
        /*0x1f04a2c*/ int GetHashCode();
    }

    struct RuntimeMethodHandle : System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ nint value;

        static /*0x1f04df4*/ nint GetFunctionPointer(nint m);
        static /*0x1f04f18*/ bool op_Equality(System.RuntimeMethodHandle left, System.RuntimeMethodHandle right);
        static /*0x1f04f20*/ bool op_Inequality(System.RuntimeMethodHandle left, System.RuntimeMethodHandle right);
        static /*0x1f04f3c*/ string ConstructInstantiation(System.Reflection.RuntimeMethodInfo method, System.TypeNameFormatFlags format);
        /*0x1f04a68*/ RuntimeMethodHandle(nint v);
        /*0x1f04a70*/ RuntimeMethodHandle(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1f04c28*/ nint get_Value();
        /*0x1f04c30*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1f04df8*/ nint GetFunctionPointer();
        /*0x1f04e00*/ bool Equals(object obj);
        /*0x1f04f04*/ bool Equals(System.RuntimeMethodHandle handle);
        /*0x1f04f10*/ int GetHashCode();
        /*0x1f05098*/ bool IsNullHandle();
    }

    struct RuntimeTypeHandle : System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ nint value;

        static /*0x1f055b0*/ bool op_Equality(System.RuntimeTypeHandle left, object right);
        static /*0x1f0562c*/ bool op_Inequality(System.RuntimeTypeHandle left, object right);
        static /*0x1f056ac*/ bool op_Equality(object left, System.RuntimeTypeHandle right);
        static /*0x1f05728*/ bool op_Inequality(object left, System.RuntimeTypeHandle right);
        static /*0x1f057a8*/ System.Reflection.TypeAttributes GetAttributes(System.RuntimeType type);
        static /*0x1f058a8*/ int GetMetadataToken(System.RuntimeType type);
        static /*0x1f058ac*/ int GetToken(System.RuntimeType type);
        static /*0x1f058b0*/ System.Type GetGenericTypeDefinition_impl(System.RuntimeType type);
        static /*0x1f058b4*/ System.Type GetGenericTypeDefinition(System.RuntimeType type);
        static /*0x1f058b8*/ bool HasProxyAttribute(System.RuntimeType type);
        static /*0x1f05908*/ bool IsPrimitive(System.RuntimeType type);
        static /*0x1f05948*/ bool IsByRef(System.RuntimeType type);
        static /*0x1f05964*/ bool IsPointer(System.RuntimeType type);
        static /*0x1f05980*/ bool IsArray(System.RuntimeType type);
        static /*0x1f059a8*/ bool IsSzArray(System.RuntimeType type);
        static /*0x1f059c4*/ bool HasElementType(System.RuntimeType type);
        static /*0x1f05944*/ System.Reflection.CorElementType GetCorElementType(System.RuntimeType type);
        static /*0x1f05a00*/ bool HasInstantiation(System.RuntimeType type);
        static /*0x1f05a04*/ bool IsComObject(System.RuntimeType type);
        static /*0x1f05a08*/ bool IsInstanceOfType(System.RuntimeType type, object o);
        static /*0x1f05a0c*/ bool HasReferences(System.RuntimeType type);
        static /*0x1f05a10*/ bool IsComObject(System.RuntimeType type, bool isGenericCOM);
        static /*0x1f05a20*/ bool IsContextful(System.RuntimeType type);
        static /*0x1f05ab4*/ bool IsEquivalentTo(System.RuntimeType rtType1, System.RuntimeType rtType2);
        static /*0x1f05abc*/ bool IsInterface(System.RuntimeType type);
        static /*0x1f05adc*/ int GetArrayRank(System.RuntimeType type);
        static /*0x1f05ae0*/ System.Reflection.RuntimeAssembly GetAssembly(System.RuntimeType type);
        static /*0x1f05ae4*/ System.RuntimeType GetElementType(System.RuntimeType type);
        static /*0x1f05ae8*/ System.Reflection.RuntimeModule GetModule(System.RuntimeType type);
        static /*0x1f05aec*/ bool IsGenericVariable(System.RuntimeType type);
        static /*0x1f05af0*/ System.RuntimeType GetBaseType(System.RuntimeType type);
        static /*0x1f05af4*/ bool CanCastTo(System.RuntimeType type, System.RuntimeType target);
        static /*0x1f05b04*/ bool type_is_assignable_from(System.Type a, System.Type b);
        static /*0x1f05b08*/ bool IsGenericTypeDefinition(System.RuntimeType type);
        static /*0x1f05b0c*/ nint GetGenericParameterInfo(System.RuntimeType type);
        static /*0x1f05b10*/ bool IsSubclassOf(System.RuntimeType childType, System.RuntimeType baseType);
        static /*0x1f05b30*/ bool is_subclass_of(nint childType, nint baseType);
        static /*0x1f05b34*/ bool IsByRefLike(System.RuntimeType type);
        static /*0x1f05b38*/ bool IsTypeDefinition(System.RuntimeType type);
        static /*0x1f05b98*/ System.RuntimeType internal_from_name(string name, ref System.Threading.StackCrawlMark stackMark, System.Reflection.Assembly callerAssembly, bool throwOnError, bool ignoreCase, bool reflectionOnly);
        static /*0x1f05ba8*/ System.RuntimeType GetTypeByName(string typeName, bool throwOnError, bool ignoreCase, bool reflectionOnly, ref System.Threading.StackCrawlMark stackMark, bool loadTypeFromPartialName);
        static /*0x1f05f18*/ nint[] CopyRuntimeTypeHandles(System.RuntimeTypeHandle[] inHandles, ref int length);
        /*0x1f050ec*/ RuntimeTypeHandle(nint val);
        /*0x1f050f4*/ RuntimeTypeHandle(System.RuntimeType type);
        /*0x1f05110*/ RuntimeTypeHandle(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1f052c8*/ nint get_Value();
        /*0x1f052d0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1f05498*/ bool Equals(object obj);
        /*0x1f0559c*/ bool Equals(System.RuntimeTypeHandle handle);
        /*0x1f055a8*/ int GetHashCode();
        /*0x1f057ac*/ System.ModuleHandle GetModuleHandle();
    }

    enum TermInfoBooleans
    {
        AutoLeftMargin = 0,
        AutoRightMargin = 1,
        NoEscCtlc = 2,
        CeolStandoutGlitch = 3,
        EatNewlineGlitch = 4,
        EraseOverstrike = 5,
        GenericType = 6,
        HardCopy = 7,
        HasMetaKey = 8,
        HasStatusLine = 9,
        InsertNullGlitch = 10,
        MemoryAbove = 11,
        MemoryBelow = 12,
        MoveInsertMode = 13,
        MoveStandoutMode = 14,
        OverStrike = 15,
        StatusLineEscOk = 16,
        DestTabsMagicSmso = 17,
        TildeGlitch = 18,
        TransparentUnderline = 19,
        XonXoff = 20,
        NeedsXonXoff = 21,
        PrtrSilent = 22,
        HardCursor = 23,
        NonRevRmcup = 24,
        NoPadChar = 25,
        NonDestScrollRegion = 26,
        CanChange = 27,
        BackColorErase = 28,
        HueLightnessSaturation = 29,
        ColAddrGlitch = 30,
        CrCancelsMicroMode = 31,
        HasPrintWheel = 32,
        RowAddrGlitch = 33,
        SemiAutoRightMargin = 34,
        CpiChangesRes = 35,
        LpiChangesRes = 36,
        Last = 37,
    }

    class TermInfoDriver : System.IConsoleDriver
    {
        static /*0x0*/ int* native_terminal_size;
        static /*0x8*/ int terminal_size;
        static /*0x10*/ string[] locations;
        static /*0x18*/ int[] _consoleColorToAnsiCode;
        /*0x10*/ System.TermInfoReader reader;
        /*0x18*/ int cursorLeft;
        /*0x1c*/ int cursorTop;
        /*0x20*/ string title;
        /*0x28*/ string titleFormat;
        /*0x30*/ bool cursorVisible;
        /*0x38*/ string csrVisible;
        /*0x40*/ string csrInvisible;
        /*0x48*/ string clear;
        /*0x50*/ string bell;
        /*0x58*/ string term;
        /*0x60*/ System.IO.StreamReader stdin;
        /*0x68*/ System.IO.CStreamWriter stdout;
        /*0x70*/ int windowWidth;
        /*0x74*/ int windowHeight;
        /*0x78*/ int bufferHeight;
        /*0x7c*/ int bufferWidth;
        /*0x80*/ char[] buffer;
        /*0x88*/ int readpos;
        /*0x8c*/ int writepos;
        /*0x90*/ string keypadXmit;
        /*0x98*/ string keypadLocal;
        /*0xa0*/ bool controlCAsInput;
        /*0xa1*/ bool inited;
        /*0xa8*/ object initLock;
        /*0xb0*/ bool initKeys;
        /*0xb8*/ string origPair;
        /*0xc0*/ string origColors;
        /*0xc8*/ string cursorAddress;
        /*0xd0*/ System.ConsoleColor fgcolor;
        /*0xd4*/ System.ConsoleColor bgcolor;
        /*0xd8*/ string setfgcolor;
        /*0xe0*/ string setbgcolor;
        /*0xe8*/ int maxColors;
        /*0xec*/ bool noGetPosition;
        /*0xf0*/ System.Collections.Hashtable keymap;
        /*0xf8*/ System.ByteMatcher rootmap;
        /*0x100*/ int rl_startx;
        /*0x104*/ int rl_starty;
        /*0x108*/ byte[] control_characters;
        /*0x110*/ char[] echobuf;
        /*0x118*/ int echon;

        static /*0x1f0bb48*/ TermInfoDriver();
        static /*0x1f05fe0*/ string TryTermInfoDir(string dir, string term);
        static /*0x1f0610c*/ string SearchTerminfo(string term);
        /*0x1f062a4*/ TermInfoDriver();
        /*0x1f062f8*/ TermInfoDriver(string term);
        /*0x1f0627c*/ void WriteConsole(string str);
        /*0x1f069b8*/ bool get_Initialized();
        /*0x1f069c0*/ void Init();
        /*0x1f075c0*/ void IncrementX();
        /*0x1f07684*/ void WriteSpecialKey(System.ConsoleKeyInfo key);
        /*0x1f07948*/ void WriteSpecialKey(char c);
        /*0x1f07af4*/ bool IsSpecialKey(System.ConsoleKeyInfo key);
        /*0x1f07b78*/ bool IsSpecialKey(char c);
        /*0x1f07ba0*/ void ChangeColor(string format, System.ConsoleColor color);
        /*0x1f07e68*/ System.ConsoleColor get_BackgroundColor();
        /*0x1f07e8c*/ void set_BackgroundColor(System.ConsoleColor value);
        /*0x1f07ecc*/ System.ConsoleColor get_ForegroundColor();
        /*0x1f07ef0*/ void set_ForegroundColor(System.ConsoleColor value);
        /*0x1f07324*/ void GetCursorPosition();
        /*0x1f08014*/ int get_BufferHeight();
        /*0x1f08160*/ void set_BufferHeight(int value);
        /*0x1f081ac*/ int get_BufferWidth();
        /*0x1f081d8*/ void set_BufferWidth(int value);
        /*0x1f08224*/ bool get_CapsLock();
        /*0x1f08240*/ int get_CursorLeft();
        /*0x1f08264*/ void set_CursorLeft(int value);
        /*0x1f082ac*/ int get_CursorTop();
        /*0x1f082d0*/ void set_CursorTop(int value);
        /*0x1f08318*/ bool get_CursorVisible();
        /*0x1f0833c*/ void set_CursorVisible(bool value);
        /*0x1f08388*/ int get_CursorSize();
        /*0x1f083a4*/ void set_CursorSize(int value);
        /*0x1f083b4*/ bool get_KeyAvailable();
        /*0x1f0843c*/ int get_LargestWindowHeight();
        /*0x1f08440*/ int get_LargestWindowWidth();
        /*0x1f08444*/ bool get_NumberLock();
        /*0x1f08460*/ string get_Title();
        /*0x1f08484*/ void set_Title(string value);
        /*0x1f084cc*/ bool get_TreatControlCAsInput();
        /*0x1f084f0*/ void set_TreatControlCAsInput(bool value);
        /*0x1f08040*/ void CheckWindowDimensions();
        /*0x1f07658*/ int get_WindowHeight();
        /*0x1f08578*/ void set_WindowHeight(int value);
        /*0x1f085c4*/ int get_WindowLeft();
        /*0x1f085e0*/ void set_WindowLeft(int value);
        /*0x1f0862c*/ int get_WindowTop();
        /*0x1f08648*/ void set_WindowTop(int value);
        /*0x1f0762c*/ int get_WindowWidth();
        /*0x1f08694*/ void set_WindowWidth(int value);
        /*0x1f086e0*/ void Clear();
        /*0x1f08710*/ void Beep(int frequency, int duration);
        /*0x1f08738*/ void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, System.ConsoleColor sourceForeColor, System.ConsoleColor sourceBackColor);
        /*0x1f07f30*/ void AddToBuffer(int b);
        /*0x1f08784*/ void AdjustBuffer();
        /*0x1f07970*/ System.ConsoleKeyInfo CreateKeyInfoFromInt(int n, bool alt);
        /*0x1f08798*/ object GetKeyFromBuffer(bool cooked);
        /*0x1f08f78*/ System.ConsoleKeyInfo ReadKeyInternal(ref bool fresh);
        /*0x1f092ac*/ bool InputPending();
        /*0x1f092e0*/ void QueueEcho(char c);
        /*0x1f093a8*/ void Echo(System.ConsoleKeyInfo key);
        /*0x1f093fc*/ void EchoFlush();
        /*0x1f09430*/ int Read(char[] dest, int index, int count);
        /*0x1f09734*/ System.ConsoleKeyInfo ReadKey(bool intercept);
        /*0x1f09798*/ string ReadLine();
        /*0x1f09968*/ string ReadToEnd();
        /*0x1f097a0*/ string ReadUntilConditionInternal(bool haltOnNewLine);
        /*0x1f09970*/ void ResetColor();
        /*0x1f099ac*/ void SetBufferSize(int width, int height);
        /*0x1f07798*/ void SetCursorPosition(int left, int top);
        /*0x1f09a14*/ void SetWindowPosition(int left, int top);
        /*0x1f09a24*/ void SetWindowSize(int width, int height);
        /*0x1f09a34*/ void CreateKeyMap();
        /*0x1f09140*/ void InitKeys();
        /*0x1f0b948*/ void AddStringMapping(System.TermInfoStrings s);
    }

    class ParameterizedStrings
    {
        [ThreadStatic] static System.ParameterizedStrings.LowLevelStack _cachedStack;

        static /*0x1f07cfc*/ string Evaluate(string format, System.ParameterizedStrings.FormatParam[] args);
        static /*0x1f0bd90*/ string EvaluateInternal(string format, ref int pos, System.ParameterizedStrings.FormatParam[] args, System.ParameterizedStrings.LowLevelStack stack, ref System.ParameterizedStrings.FormatParam[] dynamicVars, ref System.ParameterizedStrings.FormatParam[] staticVars);
        static /*0x1f0cb74*/ bool AsBool(int i);
        static /*0x1f0cb6c*/ int AsInt(bool b);
        static /*0x1f0cb80*/ string StringFromAsciiBytes(byte[] buffer, int offset, int length);
        static /*0x1f0cc78*/ int snprintf(byte* str, nint size, string format, string arg1);
        static /*0x1f0cd44*/ int snprintf(byte* str, nint size, string format, int arg1);
        static /*0x1f0c730*/ string FormatPrintF(string format, object arg);
        static /*0x1f0ca64*/ System.ParameterizedStrings.FormatParam[] GetDynamicOrStaticVariables(char c, ref System.ParameterizedStrings.FormatParam[] dynamicVars, ref System.ParameterizedStrings.FormatParam[] staticVars, ref int index);

        struct FormatParam
        {
            /*0x10*/ int _int32;
            /*0x18*/ string _string;

            static /*0x1f07cf0*/ System.ParameterizedStrings.FormatParam op_Implicit(int value);
            /*0x1f0cdfc*/ FormatParam(int value);
            /*0x1f0ce08*/ FormatParam(int intValue, string stringValue);
            /*0x1f0ce14*/ int get_Int32();
            /*0x1f0c680*/ string get_String();
            /*0x1f0c6d4*/ object get_Object();
        }

        class LowLevelStack
        {
            /*0x10*/ System.ParameterizedStrings.FormatParam[] _arr;
            /*0x18*/ int _count;

            /*0x1f0bd18*/ LowLevelStack();
            /*0x1f0c5ec*/ System.ParameterizedStrings.FormatParam Pop();
            /*0x1f0c98c*/ void Push(System.ParameterizedStrings.FormatParam item);
            /*0x1f0bd68*/ void Clear();
        }
    }

    class ByteMatcher
    {
        /*0x10*/ System.Collections.Hashtable map;
        /*0x18*/ System.Collections.Hashtable starts;

        /*0x1f0b8cc*/ ByteMatcher();
        /*0x1f0b994*/ void AddMapping(System.TermInfoStrings key, byte[] val);
        /*0x1f0bab4*/ void Sort();
        /*0x1f08a64*/ bool StartsWith(int c);
        /*0x1f08aec*/ System.TermInfoStrings Match(char[] buffer, int offset, int length, ref int used);
    }

    enum TermInfoNumbers
    {
        Columns = 0,
        InitTabs = 1,
        Lines = 2,
        LinesOfMemory = 3,
        MagicCookieGlitch = 4,
        PaddingBaudRate = 5,
        VirtualTerminal = 6,
        WidthStatusLine = 7,
        NumLabels = 8,
        LabelHeight = 9,
        LabelWidth = 10,
        MaxAttributes = 11,
        MaximumWindows = 12,
        MaxColors = 13,
        MaxPairs = 14,
        NoColorVideo = 15,
        BufferCapacity = 16,
        DotVertSpacing = 17,
        DotHorzSpacing = 18,
        MaxMicroAddress = 19,
        MaxMicroJump = 20,
        MicroColSize = 21,
        MicroLineSize = 22,
        NumberOfPins = 23,
        OutputResChar = 24,
        OutputResLine = 25,
        OutputResHorzInch = 26,
        OutputResVertInch = 27,
        PrintRate = 28,
        WideCharSize = 29,
        Buttons = 30,
        BitImageEntwining = 31,
        BitImageType = 32,
        Last = 33,
    }

    class TermInfoReader
    {
        /*0x10*/ int boolSize;
        /*0x14*/ int numSize;
        /*0x18*/ int strOffsets;
        /*0x20*/ byte[] buffer;
        /*0x28*/ int booleansOffset;
        /*0x2c*/ int intOffset;

        static /*0x1f0d1a0*/ string Escape(string s);
        /*0x1f06650*/ TermInfoReader(string term, string filename);
        /*0x1f0692c*/ TermInfoReader(string term, byte[] buffer);
        /*0x1f0cf10*/ void DetermineVersion(short magic);
        /*0x1f0ce1c*/ void ReadHeader(byte[] buffer, ref int position);
        /*0x1f0cedc*/ void ReadNames(byte[] buffer, ref int position);
        /*0x1f0d08c*/ bool Get(System.TermInfoBooleans boolean);
        /*0x1f072c4*/ int Get(System.TermInfoNumbers number);
        /*0x1f07234*/ string Get(System.TermInfoStrings tstr);
        /*0x1f0bab8*/ byte[] GetStringBytes(System.TermInfoStrings tstr);
        /*0x1f0cfc0*/ short GetInt16(byte[] buffer, int offset);
        /*0x1f0d010*/ string GetString(byte[] buffer, int offset);
        /*0x1f0d0e8*/ byte[] GetStringBytes(byte[] buffer, int offset);
    }

    enum TermInfoStrings
    {
        BackTab = 0,
        Bell = 1,
        CarriageReturn = 2,
        ChangeScrollRegion = 3,
        ClearAllTabs = 4,
        ClearScreen = 5,
        ClrEol = 6,
        ClrEos = 7,
        ColumnAddress = 8,
        CommandCharacter = 9,
        CursorAddress = 10,
        CursorDown = 11,
        CursorHome = 12,
        CursorInvisible = 13,
        CursorLeft = 14,
        CursorMemAddress = 15,
        CursorNormal = 16,
        CursorRight = 17,
        CursorToLl = 18,
        CursorUp = 19,
        CursorVisible = 20,
        DeleteCharacter = 21,
        DeleteLine = 22,
        DisStatusLine = 23,
        DownHalfLine = 24,
        EnterAltCharsetMode = 25,
        EnterBlinkMode = 26,
        EnterBoldMode = 27,
        EnterCaMode = 28,
        EnterDeleteMode = 29,
        EnterDimMode = 30,
        EnterInsertMode = 31,
        EnterSecureMode = 32,
        EnterProtectedMode = 33,
        EnterReverseMode = 34,
        EnterStandoutMode = 35,
        EnterUnderlineMode = 36,
        EraseChars = 37,
        ExitAltCharsetMode = 38,
        ExitAttributeMode = 39,
        ExitCaMode = 40,
        ExitDeleteMode = 41,
        ExitInsertMode = 42,
        ExitStandoutMode = 43,
        ExitUnderlineMode = 44,
        FlashScreen = 45,
        FormFeed = 46,
        FromStatusLine = 47,
        Init1string = 48,
        Init2string = 49,
        Init3string = 50,
        InitFile = 51,
        InsertCharacter = 52,
        InsertLine = 53,
        InsertPadding = 54,
        KeyBackspace = 55,
        KeyCatab = 56,
        KeyClear = 57,
        KeyCtab = 58,
        KeyDc = 59,
        KeyDl = 60,
        KeyDown = 61,
        KeyEic = 62,
        KeyEol = 63,
        KeyEos = 64,
        KeyF0 = 65,
        KeyF1 = 66,
        KeyF10 = 67,
        KeyF2 = 68,
        KeyF3 = 69,
        KeyF4 = 70,
        KeyF5 = 71,
        KeyF6 = 72,
        KeyF7 = 73,
        KeyF8 = 74,
        KeyF9 = 75,
        KeyHome = 76,
        KeyIc = 77,
        KeyIl = 78,
        KeyLeft = 79,
        KeyLl = 80,
        KeyNpage = 81,
        KeyPpage = 82,
        KeyRight = 83,
        KeySf = 84,
        KeySr = 85,
        KeyStab = 86,
        KeyUp = 87,
        KeypadLocal = 88,
        KeypadXmit = 89,
        LabF0 = 90,
        LabF1 = 91,
        LabF10 = 92,
        LabF2 = 93,
        LabF3 = 94,
        LabF4 = 95,
        LabF5 = 96,
        LabF6 = 97,
        LabF7 = 98,
        LabF8 = 99,
        LabF9 = 100,
        MetaOff = 101,
        MetaOn = 102,
        Newline = 103,
        PadChar = 104,
        ParmDch = 105,
        ParmDeleteLine = 106,
        ParmDownCursor = 107,
        ParmIch = 108,
        ParmIndex = 109,
        ParmInsertLine = 110,
        ParmLeftCursor = 111,
        ParmRightCursor = 112,
        ParmRindex = 113,
        ParmUpCursor = 114,
        PkeyKey = 115,
        PkeyLocal = 116,
        PkeyXmit = 117,
        PrintScreen = 118,
        PrtrOff = 119,
        PrtrOn = 120,
        RepeatChar = 121,
        Reset1string = 122,
        Reset2string = 123,
        Reset3string = 124,
        ResetFile = 125,
        RestoreCursor = 126,
        RowAddress = 127,
        SaveCursor = 128,
        ScrollForward = 129,
        ScrollReverse = 130,
        SetAttributes = 131,
        SetTab = 132,
        SetWindow = 133,
        Tab = 134,
        ToStatusLine = 135,
        UnderlineChar = 136,
        UpHalfLine = 137,
        InitProg = 138,
        KeyA1 = 139,
        KeyA3 = 140,
        KeyB2 = 141,
        KeyC1 = 142,
        KeyC3 = 143,
        PrtrNon = 144,
        CharPadding = 145,
        AcsChars = 146,
        PlabNorm = 147,
        KeyBtab = 148,
        EnterXonMode = 149,
        ExitXonMode = 150,
        EnterAmMode = 151,
        ExitAmMode = 152,
        XonCharacter = 153,
        XoffCharacter = 154,
        EnaAcs = 155,
        LabelOn = 156,
        LabelOff = 157,
        KeyBeg = 158,
        KeyCancel = 159,
        KeyClose = 160,
        KeyCommand = 161,
        KeyCopy = 162,
        KeyCreate = 163,
        KeyEnd = 164,
        KeyEnter = 165,
        KeyExit = 166,
        KeyFind = 167,
        KeyHelp = 168,
        KeyMark = 169,
        KeyMessage = 170,
        KeyMove = 171,
        KeyNext = 172,
        KeyOpen = 173,
        KeyOptions = 174,
        KeyPrevious = 175,
        KeyPrint = 176,
        KeyRedo = 177,
        KeyReference = 178,
        KeyRefresh = 179,
        KeyReplace = 180,
        KeyRestart = 181,
        KeyResume = 182,
        KeySave = 183,
        KeySuspend = 184,
        KeyUndo = 185,
        KeySbeg = 186,
        KeyScancel = 187,
        KeyScommand = 188,
        KeyScopy = 189,
        KeyScreate = 190,
        KeySdc = 191,
        KeySdl = 192,
        KeySelect = 193,
        KeySend = 194,
        KeySeol = 195,
        KeySexit = 196,
        KeySfind = 197,
        KeyShelp = 198,
        KeyShome = 199,
        KeySic = 200,
        KeySleft = 201,
        KeySmessage = 202,
        KeySmove = 203,
        KeySnext = 204,
        KeySoptions = 205,
        KeySprevious = 206,
        KeySprint = 207,
        KeySredo = 208,
        KeySreplace = 209,
        KeySright = 210,
        KeySrsume = 211,
        KeySsave = 212,
        KeySsuspend = 213,
        KeySundo = 214,
        ReqForInput = 215,
        KeyF11 = 216,
        KeyF12 = 217,
        KeyF13 = 218,
        KeyF14 = 219,
        KeyF15 = 220,
        KeyF16 = 221,
        KeyF17 = 222,
        KeyF18 = 223,
        KeyF19 = 224,
        KeyF20 = 225,
        KeyF21 = 226,
        KeyF22 = 227,
        KeyF23 = 228,
        KeyF24 = 229,
        KeyF25 = 230,
        KeyF26 = 231,
        KeyF27 = 232,
        KeyF28 = 233,
        KeyF29 = 234,
        KeyF30 = 235,
        KeyF31 = 236,
        KeyF32 = 237,
        KeyF33 = 238,
        KeyF34 = 239,
        KeyF35 = 240,
        KeyF36 = 241,
        KeyF37 = 242,
        KeyF38 = 243,
        KeyF39 = 244,
        KeyF40 = 245,
        KeyF41 = 246,
        KeyF42 = 247,
        KeyF43 = 248,
        KeyF44 = 249,
        KeyF45 = 250,
        KeyF46 = 251,
        KeyF47 = 252,
        KeyF48 = 253,
        KeyF49 = 254,
        KeyF50 = 255,
        KeyF51 = 256,
        KeyF52 = 257,
        KeyF53 = 258,
        KeyF54 = 259,
        KeyF55 = 260,
        KeyF56 = 261,
        KeyF57 = 262,
        KeyF58 = 263,
        KeyF59 = 264,
        KeyF60 = 265,
        KeyF61 = 266,
        KeyF62 = 267,
        KeyF63 = 268,
        ClrBol = 269,
        ClearMargins = 270,
        SetLeftMargin = 271,
        SetRightMargin = 272,
        LabelFormat = 273,
        SetClock = 274,
        DisplayClock = 275,
        RemoveClock = 276,
        CreateWindow = 277,
        GotoWindow = 278,
        Hangup = 279,
        DialPhone = 280,
        QuickDial = 281,
        Tone = 282,
        Pulse = 283,
        FlashHook = 284,
        FixedPause = 285,
        WaitTone = 286,
        User0 = 287,
        User1 = 288,
        User2 = 289,
        User3 = 290,
        User4 = 291,
        User5 = 292,
        User6 = 293,
        User7 = 294,
        User8 = 295,
        User9 = 296,
        OrigPair = 297,
        OrigColors = 298,
        InitializeColor = 299,
        InitializePair = 300,
        SetColorPair = 301,
        SetForeground = 302,
        SetBackground = 303,
        ChangeCharPitch = 304,
        ChangeLinePitch = 305,
        ChangeResHorz = 306,
        ChangeResVert = 307,
        DefineChar = 308,
        EnterDoublewideMode = 309,
        EnterDraftQuality = 310,
        EnterItalicsMode = 311,
        EnterLeftwardMode = 312,
        EnterMicroMode = 313,
        EnterNearLetterQuality = 314,
        EnterNormalQuality = 315,
        EnterShadowMode = 316,
        EnterSubscriptMode = 317,
        EnterSuperscriptMode = 318,
        EnterUpwardMode = 319,
        ExitDoublewideMode = 320,
        ExitItalicsMode = 321,
        ExitLeftwardMode = 322,
        ExitMicroMode = 323,
        ExitShadowMode = 324,
        ExitSubscriptMode = 325,
        ExitSuperscriptMode = 326,
        ExitUpwardMode = 327,
        MicroColumnAddress = 328,
        MicroDown = 329,
        MicroLeft = 330,
        MicroRight = 331,
        MicroRowAddress = 332,
        MicroUp = 333,
        OrderOfPins = 334,
        ParmDownMicro = 335,
        ParmLeftMicro = 336,
        ParmRightMicro = 337,
        ParmUpMicro = 338,
        SelectCharSet = 339,
        SetBottomMargin = 340,
        SetBottomMarginParm = 341,
        SetLeftMarginParm = 342,
        SetRightMarginParm = 343,
        SetTopMargin = 344,
        SetTopMarginParm = 345,
        StartBitImage = 346,
        StartCharSetDef = 347,
        StopBitImage = 348,
        StopCharSetDef = 349,
        SubscriptCharacters = 350,
        SuperscriptCharacters = 351,
        TheseCauseCr = 352,
        ZeroMotion = 353,
        CharSetNames = 354,
        KeyMouse = 355,
        MouseInfo = 356,
        ReqMousePos = 357,
        GetMouse = 358,
        SetAForeground = 359,
        SetABackground = 360,
        PkeyPlab = 361,
        DeviceType = 362,
        CodeSetInit = 363,
        Set0DesSeq = 364,
        Set1DesSeq = 365,
        Set2DesSeq = 366,
        Set3DesSeq = 367,
        SetLrMargin = 368,
        SetTbMargin = 369,
        BitImageRepeat = 370,
        BitImageNewline = 371,
        BitImageCarriageReturn = 372,
        ColorNames = 373,
        DefineBitImageRegion = 374,
        EndBitImageRegion = 375,
        SetColorBand = 376,
        SetPageLength = 377,
        DisplayPcChar = 378,
        EnterPcCharsetMode = 379,
        ExitPcCharsetMode = 380,
        EnterScancodeMode = 381,
        ExitScancodeMode = 382,
        PcTermOptions = 383,
        ScancodeEscape = 384,
        AltScancodeEsc = 385,
        EnterHorizontalHlMode = 386,
        EnterLeftHlMode = 387,
        EnterLowHlMode = 388,
        EnterRightHlMode = 389,
        EnterTopHlMode = 390,
        EnterVerticalHlMode = 391,
        SetAAttributes = 392,
        SetPglenInch = 393,
        Last = 394,
    }

    interface TypeName : System.IEquatable<System.TypeName>
    {
        string get_DisplayName();
        System.TypeName NestedName(System.TypeIdentifier innerName);
    }

    interface TypeIdentifier : System.TypeName, System.IEquatable<System.TypeName>
    {
        string get_InternalName();
    }

    class TypeNames
    {
        static /*0x1f0d2f8*/ System.TypeName FromDisplay(string displayName);
        /*0x1f0d354*/ TypeNames();

        class ATypeName : System.TypeName, System.IEquatable<System.TypeName>
        {
            /*0x1f0d4b0*/ ATypeName();
            string get_DisplayName();
            System.TypeName NestedName(System.TypeIdentifier innerName);
            /*0x1f0d358*/ bool Equals(System.TypeName other);
            /*0x1f0d428*/ int GetHashCode();
            /*0x1f0d450*/ bool Equals(object other);
        }

        class Display : System.TypeNames.ATypeName
        {
            /*0x10*/ string displayName;

            /*0x1f0d34c*/ Display(string displayName);
            /*0x1f0d4b4*/ string get_DisplayName();
            /*0x1f0d4bc*/ System.TypeName NestedName(System.TypeIdentifier innerName);
        }
    }

    class TypeIdentifiers
    {
        static /*0x1f0d5d0*/ System.TypeIdentifier FromDisplay(string displayName);
        static /*0x1f0d62c*/ System.TypeIdentifier FromInternal(string internalName);
        static /*0x1f0d688*/ System.TypeIdentifier FromInternal(string internalNameSpace, System.TypeIdentifier typeName);
        static /*0x1f0d7d4*/ System.TypeIdentifier WithoutEscape(string simpleName);
        /*0x1f0d830*/ TypeIdentifiers();

        class Display : System.TypeNames.ATypeName, System.TypeIdentifier, System.TypeName, System.IEquatable<System.TypeName>
        {
            /*0x10*/ string displayName;
            /*0x18*/ string internal_name;

            /*0x1f0d624*/ Display(string displayName);
            /*0x1f0d834*/ string get_DisplayName();
            /*0x1f0d83c*/ string get_InternalName();
            /*0x1f0d860*/ string GetInternalName();
            /*0x1f0d950*/ System.TypeName NestedName(System.TypeIdentifier innerName);
        }

        class Internal : System.TypeNames.ATypeName, System.TypeIdentifier, System.TypeName, System.IEquatable<System.TypeName>
        {
            /*0x10*/ string internalName;
            /*0x18*/ string display_name;

            /*0x1f0d680*/ Internal(string internalName);
            /*0x1f0d6f8*/ Internal(string nameSpaceInternal, System.TypeIdentifier typeName);
            /*0x1f0da30*/ string get_DisplayName();
            /*0x1f0da5c*/ string get_InternalName();
            /*0x1f0da54*/ string GetDisplayName();
            /*0x1f0db8c*/ System.TypeName NestedName(System.TypeIdentifier innerName);
        }

        class NoEscape : System.TypeNames.ATypeName, System.TypeIdentifier, System.TypeName, System.IEquatable<System.TypeName>
        {
            /*0x10*/ string simpleName;

            /*0x1f0d828*/ NoEscape(string simpleName);
            /*0x1f0dc6c*/ string get_DisplayName();
            /*0x1f0dc74*/ string get_InternalName();
            /*0x1f0dc7c*/ System.TypeName NestedName(System.TypeIdentifier innerName);
        }
    }

    interface ModifierSpec
    {
        System.Type Resolve(System.Type type);
        System.Text.StringBuilder Append(System.Text.StringBuilder sb);
    }

    class ArraySpec : System.ModifierSpec
    {
        /*0x10*/ int dimensions;
        /*0x14*/ bool bound;

        /*0x1f0dd5c*/ ArraySpec(int dimensions, bool bound);
        /*0x1f0dd6c*/ System.Type Resolve(System.Type type);
        /*0x1f0ddd0*/ System.Text.StringBuilder Append(System.Text.StringBuilder sb);
        /*0x1f0de70*/ string ToString();
        /*0x1f0dee4*/ int get_Rank();
        /*0x1f0deec*/ bool get_IsBound();
    }

    class PointerSpec : System.ModifierSpec
    {
        /*0x10*/ int pointer_level;

        /*0x1f0def4*/ PointerSpec(int pointer_level);
        /*0x1f0defc*/ System.Type Resolve(System.Type type);
        /*0x1f0df50*/ System.Text.StringBuilder Append(System.Text.StringBuilder sb);
        /*0x1f0df78*/ string ToString();
    }

    class TypeSpec
    {
        /*0x10*/ System.TypeIdentifier name;
        /*0x18*/ string assembly_name;
        /*0x20*/ System.Collections.Generic.List<System.TypeIdentifier> nested;
        /*0x28*/ System.Collections.Generic.List<System.TypeSpec> generic_params;
        /*0x30*/ System.Collections.Generic.List<System.ModifierSpec> modifier_spec;
        /*0x38*/ bool is_byref;
        /*0x40*/ string display_fullname;

        static /*0x1f0e850*/ System.TypeSpec Parse(string typeName);
        static /*0x1f0da64*/ string EscapeDisplayName(string internalName);
        static /*0x1f0d868*/ string UnescapeInternalName(string displayName);
        static /*0x1f0f494*/ bool NeedsEscaping(string internalName);
        static /*0x1f10044*/ void SkipSpace(string name, ref int pos);
        static /*0x1f100f4*/ void BoundCheck(int idx, string s);
        static /*0x1f0ff50*/ System.TypeIdentifier ParsedTypeIdentifier(string displayName);
        static /*0x1f0e928*/ System.TypeSpec Parse(string name, ref int p, bool is_recurse, bool allow_aqn);
        /*0x1f1017c*/ TypeSpec();
        /*0x1f0dfec*/ bool get_HasModifiers();
        /*0x1f0dffc*/ bool get_IsNested();
        /*0x1f0e050*/ bool get_IsByRef();
        /*0x1f0e058*/ System.TypeName get_Name();
        /*0x1f0e060*/ System.Collections.Generic.IEnumerable<System.TypeName> get_Nested();
        /*0x1f0e0e8*/ System.Collections.Generic.IEnumerable<System.ModifierSpec> get_Modifiers();
        /*0x1f0e170*/ string GetDisplayFullName(System.TypeSpec.DisplayNameFormat flags);
        /*0x1f0e7e0*/ string ModifierString();
        /*0x1f0e5ec*/ System.Text.StringBuilder GetModifierString(System.Text.StringBuilder sb);
        /*0x1f0e5c4*/ string get_DisplayFullName();
        /*0x1f0f534*/ System.Type Resolve(System.Func<System.Reflection.AssemblyName, System.Reflection.Assembly> assemblyResolver, System.Func<System.Reflection.Assembly, string, bool, System.Type> typeResolver, bool throwOnError, bool ignoreCase, ref System.Threading.StackCrawlMark stackMark);
        /*0x1f0fe40*/ void AddName(string type_name);
        /*0x1f0ff54*/ void AddModifier(System.ModifierSpec md);
        /*0x1f10180*/ System.TypeName TypeNameWithoutModifiers();
        /*0x1f101e8*/ System.TypeName get_TypeName();

        enum DisplayNameFormat
        {
            Default = 0,
            WANT_ASSEMBLY = 1,
            NO_MODIFIERS = 2,
        }

        class TypeSpecTypeName : System.TypeNames.ATypeName, System.TypeName, System.IEquatable<System.TypeName>
        {
            /*0x10*/ System.TypeSpec ts;
            /*0x18*/ bool want_modifiers;

            /*0x1f101d8*/ TypeSpecTypeName(System.TypeSpec ts, bool wantModifiers);
            /*0x1f10244*/ string get_DisplayName();
            /*0x1f1028c*/ System.TypeName NestedName(System.TypeIdentifier innerName);
        }
    }

    struct UIntPtr : System.Runtime.Serialization.ISerializable, System.IEquatable<nuint>
    {
        static /*0x0*/ nuint Zero;
        /*0x10*/ void* _pointer;

        static /*0x1f10774*/ UIntPtr();
        static /*0x1f10594*/ bool op_Equality(nuint value1, nuint value2);
        static /*0x1f105a0*/ bool op_Inequality(nuint value1, nuint value2);
        static /*0x1f105ac*/ ulong op_Explicit(nuint value);
        static /*0x1f105b0*/ uint op_Explicit(nuint value);
        static /*0x1f105b4*/ nuint op_Explicit(ulong value);
        static /*0x1f105d4*/ nuint op_Explicit(void* value);
        static /*0x1f105d8*/ void* op_Explicit(nuint value);
        static /*0x1f105dc*/ nuint op_Explicit(uint value);
        static /*0x1f103cc*/ int get_Size();
        static /*0x1f105e4*/ nuint Add(nuint pointer, int offset);
        static /*0x1f10644*/ nuint Subtract(nuint pointer, int offset);
        static /*0x1f106a4*/ nuint op_Addition(nuint pointer, int offset);
        static /*0x1f10704*/ nuint op_Subtraction(nuint pointer, int offset);
        /*0x1f1036c*/ UIntPtr(ulong value);
        /*0x1f103d4*/ UIntPtr(uint value);
        /*0x1f103e0*/ UIntPtr(void* value);
        /*0x1f103e8*/ bool Equals(object obj);
        /*0x1f10460*/ int GetHashCode();
        /*0x1f10468*/ uint ToUInt32();
        /*0x1f10470*/ ulong ToUInt64();
        /*0x1f10478*/ void* ToPointer();
        /*0x1f10480*/ string ToString();
        /*0x1f104f0*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1f10764*/ bool System.IEquatable<System.UIntPtr>.Equals(nuint other);
    }

    class ValueType
    {
        static /*0x1f1077c*/ bool InternalEquals(object o1, object o2, ref object[] fields);
        static /*0x1f10780*/ bool DefaultEquals(object o1, object o2);
        static /*0x1f1092c*/ int InternalGetHashCode(object o, ref object[] fields);
        static /*0x1f109a8*/ int GetHashCodeOfPtr(nint ptr);
        /*0x1f10778*/ ValueType();
        /*0x1f10928*/ bool Equals(object obj);
        /*0x1f10930*/ int GetHashCode();
        /*0x1f10a2c*/ string ToString();

        class Internal
        {
            static /*0x0*/ int hash_code_of_ptr_seed;
        }
    }

    struct Variant
    {
        /*0x10*/ short vt;
        /*0x12*/ ushort wReserved1;
        /*0x14*/ ushort wReserved2;
        /*0x16*/ ushort wReserved3;
        /*0x18*/ long llVal;
        /*0x18*/ int lVal;
        /*0x18*/ byte bVal;
        /*0x18*/ short iVal;
        /*0x18*/ float fltVal;
        /*0x18*/ double dblVal;
        /*0x18*/ short boolVal;
        /*0x18*/ nint bstrVal;
        /*0x18*/ sbyte cVal;
        /*0x18*/ ushort uiVal;
        /*0x18*/ uint ulVal;
        /*0x18*/ ulong ullVal;
        /*0x18*/ int intVal;
        /*0x18*/ uint uintVal;
        /*0x18*/ nint pdispVal;
        /*0x18*/ System.BRECORD bRecord;

        static /*0x1f111dc*/ object GetValueAt(int vt, nint addr);
        /*0x1f10a50*/ void SetValue(object obj);
        /*0x1f114e4*/ object GetValue();
        /*0x1f11724*/ void Clear();
    }

    struct BRECORD
    {
        /*0x10*/ nint pvRecord;
        /*0x18*/ nint pRecInfo;
    }

    class WeakReference : System.Runtime.Serialization.ISerializable
    {
        /*0x10*/ bool isLongReference;
        /*0x18*/ System.Runtime.InteropServices.GCHandle gcHandle;

        /*0x1f117c0*/ WeakReference();
        /*0x1f117c4*/ WeakReference(object target);
        /*0x1f117cc*/ WeakReference(object target, bool trackResurrection);
        /*0x1f117d8*/ WeakReference(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        /*0x1f11798*/ void AllocateHandle(object target);
        /*0x1f11904*/ bool get_IsAlive();
        /*0x1f11924*/ object get_Target();
        /*0x1f11958*/ void set_Target(object value);
        /*0x1f11964*/ bool get_TrackResurrection();
        /*0x1f1196c*/ void Finalize();
        /*0x1f119b8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
    }

    class WeakReference<T> : System.Runtime.Serialization.ISerializable
    {
        /*0x0*/ System.Runtime.InteropServices.GCHandle handle;
        /*0x0*/ bool trackResurrection;

        WeakReference(T target);
        WeakReference(T target, bool trackResurrection);
        WeakReference(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        void SetTarget(T target);
        bool TryGetTarget(ref T target);
        void Finalize();
    }

    struct ConsoleCursorInfo
    {
        /*0x10*/ int Size;
        /*0x14*/ bool Visible;
    }

    struct InputRecord
    {
        /*0x10*/ short EventType;
        /*0x12*/ bool KeyDown;
        /*0x14*/ short RepeatCount;
        /*0x16*/ short VirtualKeyCode;
        /*0x18*/ short VirtualScanCode;
        /*0x1a*/ char Character;
        /*0x1c*/ int ControlKeyState;
        /*0x20*/ int pad1;
        /*0x24*/ bool pad2;
    }

    struct CharInfo
    {
        /*0x10*/ char Character;
        /*0x12*/ short Attributes;
    }

    struct Coord
    {
        /*0x10*/ short X;
        /*0x12*/ short Y;

        /*0x1f11b3c*/ Coord(int x, int y);
    }

    struct SmallRect
    {
        /*0x10*/ short Left;
        /*0x12*/ short Top;
        /*0x14*/ short Right;
        /*0x16*/ short Bottom;

        /*0x1f11b48*/ SmallRect(int left, int top, int right, int bottom);
    }

    struct ConsoleScreenBufferInfo
    {
        /*0x10*/ System.Coord Size;
        /*0x14*/ System.Coord CursorPosition;
        /*0x18*/ short Attribute;
        /*0x1a*/ System.SmallRect Window;
        /*0x22*/ System.Coord MaxWindowSize;
    }

    enum Handles
    {
        STD_INPUT = -10,
        STD_OUTPUT = -11,
        STD_ERROR = -12,
    }

    class WindowsConsoleDriver : System.IConsoleDriver
    {
        /*0x10*/ nint inputHandle;
        /*0x18*/ nint outputHandle;
        /*0x20*/ short defaultAttribute;

        static /*0x1f11cc0*/ System.ConsoleColor GetForeground(short attr);
        static /*0x1f11cc8*/ System.ConsoleColor GetBackground(short attr);
        static /*0x1f11cd0*/ short GetAttrForeground(int attr, System.ConsoleColor color);
        static /*0x1f11cdc*/ short GetAttrBackground(int attr, System.ConsoleColor color);
        static /*0x1f127ac*/ bool IsModifierKey(short virtualKeyCode);
        static /*0x1f11ba8*/ nint GetStdHandle(System.Handles handle);
        static /*0x1f13590*/ void _Beep(int frequency, int duration);
        static /*0x1f11c2c*/ bool GetConsoleScreenBufferInfo(nint handle, ref System.ConsoleScreenBufferInfo info);
        static /*0x1f136a4*/ bool FillConsoleOutputCharacter(nint handle, char c, int size, System.Coord coord, ref int written);
        static /*0x1f13760*/ bool FillConsoleOutputAttribute(nint handle, short c, int size, System.Coord coord, ref int written);
        static /*0x1f1381c*/ bool SetConsoleCursorPosition(nint handle, System.Coord coord);
        static /*0x1f11d68*/ bool SetConsoleTextAttribute(nint handle, short attribute);
        static /*0x1f13f1c*/ bool SetConsoleScreenBufferSize(nint handle, System.Coord newSize);
        static /*0x1f13fac*/ bool SetConsoleWindowInfo(nint handle, bool absolute, ref System.SmallRect rect);
        static /*0x1f12c3c*/ int GetConsoleTitle(System.Text.StringBuilder sb, int size);
        static /*0x1f12de0*/ bool SetConsoleTitle(string title);
        static /*0x1f1217c*/ bool GetConsoleCursorInfo(nint handle, ref System.ConsoleCursorInfo info);
        static /*0x1f122fc*/ bool SetConsoleCursorInfo(nint handle, ref System.ConsoleCursorInfo info);
        static /*0x1f12024*/ short GetKeyState(int virtKey);
        static /*0x1f12f30*/ bool GetConsoleMode(nint handle, ref int mode);
        static /*0x1f130ec*/ bool SetConsoleMode(nint handle, int mode);
        static /*0x1f126a4*/ bool PeekConsoleInput(nint handle, ref System.InputRecord record, int length, ref int eventsRead);
        static /*0x1f127e0*/ bool ReadConsoleInput(nint handle, ref System.InputRecord record, int length, ref int nread);
        static /*0x1f129ac*/ System.Coord GetLargestConsoleWindowSize(nint handle);
        static /*0x1f13bb4*/ bool ReadConsoleOutput(nint handle, void* buffer, System.Coord bsize, System.Coord bpos, ref System.SmallRect region);
        static /*0x1f13c70*/ bool WriteConsoleOutput(nint handle, System.CharInfo[] buffer, System.Coord bsize, System.Coord bpos, ref System.SmallRect region);
        /*0x1f11b5c*/ WindowsConsoleDriver();
        /*0x1f11cec*/ System.ConsoleColor get_BackgroundColor();
        /*0x1f11d1c*/ void set_BackgroundColor(System.ConsoleColor value);
        /*0x1f11df8*/ int get_BufferHeight();
        /*0x1f11e24*/ void set_BufferHeight(int value);
        /*0x1f11e6c*/ int get_BufferWidth();
        /*0x1f11fc4*/ void set_BufferWidth(int value);
        /*0x1f1200c*/ bool get_CapsLock();
        /*0x1f120ac*/ int get_CursorLeft();
        /*0x1f120d8*/ void set_CursorLeft(int value);
        /*0x1f1215c*/ int get_CursorSize();
        /*0x1f12228*/ void set_CursorSize(int value);
        /*0x1f12124*/ int get_CursorTop();
        /*0x1f123b4*/ void set_CursorTop(int value);
        /*0x1f12400*/ bool get_CursorVisible();
        /*0x1f12424*/ void set_CursorVisible(bool value);
        /*0x1f124c4*/ System.ConsoleColor get_ForegroundColor();
        /*0x1f124f4*/ void set_ForegroundColor(System.ConsoleColor value);
        /*0x1f12540*/ bool get_KeyAvailable();
        /*0x1f128e8*/ bool get_Initialized();
        /*0x1f128f0*/ int get_LargestWindowHeight();
        /*0x1f12a34*/ int get_LargestWindowWidth();
        /*0x1f12af0*/ bool get_NumberLock();
        /*0x1f12b08*/ string get_Title();
        /*0x1f12ce4*/ void set_Title(string value);
        /*0x1f12e74*/ bool get_TreatControlCAsInput();
        /*0x1f12fc4*/ void set_TreatControlCAsInput(bool value);
        /*0x1f1317c*/ int get_WindowHeight();
        /*0x1f131b4*/ void set_WindowHeight(int value);
        /*0x1f1334c*/ int get_WindowLeft();
        /*0x1f13378*/ void set_WindowLeft(int value);
        /*0x1f133c0*/ int get_WindowTop();
        /*0x1f134e8*/ void set_WindowTop(int value);
        /*0x1f13208*/ int get_WindowWidth();
        /*0x1f13530*/ void set_WindowWidth(int value);
        /*0x1f13584*/ void Beep(int frequency, int duration);
        /*0x1f13618*/ void Clear();
        /*0x1f138ac*/ void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, System.ConsoleColor sourceForeColor, System.ConsoleColor sourceBackColor);
        /*0x1f13d34*/ void Init();
        /*0x1f13d38*/ string ReadLine();
        /*0x1f13dcc*/ System.ConsoleKeyInfo ReadKey(bool intercept);
        /*0x1f13f0c*/ void ResetColor();
        /*0x1f11e98*/ void SetBufferSize(int width, int height);
        /*0x1f12150*/ void SetCursorPosition(int left, int top);
        /*0x1f133ec*/ void SetWindowPosition(int left, int top);
        /*0x1f13240*/ void SetWindowSize(int width, int height);
    }

    class __ComObject
    {
        /*0x1f1404c*/ __ComObject();
    }

    struct Decimal : System.IFormattable, System.IComparable, System.IConvertible, System.IComparable<decimal>, System.IEquatable<decimal>, System.Runtime.Serialization.IDeserializationCallback, System.ISpanFormattable
    {
        static int SignMask = -2147483648;
        static int ScaleMask = 16711680;
        static int ScaleShift = 16;
        static /*0x0*/ decimal Zero;
        static /*0x10*/ decimal One;
        static /*0x20*/ decimal MinusOne;
        static /*0x30*/ decimal MaxValue;
        static /*0x40*/ decimal MinValue;
        /*0x10*/ int flags;
        /*0x14*/ int hi;
        /*0x18*/ int lo;
        /*0x1c*/ int mid;
        /*0x18*/ ulong ulomidLE;

        static /*0x1f1878c*/ Decimal();
        static /*0x1f14118*/ ref System.Decimal.DecCalc AsMutable(ref decimal d);
        static /*0x1f1411c*/ uint DecDivMod1E9(ref decimal value);
        static /*0x1f14318*/ decimal FromOACurrency(long cy);
        static /*0x1f14450*/ long ToOACurrency(decimal value);
        static /*0x1f144f8*/ bool IsValid(int flags);
        static /*0x1f147fc*/ decimal Abs(ref decimal d);
        static /*0x1f14810*/ decimal Add(decimal d1, decimal d2);
        static /*0x1f148c8*/ decimal Ceiling(decimal d);
        static /*0x1f1499c*/ int Compare(decimal d1, decimal d2);
        static /*0x1f14be0*/ decimal Divide(decimal d1, decimal d2);
        static /*0x1f14e68*/ bool Equals(decimal d1, decimal d2);
        static /*0x1f14efc*/ decimal Floor(decimal d);
        static /*0x1f153a4*/ decimal Parse(string s);
        static /*0x1f15468*/ decimal Parse(string s, System.Globalization.NumberStyles style);
        static /*0x1f15544*/ decimal Parse(string s, System.IFormatProvider provider);
        static /*0x1f15618*/ decimal Parse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x1f156fc*/ decimal Parse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider);
        static /*0x1f1579c*/ bool TryParse(string s, ref decimal result);
        static /*0x1f15870*/ bool TryParse(System.ReadOnlySpan<char> s, ref decimal result);
        static /*0x1f158f8*/ bool TryParse(string s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref decimal result);
        static /*0x1f159f0*/ bool TryParse(System.ReadOnlySpan<char> s, System.Globalization.NumberStyles style, System.IFormatProvider provider, ref decimal result);
        static /*0x1f15a98*/ int[] GetBits(decimal d);
        static /*0x1f15b34*/ void GetBytes(ref decimal d, byte[] buffer);
        static /*0x1f15c5c*/ decimal ToDecimal(byte[] buffer);
        static /*0x1f15d9c*/ ref decimal Max(ref decimal d1, ref decimal d2);
        static /*0x1f15e10*/ ref decimal Min(ref decimal d1, ref decimal d2);
        static /*0x1f15e84*/ decimal Remainder(decimal d1, decimal d2);
        static /*0x1f15f38*/ decimal Multiply(decimal d1, decimal d2);
        static /*0x1f15fec*/ decimal Negate(decimal d);
        static /*0x1f15ff4*/ decimal Round(decimal d);
        static /*0x1f16238*/ decimal Round(decimal d, int decimals);
        static /*0x1f162cc*/ decimal Round(decimal d, System.MidpointRounding mode);
        static /*0x1f16360*/ decimal Round(decimal d, int decimals, System.MidpointRounding mode);
        static /*0x1f1607c*/ decimal Round(ref decimal d, int decimals, System.MidpointRounding mode);
        static /*0x1f163f8*/ int Sign(ref decimal d);
        static /*0x1f16424*/ decimal Subtract(decimal d1, decimal d2);
        static /*0x1f164dc*/ byte ToByte(decimal value);
        static /*0x1f167cc*/ sbyte ToSByte(decimal value);
        static /*0x1f16ac8*/ short ToInt16(decimal value);
        static /*0x1f16c48*/ double ToDouble(decimal d);
        static /*0x1f1694c*/ int ToInt32(decimal d);
        static /*0x1f16ccc*/ long ToInt64(decimal d);
        static /*0x1f16e40*/ ushort ToUInt16(decimal value);
        static /*0x1f1665c*/ uint ToUInt32(decimal d);
        static /*0x1f16fc0*/ ulong ToUInt64(decimal d);
        static /*0x1f17128*/ float ToSingle(decimal d);
        static /*0x1f171ac*/ decimal Truncate(decimal d);
        static /*0x1f172b0*/ void Truncate(ref decimal d);
        static /*0x1f1734c*/ decimal op_Implicit(byte value);
        static /*0x1f17358*/ decimal op_Implicit(sbyte value);
        static /*0x1f17370*/ decimal op_Implicit(short value);
        static /*0x1f17388*/ decimal op_Implicit(ushort value);
        static /*0x1f17394*/ decimal op_Implicit(char value);
        static /*0x1f173a0*/ decimal op_Implicit(int value);
        static /*0x1f173b4*/ decimal op_Implicit(uint value);
        static /*0x1f173c0*/ decimal op_Implicit(long value);
        static /*0x1f173d8*/ decimal op_Implicit(ulong value);
        static /*0x1f173e4*/ decimal op_Explicit(float value);
        static /*0x1f17428*/ decimal op_Explicit(double value);
        static /*0x1f1746c*/ byte op_Explicit(decimal value);
        static /*0x1f174d0*/ sbyte op_Explicit(decimal value);
        static /*0x1f17534*/ char op_Explicit(decimal value);
        static /*0x1f17660*/ short op_Explicit(decimal value);
        static /*0x1f176c4*/ ushort op_Explicit(decimal value);
        static /*0x1f17728*/ int op_Explicit(decimal value);
        static /*0x1f1778c*/ uint op_Explicit(decimal value);
        static /*0x1f177f0*/ long op_Explicit(decimal value);
        static /*0x1f17854*/ ulong op_Explicit(decimal value);
        static /*0x1f178b8*/ float op_Explicit(decimal value);
        static /*0x1f1791c*/ double op_Explicit(decimal value);
        static /*0x1f17980*/ decimal op_UnaryPlus(decimal d);
        static /*0x1f17984*/ decimal op_UnaryNegation(decimal d);
        static /*0x1f1798c*/ decimal op_Increment(decimal d);
        static /*0x1f179fc*/ decimal op_Decrement(decimal d);
        static /*0x1f17a6c*/ decimal op_Addition(decimal d1, decimal d2);
        static /*0x1f17b24*/ decimal op_Subtraction(decimal d1, decimal d2);
        static /*0x1f17bdc*/ decimal op_Multiply(decimal d1, decimal d2);
        static /*0x1f17c90*/ decimal op_Division(decimal d1, decimal d2);
        static /*0x1f17d44*/ decimal op_Modulus(decimal d1, decimal d2);
        static /*0x1f17df8*/ bool op_Equality(decimal d1, decimal d2);
        static /*0x1f17e8c*/ bool op_Inequality(decimal d1, decimal d2);
        static /*0x1f17f20*/ bool op_LessThan(decimal d1, decimal d2);
        static /*0x1f17fb0*/ bool op_LessThanOrEqual(decimal d1, decimal d2);
        static /*0x1f18044*/ bool op_GreaterThan(decimal d1, decimal d2);
        static /*0x1f180d8*/ bool op_GreaterThanOrEqual(decimal d1, decimal d2);
        /*0x1f14198*/ Decimal(int value);
        /*0x1f141bc*/ Decimal(uint value);
        /*0x1f141c8*/ Decimal(long value);
        /*0x1f141f0*/ Decimal(ulong value);
        /*0x1f14200*/ Decimal(float value);
        /*0x1f1428c*/ Decimal(double value);
        /*0x1f14518*/ Decimal(int[] bits);
        /*0x1f143b4*/ Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
        /*0x1f14710*/ Decimal(int lo, int mid, int hi, int flags);
        /*0x1f147ec*/ Decimal(ref decimal d, int flags);
        /*0x1f1408c*/ uint get_High();
        /*0x1f14094*/ uint get_Low();
        /*0x1f1409c*/ uint get_Mid();
        /*0x1f140a4*/ bool get_IsNegative();
        /*0x1f140b0*/ int get_Scale();
        /*0x1f140b8*/ ulong get_Low64();
        /*0x1f14658*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
        /*0x1f14a28*/ int CompareTo(object value);
        /*0x1f14b4c*/ int CompareTo(decimal value);
        /*0x1f14c94*/ bool Equals(object value);
        /*0x1f14d74*/ bool Equals(decimal value);
        /*0x1f14e10*/ int GetHashCode();
        /*0x1f14fd0*/ string ToString();
        /*0x1f1507c*/ string ToString(string format);
        /*0x1f15144*/ string ToString(System.IFormatProvider provider);
        /*0x1f15200*/ string ToString(string format, System.IFormatProvider provider);
        /*0x1f152d8*/ bool TryFormat(System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider provider);
        /*0x1f1816c*/ System.TypeCode GetTypeCode();
        /*0x1f18174*/ bool System.IConvertible.ToBoolean(System.IFormatProvider provider);
        /*0x1f181d4*/ char System.IConvertible.ToChar(System.IFormatProvider provider);
        /*0x1f18260*/ sbyte System.IConvertible.ToSByte(System.IFormatProvider provider);
        /*0x1f182c0*/ byte System.IConvertible.ToByte(System.IFormatProvider provider);
        /*0x1f18320*/ short System.IConvertible.ToInt16(System.IFormatProvider provider);
        /*0x1f18380*/ ushort System.IConvertible.ToUInt16(System.IFormatProvider provider);
        /*0x1f183e0*/ int System.IConvertible.ToInt32(System.IFormatProvider provider);
        /*0x1f18440*/ uint System.IConvertible.ToUInt32(System.IFormatProvider provider);
        /*0x1f184a0*/ long System.IConvertible.ToInt64(System.IFormatProvider provider);
        /*0x1f18500*/ ulong System.IConvertible.ToUInt64(System.IFormatProvider provider);
        /*0x1f18560*/ float System.IConvertible.ToSingle(System.IFormatProvider provider);
        /*0x1f185c0*/ double System.IConvertible.ToDouble(System.IFormatProvider provider);
        /*0x1f18620*/ decimal System.IConvertible.ToDecimal(System.IFormatProvider provider);
        /*0x1f1862c*/ System.DateTime System.IConvertible.ToDateTime(System.IFormatProvider provider);
        /*0x1f186b8*/ object System.IConvertible.ToType(System.Type type, System.IFormatProvider provider);

        struct DecCalc
        {
            static /*0x0*/ uint[] s_powers10;
            static /*0x8*/ ulong[] s_ulongPowers10;
            static /*0x10*/ double[] s_doublePowers10;
            static /*0x18*/ System.Decimal.DecCalc.PowerOvfl[] PowerOvflValues;
            /*0x10*/ uint uflags;
            /*0x14*/ uint uhi;
            /*0x18*/ uint ulo;
            /*0x1c*/ uint umid;
            /*0x18*/ ulong ulomidLE;

            static /*0x1f1d510*/ DecCalc();
            static /*0x1f18938*/ uint GetExponent(float f);
            static /*0x1f18944*/ uint GetExponent(double d);
            static /*0x1f18950*/ ulong UInt32x32To64(uint a, uint b);
            static /*0x1f18958*/ void UInt64x64To128(ulong a, ulong b, ref System.Decimal.DecCalc result);
            static /*0x1f18a6c*/ uint Div96By32(ref System.Decimal.DecCalc.Buf12 bufNum, uint den);
            static /*0x1f18cbc*/ bool Div96ByConst(ref ulong high64, ref uint low, uint pow);
            static /*0x1f18d00*/ void Unscale(ref uint low, ref ulong high64, ref int scale);
            static /*0x1f18f5c*/ uint Div96By64(ref System.Decimal.DecCalc.Buf12 bufNum, ulong den);
            static /*0x1f19068*/ uint Div128By96(ref System.Decimal.DecCalc.Buf16 bufNum, ref System.Decimal.DecCalc.Buf12 bufDen);
            static /*0x1f192e8*/ uint IncreaseScale(ref System.Decimal.DecCalc.Buf12 bufNum, uint power);
            static /*0x1f19370*/ void IncreaseScale64(ref System.Decimal.DecCalc.Buf12 bufNum, uint power);
            static /*0x1f193ec*/ int ScaleResult(System.Decimal.DecCalc.Buf24* bufRes, uint hiRes, int scale);
            static /*0x1f19fc8*/ uint DivByConst(uint* result, uint hiRes, ref uint quotient, ref uint remainder, uint power);
            static /*0x1f1a01c*/ int LeadingZeroCount(uint value);
            static /*0x1f1a084*/ int OverflowUnscale(ref System.Decimal.DecCalc.Buf12 bufQuo, int scale, bool sticky);
            static /*0x1f1a1f8*/ int SearchScale(ref System.Decimal.DecCalc.Buf12 bufQuo, int scale);
            static /*0x1f1a1a4*/ bool Add32To96(ref System.Decimal.DecCalc.Buf12 bufNum, uint value);
            static /*0x1f1a3f4*/ void DecAddSub(ref System.Decimal.DecCalc d1, ref System.Decimal.DecCalc d2, bool sign);
            static /*0x1f1abe0*/ long VarCyFromDec(ref System.Decimal.DecCalc pdecIn);
            static /*0x1f1afe0*/ int VarDecCmp(ref decimal d1, ref decimal d2);
            static /*0x1f1b0b0*/ int VarDecCmpSub(ref decimal d1, ref decimal d2);
            static /*0x1f1b244*/ void VarDecMul(ref System.Decimal.DecCalc d1, ref System.Decimal.DecCalc d2);
            static /*0x1f1b728*/ void VarDecFromR4(float input, ref System.Decimal.DecCalc result);
            static /*0x1f1bb2c*/ void VarDecFromR8(double input, ref System.Decimal.DecCalc result);
            static /*0x1f1bf38*/ float VarR4FromDec(ref decimal value);
            static /*0x1f1bf94*/ double VarR8FromDec(ref decimal value);
            static /*0x1f1c078*/ int GetHashCode(ref decimal d);
            static /*0x1f1c308*/ void VarDecDiv(ref System.Decimal.DecCalc d1, ref System.Decimal.DecCalc d2);
            static /*0x1f1ccf0*/ void VarDecMod(ref System.Decimal.DecCalc d1, ref System.Decimal.DecCalc d2);
            static /*0x1f1d06c*/ void VarDecModFull(ref System.Decimal.DecCalc d1, ref System.Decimal.DecCalc d2, int scale);
            static /*0x1f1ad5c*/ void InternalRound(ref System.Decimal.DecCalc d, uint scale, System.Decimal.DecCalc.RoundingMode mode);
            static /*0x1f1d4a8*/ uint DecDivMod1E9(ref System.Decimal.DecCalc value);
            /*0x1f18818*/ uint get_High();
            /*0x1f18820*/ void set_High(uint value);
            /*0x1f18828*/ uint get_Low();
            /*0x1f18830*/ void set_Low(uint value);
            /*0x1f18838*/ uint get_Mid();
            /*0x1f18840*/ void set_Mid(uint value);
            /*0x1f18848*/ bool get_IsNegative();
            /*0x1f18854*/ int get_Scale();
            /*0x1f1885c*/ ulong get_Low64();
            /*0x1f188bc*/ void set_Low64(ulong value);

            enum RoundingMode
            {
                ToEven = 0,
                AwayFromZero = 1,
                Truncate = 2,
                Floor = 3,
                Ceiling = 4,
            }

            struct PowerOvfl
            {
                /*0x10*/ uint Hi;
                /*0x18*/ ulong MidLo;

                /*0x1f1d72c*/ PowerOvfl(uint hi, uint mid, uint lo);
            }

            struct Buf12
            {
                /*0x10*/ uint U0;
                /*0x14*/ uint U1;
                /*0x18*/ uint U2;
                /*0x10*/ ulong ulo64LE;
                /*0x14*/ ulong uhigh64LE;

                /*0x1f18be0*/ ulong get_Low64();
                /*0x1f18c40*/ void set_Low64(ulong value);
                /*0x1f18b04*/ ulong get_High64();
                /*0x1f18b64*/ void set_High64(ulong value);
            }

            struct Buf16
            {
                /*0x10*/ uint U0;
                /*0x14*/ uint U1;
                /*0x18*/ uint U2;
                /*0x1c*/ uint U3;
                /*0x10*/ ulong ulo64LE;
                /*0x18*/ ulong uhigh64LE;

                /*0x1f1920c*/ ulong get_Low64();
                /*0x1f1926c*/ void set_Low64(ulong value);
                /*0x1f191ac*/ ulong get_High64();
                /*0x1f1cc74*/ void set_High64(ulong value);
            }

            struct Buf24
            {
                /*0x10*/ uint U0;
                /*0x14*/ uint U1;
                /*0x18*/ uint U2;
                /*0x1c*/ uint U3;
                /*0x20*/ uint U4;
                /*0x24*/ uint U5;
                /*0x10*/ ulong ulo64LE;
                /*0x18*/ ulong umid64LE;
                /*0x20*/ ulong uhigh64LE;

                /*0x1f1ab80*/ ulong get_Low64();
                /*0x1f1aa88*/ void set_Low64(ulong value);
                /*0x1f1ab04*/ void set_Mid64(ulong value);
                /*0x1f1b6ac*/ void set_High64(ulong value);
            }

            struct Buf28
            {
                /*0x10*/ System.Decimal.DecCalc.Buf24 Buf24;
                /*0x28*/ uint U6;
            }
        }
    }

    namespace Deployment
    {
        namespace Internal
        {
            class InternalActivationContextHelper
            {
                static /*0x1f1d740*/ object GetActivationContextData(System.ActivationContext appInfo);
                static /*0x1f1d780*/ object GetApplicationComponentManifest(System.ActivationContext appInfo);
                static /*0x1f1d7c0*/ byte[] GetApplicationManifestBytes(System.ActivationContext appInfo);
                static /*0x1f1d800*/ object GetDeploymentComponentManifest(System.ActivationContext appInfo);
                static /*0x1f1d840*/ byte[] GetDeploymentManifestBytes(System.ActivationContext appInfo);
                static /*0x1f1d880*/ bool IsFirstRun(System.ActivationContext appInfo);
                static /*0x1f1d8c0*/ void PrepareForExecution(System.ActivationContext appInfo);
            }

            class InternalApplicationIdentityHelper
            {
                static /*0x1f1d900*/ object GetInternalAppId(System.ApplicationIdentity id);
            }
        }
    }

    namespace Threading
    {
        class AbandonedMutexException : System.SystemException
        {
            /*0x8c*/ int _mutexIndex;
            /*0x90*/ System.Threading.Mutex _mutex;

            /*0x1f1d940*/ AbandonedMutexException();
            /*0x1f1d9a4*/ AbandonedMutexException(string message);
            /*0x1f1d9d0*/ AbandonedMutexException(string message, System.Exception inner);
            /*0x1f1d9fc*/ AbandonedMutexException(int location, System.Threading.WaitHandle handle);
            /*0x1f1db20*/ AbandonedMutexException(string message, int location, System.Threading.WaitHandle handle);
            /*0x1f1dba8*/ AbandonedMutexException(string message, System.Exception inner, int location, System.Threading.WaitHandle handle);
            /*0x1f1dc30*/ AbandonedMutexException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f1dab4*/ void SetupException(int location, System.Threading.WaitHandle handle);
            /*0x1f1dc40*/ System.Threading.Mutex get_Mutex();
            /*0x1f1dc48*/ int get_MutexIndex();
        }

        enum ApartmentState
        {
            STA = 0,
            MTA = 1,
            Unknown = 2,
        }

        class AsyncLocal<T> : System.Threading.IAsyncLocal
        {
            /*0x0*/ System.Action<System.Threading.AsyncLocalValueChangedArgs<T>> m_valueChangedHandler;

            AsyncLocal();
            AsyncLocal(System.Action<System.Threading.AsyncLocalValueChangedArgs<T>> valueChangedHandler);
            T get_Value();
            void set_Value(T value);
            void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged);
        }

        interface IAsyncLocal
        {
            void OnValueChanged(object previousValue, object currentValue, bool contextChanged);
        }

        struct AsyncLocalValueChangedArgs<T>
        {
            /*0x0*/ T <PreviousValue>k__BackingField;
            /*0x0*/ T <CurrentValue>k__BackingField;
            /*0x0*/ bool <ThreadContextChanged>k__BackingField;

            AsyncLocalValueChangedArgs(T previousValue, T currentValue, bool contextChanged);
            T get_PreviousValue();
            T get_CurrentValue();
            bool get_ThreadContextChanged();
        }

        interface IAsyncLocalValueMap
        {
            bool TryGetValue(System.Threading.IAsyncLocal key, ref object value);
            System.Threading.IAsyncLocalValueMap Set(System.Threading.IAsyncLocal key, object value);
        }

        class AsyncLocalValueMap
        {
            static /*0x0*/ System.Threading.IAsyncLocalValueMap <Empty>k__BackingField;

            static /*0x1f1dca8*/ AsyncLocalValueMap();
            static /*0x1f1dc50*/ System.Threading.IAsyncLocalValueMap get_Empty();

            class EmptyAsyncLocalValueMap : System.Threading.IAsyncLocalValueMap
            {
                /*0x1f1dd20*/ EmptyAsyncLocalValueMap();
                /*0x1f1dd28*/ System.Threading.IAsyncLocalValueMap Set(System.Threading.IAsyncLocal key, object value);
                /*0x1f1ddcc*/ bool TryGetValue(System.Threading.IAsyncLocal key, ref object value);
            }

            class OneElementAsyncLocalValueMap : System.Threading.IAsyncLocalValueMap
            {
                /*0x10*/ System.Threading.IAsyncLocal _key1;
                /*0x18*/ object _value1;

                /*0x1f1dda0*/ OneElementAsyncLocalValueMap(System.Threading.IAsyncLocal key, object value);
                /*0x1f1ddd8*/ System.Threading.IAsyncLocalValueMap Set(System.Threading.IAsyncLocal key, object value);
                /*0x1f1df44*/ bool TryGetValue(System.Threading.IAsyncLocal key, ref object value);
            }

            class TwoElementAsyncLocalValueMap : System.Threading.IAsyncLocalValueMap
            {
                /*0x10*/ System.Threading.IAsyncLocal _key1;
                /*0x18*/ System.Threading.IAsyncLocal _key2;
                /*0x20*/ object _value1;
                /*0x28*/ object _value2;

                /*0x1f1df04*/ TwoElementAsyncLocalValueMap(System.Threading.IAsyncLocal key1, object value1, System.Threading.IAsyncLocal key2, object value2);
                /*0x1f1df6c*/ System.Threading.IAsyncLocalValueMap Set(System.Threading.IAsyncLocal key, object value);
                /*0x1f1e130*/ bool TryGetValue(System.Threading.IAsyncLocal key, ref object value);
            }

            class ThreeElementAsyncLocalValueMap : System.Threading.IAsyncLocalValueMap
            {
                /*0x10*/ System.Threading.IAsyncLocal _key1;
                /*0x18*/ System.Threading.IAsyncLocal _key2;
                /*0x20*/ System.Threading.IAsyncLocal _key3;
                /*0x28*/ object _value1;
                /*0x30*/ object _value2;
                /*0x38*/ object _value3;

                /*0x1f1e0dc*/ ThreeElementAsyncLocalValueMap(System.Threading.IAsyncLocal key1, object value1, System.Threading.IAsyncLocal key2, object value2, System.Threading.IAsyncLocal key3, object value3);
                /*0x1f1e16c*/ System.Threading.IAsyncLocalValueMap Set(System.Threading.IAsyncLocal key, object value);
                /*0x1f1e4b8*/ bool TryGetValue(System.Threading.IAsyncLocal key, ref object value);
            }

            class MultiElementAsyncLocalValueMap : System.Threading.IAsyncLocalValueMap
            {
                /*0x10*/ System.Collections.Generic.KeyValuePair<System.Threading.IAsyncLocal, object> _keyValues;

                /*0x1f1e3ac*/ MultiElementAsyncLocalValueMap(int count);
                /*0x1f1e414*/ void UnsafeStore(int index, System.Threading.IAsyncLocal key, object value);
                /*0x1f1e508*/ System.Threading.IAsyncLocalValueMap Set(System.Threading.IAsyncLocal key, object value);
                /*0x1f1e8e8*/ bool TryGetValue(System.Threading.IAsyncLocal key, ref object value);
            }

            class ManyElementAsyncLocalValueMap : System.Collections.Generic.Dictionary<System.Threading.IAsyncLocal, object>, System.Threading.IAsyncLocalValueMap
            {
                /*0x1f1e890*/ ManyElementAsyncLocalValueMap(int capacity);
                /*0x1f1e990*/ System.Threading.IAsyncLocalValueMap Set(System.Threading.IAsyncLocal key, object value);
            }
        }

        class AutoResetEvent : System.Threading.EventWaitHandle
        {
            /*0x1f1ed88*/ AutoResetEvent(bool initialState);
        }

        enum EventResetMode
        {
            AutoReset = 0,
            ManualReset = 1,
        }

        class LazyInitializer
        {
            static T EnsureInitialized<T>(ref T target);
            static T EnsureInitializedCore<T>(ref T target);
            static T EnsureInitialized<T>(ref T target, System.Func<T> valueFactory);
            static T EnsureInitializedCore<T>(ref T target, System.Func<T> valueFactory);
            static T EnsureInitialized<T>(ref T target, ref bool initialized, ref object syncLock);
            static T EnsureInitializedCore<T>(ref T target, ref bool initialized, ref object syncLock);
            static T EnsureInitialized<T>(ref T target, ref bool initialized, ref object syncLock, System.Func<T> valueFactory);
            static T EnsureInitializedCore<T>(ref T target, ref bool initialized, ref object syncLock, System.Func<T> valueFactory);
            static T EnsureInitialized<T>(ref T target, ref object syncLock, System.Func<T> valueFactory);
            static T EnsureInitializedCore<T>(ref T target, ref object syncLock, System.Func<T> valueFactory);
            static /*0x1f1eda4*/ object EnsureLockInitialized(ref object syncLock);
        }

        enum LazyThreadSafetyMode
        {
            None = 0,
            PublicationOnly = 1,
            ExecutionAndPublication = 2,
        }

        class LockRecursionException : System.Exception
        {
            /*0x1f1ee24*/ LockRecursionException();
            /*0x1f1ee7c*/ LockRecursionException(string message);
            /*0x1f1eee4*/ LockRecursionException(string message, System.Exception innerException);
            /*0x1f1ef54*/ LockRecursionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class ManualResetEvent : System.Threading.EventWaitHandle
        {
            /*0x1f1efd4*/ ManualResetEvent(bool initialState);
        }

        class ParameterizedThreadStart : System.MulticastDelegate
        {
            /*0x1f1efe4*/ ParameterizedThreadStart(object object, nint method);
            /*0x1f1f110*/ void Invoke(object obj);
            /*0x1f1f124*/ System.IAsyncResult BeginInvoke(object obj, System.AsyncCallback callback, object object);
            /*0x1f1f144*/ void EndInvoke(System.IAsyncResult result);
        }

        class SemaphoreFullException : System.SystemException
        {
            /*0x1f1f150*/ SemaphoreFullException();
            /*0x1f1f19c*/ SemaphoreFullException(string message);
            /*0x1f1f1a4*/ SemaphoreFullException(string message, System.Exception innerException);
            /*0x1f1f1ac*/ SemaphoreFullException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class SendOrPostCallback : System.MulticastDelegate
        {
            /*0x1f1f1b4*/ SendOrPostCallback(object object, nint method);
            /*0x1f1f2e0*/ void Invoke(object state);
            /*0x1f1f2f4*/ System.IAsyncResult BeginInvoke(object state, System.AsyncCallback callback, object object);
            /*0x1f1f314*/ void EndInvoke(System.IAsyncResult result);
        }

        class SynchronizationLockException : System.SystemException
        {
            /*0x1f1f320*/ SynchronizationLockException();
            /*0x1f1f37c*/ SynchronizationLockException(string message);
            /*0x1f1f3a0*/ SynchronizationLockException(string message, System.Exception innerException);
            /*0x1f1f3c4*/ SynchronizationLockException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum ThreadPriority
        {
            Lowest = 0,
            BelowNormal = 1,
            Normal = 2,
            AboveNormal = 3,
            Highest = 4,
        }

        class ThreadStart : System.MulticastDelegate
        {
            /*0x1f1f3cc*/ ThreadStart(object object, nint method);
            /*0x1f1f488*/ void Invoke();
            /*0x1f1f49c*/ System.IAsyncResult BeginInvoke(System.AsyncCallback callback, object object);
            /*0x1f1f4bc*/ void EndInvoke(System.IAsyncResult result);
        }

        class ThreadStartException : System.SystemException
        {
            /*0x1f1f4c8*/ ThreadStartException();
            /*0x1f1f524*/ ThreadStartException(System.Exception reason);
            /*0x1f1f590*/ ThreadStartException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum ThreadState
        {
            Running = 0,
            StopRequested = 1,
            SuspendRequested = 2,
            Background = 4,
            Unstarted = 8,
            Stopped = 16,
            WaitSleepJoin = 32,
            Suspended = 64,
            AbortRequested = 128,
            Aborted = 256,
        }

        class ThreadStateException : System.SystemException
        {
            /*0x1f1f598*/ ThreadStateException();
            /*0x1f1f5f4*/ ThreadStateException(string message);
            /*0x1f1f618*/ ThreadStateException(string message, System.Exception innerException);
            /*0x1f1f63c*/ ThreadStateException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class Timeout
        {
            static int Infinite = -1;
            static uint UnsignedInfinite = 4294967295;
            static /*0x0*/ System.TimeSpan InfiniteTimeSpan;

            static /*0x1f1f644*/ Timeout();
        }

        class WaitHandleCannotBeOpenedException : System.ApplicationException
        {
            /*0x1f1f6b4*/ WaitHandleCannotBeOpenedException();
            /*0x1f1f710*/ WaitHandleCannotBeOpenedException(string message);
            /*0x1f1f734*/ WaitHandleCannotBeOpenedException(string message, System.Exception innerException);
            /*0x1f1f758*/ WaitHandleCannotBeOpenedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class CountdownEvent : System.IDisposable
        {
            /*0x10*/ int _initialCount;
            /*0x14*/ int _currentCount;
            /*0x18*/ System.Threading.ManualResetEventSlim _event;
            /*0x20*/ bool _disposed;

            /*0x1f1f760*/ CountdownEvent(int initialCount);
            /*0x1f1f854*/ int get_CurrentCount();
            /*0x1f1f86c*/ int get_InitialCount();
            /*0x1f1f874*/ bool get_IsSet();
            /*0x1f1f890*/ System.Threading.WaitHandle get_WaitHandle();
            /*0x1f1f950*/ void Dispose();
            /*0x1f1f9bc*/ void Dispose(bool disposing);
            /*0x1f1fa58*/ bool Signal();
            /*0x1f1fb0c*/ bool Signal(int signalCount);
            /*0x1f1fc40*/ void AddCount();
            /*0x1f1fca8*/ bool TryAddCount();
            /*0x1f1fc48*/ void AddCount(int signalCount);
            /*0x1f1fcb0*/ bool TryAddCount(int signalCount);
            /*0x1f1fdd4*/ void Reset();
            /*0x1f1fddc*/ void Reset(int count);
            /*0x1f1fec0*/ void Wait();
            /*0x1f1ff90*/ void Wait(System.Threading.CancellationToken cancellationToken);
            /*0x1f1ff9c*/ bool Wait(System.TimeSpan timeout);
            /*0x1f20048*/ bool Wait(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken);
            /*0x1f200f8*/ bool Wait(int millisecondsTimeout);
            /*0x1f1fecc*/ bool Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
            /*0x1f1f8b0*/ void ThrowIfDisposed();
        }

        struct CancellationToken
        {
            static /*0x0*/ System.Action<object> s_actionToActionObjShunt;
            /*0x10*/ System.Threading.CancellationTokenSource _source;

            static /*0x1f20fe4*/ CancellationToken();
            static /*0x1f20588*/ System.Threading.CancellationToken get_None();
            static /*0x1f20f70*/ bool op_Equality(System.Threading.CancellationToken left, System.Threading.CancellationToken right);
            static /*0x1f20f7c*/ bool op_Inequality(System.Threading.CancellationToken left, System.Threading.CancellationToken right);
            /*0x1f20724*/ CancellationToken(System.Threading.CancellationTokenSource source);
            /*0x1f2072c*/ CancellationToken(bool canceled);
            /*0x1f20590*/ bool get_IsCancellationRequested();
            /*0x1f205d8*/ bool get_CanBeCanceled();
            /*0x1f205e8*/ System.Threading.WaitHandle get_WaitHandle();
            /*0x1f207a0*/ System.Threading.CancellationTokenRegistration Register(System.Action callback);
            /*0x1f209c0*/ System.Threading.CancellationTokenRegistration Register(System.Action callback, bool useSynchronizationContext);
            /*0x1f20ab4*/ System.Threading.CancellationTokenRegistration Register(System.Action<object> callback, object state);
            /*0x1f20aec*/ System.Threading.CancellationTokenRegistration Register(System.Action<object> callback, object state, bool useSynchronizationContext);
            /*0x1f20b24*/ System.Threading.CancellationTokenRegistration InternalRegisterWithoutEC(System.Action<object> callback, object state);
            /*0x1f2088c*/ System.Threading.CancellationTokenRegistration Register(System.Action<object> callback, object state, bool useSynchronizationContext, bool useExecutionContext);
            /*0x1f20e74*/ bool Equals(System.Threading.CancellationToken other);
            /*0x1f20e84*/ bool Equals(object other);
            /*0x1f20efc*/ int GetHashCode();
            /*0x1f20100*/ void ThrowIfCancellationRequested();
            /*0x1f20f88*/ void ThrowOperationCanceledException();

            class <>c
            {
                static /*0x0*/ System.Threading.CancellationToken.<> <>9;

                static /*0x1f210a8*/ <>c();
                /*0x1f2110c*/ <>c();
                /*0x1f21114*/ void <.cctor>b__26_0(object obj);
            }
        }

        class ManualResetEventSlim : System.IDisposable
        {
            static int DEFAULT_SPIN_SP = 1;
            static int SignalledState_BitMask = -2147483648;
            static int SignalledState_ShiftCount = 31;
            static int Dispose_BitMask = 1073741824;
            static int SpinCountState_BitMask = 1073217536;
            static int SpinCountState_ShiftCount = 19;
            static int SpinCountState_MaxValue = 2047;
            static int NumWaitersState_BitMask = 524287;
            static int NumWaitersState_ShiftCount = 0;
            static int NumWaitersState_MaxValue = 524287;
            static /*0x0*/ System.Action<object> s_cancellationTokenCallback;
            /*0x10*/ object m_lock;
            /*0x18*/ System.Threading.ManualResetEvent m_eventObj;
            /*0x20*/ int m_combinedState;

            static /*0x1f22048*/ ManualResetEventSlim();
            static /*0x1f21f28*/ void CancellationTokenCallback(object obj);
            static /*0x1f214d0*/ int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
            static /*0x1f213a8*/ int ExtractStatePortion(int state, int mask);
            /*0x1f1f844*/ ManualResetEventSlim();
            /*0x1f21600*/ ManualResetEventSlim(bool initialState);
            /*0x1f2172c*/ ManualResetEventSlim(bool initialState, int spinCount);
            /*0x1f1f914*/ System.Threading.WaitHandle get_WaitHandle();
            /*0x1f2134c*/ bool get_IsSet();
            /*0x1f213b0*/ void set_IsSet(bool value);
            /*0x1f21474*/ int get_SpinCount();
            /*0x1f214dc*/ void set_SpinCount(int value);
            /*0x1f21510*/ int get_Waiters();
            /*0x1f2156c*/ void set_Waiters(int value);
            /*0x1f2167c*/ void Initialize(bool initialState, int spinCount);
            /*0x1f2184c*/ void EnsureLockObjectCreated();
            /*0x1f211e4*/ bool LazyInitializeEvent();
            /*0x1f1f84c*/ void Set();
            /*0x1f21958*/ void Set(bool duringCancellation);
            /*0x1f1fe74*/ void Reset();
            /*0x1f21bc0*/ void Wait();
            /*0x1f21bcc*/ void Wait(System.Threading.CancellationToken cancellationToken);
            /*0x1f21bd8*/ bool Wait(System.TimeSpan timeout);
            /*0x1f21c84*/ bool Wait(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken);
            /*0x1f21d34*/ bool Wait(int millisecondsTimeout);
            /*0x1f20138*/ bool Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
            /*0x1f1f9ec*/ void Dispose();
            /*0x1f21e34*/ void Dispose(bool disposing);
            /*0x1f21180*/ void ThrowIfDisposed();
            /*0x1f213d0*/ void UpdateStateAtomically(int newBits, int updateBitsMask);
        }

        struct NativeOverlapped
        {
            /*0x10*/ nint InternalLow;
            /*0x18*/ nint InternalHigh;
            /*0x20*/ int OffsetLow;
            /*0x24*/ int OffsetHigh;
            /*0x28*/ nint EventHandle;
        }

        struct SpinWait
        {
            static int YieldThreshold = 10;
            static int Sleep0EveryHowManyYields = 5;
            static int DefaultSleep1Threshold = 20;
            static int Sleep1ThresholdForLongSpinBeforeWait = 40;
            static /*0x0*/ int SpinCountforSpinBeforeWait;
            /*0x10*/ int _count;

            static /*0x1f22638*/ SpinWait();
            static /*0x1f22310*/ void SpinUntil(System.Func<bool> condition);
            static /*0x1f22514*/ bool SpinUntil(System.Func<bool> condition, System.TimeSpan timeout);
            static /*0x1f22368*/ bool SpinUntil(System.Func<bool> condition, int millisecondsTimeout);
            /*0x1f220dc*/ int get_Count();
            /*0x1f220e4*/ void set_Count(int value);
            /*0x1f220ec*/ bool get_NextSpinWillYield();
            /*0x1f1fc38*/ void SpinOnce();
            /*0x1f21d44*/ void SpinOnce(int sleep1Threshold);
            /*0x1f22164*/ void SpinOnceCore(int sleep1Threshold);
            /*0x1f22308*/ void Reset();
        }

        class PlatformHelper
        {
            static int PROCESSOR_COUNT_REFRESH_INTERVAL_MS = 30000;
            static /*0x0*/ int s_processorCount;
            static /*0x4*/ int s_lastProcessorCountRefreshTicks;
            static /*0x8*/ bool IsSingleProcessor;

            static /*0x1f227a8*/ PlatformHelper();
            static /*0x1f226bc*/ int get_ProcessorCount();
        }

        class TimeoutHelper
        {
            static /*0x1f21d3c*/ uint GetTime();
            static /*0x1f21df0*/ int UpdateTimeOut(uint startTime, int originalWaitMillisecondsTimeout);
        }

        struct CancellationTokenRegistration : System.IEquatable<System.Threading.CancellationTokenRegistration>, System.IDisposable, System.IAsyncDisposable
        {
            /*0x10*/ System.Threading.CancellationCallbackInfo m_callbackInfo;
            /*0x18*/ System.Threading.SparselyPopulatedArrayAddInfo<System.Threading.CancellationCallbackInfo> m_registrationInfo;

            static /*0x1f229e4*/ bool op_Equality(System.Threading.CancellationTokenRegistration left, System.Threading.CancellationTokenRegistration right);
            static /*0x1f22a94*/ bool op_Inequality(System.Threading.CancellationTokenRegistration left, System.Threading.CancellationTokenRegistration right);
            /*0x1f227fc*/ CancellationTokenRegistration(System.Threading.CancellationCallbackInfo callbackInfo, System.Threading.SparselyPopulatedArrayAddInfo<System.Threading.CancellationCallbackInfo> registrationInfo);
            /*0x1f22808*/ System.Threading.CancellationToken get_Token();
            /*0x1f22854*/ bool Unregister();
            /*0x1f228d0*/ void Dispose();
            /*0x1f22ac8*/ bool Equals(object obj);
            /*0x1f22a14*/ bool Equals(System.Threading.CancellationTokenRegistration other);
            /*0x1f22b58*/ int GetHashCode();
            /*0x1f22be8*/ System.Threading.Tasks.ValueTask DisposeAsync();
        }

        class CancellationTokenSource : System.IDisposable
        {
            static int CannotBeCanceled = 0;
            static int NotCanceledState = 1;
            static int NotifyingState = 2;
            static int NotifyingCompleteState = 3;
            static /*0x0*/ System.Threading.CancellationTokenSource s_canceledSource;
            static /*0x8*/ System.Threading.CancellationTokenSource s_neverCanceledSource;
            static /*0x10*/ int s_nLists;
            static /*0x18*/ System.Threading.TimerCallback s_timerCallback;
            /*0x10*/ System.Threading.ManualResetEvent _kernelEvent;
            /*0x18*/ System.Threading.SparselyPopulatedArray<System.Threading.CancellationCallbackInfo> _registeredCallbacksLists;
            /*0x20*/ int _state;
            /*0x24*/ int _threadIDExecutingCallbacks;
            /*0x28*/ bool _disposed;
            /*0x30*/ System.Threading.CancellationCallbackInfo _executingCallback;
            /*0x38*/ System.Threading.Timer _timer;

            static /*0x1f24354*/ CancellationTokenSource();
            static /*0x1f232f0*/ void TimerCallbackLogic(object obj);
            static /*0x1f23504*/ void ThrowObjectDisposedException();
            static /*0x1f23cf8*/ System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken token1, System.Threading.CancellationToken token2);
            static /*0x1f23fb0*/ System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken token);
            static /*0x1f24060*/ System.Threading.CancellationTokenSource CreateLinkedTokenSource(System.Threading.CancellationToken[] tokens);
            /*0x1f22d30*/ CancellationTokenSource();
            /*0x1f22d64*/ CancellationTokenSource(System.TimeSpan delay);
            /*0x1f22edc*/ CancellationTokenSource(int millisecondsDelay);
            /*0x1f205bc*/ bool get_IsCancellationRequested();
            /*0x1f22964*/ bool get_IsCancellationCompleted();
            /*0x1f22c7c*/ bool get_IsDisposed();
            /*0x1f22980*/ int get_ThreadIDExecutingCallbacks();
            /*0x1f22c84*/ void set_ThreadIDExecutingCallbacks(int value);
            /*0x1f2283c*/ System.Threading.CancellationToken get_Token();
            /*0x1f22cfc*/ bool get_CanBeCanceled();
            /*0x1f20654*/ System.Threading.WaitHandle get_WaitHandle();
            /*0x1f22d18*/ System.Threading.CancellationCallbackInfo get_ExecutingCallback();
            /*0x1f22e20*/ void InitializeWithTimer(int millisecondsDelay);
            /*0x1f22f6c*/ void Cancel();
            /*0x1f22f88*/ void Cancel(bool throwOnFirstException);
            /*0x1f23060*/ void CancelAfter(System.TimeSpan delay);
            /*0x1f23104*/ void CancelAfter(int millisecondsDelay);
            /*0x1f23408*/ void Dispose();
            /*0x1f23474*/ void Dispose(bool disposing);
            /*0x1f22ca8*/ void ThrowIfDisposed();
            /*0x1f20bac*/ System.Threading.CancellationTokenRegistration InternalRegister(System.Action<object> callback, object stateForCallback, System.Threading.SynchronizationContext targetSyncContext, System.Threading.ExecutionContext executionContext);
            /*0x1f22fb0*/ void NotifyCancellation(bool throwOnFirstException);
            /*0x1f235e8*/ void ExecuteCallbackHandlers(bool throwOnFirstException);
            /*0x1f23b84*/ void CancellationCallbackCoreWork_OnSyncContext(object obj);
            /*0x1f23ac8*/ void CancellationCallbackCoreWork(System.Threading.CancellationCallbackCoreWorkArguments args);
            /*0x1f22998*/ void WaitForCallbackToComplete(System.Threading.CancellationCallbackInfo callbackInfo);

            class Linked1CancellationTokenSource : System.Threading.CancellationTokenSource
            {
                /*0x40*/ System.Threading.CancellationTokenRegistration _reg1;

                /*0x1f23dcc*/ Linked1CancellationTokenSource(System.Threading.CancellationToken token1);
                /*0x1f244d4*/ void Dispose(bool disposing);
            }

            class Linked2CancellationTokenSource : System.Threading.CancellationTokenSource
            {
                /*0x40*/ System.Threading.CancellationTokenRegistration _reg1;
                /*0x58*/ System.Threading.CancellationTokenRegistration _reg2;

                /*0x1f23ea4*/ Linked2CancellationTokenSource(System.Threading.CancellationToken token1, System.Threading.CancellationToken token2);
                /*0x1f24508*/ void Dispose(bool disposing);
            }

            class LinkedNCancellationTokenSource : System.Threading.CancellationTokenSource
            {
                static /*0x0*/ System.Action<object> s_linkedTokenCancelDelegate;
                /*0x40*/ System.Threading.CancellationTokenRegistration[] _linkingRegistrations;

                static /*0x1f245d4*/ LinkedNCancellationTokenSource();
                /*0x1f241c4*/ LinkedNCancellationTokenSource(System.Threading.CancellationToken[] tokens);
                /*0x1f24544*/ void Dispose(bool disposing);

                class <>c
                {
                    static /*0x0*/ System.Threading.CancellationTokenSource.LinkedNCancellationTokenSource.<> <>9;

                    static /*0x1f24698*/ <>c();
                    /*0x1f246fc*/ <>c();
                    /*0x1f24704*/ void <.cctor>b__4_0(object s);
                }
            }
        }

        struct CancellationCallbackCoreWorkArguments
        {
            /*0x10*/ System.Threading.SparselyPopulatedArrayFragment<System.Threading.CancellationCallbackInfo> _currArrayFragment;
            /*0x18*/ int _currArrayIndex;

            /*0x1f23abc*/ CancellationCallbackCoreWorkArguments(System.Threading.SparselyPopulatedArrayFragment<System.Threading.CancellationCallbackInfo> currArrayFragment, int currArrayIndex);
        }

        class CancellationCallbackInfo
        {
            static /*0x0*/ System.Threading.ContextCallback s_executionContextCallback;
            /*0x10*/ System.Action<object> Callback;
            /*0x18*/ object StateForCallback;
            /*0x20*/ System.Threading.ExecutionContext TargetExecutionContext;
            /*0x28*/ System.Threading.CancellationTokenSource CancellationTokenSource;

            static /*0x1f2499c*/ void ExecutionContextCallback(object obj);
            /*0x1f23558*/ CancellationCallbackInfo(System.Action<object> callback, object stateForCallback, System.Threading.ExecutionContext targetExecutionContext, System.Threading.CancellationTokenSource cancellationTokenSource);
            /*0x1f23bfc*/ void ExecuteCallback();

            class WithSyncContext : System.Threading.CancellationCallbackInfo
            {
                /*0x30*/ System.Threading.SynchronizationContext TargetSyncContext;

                /*0x1f23598*/ WithSyncContext(System.Action<object> callback, object stateForCallback, System.Threading.ExecutionContext targetExecutionContext, System.Threading.CancellationTokenSource cancellationTokenSource, System.Threading.SynchronizationContext targetSyncContext);
            }
        }

        class SparselyPopulatedArray<T>
        {
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _head;
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _tail;

            SparselyPopulatedArray(int initialSize);
            System.Threading.SparselyPopulatedArrayFragment<T> get_Tail();
            System.Threading.SparselyPopulatedArrayAddInfo<T> Add(T element);
        }

        struct SparselyPopulatedArrayAddInfo<T>
        {
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _source;
            /*0x0*/ int _index;

            SparselyPopulatedArrayAddInfo(System.Threading.SparselyPopulatedArrayFragment<T> source, int index);
            System.Threading.SparselyPopulatedArrayFragment<T> get_Source();
            int get_Index();
        }

        class SparselyPopulatedArrayFragment<T>
        {
            /*0x0*/ T[] _elements;
            /*0x0*/ int _freeCount;
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _next;
            /*0x0*/ System.Threading.SparselyPopulatedArrayFragment<T> _prev;

            SparselyPopulatedArrayFragment(int size);
            SparselyPopulatedArrayFragment(int size, System.Threading.SparselyPopulatedArrayFragment<T> prev);
            T get_Item(int index);
            int get_Length();
            System.Threading.SparselyPopulatedArrayFragment<T> get_Prev();
            T SafeAtomicRemove(int index, T expectedElement);
        }

        struct LockHolder : System.IDisposable
        {
            /*0x10*/ System.Threading.Lock _lock;

            static /*0x1f24a28*/ System.Threading.LockHolder Hold(System.Threading.Lock l);
            /*0x1f24a54*/ void Dispose();
        }

        class Lock
        {
            /*0x10*/ object _lock;

            /*0x1f24a80*/ Lock();
            /*0x1f24a4c*/ void Acquire();
            /*0x1f24a70*/ void Release();
        }

        class SemaphoreSlim : System.IDisposable
        {
            static int NO_MAXIMUM = 2147483647;
            static /*0x0*/ System.Threading.Tasks.Task<bool> s_trueTask;
            static /*0x8*/ System.Threading.Tasks.Task<bool> s_falseTask;
            static /*0x10*/ System.Action<object> s_cancellationTokenCanceledEventHandler;
            /*0x10*/ int m_currentCount;
            /*0x14*/ int m_maxCount;
            /*0x18*/ int m_waitCount;
            /*0x20*/ object m_lockObj;
            /*0x28*/ System.Threading.ManualResetEvent m_waitHandle;
            /*0x30*/ System.Threading.SemaphoreSlim.TaskNode m_asyncHead;
            /*0x38*/ System.Threading.SemaphoreSlim.TaskNode m_asyncTail;

            static /*0x1f2620c*/ SemaphoreSlim();
            static /*0x1f26024*/ void QueueWaiterTask(System.Threading.SemaphoreSlim.TaskNode waiterTask);
            static /*0x1f260f8*/ void CancellationTokenCanceledEventHandler(object obj);
            static /*0x1f24e70*/ string GetResourceString(string str);
            /*0x1f24cd4*/ SemaphoreSlim(int initialCount);
            /*0x1f24cdc*/ SemaphoreSlim(int initialCount, int maxCount);
            /*0x1f24ae8*/ int get_CurrentCount();
            /*0x1f24b00*/ System.Threading.WaitHandle get_AvailableWaitHandle();
            /*0x1f24e78*/ void Wait();
            /*0x1f2535c*/ void Wait(System.Threading.CancellationToken cancellationToken);
            /*0x1f25368*/ bool Wait(System.TimeSpan timeout);
            /*0x1f25488*/ bool Wait(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken);
            /*0x1f255ac*/ bool Wait(int millisecondsTimeout);
            /*0x1f24e84*/ bool Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
            /*0x1f25898*/ bool WaitUntilCountOrTimeout(int millisecondsTimeout, uint startTime, System.Threading.CancellationToken cancellationToken);
            /*0x1f25928*/ System.Threading.Tasks.Task WaitAsync();
            /*0x1f25934*/ System.Threading.Tasks.Task WaitAsync(System.Threading.CancellationToken cancellationToken);
            /*0x1f25940*/ System.Threading.Tasks.Task<bool> WaitAsync(int millisecondsTimeout);
            /*0x1f25948*/ System.Threading.Tasks.Task<bool> WaitAsync(System.TimeSpan timeout);
            /*0x1f25950*/ System.Threading.Tasks.Task<bool> WaitAsync(System.TimeSpan timeout, System.Threading.CancellationToken cancellationToken);
            /*0x1f255b4*/ System.Threading.Tasks.Task<bool> WaitAsync(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
            /*0x1f25a70*/ System.Threading.SemaphoreSlim.TaskNode CreateAndAddAsyncWaiter();
            /*0x1f25c60*/ bool RemoveAsyncWaiter(System.Threading.SemaphoreSlim.TaskNode task);
            /*0x1f25af4*/ System.Threading.Tasks.Task<bool> WaitUntilCountOrTimeoutAsync(System.Threading.SemaphoreSlim.TaskNode asyncWaiter, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
            /*0x1f25ce0*/ int Release();
            /*0x1f25ce8*/ int Release(int releaseCount);
            /*0x1f26030*/ void Dispose();
            /*0x1f2609c*/ void Dispose(bool disposing);
            /*0x1f24c50*/ void CheckDispose();

            class TaskNode : System.Threading.Tasks.Task<bool>, System.Threading.IThreadPoolWorkItem
            {
                /*0x58*/ System.Threading.SemaphoreSlim.TaskNode Prev;
                /*0x60*/ System.Threading.SemaphoreSlim.TaskNode Next;

                /*0x1f25c18*/ TaskNode();
                /*0x1f26338*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                /*0x1f26384*/ void System.Threading.IThreadPoolWorkItem.MarkAborted(System.Threading.ThreadAbortException tae);
            }

            struct <WaitUntilCountOrTimeoutAsync>d__32 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<bool> <>t__builder;
                /*0x30*/ System.Threading.CancellationToken cancellationToken;
                /*0x38*/ System.Threading.SemaphoreSlim.TaskNode asyncWaiter;
                /*0x40*/ int millisecondsTimeout;
                /*0x48*/ System.Threading.SemaphoreSlim <>4__this;
                /*0x50*/ System.Threading.CancellationTokenSource <cts>5__2;
                /*0x58*/ object <>7__wrap2;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<System.Threading.Tasks.Task> <>u__1;
                /*0x70*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<bool> <>u__2;

                /*0x1f26388*/ void MoveNext();
                /*0x1f26af4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        struct SpinLock
        {
            static int SPINNING_FACTOR = 100;
            static int SLEEP_ONE_FREQUENCY = 40;
            static int SLEEP_ZERO_FREQUENCY = 10;
            static int TIMEOUT_CHECK_FREQUENCY = 10;
            static int LOCK_ID_DISABLE_MASK = -2147483648;
            static int LOCK_ANONYMOUS_OWNED = 1;
            static int WAITERS_MASK = 2147483646;
            static int ID_DISABLED_AND_ANONYMOUS_OWNED = -2147483647;
            static int LOCK_UNOWNED = 0;
            static /*0x0*/ int MAXIMUM_WAITERS;
            /*0x10*/ int m_owner;

            static /*0x1f2764c*/ SpinLock();
            /*0x1f26b4c*/ SpinLock(bool enableThreadOwnerTracking);
            /*0x1f26b84*/ void Enter(ref bool lockTaken);
            /*0x1f2707c*/ void TryEnter(ref bool lockTaken);
            /*0x1f27124*/ void TryEnter(System.TimeSpan timeout, ref bool lockTaken);
            /*0x1f27088*/ void TryEnter(int millisecondsTimeout, ref bool lockTaken);
            /*0x1f26c04*/ void ContinueTryEnter(int millisecondsTimeout, ref bool lockTaken);
            /*0x1f2738c*/ void DecrementWaiters();
            /*0x1f27254*/ void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, uint startTime, ref bool lockTaken);
            /*0x1f273ec*/ void Exit();
            /*0x1f27514*/ void Exit(bool useMemoryBarrier);
            /*0x1f27434*/ void ExitSlowPath(bool useMemoryBarrier);
            /*0x1f27610*/ bool get_IsHeld();
            /*0x1f27568*/ bool get_IsHeldByCurrentThread();
            /*0x1f27238*/ bool get_IsThreadOwnerTrackingEnabled();

            class SystemThreading_SpinLockDebugView
            {
            }
        }

        class ThreadLocal<T> : System.IDisposable
        {
            static /*0x0*/ System.Threading.ThreadLocal.IdManager<T> s_idManager;
            [ThreadStatic] static System.Threading.ThreadLocal.LinkedSlotVolatile<T> ts_slotArray;
            [ThreadStatic] static System.Threading.ThreadLocal.FinalizationHelper<T> ts_finalizationHelper;
            /*0x0*/ System.Func<T> m_valueFactory;
            /*0x0*/ int m_idComplement;
            /*0x0*/ bool m_initialized;
            /*0x0*/ System.Threading.ThreadLocal.LinkedSlot<T> m_linkedSlot;
            /*0x0*/ bool m_trackAllValues;

            static ThreadLocal();
            static int GetNewTableSize(int minSize);
            ThreadLocal();
            ThreadLocal(bool trackAllValues);
            ThreadLocal(System.Func<T> valueFactory);
            ThreadLocal(System.Func<T> valueFactory, bool trackAllValues);
            void Initialize(System.Func<T> valueFactory, bool trackAllValues);
            void Finalize();
            void Dispose();
            void Dispose(bool disposing);
            string ToString();
            T get_Value();
            void set_Value(T value);
            T GetValueSlow();
            void SetValueSlow(T value, System.Threading.ThreadLocal.LinkedSlotVolatile<T> slotArray);
            void CreateLinkedSlot(System.Threading.ThreadLocal.LinkedSlotVolatile<T> slotArray, int id, T value);
            System.Collections.Generic.IList<T> get_Values();
            System.Collections.Generic.List<T> GetValuesAsList();
            int get_ValuesCountForDebugDisplay();
            bool get_IsValueCreated();
            T get_ValueForDebugDisplay();
            System.Collections.Generic.List<T> get_ValuesForDebugDisplay();
            void GrowTable(ref System.Threading.ThreadLocal.LinkedSlotVolatile<T> table, int minLength);

            struct LinkedSlotVolatile<T>
            {
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlot<T> Value;
            }

            class LinkedSlot<T>
            {
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlot<T> Next;
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlot<T> Previous;
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlotVolatile<T> SlotArray;
                /*0x0*/ T Value;

                LinkedSlot(System.Threading.ThreadLocal.LinkedSlotVolatile<T> slotArray);
            }

            class IdManager<T>
            {
                /*0x0*/ int m_nextIdToTry;
                /*0x0*/ System.Collections.Generic.List<bool> m_freeIds;

                IdManager();
                int GetId();
                void ReturnId(int id);
            }

            class FinalizationHelper<T>
            {
                /*0x0*/ System.Threading.ThreadLocal.LinkedSlotVolatile<T> SlotArray;
                /*0x0*/ bool m_trackAllValues;

                FinalizationHelper(System.Threading.ThreadLocal.LinkedSlotVolatile<T> slotArray, bool trackAllValues);
                void Finalize();
            }
        }

        class SystemThreading_ThreadLocalDebugView<T>
        {
            /*0x0*/ System.Threading.ThreadLocal<T> m_tlocal;

            SystemThreading_ThreadLocalDebugView(System.Threading.ThreadLocal<T> tlocal);
            bool get_IsValueCreated();
            T get_Value();
            System.Collections.Generic.List<T> get_Values();
        }

        class EventWaitHandle : System.Threading.WaitHandle
        {
            static /*0x1f27ca4*/ System.Threading.EventWaitHandle OpenExisting(string name);
            static /*0x1f27cac*/ System.Threading.EventWaitHandle OpenExisting(string name, System.Security.AccessControl.EventWaitHandleRights rights);
            static /*0x1f27e84*/ bool TryOpenExisting(string name, ref System.Threading.EventWaitHandle result);
            static /*0x1f27e90*/ bool TryOpenExisting(string name, System.Security.AccessControl.EventWaitHandleRights rights, ref System.Threading.EventWaitHandle result);
            static /*0x1f27ce8*/ System.Threading.WaitHandle.OpenExistingResult OpenExistingWorker(string name, System.Security.AccessControl.EventWaitHandleRights rights, ref System.Threading.EventWaitHandle result);
            /*0x1f1ed98*/ EventWaitHandle(bool initialState, System.Threading.EventResetMode mode);
            /*0x1f27698*/ EventWaitHandle(bool initialState, System.Threading.EventResetMode mode, string name);
            /*0x1f27958*/ EventWaitHandle(bool initialState, System.Threading.EventResetMode mode, string name, ref bool createdNew);
            /*0x1f27960*/ EventWaitHandle(bool initialState, System.Threading.EventResetMode mode, string name, ref bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);
            /*0x1f27c30*/ EventWaitHandle(Microsoft.Win32.SafeHandles.SafeWaitHandle handle);
            /*0x1f21b5c*/ bool Reset();
            /*0x1f218f4*/ bool Set();
            /*0x1f27e98*/ System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl();
            /*0x1f27f08*/ void SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);
        }

        class ContextCallback : System.MulticastDelegate
        {
            /*0x1f24788*/ ContextCallback(object object, nint method);
            /*0x1f27f40*/ void Invoke(object state);
            /*0x1f27f54*/ System.IAsyncResult BeginInvoke(object state, System.AsyncCallback callback, object object);
            /*0x1f27f74*/ void EndInvoke(System.IAsyncResult result);
        }

        class ContextCallback<TState> : System.MulticastDelegate
        {
            ContextCallback(object object, nint method);
            void Invoke(ref TState state);
            System.IAsyncResult BeginInvoke(ref TState state, System.AsyncCallback callback, object object);
            void EndInvoke(ref TState state, System.IAsyncResult result);
        }

        struct ExecutionContextSwitcher
        {
            /*0x10*/ System.Threading.ExecutionContext.Reader outerEC;
            /*0x18*/ bool outerECBelongsToScope;
            /*0x20*/ object hecsw;
            /*0x28*/ System.Threading.Thread thread;

            /*0x1f27f80*/ bool UndoNoThrow();
            /*0x1f28008*/ void Undo();
        }

        struct AsyncFlowControl : System.IDisposable
        {
            /*0x10*/ bool useEC;
            /*0x18*/ System.Threading.ExecutionContext _ec;
            /*0x20*/ System.Threading.Thread _thread;

            static /*0x1f288d8*/ bool op_Equality(System.Threading.AsyncFlowControl a, System.Threading.AsyncFlowControl b);
            static /*0x1f28918*/ bool op_Inequality(System.Threading.AsyncFlowControl a, System.Threading.AsyncFlowControl b);
            /*0x1f28530*/ void Setup();
            /*0x1f285a0*/ void Dispose();
            /*0x1f285a4*/ void Undo();
            /*0x1f28758*/ int GetHashCode();
            /*0x1f287fc*/ bool Equals(object obj);
            /*0x1f28898*/ bool Equals(System.Threading.AsyncFlowControl obj);
        }

        class ExecutionContext : System.IDisposable, System.Runtime.Serialization.ISerializable
        {
            static /*0x0*/ System.Threading.ExecutionContext s_dummyDefaultEC;
            static /*0x8*/ System.Threading.ExecutionContext Default;
            /*0x10*/ System.Threading.SynchronizationContext _syncContext;
            /*0x18*/ System.Threading.SynchronizationContext _syncContextNoFlow;
            /*0x20*/ System.Runtime.Remoting.Messaging.LogicalCallContext _logicalCallContext;
            /*0x28*/ System.Runtime.Remoting.Messaging.IllogicalCallContext _illogicalCallContext;
            /*0x30*/ System.Threading.ExecutionContext.Flags _flags;
            /*0x38*/ System.Collections.Generic.Dictionary<System.Threading.IAsyncLocal, object> _localValues;
            /*0x40*/ System.Collections.Generic.List<System.Threading.IAsyncLocal> _localChangeNotifications;

            static /*0x1f29c30*/ ExecutionContext();
            static /*0x1f28994*/ System.Threading.ExecutionContext get_PreAllocatedDefault();
            static /*0x1f28a30*/ object GetLocalValue(System.Threading.IAsyncLocal local);
            static /*0x1f28af0*/ void SetLocalValue(System.Threading.IAsyncLocal local, object newValue, bool needChangeNotifications);
            static /*0x1f280ac*/ void OnAsyncLocalContextChanged(System.Threading.ExecutionContext previous, System.Threading.ExecutionContext current);
            static /*0x1f248b4*/ void Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state);
            static /*0x1f28ed0*/ void Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx);
            static /*0x1f29158*/ void RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state);
            static /*0x1f28f4c*/ void RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx);
            static void RunInternal<TState>(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback<TState> callback, ref TState state);
            static void RunInternal<TState>(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback<TState> callback, ref TState state, bool preserveSyncCtx);
            static /*0x1f29458*/ void EstablishCopyOnWriteScope(ref System.Threading.ExecutionContextSwitcher ecsw);
            static /*0x1f2926c*/ void EstablishCopyOnWriteScope(System.Threading.Thread currentThread, bool knownNullWindowsIdentity, ref System.Threading.ExecutionContextSwitcher ecsw);
            static /*0x1f292c4*/ System.Threading.ExecutionContextSwitcher SetExecutionContext(System.Threading.ExecutionContext executionContext, bool preserveSyncCtx);
            static /*0x1f2972c*/ System.Threading.AsyncFlowControl SuppressFlow();
            static /*0x1f286b0*/ void RestoreFlow();
            static /*0x1f2980c*/ bool IsFlowSuppressed();
            static /*0x1f20b5c*/ System.Threading.ExecutionContext Capture();
            static /*0x1f299b8*/ System.Threading.ExecutionContext FastCapture();
            static /*0x1f2983c*/ System.Threading.ExecutionContext Capture(ref System.Threading.StackCrawlMark stackMark, System.Threading.ExecutionContext.CaptureOptions options);
            /*0x1f289f8*/ ExecutionContext();
            /*0x1f28a00*/ ExecutionContext(bool isPreAllocatedDefault);
            /*0x1f29b30*/ ExecutionContext(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f28958*/ bool get_isNewCapture();
            /*0x1f2896c*/ void set_isNewCapture(bool value);
            /*0x1f28988*/ bool get_isFlowSuppressed();
            /*0x1f28584*/ void set_isFlowSuppressed(bool value);
            /*0x1f289ec*/ bool get_IsPreAllocatedDefault();
            /*0x1f28dc4*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
            /*0x1f28e30*/ void set_LogicalCallContext(System.Runtime.Remoting.Messaging.LogicalCallContext value);
            /*0x1f28e38*/ System.Runtime.Remoting.Messaging.IllogicalCallContext get_IllogicalCallContext();
            /*0x1f28ea4*/ void set_IllogicalCallContext(System.Runtime.Remoting.Messaging.IllogicalCallContext value);
            /*0x1f28eac*/ System.Threading.SynchronizationContext get_SynchronizationContext();
            /*0x1f28eb4*/ void set_SynchronizationContext(System.Threading.SynchronizationContext value);
            /*0x1f28ebc*/ System.Threading.SynchronizationContext get_SynchronizationContextNoFlow();
            /*0x1f28ec4*/ void set_SynchronizationContextNoFlow(System.Threading.SynchronizationContext value);
            /*0x1f28ecc*/ void Dispose();
            /*0x1f294f4*/ System.Threading.ExecutionContext CreateCopy();
            /*0x1f29634*/ System.Threading.ExecutionContext CreateMutableCopy();
            /*0x1f29a20*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f291f4*/ bool IsDefaultFTContext(bool ignoreSyncCtx);

            enum Flags
            {
                None = 0,
                IsNewCapture = 1,
                IsFlowSuppressed = 2,
                IsPreAllocatedDefault = 4,
            }

            struct Reader
            {
                /*0x10*/ System.Threading.ExecutionContext m_ec;

                /*0x1f29cc0*/ Reader(System.Threading.ExecutionContext ec);
                /*0x1f29cc8*/ System.Threading.ExecutionContext DangerousGetRawExecutionContext();
                /*0x1f291c8*/ bool get_IsNull();
                /*0x1f291d8*/ bool IsDefaultFTContext(bool ignoreSyncCtx);
                /*0x1f29cd0*/ bool get_IsFlowSuppressed();
                /*0x1f294c4*/ System.Threading.SynchronizationContext get_SynchronizationContext();
                /*0x1f294dc*/ System.Threading.SynchronizationContext get_SynchronizationContextNoFlow();
                /*0x1f29a08*/ System.Runtime.Remoting.Messaging.LogicalCallContext.Reader get_LogicalCallContext();
                /*0x1f29cec*/ System.Runtime.Remoting.Messaging.IllogicalCallContext.Reader get_IllogicalCallContext();
                /*0x1f28a74*/ object GetLocalValue(System.Threading.IAsyncLocal local);
                /*0x1f29244*/ bool HasSameLocalValues(System.Threading.ExecutionContext other);
            }

            enum CaptureOptions
            {
                None = 0,
                IgnoreSyncCtx = 1,
                OptimizeDefaultCase = 2,
            }
        }

        class Monitor
        {
            static /*0x1f24a78*/ void Enter(object obj);
            static /*0x1f218d4*/ void Enter(object obj, ref bool lockTaken);
            static /*0x1f29d04*/ void ThrowLockTakenException();
            static /*0x1f24a7c*/ void Exit(object obj);
            static /*0x1f29d80*/ bool TryEnter(object obj);
            static /*0x1f29db8*/ void TryEnter(object obj, ref bool lockTaken);
            static /*0x1f29e74*/ bool TryEnter(object obj, int millisecondsTimeout);
            static /*0x1f29e90*/ int MillisecondsTimeoutFromTimeSpan(System.TimeSpan timeout);
            static /*0x1f29f44*/ bool TryEnter(object obj, System.TimeSpan timeout);
            static /*0x1f29da0*/ void TryEnter(object obj, int millisecondsTimeout, ref bool lockTaken);
            static /*0x1f29f7c*/ void TryEnter(object obj, System.TimeSpan timeout, ref bool lockTaken);
            static /*0x1f29fb8*/ bool IsEntered(object obj);
            static /*0x1f2a014*/ bool Wait(object obj, int millisecondsTimeout, bool exitContext);
            static /*0x1f2a12c*/ bool Wait(object obj, System.TimeSpan timeout, bool exitContext);
            static /*0x1f21e2c*/ bool Wait(object obj, int millisecondsTimeout);
            static /*0x1f2a15c*/ bool Wait(object obj, System.TimeSpan timeout);
            static /*0x1f2a180*/ bool Wait(object obj);
            static /*0x1f25fcc*/ void Pulse(object obj);
            static /*0x1f21b04*/ void PulseAll(object obj);
            static /*0x1f2a254*/ bool Monitor_test_synchronised(object obj);
            static /*0x1f2a258*/ void Monitor_pulse(object obj);
            static /*0x1f2a18c*/ void ObjPulse(object obj);
            static /*0x1f2a25c*/ void Monitor_pulse_all(object obj);
            static /*0x1f2a1f0*/ void ObjPulseAll(object obj);
            static /*0x1f2a260*/ bool Monitor_wait(object obj, int ms);
            static /*0x1f2a074*/ bool ObjWait(bool exitContext, int millisecondsTimeout, object obj);
            static /*0x1f2a264*/ void try_enter_with_atomic_var(object obj, int millisecondsTimeout, ref bool lockTaken);
            static /*0x1f29dd8*/ void ReliableEnterTimeout(object obj, int timeout, ref bool lockTaken);
            static /*0x1f29d74*/ void ReliableEnter(object obj, ref bool lockTaken);
            static /*0x1f2a268*/ bool Monitor_test_owner(object obj);
            static /*0x1f2a010*/ bool IsEnteredNative(object obj);
        }

        enum SynchronizationContextProperties
        {
            None = 0,
            RequireWaitNotification = 1,
        }

        class SynchronizationContext
        {
            static /*0x0*/ System.Type s_cachedPreparedType1;
            static /*0x8*/ System.Type s_cachedPreparedType2;
            static /*0x10*/ System.Type s_cachedPreparedType3;
            static /*0x18*/ System.Type s_cachedPreparedType4;
            static /*0x20*/ System.Type s_cachedPreparedType5;
            /*0x10*/ System.Threading.SynchronizationContextProperties _props;

            static /*0x1f2a898*/ int WaitHelper(nint[] waitHandles, bool waitAll, int millisecondsTimeout);
            static /*0x1f2a928*/ void SetSynchronizationContext(System.Threading.SynchronizationContext syncContext);
            static /*0x1f2aa3c*/ System.Threading.SynchronizationContext get_Current();
            static /*0x1f2aac8*/ System.Threading.SynchronizationContext get_CurrentNoFlow();
            static /*0x1f2aa7c*/ System.Threading.SynchronizationContext GetThreadLocalContext();
            static /*0x1f2acb8*/ int InvokeWaitMethodHelper(System.Threading.SynchronizationContext syncContext, nint[] waitHandles, bool waitAll, int millisecondsTimeout);
            static /*0x1f2acd8*/ System.Threading.SynchronizationContext get_CurrentExplicit();
            /*0x1f2a26c*/ SynchronizationContext();
            /*0x1f2a274*/ void SetWaitNotificationRequired();
            /*0x1f2a61c*/ bool IsWaitNotificationRequired();
            /*0x1f2a628*/ void Send(System.Threading.SendOrPostCallback d, object state);
            /*0x1f2a650*/ void Post(System.Threading.SendOrPostCallback d, object state);
            /*0x1f2a82c*/ void OperationStarted();
            /*0x1f2a830*/ void OperationCompleted();
            /*0x1f2a834*/ int Wait(nint[] waitHandles, bool waitAll, int millisecondsTimeout);
            /*0x1f2ac5c*/ System.Threading.SynchronizationContext CreateCopy();

            class WaitDelegate : System.MulticastDelegate
            {
                /*0x1f2a544*/ WaitDelegate(object object, nint method);
                /*0x1f2acdc*/ int Invoke(nint[] waitHandles, bool waitAll, int millisecondsTimeout);
            }
        }

        class OSSpecificSynchronizationContext : System.Threading.SynchronizationContext
        {
            static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Threading.OSSpecificSynchronizationContext> s_ContextCache;
            /*0x18*/ object m_OSSynchronizationContext;

            static /*0x1f2b1a4*/ OSSpecificSynchronizationContext();
            static /*0x1f2ab00*/ System.Threading.OSSpecificSynchronizationContext Get();
            static /*0x1f2acf4*/ void InvocationEntry(nint arg);
            static /*0x1f2ae84*/ object GetOSContext();
            static /*0x1f2b178*/ void PostInternal(object osSynchronizationContext, nint callback, nint arg);
            /*0x1f2ae5c*/ OSSpecificSynchronizationContext(object osContext);
            /*0x1f2ae88*/ System.Threading.SynchronizationContext CreateCopy();
            /*0x1f2aef0*/ void Send(System.Threading.SendOrPostCallback d, object state);
            /*0x1f2af30*/ void Post(System.Threading.SendOrPostCallback d, object state);

            class InvocationEntryDelegate : System.MulticastDelegate
            {
                /*0x1f2b088*/ InvocationEntryDelegate(object object, nint method);
                /*0x1f2b230*/ void Invoke(nint arg);
            }

            class InvocationContext
            {
                /*0x10*/ System.Threading.SendOrPostCallback m_Delegate;
                /*0x18*/ object m_State;

                /*0x1f2b14c*/ InvocationContext(System.Threading.SendOrPostCallback d, object state);
                /*0x1f2b17c*/ void Invoke();
            }

            class <>c
            {
                static /*0x0*/ System.Threading.OSSpecificSynchronizationContext.<> <>9;
                static /*0x8*/ System.Runtime.CompilerServices.ConditionalWeakTable.CreateValueCallback<object, System.Threading.OSSpecificSynchronizationContext> <>9__3_0;

                static /*0x1f2b244*/ <>c();
                /*0x1f2b2a8*/ <>c();
                /*0x1f2b2b0*/ System.Threading.OSSpecificSynchronizationContext <Get>b__3_0(object _osContext);
            }
        }

        class InternalCrossContextDelegate : System.MulticastDelegate
        {
            /*0x1f2b314*/ InternalCrossContextDelegate(object object, nint method);
            /*0x1f2b440*/ object Invoke(object[] args);
            /*0x1f2b454*/ System.IAsyncResult BeginInvoke(object[] args, System.AsyncCallback callback, object object);
            /*0x1f2b474*/ object EndInvoke(System.IAsyncResult result);
        }

        class ThreadHelper
        {
            static /*0x0*/ System.Threading.ContextCallback _ccb;
            /*0x10*/ System.Delegate _start;
            /*0x18*/ object _startArg;
            /*0x20*/ System.Threading.ExecutionContext _executionContext;

            static /*0x1f2b7b8*/ ThreadHelper();
            static /*0x1f2b4b0*/ void ThreadStart_Context(object state);
            /*0x1f2b480*/ ThreadHelper(System.Delegate start);
            /*0x1f2b4a8*/ void SetExecutionContextHelper(System.Threading.ExecutionContext ec);
            /*0x1f2b5bc*/ void ThreadStart(object obj);
            /*0x1f2b6c0*/ void ThreadStart();
        }

        class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread
        {
            static /*0x0*/ System.LocalDataStoreMgr s_LocalDataStoreMgr;
            static /*0x8*/ System.Threading.AsyncLocal<System.Globalization.CultureInfo> s_asyncLocalCurrentCulture;
            static /*0x10*/ System.Threading.AsyncLocal<System.Globalization.CultureInfo> s_asyncLocalCurrentUICulture;
            [ThreadStatic] static System.LocalDataStoreHolder s_LocalDataStore;
            [ThreadStatic] static System.Globalization.CultureInfo m_CurrentCulture;
            [ThreadStatic] static System.Globalization.CultureInfo m_CurrentUICulture;
            [ThreadStatic] static System.Threading.Thread current_thread;
            /*0x10*/ System.Threading.InternalThread internal_thread;
            /*0x18*/ object m_ThreadStartArg;
            /*0x20*/ object pending_exception;
            /*0x28*/ System.MulticastDelegate m_Delegate;
            /*0x30*/ System.Threading.ExecutionContext m_ExecutionContext;
            /*0x38*/ bool m_ExecutionContextBelongsToOuterScope;
            /*0x40*/ System.Security.Principal.IPrincipal principal;
            /*0x48*/ int principal_version;

            static /*0x1f2b84c*/ void AsyncLocalSetCurrentCulture(System.Threading.AsyncLocalValueChangedArgs<System.Globalization.CultureInfo> args);
            static /*0x1f2b8ac*/ void AsyncLocalSetCurrentUICulture(System.Threading.AsyncLocalValueChangedArgs<System.Globalization.CultureInfo> args);
            static /*0x1f2c078*/ void ResetAbort();
            static /*0x1f2c2a0*/ void SleepInternal(int millisecondsTimeout);
            static /*0x1f2c2a4*/ void Sleep(int millisecondsTimeout);
            static /*0x1f2c320*/ void Sleep(System.TimeSpan timeout);
            static /*0x1f2c3d8*/ bool YieldInternal();
            static /*0x1f2c3dc*/ bool Yield();
            static /*0x1f2c4c8*/ System.LocalDataStoreSlot AllocateDataSlot();
            static /*0x1f2c580*/ System.LocalDataStoreSlot AllocateNamedDataSlot(string name);
            static /*0x1f2c5a4*/ System.LocalDataStoreSlot GetNamedDataSlot(string name);
            static /*0x1f2c5c8*/ void FreeNamedDataSlot(string name);
            static /*0x1f2c5ec*/ object GetData(System.LocalDataStoreSlot slot);
            static /*0x1f2c674*/ void SetData(System.LocalDataStoreSlot slot, object data);
            static /*0x1f2ca04*/ void nativeInitCultureAccessors();
            static /*0x1f2cd6c*/ void MemoryBarrier();
            static /*0x1f2c4e4*/ System.LocalDataStoreMgr get_LocalDataStoreManager();
            static /*0x1f2cd98*/ byte[] ByteArrayToRootDomain(byte[] arr);
            static /*0x1f2cd9c*/ byte[] ByteArrayToCurrentDomain(byte[] arr);
            static /*0x1f2cda0*/ System.Runtime.Remoting.Contexts.Context get_CurrentContext();
            static /*0x1f2cda8*/ void DeserializePrincipal(System.Threading.Thread th);
            static /*0x1f2d134*/ void SerializePrincipal(System.Threading.Thread th, System.Security.Principal.IPrincipal value);
            static /*0x1f2d6f0*/ System.Security.Principal.IPrincipal get_CurrentPrincipal();
            static /*0x1f2d848*/ void set_CurrentPrincipal(System.Security.Principal.IPrincipal value);
            static /*0x1f2d840*/ System.AppDomain GetDomain();
            static /*0x1f2d998*/ void GetCurrentThread_icall(ref System.Threading.Thread thread);
            static /*0x1f2d99c*/ System.Threading.Thread GetCurrentThread();
            static /*0x1f2a950*/ System.Threading.Thread get_CurrentThread();
            static /*0x1f2d9b8*/ int get_CurrentThreadId();
            static /*0x1f2d9dc*/ int GetDomainID();
            static /*0x1f2dcb0*/ string GetName_internal(System.Threading.InternalThread thread);
            static /*0x1f2dcb4*/ void SetName_icall(System.Threading.InternalThread thread, char* name, int nameLength);
            static /*0x1f2dcb8*/ void SetName_internal(System.Threading.InternalThread thread, string name);
            static /*0x1f2dd50*/ void Abort_internal(System.Threading.InternalThread thread, object stateInfo);
            static /*0x1f2ddb8*/ void SpinWait_nop();
            static /*0x1f2ddbc*/ void SpinWait(int iterations);
            static /*0x1f2dca8*/ void SetState(System.Threading.InternalThread thread, System.Threading.ThreadState set);
            static /*0x1f2dcac*/ void ClrState(System.Threading.InternalThread thread, System.Threading.ThreadState clr);
            static /*0x1f2dc48*/ System.Threading.ThreadState GetState(System.Threading.InternalThread thread);
            static /*0x1f2dde4*/ byte VolatileRead(ref byte address);
            static /*0x1f2dde8*/ double VolatileRead(ref double address);
            static /*0x1f2ddec*/ short VolatileRead(ref short address);
            static /*0x1f2ddf0*/ int VolatileRead(ref int address);
            static /*0x1f2ddf4*/ long VolatileRead(ref long address);
            static /*0x1f2ddf8*/ nint VolatileRead(ref nint address);
            static /*0x1f2ddfc*/ object VolatileRead(ref object address);
            static /*0x1f2de00*/ sbyte VolatileRead(ref sbyte address);
            static /*0x1f2de04*/ float VolatileRead(ref float address);
            static /*0x1f2de08*/ ushort VolatileRead(ref ushort address);
            static /*0x1f2de0c*/ uint VolatileRead(ref uint address);
            static /*0x1f2de10*/ ulong VolatileRead(ref ulong address);
            static /*0x1f2de14*/ nuint VolatileRead(ref nuint address);
            static /*0x1f2de18*/ void VolatileWrite(ref byte address, byte value);
            static /*0x1f2de1c*/ void VolatileWrite(ref double address, double value);
            static /*0x1f2de20*/ void VolatileWrite(ref short address, short value);
            static /*0x1f2de24*/ void VolatileWrite(ref int address, int value);
            static /*0x1f2de28*/ void VolatileWrite(ref long address, long value);
            static /*0x1f2de2c*/ void VolatileWrite(ref nint address, nint value);
            static /*0x1f2de30*/ void VolatileWrite(ref object address, object value);
            static /*0x1f2de34*/ void VolatileWrite(ref sbyte address, sbyte value);
            static /*0x1f2de38*/ void VolatileWrite(ref float address, float value);
            static /*0x1f2de3c*/ void VolatileWrite(ref ushort address, ushort value);
            static /*0x1f2de40*/ void VolatileWrite(ref uint address, uint value);
            static /*0x1f2de44*/ void VolatileWrite(ref ulong address, ulong value);
            static /*0x1f2de48*/ void VolatileWrite(ref nuint address, nuint value);
            static /*0x1f2de4c*/ int SystemMaxStackStize();
            static /*0x1f2c3e0*/ int GetProcessDefaultStackSize(int maxStackSize);
            static /*0x1f2de7c*/ void BeginCriticalRegion();
            static /*0x1f2decc*/ void EndCriticalRegion();
            static /*0x1f2df1c*/ void BeginThreadAffinity();
            static /*0x1f2df20*/ void EndThreadAffinity();
            static /*0x1f2dfbc*/ void GetStackTraces(ref System.Threading.Thread[] threads, ref object[] stack_frames);
            static /*0x1f2dfc0*/ System.Collections.Generic.Dictionary<System.Threading.Thread, System.Diagnostics.StackTrace> Mono_GetStackTraces();
            static /*0x1f2e18c*/ int GetCurrentProcessorId();
            /*0x1f2b90c*/ Thread(System.Threading.ThreadStart start);
            /*0x1f2babc*/ Thread(System.Threading.ThreadStart start, int maxStackSize);
            /*0x1f2bbac*/ Thread(System.Threading.ParameterizedThreadStart start);
            /*0x1f2bc2c*/ Thread(System.Threading.ParameterizedThreadStart start, int maxStackSize);
            /*0x1f2d9e4*/ Thread(System.Threading.InternalThread it);
            /*0x1f2bd1c*/ void Start();
            /*0x1f2be00*/ void Start(object parameter);
            /*0x1f2bd38*/ void Start(ref System.Threading.StackCrawlMark stackMark);
            /*0x1f2aa74*/ System.Threading.ExecutionContext.Reader GetExecutionContextReader();
            /*0x1f2bf44*/ bool get_ExecutionContextBelongsToCurrentScope();
            /*0x1f2bf54*/ void set_ExecutionContextBelongsToCurrentScope(bool value);
            /*0x1f2bf64*/ System.Threading.ExecutionContext get_ExecutionContext();
            /*0x1f2a9ac*/ System.Threading.ExecutionContext GetMutableExecutionContext();
            /*0x1f2bf90*/ void SetExecutionContext(System.Threading.ExecutionContext value, bool belongsToCurrentScope);
            /*0x1f2bfa4*/ void SetExecutionContext(System.Threading.ExecutionContext.Reader value, bool belongsToCurrentScope);
            /*0x1f2bfb8*/ void SetCompressedStack(System.Threading.CompressedStack stack);
            /*0x1f2c018*/ System.Threading.CompressedStack GetCompressedStack();
            /*0x1f2c124*/ void ResetAbortNative();
            /*0x1f2c12c*/ void Suspend();
            /*0x1f2c130*/ void SuspendInternal();
            /*0x1f2c134*/ void Resume();
            /*0x1f2c138*/ void ResumeInternal();
            /*0x1f2c13c*/ void Interrupt();
            /*0x1f2c140*/ void InterruptInternal();
            /*0x1f2c144*/ System.Threading.ThreadPriority get_Priority();
            /*0x1f2c14c*/ void set_Priority(System.Threading.ThreadPriority value);
            /*0x1f2c148*/ int GetPriorityNative();
            /*0x1f2c150*/ void SetPriorityNative(int priority);
            /*0x1f2c154*/ bool JoinInternal(int millisecondsTimeout);
            /*0x1f2c158*/ void Join();
            /*0x1f2c160*/ bool Join(int millisecondsTimeout);
            /*0x1f2c1dc*/ bool Join(System.TimeSpan timeout);
            /*0x1f2b98c*/ void SetStartHelper(System.Delegate start, int maxStackSize);
            /*0x1f2c718*/ System.Globalization.CultureInfo get_CurrentUICulture();
            /*0x1f2c7f0*/ void set_CurrentUICulture(System.Globalization.CultureInfo value);
            /*0x1f2c744*/ System.Globalization.CultureInfo GetCurrentUICultureNoAppX();
            /*0x1f2caa8*/ System.Globalization.CultureInfo get_CurrentCulture();
            /*0x1f2cb80*/ void set_CurrentCulture(System.Globalization.CultureInfo value);
            /*0x1f2cad4*/ System.Globalization.CultureInfo GetCurrentCultureNoAppX();
            /*0x1f2cd70*/ void ConstructInternalThread();
            /*0x1f2cd74*/ System.Threading.InternalThread get_Internal();
            /*0x1f2d9e0*/ bool Thread_internal(System.MulticastDelegate start);
            /*0x1f2da0c*/ void Finalize();
            /*0x1f2da14*/ System.Threading.ApartmentState get_ApartmentState();
            /*0x1f2dac0*/ void set_ApartmentState(System.Threading.ApartmentState value);
            /*0x1f2db98*/ bool get_IsThreadPoolThread();
            /*0x1f2db9c*/ bool get_IsThreadPoolThreadInternal();
            /*0x1f2dbc8*/ void set_IsThreadPoolThreadInternal(bool value);
            /*0x1f2dc04*/ bool get_IsAlive();
            /*0x1f2dc4c*/ bool get_IsBackground();
            /*0x1f2dc60*/ void set_IsBackground(bool value);
            /*0x1f2dcf8*/ string get_Name();
            /*0x1f2dd1c*/ void set_Name(string value);
            /*0x1f2c100*/ System.Threading.ThreadState get_ThreadState();
            /*0x1f2dd54*/ void Abort();
            /*0x1f2dd7c*/ void Abort(object stateInfo);
            /*0x1f2ddb0*/ object GetAbortExceptionState();
            /*0x1f2ddb4*/ object get_AbortReason();
            /*0x1f2c128*/ void ClearAbortReason();
            /*0x1f2bed8*/ void StartInternal(object principal, ref System.Threading.StackCrawlMark stackMark);
            /*0x1f2c48c*/ void SetStart(System.MulticastDelegate start, int maxStackSize);
            /*0x1f2de50*/ int get_ManagedThreadId();
            /*0x1f2df24*/ System.Threading.ApartmentState GetApartmentState();
            /*0x1f2df58*/ void SetApartmentState(System.Threading.ApartmentState state);
            /*0x1f2dae8*/ bool TrySetApartmentState(System.Threading.ApartmentState state);
            /*0x1f2dfb8*/ int GetHashCode();
            /*0x1f2e14c*/ void DisableComObjectEagerCleanup();
            /*0x1f2da48*/ System.Threading.ThreadState ValidateThreadState();
            /*0x1f2e1dc*/ void System.Runtime.InteropServices._Thread.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x1f2e214*/ void System.Runtime.InteropServices._Thread.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x1f2e24c*/ void System.Runtime.InteropServices._Thread.GetTypeInfoCount(ref uint pcTInfo);
            /*0x1f2e284*/ void System.Runtime.InteropServices._Thread.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        }

        enum StackCrawlMark
        {
            LookForMe = 0,
            LookForMyCaller = 1,
            LookForMyCallersCaller = 2,
            LookForThread = 3,
        }

        class ThreadAbortException : System.SystemException
        {
            /*0x1f2e2bc*/ ThreadAbortException();
            /*0x1f2e338*/ ThreadAbortException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f2e340*/ object get_ExceptionState();
        }

        class ThreadInterruptedException : System.SystemException
        {
            /*0x1f2e358*/ ThreadInterruptedException();
            /*0x1f2e3d4*/ ThreadInterruptedException(string message);
            /*0x1f2e3fc*/ ThreadInterruptedException(string message, System.Exception innerException);
            /*0x1f2e424*/ ThreadInterruptedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        interface IThreadPoolWorkItem
        {
            void ExecuteWorkItem();
            void MarkAborted(System.Threading.ThreadAbortException tae);
        }

        class WaitCallback : System.MulticastDelegate
        {
            /*0x1f2a6d8*/ WaitCallback(object object, nint method);
            /*0x1f2e42c*/ void Invoke(object state);
            /*0x1f2e440*/ System.IAsyncResult BeginInvoke(object state, System.AsyncCallback callback, object object);
            /*0x1f2e460*/ void EndInvoke(System.IAsyncResult result);
        }

        class WaitOrTimerCallback : System.MulticastDelegate
        {
            /*0x1f2e46c*/ WaitOrTimerCallback(object object, nint method);
            /*0x1f2e59c*/ void Invoke(object state, bool timedOut);
            /*0x1f2e5b4*/ System.IAsyncResult BeginInvoke(object state, bool timedOut, System.AsyncCallback callback, object object);
            /*0x1f2e64c*/ void EndInvoke(System.IAsyncResult result);
        }

        class IOCompletionCallback : System.MulticastDelegate
        {
            /*0x1f2e658*/ IOCompletionCallback(object object, nint method);
            /*0x1f2e71c*/ void Invoke(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP);
            /*0x1f2e730*/ System.IAsyncResult BeginInvoke(uint errorCode, uint numBytes, System.Threading.NativeOverlapped* pOVERLAP, System.AsyncCallback callback, object object);
            /*0x1f2e7d4*/ void EndInvoke(System.IAsyncResult result);
        }

        class ThreadPoolGlobals
        {
            static uint tpQuantum = 30;
            static /*0x0*/ int processorCount;
            static /*0x4*/ bool vmTpInitialized;
            static /*0x5*/ bool enableWorkerTracking;
            static /*0x8*/ System.Threading.ThreadPoolWorkQueue workQueue;

            static /*0x1f2e7f0*/ ThreadPoolGlobals();
            static /*0x1f2e7e0*/ bool get_tpHosted();
        }

        class ThreadPoolWorkQueue
        {
            static /*0x0*/ System.Threading.ThreadPoolWorkQueue.SparseArray<System.Threading.ThreadPoolWorkQueue.WorkStealingQueue> allThreadQueues;
            /*0x10*/ System.Threading.ThreadPoolWorkQueue.QueueSegment queueHead;
            /*0x18*/ System.Threading.ThreadPoolWorkQueue.QueueSegment queueTail;
            /*0x20*/ int numOutstandingThreadRequests;

            static /*0x1f2ff04*/ ThreadPoolWorkQueue();
            static /*0x1f2faac*/ bool Dispatch();
            /*0x1f2e878*/ ThreadPoolWorkQueue();
            /*0x1f2e948*/ System.Threading.ThreadPoolWorkQueueThreadLocals EnsureCurrentThreadHasQueue();
            /*0x1f2eae4*/ void EnsureThreadRequested();
            /*0x1f2eb84*/ void MarkThreadRequestSatisfied();
            /*0x1f2ebcc*/ void Enqueue(System.Threading.IThreadPoolWorkItem callback, bool forceGlobal);
            /*0x1f2f1f8*/ bool LocalFindAndPop(System.Threading.IThreadPoolWorkItem callback);
            /*0x1f2f530*/ void Dequeue(System.Threading.ThreadPoolWorkQueueThreadLocals tl, ref System.Threading.IThreadPoolWorkItem callback, ref bool missedSteal);

            class SparseArray<T>
            {
                /*0x0*/ T[] m_array;

                SparseArray(int initialSize);
                T[] get_Current();
                int Add(T e);
                void Remove(T e);
            }

            class WorkStealingQueue
            {
                /*0x10*/ System.Threading.IThreadPoolWorkItem[] m_array;
                /*0x18*/ int m_mask;
                /*0x1c*/ int m_headIndex;
                /*0x20*/ int m_tailIndex;
                /*0x24*/ System.Threading.SpinLock m_foreignLock;

                /*0x1f301e4*/ WorkStealingQueue();
                /*0x1f2ecfc*/ void LocalPush(System.Threading.IThreadPoolWorkItem obj);
                /*0x1f2f268*/ bool LocalFindAndPop(System.Threading.IThreadPoolWorkItem obj);
                /*0x1f2f6f8*/ bool LocalPop(ref System.Threading.IThreadPoolWorkItem obj);
                /*0x1f2faa4*/ bool TrySteal(ref System.Threading.IThreadPoolWorkItem obj, ref bool missedSteal);
                /*0x1f2ff98*/ bool TrySteal(ref System.Threading.IThreadPoolWorkItem obj, ref bool missedSteal, int millisecondsTimeout);
            }

            class QueueSegment
            {
                /*0x10*/ System.Threading.IThreadPoolWorkItem[] nodes;
                /*0x18*/ int indexes;
                /*0x20*/ System.Threading.ThreadPoolWorkQueue.QueueSegment Next;

                /*0x1f2e8ec*/ QueueSegment();
                /*0x1f30278*/ void GetIndexes(ref int upper, ref int lower);
                /*0x1f302ac*/ bool CompareExchangeIndexes(ref int prevUpper, int newUpper, ref int prevLower, int newLower);
                /*0x1f2fa60*/ bool IsUsedUp();
                /*0x1f2f148*/ bool TryEnqueue(System.Threading.IThreadPoolWorkItem node);
                /*0x1f2f974*/ bool TryDequeue(ref System.Threading.IThreadPoolWorkItem node);
            }
        }

        class ThreadPoolWorkQueueThreadLocals
        {
            [ThreadStatic] static System.Threading.ThreadPoolWorkQueueThreadLocals threadLocals;
            /*0x10*/ System.Threading.ThreadPoolWorkQueue workQueue;
            /*0x18*/ System.Threading.ThreadPoolWorkQueue.WorkStealingQueue workStealingQueue;
            /*0x20*/ System.Random random;

            /*0x1f2e9d4*/ ThreadPoolWorkQueueThreadLocals(System.Threading.ThreadPoolWorkQueue tpq);
            /*0x1f30314*/ void CleanUp();
            /*0x1f303e0*/ void Finalize();
        }

        class _ThreadPoolWaitCallback
        {
            static /*0x1f304ac*/ bool PerformWaitCallback();
        }

        class QueueUserWorkItemCallback : System.Threading.IThreadPoolWorkItem
        {
            static /*0x0*/ System.Threading.ContextCallback ccb;
            /*0x10*/ System.Threading.WaitCallback callback;
            /*0x18*/ System.Threading.ExecutionContext context;
            /*0x20*/ object state;

            static /*0x1f30740*/ QueueUserWorkItemCallback();
            static /*0x1f306c8*/ void WaitCallback_Context(object state);
            /*0x1f304f8*/ QueueUserWorkItemCallback(System.Threading.WaitCallback waitCallback, object stateObj, bool compressStack, ref System.Threading.StackCrawlMark stackMark);
            /*0x1f305b0*/ QueueUserWorkItemCallback(System.Threading.WaitCallback waitCallback, object stateObj, System.Threading.ExecutionContext ec);
            /*0x1f305ec*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
            /*0x1f306c4*/ void System.Threading.IThreadPoolWorkItem.MarkAborted(System.Threading.ThreadAbortException tae);
        }

        class _ThreadPoolWaitOrTimerCallback
        {
            static /*0x0*/ System.Threading.ContextCallback _ccbt;
            static /*0x8*/ System.Threading.ContextCallback _ccbf;
            /*0x10*/ System.Threading.WaitOrTimerCallback _waitOrTimerCallback;
            /*0x18*/ System.Threading.ExecutionContext _executionContext;
            /*0x20*/ object _state;

            static /*0x1f307d4*/ _ThreadPoolWaitOrTimerCallback();
            static /*0x1f30960*/ void WaitOrTimerCallback_Context_t(object state);
            static /*0x1f30a54*/ void WaitOrTimerCallback_Context_f(object state);
            static /*0x1f309b8*/ void WaitOrTimerCallback_Context(object state, bool timedOut);
            static /*0x1f30aac*/ void PerformWaitOrTimerCallback(object state, bool timedOut);
            /*0x1f308a8*/ _ThreadPoolWaitOrTimerCallback(System.Threading.WaitOrTimerCallback waitOrTimerCallback, object state, bool compressStack, ref System.Threading.StackCrawlMark stackMark);
        }

        class ThreadPool
        {
            static /*0x1f30d58*/ bool SetMaxThreads(int workerThreads, int completionPortThreads);
            static /*0x1f30d60*/ void GetMaxThreads(ref int workerThreads, ref int completionPortThreads);
            static /*0x1f30d68*/ bool SetMinThreads(int workerThreads, int completionPortThreads);
            static /*0x1f30d70*/ void GetMinThreads(ref int workerThreads, ref int completionPortThreads);
            static /*0x1f30d78*/ void GetAvailableThreads(ref int workerThreads, ref int completionPortThreads);
            static /*0x1f30d80*/ System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
            static /*0x1f30f60*/ System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);
            static /*0x1f30d8c*/ System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce, ref System.Threading.StackCrawlMark stackMark, bool compressStack);
            static /*0x1f31048*/ System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
            static /*0x1f310cc*/ System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
            static /*0x1f31150*/ System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
            static /*0x1f311d4*/ System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
            static /*0x1f31258*/ System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, System.TimeSpan timeout, bool executeOnlyOnce);
            static /*0x1f3134c*/ System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, System.TimeSpan timeout, bool executeOnlyOnce);
            static /*0x1f2a804*/ bool QueueUserWorkItem(System.Threading.WaitCallback callBack, object state);
            static /*0x1f31560*/ bool QueueUserWorkItem(System.Threading.WaitCallback callBack);
            static /*0x1f31020*/ bool UnsafeQueueUserWorkItem(System.Threading.WaitCallback callBack, object state);
            static bool QueueUserWorkItem<TState>(System.Action<TState> callBack, TState state, bool preferLocal);
            static bool UnsafeQueueUserWorkItem<TState>(System.Action<TState> callBack, TState state, bool preferLocal);
            static /*0x1f31440*/ bool QueueUserWorkItemHelper(System.Threading.WaitCallback callBack, object state, ref System.Threading.StackCrawlMark stackMark, bool compressStack, bool forceGlobal);
            static /*0x1f31620*/ void UnsafeQueueCustomWorkItem(System.Threading.IThreadPoolWorkItem workItem, bool forceGlobal);
            static /*0x1f3169c*/ bool TryPopCustomWorkItem(System.Threading.IThreadPoolWorkItem workItem);
            static /*0x1f31738*/ System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem> GetQueuedWorkItems();
            static /*0x1f31800*/ System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem> EnumerateQueuedWorkItems(System.Threading.ThreadPoolWorkQueue.WorkStealingQueue[] wsQueues, System.Threading.ThreadPoolWorkQueue.QueueSegment globalQueueTail);
            static /*0x1f318bc*/ System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem> GetLocallyQueuedWorkItems();
            static /*0x1f31978*/ System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem> GetGloballyQueuedWorkItems();
            static /*0x1f319e8*/ object[] ToObjectArray(System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem> workitems);
            static /*0x1f31f80*/ object[] GetQueuedWorkItemsForDebugger();
            static /*0x1f31f90*/ object[] GetGloballyQueuedWorkItemsForDebugger();
            static /*0x1f31fa0*/ object[] GetLocallyQueuedWorkItemsForDebugger();
            static /*0x1f2eb80*/ bool RequestWorkerThread();
            static /*0x1f31fb0*/ bool PostQueuedCompletionStatus(System.Threading.NativeOverlapped* overlapped);
            static /*0x1f31fb4*/ bool UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped* overlapped);
            static /*0x1f3158c*/ void EnsureVMInitialized();
            static /*0x1f30d6c*/ bool SetMinThreadsNative(int workerThreads, int completionPortThreads);
            static /*0x1f30d5c*/ bool SetMaxThreadsNative(int workerThreads, int completionPortThreads);
            static /*0x1f30d74*/ void GetMinThreadsNative(ref int workerThreads, ref int completionPortThreads);
            static /*0x1f30d64*/ void GetMaxThreadsNative(ref int workerThreads, ref int completionPortThreads);
            static /*0x1f30d7c*/ void GetAvailableThreadsNative(ref int workerThreads, ref int completionPortThreads);
            static /*0x1f2ff00*/ bool NotifyWorkItemComplete();
            static /*0x1f32008*/ void ReportThreadStatus(bool isWorking);
            static /*0x1f32010*/ void NotifyWorkItemProgress();
            static /*0x1f32020*/ void NotifyWorkItemProgressNative();
            static /*0x1f2f1f4*/ void NotifyWorkItemQueued();
            static /*0x1f2e7e8*/ bool IsThreadPoolHosted();
            static /*0x1f32004*/ void InitializeVMTp(ref bool enableWorkerTracking);
            static /*0x1f32024*/ bool BindHandle(nint osHandle);
            static /*0x1f32034*/ bool BindHandle(System.Runtime.InteropServices.SafeHandle osHandle);
            static /*0x1f3202c*/ bool BindIOCompletionCallbackNative(nint fileHandle);
            static /*0x1f3214c*/ bool get_IsThreadPoolThread();

            class <>c__DisplayClass17_0<TState>
            {
                /*0x0*/ System.Action<TState> callBack;

                <>c__DisplayClass17_0();
                void <QueueUserWorkItem>b__0(object x);
            }

            class <>c__DisplayClass18_0<TState>
            {
                /*0x0*/ System.Action<TState> callBack;

                <>c__DisplayClass18_0();
                void <UnsafeQueueUserWorkItem>b__0(object x);
            }

            class <EnumerateQueuedWorkItems>d__23 : System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Threading.IThreadPoolWorkItem>, System.IDisposable, System.Collections.IEnumerator
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Threading.IThreadPoolWorkItem <>2__current;
                /*0x20*/ int <>l__initialThreadId;
                /*0x28*/ System.Threading.ThreadPoolWorkQueue.WorkStealingQueue[] wsQueues;
                /*0x30*/ System.Threading.ThreadPoolWorkQueue.WorkStealingQueue[] <>3__wsQueues;
                /*0x38*/ System.Threading.ThreadPoolWorkQueue.QueueSegment globalQueueTail;
                /*0x40*/ System.Threading.ThreadPoolWorkQueue.QueueSegment <>3__globalQueueTail;
                /*0x48*/ System.Threading.ThreadPoolWorkQueue.WorkStealingQueue[] <>7__wrap1;
                /*0x50*/ int <>7__wrap2;
                /*0x58*/ System.Threading.IThreadPoolWorkItem[] <items>5__4;
                /*0x60*/ int <i>5__5;
                /*0x68*/ System.Threading.ThreadPoolWorkQueue.QueueSegment <segment>5__6;

                /*0x1f31888*/ <EnumerateQueuedWorkItems>d__23(int <>1__state);
                /*0x1f32164*/ void System.IDisposable.Dispose();
                /*0x1f32168*/ bool MoveNext();
                /*0x1f32310*/ System.Threading.IThreadPoolWorkItem System.Collections.Generic.IEnumerator<System.Threading.IThreadPoolWorkItem>.get_Current();
                /*0x1f32318*/ void System.Collections.IEnumerator.Reset();
                /*0x1f32358*/ object System.Collections.IEnumerator.get_Current();
                /*0x1f32360*/ System.Collections.Generic.IEnumerator<System.Threading.IThreadPoolWorkItem> System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem>.GetEnumerator();
                /*0x1f3240c*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            }
        }

        class WaitHandle : System.MarshalByRefObject, System.IDisposable
        {
            static int WaitTimeout = 258;
            static int MAX_WAITHANDLES = 64;
            static int WAIT_OBJECT_0 = 0;
            static int WAIT_ABANDONED = 128;
            static int WAIT_FAILED = 2147483647;
            static int ERROR_TOO_MANY_POSTS = 298;
            static int ERROR_NOT_OWNED_BY_CALLER = 299;
            static int MaxWaitHandles = 64;
            static /*0x0*/ nint InvalidHandle;
            /*0x18*/ nint waitHandle;
            /*0x20*/ Microsoft.Win32.SafeHandles.SafeWaitHandle safeWaitHandle;
            /*0x28*/ bool hasThreadAffinity;

            static /*0x1f342b4*/ WaitHandle();
            static /*0x1f3297c*/ bool InternalWaitOne(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, long millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
            static /*0x1f32d64*/ bool WaitAll(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
            static /*0x1f333c4*/ bool WaitAll(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout, bool exitContext);
            static /*0x1f334d4*/ bool WaitAll(System.Threading.WaitHandle[] waitHandles);
            static /*0x1f33530*/ bool WaitAll(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);
            static /*0x1f33598*/ bool WaitAll(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout);
            static /*0x1f33600*/ int WaitAny(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
            static /*0x1f3395c*/ int WaitAny(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout, bool exitContext);
            static /*0x1f33a68*/ int WaitAny(System.Threading.WaitHandle[] waitHandles, System.TimeSpan timeout);
            static /*0x1f33ad0*/ int WaitAny(System.Threading.WaitHandle[] waitHandles);
            static /*0x1f33b2c*/ int WaitAny(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);
            static /*0x1f33b94*/ bool SignalAndWait(System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);
            static /*0x1f33e34*/ bool SignalAndWait(System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, System.TimeSpan timeout, bool exitContext);
            static /*0x1f33c00*/ bool SignalAndWait(System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
            static /*0x1f32c24*/ void ThrowAbandonedMutexException();
            static /*0x1f33908*/ void ThrowAbandonedMutexException(int location, System.Threading.WaitHandle handle);
            static /*0x1f32a70*/ int WaitOneNative(System.Runtime.InteropServices.SafeHandle waitableSafeHandle, uint millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
            static /*0x1f33008*/ int WaitMultiple(System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext, bool WaitAll);
            static /*0x1f2a920*/ int Wait_internal(nint* handles, int numHandles, bool waitAll, int ms);
            static /*0x1f33f4c*/ int SignalAndWaitOne(Microsoft.Win32.SafeHandles.SafeWaitHandle waitHandleToSignal, Microsoft.Win32.SafeHandles.SafeWaitHandle waitHandleToWaitOn, int millisecondsTimeout, bool hasThreadAffinity, bool exitContext);
            static /*0x1f34204*/ int SignalAndWait_Internal(nint toSignal, nint toWaitOn, int ms);
            static /*0x1f34208*/ int ToTimeoutMilliseconds(System.TimeSpan timeout);
            /*0x1f32410*/ WaitHandle();
            /*0x1f3242c*/ void Init();
            /*0x1f32498*/ nint get_Handle();
            /*0x1f32518*/ void set_Handle(nint value);
            /*0x1f32604*/ Microsoft.Win32.SafeHandles.SafeWaitHandle get_SafeWaitHandle();
            /*0x1f326bc*/ void set_SafeWaitHandle(Microsoft.Win32.SafeHandles.SafeWaitHandle value);
            /*0x1f32744*/ void SetHandleInternal(Microsoft.Win32.SafeHandles.SafeWaitHandle handle);
            /*0x1f32778*/ bool WaitOne(int millisecondsTimeout, bool exitContext);
            /*0x1f3287c*/ bool WaitOne(System.TimeSpan timeout, bool exitContext);
            /*0x1f32948*/ bool WaitOne();
            /*0x1f3295c*/ bool WaitOne(int millisecondsTimeout);
            /*0x1f3296c*/ bool WaitOne(System.TimeSpan timeout);
            /*0x1f327fc*/ bool WaitOne(long timeout, bool exitContext);
            /*0x1f32c64*/ bool WaitOneWithoutFAS();
            /*0x1f340dc*/ void Close();
            /*0x1f3414c*/ void Dispose(bool explicitDisposing);
            /*0x1f34194*/ void Dispose();

            enum OpenExistingResult
            {
                Success = 0,
                NameNotFound = 1,
                PathNotFound = 2,
                NameInvalid = 3,
            }
        }

        class WaitHandleExtensions
        {
            static /*0x1f34308*/ Microsoft.Win32.SafeHandles.SafeWaitHandle GetSafeWaitHandle(System.Threading.WaitHandle waitHandle);
            static /*0x1f34360*/ void SetSafeWaitHandle(System.Threading.WaitHandle waitHandle, Microsoft.Win32.SafeHandles.SafeWaitHandle value);
        }

        class CompressedStack : System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ System.Collections.ArrayList _list;

            static /*0x1f3455c*/ System.Threading.CompressedStack Capture();
            static /*0x1f3459c*/ System.Threading.CompressedStack GetCompressedStack();
            static /*0x1f34634*/ void Run(System.Threading.CompressedStack compressedStack, System.Threading.ContextCallback callback, object state);
            /*0x1f343b8*/ CompressedStack(int length);
            /*0x1f34434*/ CompressedStack(System.Threading.CompressedStack cs);
            /*0x1f34774*/ CompressedStack();
            /*0x1f344fc*/ System.Threading.CompressedStack CreateCopy();
            /*0x1f345dc*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f34674*/ bool Equals(System.Threading.CompressedStack cs);
            /*0x1f34738*/ bool IsEmpty();
            /*0x1f3476c*/ System.Collections.IList get_List();
        }

        class HostExecutionContext : System.IDisposable
        {
            /*0x10*/ object _state;

            /*0x1f347ac*/ HostExecutionContext();
            /*0x1f347c8*/ HostExecutionContext(object state);
            /*0x1f347f0*/ System.Threading.HostExecutionContext CreateCopy();
            /*0x1f34858*/ object get_State();
            /*0x1f34860*/ void set_State(object value);
            /*0x1f34868*/ void Dispose();
            /*0x1f348d4*/ void Dispose(bool disposing);
        }

        class HostExecutionContextManager
        {
            /*0x1f348d8*/ HostExecutionContextManager();
            /*0x1f348e0*/ System.Threading.HostExecutionContext Capture();
            /*0x1f34920*/ void Revert(object previousState);
            /*0x1f34960*/ object SetHostExecutionContext(System.Threading.HostExecutionContext hostExecutionContext);
        }

        class Interlocked
        {
            static /*0x1f2eb7c*/ int CompareExchange(ref int location1, int value, int comparand);
            static /*0x1f349a0*/ int CompareExchange(ref int location1, int value, int comparand, ref bool succeeded);
            static /*0x1f349a4*/ void CompareExchange(ref object location1, ref object value, ref object comparand, ref object result);
            static /*0x1f349a8*/ object CompareExchange(ref object location1, object value, object comparand);
            static /*0x1f349d4*/ float CompareExchange(ref float location1, float value, float comparand);
            static /*0x1f349d8*/ int Decrement(ref int location);
            static /*0x1f349dc*/ long Decrement(ref long location);
            static /*0x1f349e0*/ int Increment(ref int location);
            static /*0x1f349e4*/ long Increment(ref long location);
            static /*0x1f2ff94*/ int Exchange(ref int location1, int value);
            static /*0x1f349e8*/ void Exchange(ref object location1, ref object value, ref object result);
            static /*0x1f349ec*/ object Exchange(ref object location1, object value);
            static /*0x1f34a10*/ float Exchange(ref float location1, float value);
            static /*0x1f34a14*/ long CompareExchange(ref long location1, long value, long comparand);
            static /*0x1f34a18*/ nint CompareExchange(ref nint location1, nint value, nint comparand);
            static /*0x1f34a1c*/ double CompareExchange(ref double location1, double value, double comparand);
            static T CompareExchange<T>(ref T location1, T value, T comparand);
            static /*0x1f34a20*/ long Exchange(ref long location1, long value);
            static /*0x1f34a24*/ nint Exchange(ref nint location1, nint value);
            static /*0x1f34a28*/ double Exchange(ref double location1, double value);
            static T Exchange<T>(ref T location1, T value);
            static /*0x1f34a2c*/ long Read(ref long location);
            static /*0x1f34a30*/ int Add(ref int location1, int value);
            static /*0x1f34a34*/ long Add(ref long location1, long value);
            static /*0x1f34a38*/ void MemoryBarrier();
            static /*0x1f34a3c*/ void MemoryBarrierProcessWide();
            static /*0x1f34a40*/ void SpeculationBarrier();
        }

        struct LockCookie
        {
            /*0x10*/ int ThreadId;
            /*0x14*/ int ReaderLocks;
            /*0x18*/ int WriterLocks;

            static /*0x1f34bcc*/ bool op_Equality(System.Threading.LockCookie a, System.Threading.LockCookie b);
            static /*0x1f34bfc*/ bool op_Inequality(System.Threading.LockCookie a, System.Threading.LockCookie b);
            /*0x1f34a78*/ LockCookie(int thread_id);
            /*0x1f34a84*/ LockCookie(int thread_id, int reader_locks, int writer_locks);
            /*0x1f34a90*/ int GetHashCode();
            /*0x1f34afc*/ bool Equals(System.Threading.LockCookie obj);
            /*0x1f34b34*/ bool Equals(object obj);
        }

        class LockQueue
        {
            /*0x10*/ System.Threading.ReaderWriterLock rwlock;
            /*0x18*/ int lockCount;

            /*0x1f34c2c*/ LockQueue(System.Threading.ReaderWriterLock rwlock);
            /*0x1f34c54*/ bool Wait(int timeout);
            /*0x1f34e08*/ bool get_IsEmpty();
            /*0x1f34ec8*/ void Pulse();
        }

        class Mutex : System.Threading.WaitHandle
        {
            static /*0x1f34f80*/ nint CreateMutex_icall(bool initiallyOwned, char* name, int name_length, ref bool created);
            static /*0x1f34f88*/ nint OpenMutex_icall(char* name, int name_length, System.Security.AccessControl.MutexRights rights, ref System.IO.MonoIOError error);
            static /*0x1f34f8c*/ bool ReleaseMutex_internal(nint handle);
            static /*0x1f34f90*/ nint CreateMutex_internal(bool initiallyOwned, string name, ref bool created);
            static /*0x1f34fd8*/ nint OpenMutex_internal(string name, System.Security.AccessControl.MutexRights rights, ref System.IO.MonoIOError error);
            static /*0x1f352e8*/ System.Threading.Mutex OpenExisting(string name);
            static /*0x1f35328*/ System.Threading.Mutex OpenExisting(string name, System.Security.AccessControl.MutexRights rights);
            static /*0x1f35368*/ bool TryOpenExisting(string name, ref System.Threading.Mutex result);
            static /*0x1f353a8*/ bool TryOpenExisting(string name, System.Security.AccessControl.MutexRights rights, ref System.Threading.Mutex result);
            /*0x1f35020*/ Mutex(nint handle);
            /*0x1f350a0*/ Mutex();
            /*0x1f35138*/ Mutex(bool initiallyOwned);
            /*0x1f351d4*/ Mutex(bool initiallyOwned, string name);
            /*0x1f35230*/ Mutex(bool initiallyOwned, string name, ref bool createdNew);
            /*0x1f3528c*/ Mutex(bool initiallyOwned, string name, ref bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);
            /*0x1f353e8*/ void ReleaseMutex();
            /*0x1f35454*/ System.Security.AccessControl.MutexSecurity GetAccessControl();
            /*0x1f3548c*/ void SetAccessControl(System.Security.AccessControl.MutexSecurity mutexSecurity);
        }

        class NativeEventCalls
        {
            static /*0x1f354c4*/ nint CreateEvent_internal(bool manual, bool initial, string name, ref int errorCode);
            static /*0x1f3551c*/ nint CreateEvent_icall(bool manual, bool initial, char* name, int name_length, ref int errorCode);
            static /*0x1f35528*/ bool SetEvent(Microsoft.Win32.SafeHandles.SafeWaitHandle handle);
            static /*0x1f35608*/ bool SetEvent_internal(nint handle);
            static /*0x1f3560c*/ bool ResetEvent(Microsoft.Win32.SafeHandles.SafeWaitHandle handle);
            static /*0x1f356ec*/ bool ResetEvent_internal(nint handle);
            static /*0x1f356f0*/ void CloseEvent_internal(nint handle);
        }

        class Overlapped
        {
            /*0x10*/ System.IAsyncResult ares;
            /*0x18*/ int offsetL;
            /*0x1c*/ int offsetH;
            /*0x20*/ int evt;
            /*0x28*/ nint evt_ptr;

            static /*0x1f35784*/ void Free(System.Threading.NativeOverlapped* nativeOverlappedPtr);
            static /*0x1f35874*/ System.Threading.Overlapped Unpack(System.Threading.NativeOverlapped* nativeOverlappedPtr);
            /*0x1f356f4*/ Overlapped();
            /*0x1f356fc*/ Overlapped(int offsetLo, int offsetHi, int hEvent, System.IAsyncResult ar);
            /*0x1f35740*/ Overlapped(int offsetLo, int offsetHi, nint hEvent, System.IAsyncResult ar);
            /*0x1f35974*/ System.Threading.NativeOverlapped* Pack(System.Threading.IOCompletionCallback iocb);
            /*0x1f35a60*/ System.Threading.NativeOverlapped* Pack(System.Threading.IOCompletionCallback iocb, object userData);
            /*0x1f35b3c*/ System.Threading.NativeOverlapped* UnsafePack(System.Threading.IOCompletionCallback iocb);
            /*0x1f35b40*/ System.Threading.NativeOverlapped* UnsafePack(System.Threading.IOCompletionCallback iocb, object userData);
            /*0x1f35b44*/ System.IAsyncResult get_AsyncResult();
            /*0x1f35b4c*/ void set_AsyncResult(System.IAsyncResult value);
            /*0x1f35b54*/ int get_EventHandle();
            /*0x1f35b5c*/ void set_EventHandle(int value);
            /*0x1f35b64*/ nint get_EventHandleIntPtr();
            /*0x1f35b6c*/ void set_EventHandleIntPtr(nint value);
            /*0x1f35b74*/ int get_OffsetHigh();
            /*0x1f35b7c*/ void set_OffsetHigh(int value);
            /*0x1f35b84*/ int get_OffsetLow();
            /*0x1f35b8c*/ void set_OffsetLow(int value);
        }

        class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
        {
            /*0x10*/ int seq_num;
            /*0x14*/ int state;
            /*0x18*/ int readers;
            /*0x1c*/ int writer_lock_owner;
            /*0x20*/ System.Threading.LockQueue writer_queue;
            /*0x28*/ System.Collections.Hashtable reader_locks;

            /*0x1f35b94*/ ReaderWriterLock();
            /*0x1f35c68*/ void Finalize();
            /*0x1f35c70*/ bool get_IsReaderLockHeld();
            /*0x1f35d9c*/ bool get_IsWriterLockHeld();
            /*0x1f35e74*/ int get_WriterSeqNum();
            /*0x1f35f2c*/ void AcquireReaderLock(int millisecondsTimeout);
            /*0x1f35f34*/ void AcquireReaderLock(int millisecondsTimeout, int initialLockCount);
            /*0x1f36490*/ void AcquireReaderLock(System.TimeSpan timeout);
            /*0x1f36554*/ void AcquireWriterLock(int millisecondsTimeout);
            /*0x1f362f0*/ void AcquireWriterLock(int millisecondsTimeout, int initialLockCount);
            /*0x1f3655c*/ void AcquireWriterLock(System.TimeSpan timeout);
            /*0x1f3657c*/ bool AnyWritersSince(int seqNum);
            /*0x1f36640*/ void DowngradeFromWriterLock(ref System.Threading.LockCookie lockCookie);
            /*0x1f36840*/ System.Threading.LockCookie ReleaseLock();
            /*0x1f36be0*/ void ReleaseReaderLock();
            /*0x1f36ac4*/ void ReleaseReaderLock(int currentCount, int releaseCount);
            /*0x1f36dc4*/ void ReleaseWriterLock();
            /*0x1f36a64*/ void ReleaseWriterLock(int releaseCount);
            /*0x1f36ef0*/ void RestoreLock(ref System.Threading.LockCookie lockCookie);
            /*0x1f36fd4*/ System.Threading.LockCookie UpgradeToWriterLock(int millisecondsTimeout);
            /*0x1f3715c*/ System.Threading.LockCookie UpgradeToWriterLock(System.TimeSpan timeout);
            /*0x1f3696c*/ System.Threading.LockCookie GetLockCookie();
            /*0x1f362c0*/ bool HasWriterLock();
            /*0x1f364b0*/ int CheckTimeout(System.TimeSpan timeout);
        }

        class RegisteredWaitHandle : System.MarshalByRefObject
        {
            /*0x18*/ System.Threading.WaitHandle _waitObject;
            /*0x20*/ System.Threading.WaitOrTimerCallback _callback;
            /*0x28*/ object _state;
            /*0x30*/ System.Threading.WaitHandle _finalEvent;
            /*0x38*/ System.Threading.ManualResetEvent _cancelEvent;
            /*0x40*/ System.TimeSpan _timeout;
            /*0x48*/ int _callsInProcess;
            /*0x4c*/ bool _executeOnlyOnce;
            /*0x4d*/ bool _unregistered;

            /*0x1f30f6c*/ RegisteredWaitHandle(System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callback, object state, System.TimeSpan timeout, bool executeOnlyOnce);
            /*0x1f378a4*/ RegisteredWaitHandle();
            /*0x1f37180*/ void Wait(object state);
            /*0x1f376ac*/ void DoCallBack(object timedOut);
            /*0x1f377b0*/ bool Unregister(System.Threading.WaitHandle waitObject);
        }

        class InternalThread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject
        {
            /*0x10*/ int lock_thread_id;
            /*0x18*/ nint handle;
            /*0x20*/ nint native_handle;
            /*0x28*/ nint name_chars;
            /*0x30*/ int name_free;
            /*0x34*/ int name_length;
            /*0x38*/ System.Threading.ThreadState state;
            /*0x40*/ object abort_exc;
            /*0x48*/ int abort_state_handle;
            /*0x50*/ long thread_id;
            /*0x58*/ nint debugger_thread;
            /*0x60*/ nuint static_data;
            /*0x68*/ nint runtime_thread_info;
            /*0x70*/ object current_appcontext;
            /*0x78*/ object root_domain_thread;
            /*0x80*/ byte[] _serialized_principal;
            /*0x88*/ int _serialized_principal_version;
            /*0x90*/ nint appdomain_refs;
            /*0x98*/ int interruption_requested;
            /*0xa0*/ nint longlived;
            /*0xa8*/ bool threadpool_thread;
            /*0xa9*/ bool thread_interrupt_requested;
            /*0xac*/ int stack_size;
            /*0xb0*/ byte apartment_state;
            /*0xb4*/ int critical_region_level;
            /*0xb8*/ int managed_id;
            /*0xbc*/ int small_id;
            /*0xc0*/ nint manage_callback;
            /*0xc8*/ nint flags;
            /*0xd0*/ nint thread_pinning_ref;
            /*0xd8*/ nint abort_protected_block_count;
            /*0xe0*/ int priority;
            /*0xe8*/ nint owned_mutex;
            /*0xf0*/ nint suspended_event;
            /*0xf8*/ int self_suspended;
            /*0x100*/ nint thread_state;
            /*0x108*/ nint netcore0;
            /*0x110*/ nint netcore1;
            /*0x118*/ nint netcore2;
            /*0x120*/ nint last;

            /*0x1f37974*/ InternalThread();
            /*0x1f378dc*/ void Thread_free_internal();
            /*0x1f378e0*/ void Finalize();
        }

        class Timer : System.MarshalByRefObject, System.IDisposable, System.IAsyncDisposable
        {
            static long MaxValue = 4294967294;
            /*0x18*/ System.Threading.TimerCallback callback;
            /*0x20*/ object state;
            /*0x28*/ long due_time_ms;
            /*0x30*/ long period_ms;
            /*0x38*/ long next_run;
            /*0x40*/ bool disposed;
            /*0x41*/ bool is_dead;
            /*0x42*/ bool is_added;

            static /*0x1f37984*/ System.Threading.Timer.Scheduler get_scheduler();
            static /*0x1f38000*/ long GetTimeMonotonic();
            /*0x1f37a0c*/ Timer(System.Threading.TimerCallback callback, object state, int dueTime, int period);
            /*0x1f37acc*/ Timer(System.Threading.TimerCallback callback, object state, long dueTime, long period);
            /*0x1f37b18*/ Timer(System.Threading.TimerCallback callback, object state, System.TimeSpan dueTime, System.TimeSpan period);
            /*0x1f37ba8*/ Timer(System.Threading.TimerCallback callback, object state, uint dueTime, uint period);
            /*0x1f37c04*/ Timer(System.Threading.TimerCallback callback);
            /*0x1f37a58*/ void Init(System.Threading.TimerCallback callback, object state, long dueTime, long period);
            /*0x1f37e1c*/ bool Change(int dueTime, int period);
            /*0x1f37e3c*/ bool Change(System.TimeSpan dueTime, System.TimeSpan period);
            /*0x1f37eb4*/ bool Change(uint dueTime, uint period);
            /*0x1f37ee4*/ void Dispose();
            /*0x1f37fe8*/ bool Change(long dueTime, long period);
            /*0x1f37c3c*/ bool Change(long dueTime, long period, bool first);
            /*0x1f38194*/ bool Dispose(System.Threading.WaitHandle notifyObject);
            /*0x1f38208*/ System.Threading.Tasks.ValueTask DisposeAsync();
            /*0x1f3829c*/ void KeepRootedWhileScheduled();

            struct TimerComparer : System.Collections.IComparer, System.Collections.Generic.IComparer<System.Threading.Timer>
            {
                /*0x1f382a0*/ int System.Collections.IComparer.Compare(object x, object y);
                /*0x1f38338*/ int Compare(System.Threading.Timer tx, System.Threading.Timer ty);
            }

            class Scheduler
            {
                static /*0x0*/ System.Threading.Timer.Scheduler instance;
                /*0x10*/ bool needReSort;
                /*0x18*/ System.Collections.Generic.List<System.Threading.Timer> list;
                /*0x20*/ long current_next_run;
                /*0x28*/ System.Threading.ManualResetEvent changed;

                static /*0x1f38c44*/ Scheduler();
                static /*0x1f388f4*/ System.Threading.Timer.Scheduler get_Instance();
                static /*0x1f38b08*/ void TimerCB(object o);
                /*0x1f3894c*/ Scheduler();
                /*0x1f383a8*/ void InitScheduler();
                /*0x1f38490*/ void WakeupScheduler();
                /*0x1f384ac*/ void SchedulerThread();
                /*0x1f37f1c*/ void Remove(System.Threading.Timer timer);
                /*0x1f38004*/ void Change(System.Threading.Timer timer, long new_next_run);
                /*0x1f38a18*/ void Add(System.Threading.Timer timer);
                /*0x1f389e8*/ void InternalRemove(System.Threading.Timer timer);
                /*0x1f38b80*/ void FireTimer(System.Threading.Timer timer);
                /*0x1f385e0*/ int RunSchedulerLoop();
            }
        }

        class TimerCallback : System.MulticastDelegate
        {
            /*0x1f38ca4*/ TimerCallback(object object, nint method);
            /*0x1f38dd0*/ void Invoke(object state);
            /*0x1f38de4*/ System.IAsyncResult BeginInvoke(object state, System.AsyncCallback callback, object object);
            /*0x1f38e04*/ void EndInvoke(System.IAsyncResult result);
        }

        class Volatile
        {
            static /*0x1f38e10*/ bool Read(ref bool location);
            static /*0x1f38e28*/ void Write(ref bool location, bool value);
            static /*0x1f38e4c*/ byte Read(ref byte location);
            static /*0x1f38e64*/ void Write(ref byte location, byte value);
            static /*0x1f38e88*/ short Read(ref short location);
            static /*0x1f38ea0*/ void Write(ref short location, short value);
            static /*0x1f38ec4*/ int Read(ref int location);
            static /*0x1f38edc*/ void Write(ref int location, int value);
            static /*0x1f38f00*/ nint Read(ref nint location);
            static /*0x1f38f18*/ void Write(ref nint location, nint value);
            static /*0x1f38f3c*/ sbyte Read(ref sbyte location);
            static /*0x1f38f54*/ void Write(ref sbyte location, sbyte value);
            static /*0x1f38f78*/ float Read(ref float location);
            static /*0x1f38f98*/ void Write(ref float location, float value);
            static /*0x1f38fbc*/ ushort Read(ref ushort location);
            static /*0x1f38fd4*/ void Write(ref ushort location, ushort value);
            static /*0x1f38ff8*/ uint Read(ref uint location);
            static /*0x1f39010*/ void Write(ref uint location, uint value);
            static /*0x1f39034*/ nuint Read(ref nuint location);
            static /*0x1f3904c*/ void Write(ref nuint location, nuint value);
            static T Read<T>(ref T location);
            static void Write<T>(ref T location, T value);
            static /*0x1f39070*/ long Read(ref long location);
            static /*0x1f39088*/ ulong Read(ref ulong location);
            static /*0x1f390a0*/ double Read(ref double location);
            static /*0x1f390c0*/ void Write(ref long location, long value);
            static /*0x1f390e4*/ void Write(ref ulong location, ulong value);
            static /*0x1f39108*/ void Write(ref double location, double value);

            struct VolatileBoolean
            {
                /*0x10*/ bool Value;
            }

            struct VolatileByte
            {
                /*0x10*/ byte Value;
            }

            struct VolatileInt16
            {
                /*0x10*/ short Value;
            }

            struct VolatileInt32
            {
                /*0x10*/ int Value;
            }

            struct VolatileIntPtr
            {
                /*0x10*/ nint Value;
            }

            struct VolatileSByte
            {
                /*0x10*/ sbyte Value;
            }

            struct VolatileSingle
            {
                /*0x10*/ float Value;
            }

            struct VolatileUInt16
            {
                /*0x10*/ ushort Value;
            }

            struct VolatileUInt32
            {
                /*0x10*/ uint Value;
            }

            struct VolatileUIntPtr
            {
                /*0x10*/ nuint Value;
            }

            struct VolatileObject
            {
                /*0x10*/ object Value;
            }
        }

        class PreAllocatedOverlapped : System.IDisposable
        {
            /*0x1f3912c*/ PreAllocatedOverlapped(System.Threading.IOCompletionCallback callback, object state, object pinData);
            /*0x1f39174*/ void Dispose();
        }

        class ThreadPoolBoundHandle : System.IDisposable
        {
            static /*0x1f39240*/ System.Threading.ThreadPoolBoundHandle BindHandle(System.Runtime.InteropServices.SafeHandle handle);
            static /*0x1f392c4*/ object GetNativeOverlappedState(System.Threading.NativeOverlapped* overlapped);
            /*0x1f39178*/ ThreadPoolBoundHandle();
            /*0x1f39180*/ System.Runtime.InteropServices.SafeHandle get_Handle();
            /*0x1f391c0*/ System.Threading.NativeOverlapped* AllocateNativeOverlapped(System.Threading.IOCompletionCallback callback, object state, object pinData);
            /*0x1f39200*/ System.Threading.NativeOverlapped* AllocateNativeOverlapped(System.Threading.PreAllocatedOverlapped preAllocated);
            /*0x1f39280*/ void Dispose();
            /*0x1f39284*/ void FreeNativeOverlapped(System.Threading.NativeOverlapped* overlapped);
        }

        namespace Tasks
        {
            class TaskCanceledException : System.OperationCanceledException
            {
                /*0x98*/ System.Threading.Tasks.Task _canceledTask;

                /*0x1f39304*/ TaskCanceledException();
                /*0x1f39350*/ TaskCanceledException(string message);
                /*0x1f39358*/ TaskCanceledException(string message, System.Exception innerException);
                /*0x1f39360*/ TaskCanceledException(string message, System.Exception innerException, System.Threading.CancellationToken token);
                /*0x1f39368*/ TaskCanceledException(System.Threading.Tasks.Task task);
                /*0x1f3940c*/ TaskCanceledException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f39414*/ System.Threading.Tasks.Task get_Task();
            }

            class TaskCompletionSource<TResult>
            {
                /*0x0*/ System.Threading.Tasks.Task<TResult> _task;

                TaskCompletionSource();
                TaskCompletionSource(System.Threading.Tasks.TaskCreationOptions creationOptions);
                TaskCompletionSource(object state);
                TaskCompletionSource(object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> get_Task();
                void SpinUntilCompleted();
                bool TrySetException(System.Exception exception);
                bool TrySetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions);
                void SetException(System.Exception exception);
                void SetException(System.Collections.Generic.IEnumerable<System.Exception> exceptions);
                bool TrySetResult(TResult result);
                void SetResult(TResult result);
                bool TrySetCanceled();
                bool TrySetCanceled(System.Threading.CancellationToken cancellationToken);
                void SetCanceled();
            }

            class TaskSchedulerException : System.Exception
            {
                /*0x1f3941c*/ TaskSchedulerException();
                /*0x1f3948c*/ TaskSchedulerException(string message);
                /*0x1f394f4*/ TaskSchedulerException(System.Exception innerException);
                /*0x1f39574*/ TaskSchedulerException(string message, System.Exception innerException);
                /*0x1f395e4*/ TaskSchedulerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class TaskToApm
            {
                static /*0x1f39664*/ System.IAsyncResult Begin(System.Threading.Tasks.Task task, System.AsyncCallback callback, object state);
                static /*0x1f398f0*/ void End(System.IAsyncResult asyncResult);
                static TResult End<TResult>(System.IAsyncResult asyncResult);
                static /*0x1f397f8*/ void InvokeCallbackWhenTaskCompletes(System.Threading.Tasks.Task antecedent, System.AsyncCallback callback, System.IAsyncResult asyncResult);

                class TaskWrapperAsyncResult : System.IAsyncResult
                {
                    /*0x10*/ System.Threading.Tasks.Task Task;
                    /*0x18*/ object _state;
                    /*0x20*/ bool _completedSynchronously;

                    /*0x1f397bc*/ TaskWrapperAsyncResult(System.Threading.Tasks.Task task, object state, bool completedSynchronously);
                    /*0x1f39a1c*/ object System.IAsyncResult.get_AsyncState();
                    /*0x1f39a24*/ bool System.IAsyncResult.get_CompletedSynchronously();
                    /*0x1f39a2c*/ bool System.IAsyncResult.get_IsCompleted();
                    /*0x1f39a44*/ System.Threading.WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
                }

                class <>c__DisplayClass3_0
                {
                    /*0x10*/ System.AsyncCallback callback;
                    /*0x18*/ System.IAsyncResult asyncResult;

                    /*0x1f399e0*/ <>c__DisplayClass3_0();
                    /*0x1f39ae8*/ void <InvokeCallbackWhenTaskCompletes>b__0();
                }
            }

            struct ValueTask : System.IEquatable<System.Threading.Tasks.ValueTask>
            {
                static /*0x0*/ System.Threading.Tasks.Task s_canceledTask;
                /*0x10*/ object _obj;
                /*0x18*/ short _token;
                /*0x1a*/ bool _continueOnCapturedContext;

                static /*0x1f3a878*/ ValueTask();
                static /*0x1f39b10*/ System.Threading.Tasks.Task get_CompletedTask();
                static /*0x1f39ce4*/ bool op_Equality(System.Threading.Tasks.ValueTask left, System.Threading.Tasks.ValueTask right);
                static /*0x1f39d04*/ bool op_Inequality(System.Threading.Tasks.ValueTask left, System.Threading.Tasks.ValueTask right);
                /*0x1f39b98*/ ValueTask(System.Threading.Tasks.Task task);
                /*0x1f39bd0*/ ValueTask(System.Threading.Tasks.Sources.IValueTaskSource source, short token);
                /*0x1f39c0c*/ ValueTask(object obj, short token, bool continueOnCapturedContext);
                /*0x1f39c20*/ int GetHashCode();
                /*0x1f39c38*/ bool Equals(object obj);
                /*0x1f39cc0*/ bool Equals(System.Threading.Tasks.ValueTask other);
                /*0x1f39d24*/ System.Threading.Tasks.Task AsTask();
                /*0x1f3a0b4*/ System.Threading.Tasks.ValueTask Preserve();
                /*0x1f39ddc*/ System.Threading.Tasks.Task GetTaskForValueTaskSource(System.Threading.Tasks.Sources.IValueTaskSource t);
                /*0x1f3a2d0*/ bool get_IsCompleted();
                /*0x1f3a3d4*/ bool get_IsCompletedSuccessfully();
                /*0x1f3a50c*/ bool get_IsFaulted();
                /*0x1f3a628*/ bool get_IsCanceled();
                /*0x1f3a750*/ void ThrowIfCompletedUnsuccessfully();
                /*0x1f3a854*/ System.Runtime.CompilerServices.ValueTaskAwaiter GetAwaiter();
                /*0x1f3a860*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);

                class ValueTaskSourceAsTask : System.Threading.Tasks.Task<System.Threading.Tasks.VoidTaskResult>
                {
                    static /*0x0*/ System.Action<object> s_completionAction;
                    /*0x58*/ System.Threading.Tasks.Sources.IValueTaskSource _source;
                    /*0x60*/ short _token;

                    static /*0x1f3a954*/ ValueTaskSourceAsTask();
                    /*0x1f3a1b0*/ ValueTaskSourceAsTask(System.Threading.Tasks.Sources.IValueTaskSource source, short token);

                    class <>c
                    {
                        static /*0x0*/ System.Threading.Tasks.ValueTask.ValueTaskSourceAsTask.<> <>9;

                        static /*0x1f3aa18*/ <>c();
                        /*0x1f3aa7c*/ <>c();
                        /*0x1f3aa84*/ void <.cctor>b__4_0(object state);
                    }
                }
            }

            struct ValueTask<TResult> : System.IEquatable<System.Threading.Tasks.ValueTask<TResult>>
            {
                static /*0x0*/ System.Threading.Tasks.Task<TResult> s_canceledTask;
                /*0x0*/ object _obj;
                /*0x0*/ TResult _result;
                /*0x0*/ short _token;
                /*0x0*/ bool _continueOnCapturedContext;

                static bool op_Equality(System.Threading.Tasks.ValueTask<TResult> left, System.Threading.Tasks.ValueTask<TResult> right);
                static bool op_Inequality(System.Threading.Tasks.ValueTask<TResult> left, System.Threading.Tasks.ValueTask<TResult> right);
                ValueTask(TResult result);
                ValueTask(System.Threading.Tasks.Task<TResult> task);
                ValueTask(System.Threading.Tasks.Sources.IValueTaskSource<TResult> source, short token);
                ValueTask(object obj, TResult result, short token, bool continueOnCapturedContext);
                int GetHashCode();
                bool Equals(object obj);
                bool Equals(System.Threading.Tasks.ValueTask<TResult> other);
                System.Threading.Tasks.Task<TResult> AsTask();
                System.Threading.Tasks.ValueTask<TResult> Preserve();
                System.Threading.Tasks.Task<TResult> GetTaskForValueTaskSource(System.Threading.Tasks.Sources.IValueTaskSource<TResult> t);
                bool get_IsCompleted();
                bool get_IsCompletedSuccessfully();
                bool get_IsFaulted();
                bool get_IsCanceled();
                TResult get_Result();
                System.Runtime.CompilerServices.ValueTaskAwaiter<TResult> GetAwaiter();
                System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext);
                string ToString();

                class ValueTaskSourceAsTask<TResult> : System.Threading.Tasks.Task<TResult>
                {
                    static /*0x0*/ System.Action<object> s_completionAction;
                    /*0x0*/ System.Threading.Tasks.Sources.IValueTaskSource<TResult> _source;
                    /*0x0*/ short _token;

                    static ValueTaskSourceAsTask();
                    ValueTaskSourceAsTask(System.Threading.Tasks.Sources.IValueTaskSource<TResult> source, short token);

                    class <>c<TResult>
                    {
                        static /*0x0*/ System.Threading.Tasks.ValueTask.ValueTaskSourceAsTask.<>c<TResult> <>9;

                        static <>c();
                        <>c();
                        void <.cctor>b__4_0(object state);
                    }
                }
            }

            class BeginEndAwaitableAdapter : System.Threading.Tasks.RendezvousAwaitable<System.IAsyncResult>
            {
                static /*0x0*/ System.AsyncCallback Callback;

                static /*0x1f3ae20*/ BeginEndAwaitableAdapter();
                /*0x1f3ada0*/ BeginEndAwaitableAdapter();

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.BeginEndAwaitableAdapter.<> <>9;

                    static /*0x1f3aee4*/ <>c();
                    /*0x1f3af48*/ <>c();
                    /*0x1f3af50*/ void <.cctor>b__2_0(System.IAsyncResult asyncResult);
                }
            }

            class TaskAwaiters
            {
                static /*0x1f3b03c*/ System.Threading.Tasks.ForceAsyncAwaiter ForceAsync(System.Threading.Tasks.Task task);
            }

            struct ForceAsyncAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                /*0x10*/ System.Threading.Tasks.Task _task;

                /*0x1f3b040*/ ForceAsyncAwaiter(System.Threading.Tasks.Task task);
                /*0x1f3b048*/ System.Threading.Tasks.ForceAsyncAwaiter GetAwaiter();
                /*0x1f3b050*/ bool get_IsCompleted();
                /*0x1f3b058*/ void GetResult();
                /*0x1f3b084*/ void OnCompleted(System.Action action);
                /*0x1f3b0dc*/ void UnsafeOnCompleted(System.Action action);
            }

            class RendezvousAwaitable<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                static /*0x0*/ System.Action s_completionSentinel;
                /*0x0*/ System.Action _continuation;
                /*0x0*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo _error;
                /*0x0*/ TResult _result;
                /*0x0*/ bool <RunContinuationsAsynchronously>k__BackingField;

                static RendezvousAwaitable();
                RendezvousAwaitable();
                bool get_RunContinuationsAsynchronously();
                void set_RunContinuationsAsynchronously(bool value);
                System.Threading.Tasks.RendezvousAwaitable<TResult> GetAwaiter();
                bool get_IsCompleted();
                TResult GetResult();
                void SetResult(TResult result);
                void SetCanceled(System.Threading.CancellationToken token);
                void SetException(System.Exception exception);
                void NotifyAwaiter();
                void OnCompleted(System.Action continuation);
                void UnsafeOnCompleted(System.Action continuation);
                void AssertResultConsistency(bool expectedCompleted);

                class <>c<TResult>
                {
                    static /*0x0*/ System.Threading.Tasks.RendezvousAwaitable.<>c<TResult> <>9;

                    static <>c();
                    <>c();
                    void <.cctor>b__20_0();
                }
            }

            class Box<T>
            {
                /*0x0*/ T Value;

                Box(T value);
            }

            class ParallelOptions
            {
                /*0x10*/ System.Threading.Tasks.TaskScheduler _scheduler;
                /*0x18*/ int _maxDegreeOfParallelism;
                /*0x20*/ System.Threading.CancellationToken _cancellationToken;

                /*0x1f3b134*/ ParallelOptions();
                /*0x1f3b208*/ System.Threading.Tasks.TaskScheduler get_TaskScheduler();
                /*0x1f3b210*/ void set_TaskScheduler(System.Threading.Tasks.TaskScheduler value);
                /*0x1f3b218*/ System.Threading.Tasks.TaskScheduler get_EffectiveTaskScheduler();
                /*0x1f3b280*/ int get_MaxDegreeOfParallelism();
                /*0x1f3b288*/ void set_MaxDegreeOfParallelism(int value);
                /*0x1f3b2f0*/ System.Threading.CancellationToken get_CancellationToken();
                /*0x1f3b2f8*/ void set_CancellationToken(System.Threading.CancellationToken value);
                /*0x1f3b300*/ int get_EffectiveMaxConcurrencyLevel();
            }

            class Parallel
            {
                static int DEFAULT_LOOP_STRIDE = 16;
                static /*0x0*/ int s_forkJoinContextID;
                static /*0x8*/ System.Threading.Tasks.ParallelOptions s_defaultParallelOptions;

                static /*0x1f3d330*/ Parallel();
                static /*0x1f3b3b0*/ void Invoke(System.Action[] actions);
                static /*0x1f3b410*/ void Invoke(System.Threading.Tasks.ParallelOptions parallelOptions, System.Action[] actions);
                static /*0x1f3c500*/ System.Threading.Tasks.ParallelLoopResult For(int fromInclusive, int toExclusive, System.Action<int> body);
                static /*0x1f3c61c*/ System.Threading.Tasks.ParallelLoopResult For(long fromInclusive, long toExclusive, System.Action<long> body);
                static /*0x1f3c738*/ System.Threading.Tasks.ParallelLoopResult For(int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<int> body);
                static /*0x1f3c878*/ System.Threading.Tasks.ParallelLoopResult For(long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<long> body);
                static /*0x1f3c9b8*/ System.Threading.Tasks.ParallelLoopResult For(int fromInclusive, int toExclusive, System.Action<int, System.Threading.Tasks.ParallelLoopState> body);
                static /*0x1f3cad4*/ System.Threading.Tasks.ParallelLoopResult For(long fromInclusive, long toExclusive, System.Action<long, System.Threading.Tasks.ParallelLoopState> body);
                static /*0x1f3cbf0*/ System.Threading.Tasks.ParallelLoopResult For(int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<int, System.Threading.Tasks.ParallelLoopState> body);
                static /*0x1f3cd30*/ System.Threading.Tasks.ParallelLoopResult For(long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<long, System.Threading.Tasks.ParallelLoopState> body);
                static System.Threading.Tasks.ParallelLoopResult For<TLocal>(int fromInclusive, int toExclusive, System.Func<TLocal> localInit, System.Func<int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult For<TLocal>(long fromInclusive, long toExclusive, System.Func<TLocal> localInit, System.Func<long, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult For<TLocal>(int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, System.Func<TLocal> localInit, System.Func<int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult For<TLocal>(long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, System.Func<TLocal> localInit, System.Func<long, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static /*0x1f3ce70*/ bool CheckTimeoutReached(int timeoutOccursAt);
                static /*0x1f3ceb0*/ int ComputeTimeoutPoint(int timeoutLength);
                static System.Threading.Tasks.ParallelLoopResult ForWorker<TLocal>(int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<int> body, System.Action<int, System.Threading.Tasks.ParallelLoopState> bodyWithState, System.Func<int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithLocal, System.Func<TLocal> localInit, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForWorker64<TLocal>(long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<long> body, System.Action<long, System.Threading.Tasks.ParallelLoopState> bodyWithState, System.Func<long, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithLocal, System.Func<TLocal> localInit, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Generic.IEnumerable<TSource> source, System.Action<TSource> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Generic.IEnumerable<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Generic.IEnumerable<TSource> source, System.Action<TSource, System.Threading.Tasks.ParallelLoopState> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Generic.IEnumerable<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource, System.Threading.Tasks.ParallelLoopState> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Generic.IEnumerable<TSource> source, System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Generic.IEnumerable<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource, TLocal>(System.Collections.Generic.IEnumerable<TSource> source, System.Func<TLocal> localInit, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource, TLocal>(System.Collections.Generic.IEnumerable<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Func<TLocal> localInit, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource, TLocal>(System.Collections.Generic.IEnumerable<TSource> source, System.Func<TLocal> localInit, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource, TLocal>(System.Collections.Generic.IEnumerable<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Func<TLocal> localInit, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEachWorker<TSource, TLocal>(System.Collections.Generic.IEnumerable<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource> body, System.Action<TSource, System.Threading.Tasks.ParallelLoopState> bodyWithState, System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> bodyWithStateAndIndex, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, System.Func<TLocal> localInit, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEachWorker<TSource, TLocal>(TSource[] array, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource> body, System.Action<TSource, System.Threading.Tasks.ParallelLoopState> bodyWithState, System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> bodyWithStateAndIndex, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, System.Func<TLocal> localInit, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEachWorker<TSource, TLocal>(System.Collections.Generic.IList<TSource> list, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource> body, System.Action<TSource, System.Threading.Tasks.ParallelLoopState> bodyWithState, System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> bodyWithStateAndIndex, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, System.Func<TLocal> localInit, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Concurrent.Partitioner<TSource> source, System.Action<TSource> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Concurrent.Partitioner<TSource> source, System.Action<TSource, System.Threading.Tasks.ParallelLoopState> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Concurrent.OrderablePartitioner<TSource> source, System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource, TLocal>(System.Collections.Concurrent.Partitioner<TSource> source, System.Func<TLocal> localInit, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource, TLocal>(System.Collections.Concurrent.OrderablePartitioner<TSource> source, System.Func<TLocal> localInit, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Concurrent.Partitioner<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Concurrent.Partitioner<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource, System.Threading.Tasks.ParallelLoopState> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource>(System.Collections.Concurrent.OrderablePartitioner<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> body);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource, TLocal>(System.Collections.Concurrent.Partitioner<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Func<TLocal> localInit, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult ForEach<TSource, TLocal>(System.Collections.Concurrent.OrderablePartitioner<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Func<TLocal> localInit, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> body, System.Action<TLocal> localFinally);
                static System.Threading.Tasks.ParallelLoopResult PartitionerForEachWorker<TSource, TLocal>(System.Collections.Concurrent.Partitioner<TSource> source, System.Threading.Tasks.ParallelOptions parallelOptions, System.Action<TSource> simpleBody, System.Action<TSource, System.Threading.Tasks.ParallelLoopState> bodyWithState, System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> bodyWithStateAndIndex, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal, System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> bodyWithEverything, System.Func<TLocal> localInit, System.Action<TLocal> localFinally);
                static /*0x1f3cecc*/ System.OperationCanceledException ReduceToSingleCancellationException(System.Collections.ICollection exceptions, System.Threading.CancellationToken cancelToken);
                static /*0x1f3c30c*/ void ThrowSingleCancellationExceptionOrOtherException(System.Collections.ICollection exceptions, System.Threading.CancellationToken cancelToken, System.Exception otherException);

                class <>c__DisplayClass4_0
                {
                    /*0x10*/ System.Action[] actionsCopy;
                    /*0x18*/ System.Threading.Tasks.ParallelOptions parallelOptions;
                    /*0x20*/ int actionIndex;
                    /*0x28*/ System.Collections.Concurrent.ConcurrentQueue<System.Exception> exceptionQ;

                    /*0x1f3c10c*/ <>c__DisplayClass4_0();
                    /*0x1f3d3a4*/ void <Invoke>b__0(ref object state, int timeout, ref bool replicationDelegateYieldedBeforeCompletion);
                }

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.Parallel.<> <>9;
                    static /*0x8*/ System.Func<System.Collections.Concurrent.ConcurrentQueue<System.Exception>> <>9__4_1;
                    static /*0x10*/ System.Func<System.Collections.Concurrent.ConcurrentQueue<System.Exception>> <>9__4_2;

                    static /*0x1f3d5f0*/ <>c();
                    /*0x1f3d654*/ <>c();
                    /*0x1f3d65c*/ System.Collections.Concurrent.ConcurrentQueue<System.Exception> <Invoke>b__4_1();
                    /*0x1f3d6cc*/ System.Collections.Concurrent.ConcurrentQueue<System.Exception> <Invoke>b__4_2();
                }

                class <>c__DisplayClass19_0<TLocal>
                {
                    /*0x0*/ System.OperationCanceledException oce;
                    /*0x0*/ System.Threading.Tasks.ParallelOptions parallelOptions;
                    /*0x0*/ System.Threading.Tasks.ParallelLoopStateFlags32 sharedPStateFlags;
                    /*0x0*/ System.Threading.Tasks.RangeManager rangeManager;
                    /*0x0*/ int forkJoinContextID;
                    /*0x0*/ System.Action<int, System.Threading.Tasks.ParallelLoopState> bodyWithState;
                    /*0x0*/ System.Func<int, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithLocal;
                    /*0x0*/ System.Func<TLocal> localInit;
                    /*0x0*/ System.Action<int> body;
                    /*0x0*/ System.Action<TLocal> localFinally;

                    <>c__DisplayClass19_0();
                    void <ForWorker>b__0(object o);
                    void <ForWorker>b__1(ref System.Threading.Tasks.RangeWorker currentWorker, int timeout, ref bool replicationDelegateYieldedBeforeCompletion);
                }

                class <>c__DisplayClass20_0<TLocal>
                {
                    /*0x0*/ System.OperationCanceledException oce;
                    /*0x0*/ System.Threading.Tasks.ParallelOptions parallelOptions;
                    /*0x0*/ System.Threading.Tasks.ParallelLoopStateFlags64 sharedPStateFlags;
                    /*0x0*/ System.Threading.Tasks.RangeManager rangeManager;
                    /*0x0*/ int forkJoinContextID;
                    /*0x0*/ System.Action<long, System.Threading.Tasks.ParallelLoopState> bodyWithState;
                    /*0x0*/ System.Func<long, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithLocal;
                    /*0x0*/ System.Func<TLocal> localInit;
                    /*0x0*/ System.Action<long> body;
                    /*0x0*/ System.Action<TLocal> localFinally;

                    <>c__DisplayClass20_0();
                    void <ForWorker64>b__0(object o);
                    void <ForWorker64>b__1(ref System.Threading.Tasks.RangeWorker currentWorker, int timeout, ref bool replicationDelegateYieldedBeforeCompletion);
                }

                class <>c__DisplayClass32_0<TSource, TLocal>
                {
                    /*0x0*/ System.Action<TSource> body;
                    /*0x0*/ TSource[] array;
                    /*0x0*/ System.Action<TSource, System.Threading.Tasks.ParallelLoopState> bodyWithState;
                    /*0x0*/ System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> bodyWithStateAndIndex;
                    /*0x0*/ System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal;
                    /*0x0*/ System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> bodyWithEverything;

                    <>c__DisplayClass32_0();
                    void <ForEachWorker>b__0(int i);
                    void <ForEachWorker>b__1(int i, System.Threading.Tasks.ParallelLoopState state);
                    void <ForEachWorker>b__2(int i, System.Threading.Tasks.ParallelLoopState state);
                    TLocal <ForEachWorker>b__3(int i, System.Threading.Tasks.ParallelLoopState state, TLocal local);
                    TLocal <ForEachWorker>b__4(int i, System.Threading.Tasks.ParallelLoopState state, TLocal local);
                }

                class <>c__DisplayClass33_0<TSource, TLocal>
                {
                    /*0x0*/ System.Action<TSource> body;
                    /*0x0*/ System.Collections.Generic.IList<TSource> list;
                    /*0x0*/ System.Action<TSource, System.Threading.Tasks.ParallelLoopState> bodyWithState;
                    /*0x0*/ System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> bodyWithStateAndIndex;
                    /*0x0*/ System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal;
                    /*0x0*/ System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> bodyWithEverything;

                    <>c__DisplayClass33_0();
                    void <ForEachWorker>b__0(int i);
                    void <ForEachWorker>b__1(int i, System.Threading.Tasks.ParallelLoopState state);
                    void <ForEachWorker>b__2(int i, System.Threading.Tasks.ParallelLoopState state);
                    TLocal <ForEachWorker>b__3(int i, System.Threading.Tasks.ParallelLoopState state, TLocal local);
                    TLocal <ForEachWorker>b__4(int i, System.Threading.Tasks.ParallelLoopState state, TLocal local);
                }

                class <>c__DisplayClass44_0<TSource, TLocal>
                {
                    /*0x0*/ System.OperationCanceledException oce;
                    /*0x0*/ System.Threading.Tasks.ParallelOptions parallelOptions;
                    /*0x0*/ System.Threading.Tasks.ParallelLoopStateFlags64 sharedPStateFlags;
                    /*0x0*/ int forkJoinContextID;
                    /*0x0*/ System.Action<TSource, System.Threading.Tasks.ParallelLoopState> bodyWithState;
                    /*0x0*/ System.Action<TSource, System.Threading.Tasks.ParallelLoopState, long> bodyWithStateAndIndex;
                    /*0x0*/ System.Func<TSource, System.Threading.Tasks.ParallelLoopState, TLocal, TLocal> bodyWithStateAndLocal;
                    /*0x0*/ System.Func<TSource, System.Threading.Tasks.ParallelLoopState, long, TLocal, TLocal> bodyWithEverything;
                    /*0x0*/ System.Func<TLocal> localInit;
                    /*0x0*/ System.Collections.Concurrent.OrderablePartitioner<TSource> orderedSource;
                    /*0x0*/ System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> orderablePartitionerSource;
                    /*0x0*/ System.Action<TSource> simpleBody;
                    /*0x0*/ System.Collections.Generic.IEnumerable<TSource> partitionerSource;
                    /*0x0*/ System.Action<TLocal> localFinally;

                    <>c__DisplayClass44_0();
                    void <PartitionerForEachWorker>b__0(object o);
                    void <PartitionerForEachWorker>b__1(ref System.Collections.IEnumerator partitionState, int timeout, ref bool replicationDelegateYieldedBeforeCompletion);
                }
            }

            class ParallelEtwProvider : System.Diagnostics.Tracing.EventSource
            {
                static System.Diagnostics.Tracing.EventKeywords ALL_KEYWORDS = -1;
                static int PARALLELLOOPBEGIN_ID = 1;
                static int PARALLELLOOPEND_ID = 2;
                static int PARALLELINVOKEBEGIN_ID = 3;
                static int PARALLELINVOKEEND_ID = 4;
                static int PARALLELFORK_ID = 5;
                static int PARALLELJOIN_ID = 6;
                static /*0x0*/ System.Threading.Tasks.ParallelEtwProvider Log;

                static /*0x1f3daf8*/ ParallelEtwProvider();
                /*0x1f3d73c*/ ParallelEtwProvider();
                /*0x1f3d744*/ void ParallelLoopBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID, System.Threading.Tasks.ParallelEtwProvider.ForkJoinOperationType OperationType, long InclusiveFrom, long ExclusiveTo);
                /*0x1f3d898*/ void ParallelLoopEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID, long TotalIterations);
                /*0x1f3c1d8*/ void ParallelInvokeBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID, System.Threading.Tasks.ParallelEtwProvider.ForkJoinOperationType OperationType, int ActionCount);
                /*0x1f3d9c0*/ void ParallelInvokeEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID);
                /*0x1f3da28*/ void ParallelFork(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID);
                /*0x1f3da90*/ void ParallelJoin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ForkJoinContextID);

                enum ForkJoinOperationType
                {
                    ParallelInvoke = 1,
                    ParallelFor = 2,
                    ParallelForEach = 3,
                }

                class Tasks
                {
                    static System.Diagnostics.Tracing.EventTask Loop = 1;
                    static System.Diagnostics.Tracing.EventTask Invoke = 2;
                    static System.Diagnostics.Tracing.EventTask ForkJoin = 5;
                }
            }

            class ParallelLoopState
            {
                /*0x10*/ System.Threading.Tasks.ParallelLoopStateFlags _flagsBase;

                static /*0x1f3dd88*/ void Break(int iteration, System.Threading.Tasks.ParallelLoopStateFlags32 pflags);
                static /*0x1f3df14*/ void Break(long iteration, System.Threading.Tasks.ParallelLoopStateFlags64 pflags);
                /*0x1f3db5c*/ ParallelLoopState(System.Threading.Tasks.ParallelLoopStateFlags fbase);
                /*0x1f3e064*/ ParallelLoopState();
                /*0x1f3db84*/ bool get_InternalShouldExitCurrentIteration();
                /*0x1f3dbd4*/ bool get_ShouldExitCurrentIteration();
                /*0x1f3dbe0*/ bool get_IsStopped();
                /*0x1f3dc1c*/ bool get_IsExceptional();
                /*0x1f3dc40*/ System.Nullable<long> get_InternalLowestBreakIteration();
                /*0x1f3dc90*/ System.Nullable<long> get_LowestBreakIteration();
                /*0x1f3dc9c*/ void Stop();
                /*0x1f3dd2c*/ void InternalBreak();
                /*0x1f3dd7c*/ void Break();
            }

            class ParallelLoopState32 : System.Threading.Tasks.ParallelLoopState
            {
                /*0x18*/ System.Threading.Tasks.ParallelLoopStateFlags32 _sharedParallelStateFlags;
                /*0x20*/ int _currentIteration;

                /*0x1f3e09c*/ ParallelLoopState32(System.Threading.Tasks.ParallelLoopStateFlags32 sharedParallelStateFlags);
                /*0x1f3e0c4*/ int get_CurrentIteration();
                /*0x1f3e0cc*/ void set_CurrentIteration(int value);
                /*0x1f3e0d4*/ bool get_InternalShouldExitCurrentIteration();
                /*0x1f3e14c*/ System.Nullable<long> get_InternalLowestBreakIteration();
                /*0x1f3e21c*/ void InternalBreak();
            }

            class ParallelLoopState64 : System.Threading.Tasks.ParallelLoopState
            {
                /*0x18*/ System.Threading.Tasks.ParallelLoopStateFlags64 _sharedParallelStateFlags;
                /*0x20*/ long _currentIteration;

                /*0x1f3e22c*/ ParallelLoopState64(System.Threading.Tasks.ParallelLoopStateFlags64 sharedParallelStateFlags);
                /*0x1f3e254*/ long get_CurrentIteration();
                /*0x1f3e25c*/ void set_CurrentIteration(long value);
                /*0x1f3e264*/ bool get_InternalShouldExitCurrentIteration();
                /*0x1f3e2f4*/ System.Nullable<long> get_InternalLowestBreakIteration();
                /*0x1f3e3a4*/ void InternalBreak();
            }

            class ParallelLoopStateFlags
            {
                static int ParallelLoopStateNone = 0;
                static int ParallelLoopStateExceptional = 1;
                static int ParallelLoopStateBroken = 2;
                static int ParallelLoopStateStopped = 4;
                static int ParallelLoopStateCanceled = 8;
                /*0x10*/ int _loopStateFlags;

                /*0x1f3e40c*/ ParallelLoopStateFlags();
                /*0x1f3dc04*/ int get_LoopStateFlags();
                /*0x1f3e3ac*/ bool AtomicLoopStateUpdate(int newState, int illegalStates);
                /*0x1f3de74*/ bool AtomicLoopStateUpdate(int newState, int illegalStates, ref int oldState);
                /*0x1f3e3c8*/ void SetExceptional();
                /*0x1f3dcb4*/ void Stop();
                /*0x1f3e3e8*/ bool Cancel();
            }

            class ParallelLoopStateFlags32 : System.Threading.Tasks.ParallelLoopStateFlags
            {
                /*0x14*/ int _lowestBreakIteration;

                /*0x1f3e44c*/ ParallelLoopStateFlags32();
                /*0x1f3e414*/ int get_LowestBreakIteration();
                /*0x1f3e164*/ System.Nullable<long> get_NullableLowestBreakIteration();
                /*0x1f3e0f4*/ bool ShouldExitLoop(int CallerIteration);
                /*0x1f3e42c*/ bool ShouldExitLoop();
            }

            class ParallelLoopStateFlags64 : System.Threading.Tasks.ParallelLoopStateFlags
            {
                /*0x18*/ long _lowestBreakIteration;

                /*0x1f3e490*/ ParallelLoopStateFlags64();
                /*0x1f3e034*/ long get_LowestBreakIteration();
                /*0x1f3e30c*/ System.Nullable<long> get_NullableLowestBreakIteration();
                /*0x1f3e284*/ bool ShouldExitLoop(long CallerIteration);
                /*0x1f3e470*/ bool ShouldExitLoop();
            }

            struct ParallelLoopResult
            {
                /*0x10*/ bool _completed;
                /*0x18*/ System.Nullable<long> _lowestBreakIteration;

                /*0x1f3e4a0*/ bool get_IsCompleted();
                /*0x1f3e4a8*/ System.Nullable<long> get_LowestBreakIteration();
            }

            struct IndexRange
            {
                /*0x10*/ long _nFromInclusive;
                /*0x18*/ long _nToExclusive;
                /*0x20*/ System.Threading.Tasks.Box<long> _nSharedCurrentIndexOffset;
                /*0x28*/ int _bRangeFinished;
            }

            struct RangeWorker
            {
                /*0x10*/ System.Threading.Tasks.IndexRange[] _indexRanges;
                /*0x18*/ int _nCurrentIndexRange;
                /*0x20*/ long _nStep;
                /*0x28*/ long _nIncrementValue;
                /*0x30*/ long _nMaxIncrementValue;
                /*0x38*/ bool _use32BitCurrentIndex;

                /*0x1f3e4c4*/ RangeWorker(System.Threading.Tasks.IndexRange[] ranges, int nInitialRange, long nStep, bool use32BitCurrentIndex);
                /*0x1f3e4b4*/ bool get_IsInitialized();
                /*0x1f3e4e4*/ bool FindNewWork(ref long nFromInclusiveLocal, ref long nToExclusiveLocal);
                /*0x1f3e744*/ bool FindNewWork32(ref int nFromInclusiveLocal32, ref int nToExclusiveLocal32);
            }

            class RangeManager
            {
                /*0x10*/ System.Threading.Tasks.IndexRange[] _indexRanges;
                /*0x18*/ bool _use32BitCurrentIndex;
                /*0x1c*/ int _nCurrentIndexRangeToAssign;
                /*0x20*/ long _nStep;

                /*0x1f3e788*/ RangeManager(long nFromInclusive, long nToExclusive, long nStep, int nNumExpectedWorkers);
                /*0x1f3e900*/ System.Threading.Tasks.RangeWorker RegisterNewWorker();
            }

            class TaskReplicator
            {
                static int CooperativeMultitaskingTaskTimeout_Min = 100;
                static int CooperativeMultitaskingTaskTimeout_Increment = 50;
                static int CooperativeMultitaskingTaskTimeout_RootTask = 1073741823;
                /*0x10*/ System.Threading.Tasks.TaskScheduler _scheduler;
                /*0x18*/ bool _stopOnFirstFailure;
                /*0x20*/ System.Collections.Concurrent.ConcurrentQueue<System.Threading.Tasks.TaskReplicator.Replica> _pendingReplicas;
                /*0x28*/ System.Collections.Concurrent.ConcurrentQueue<System.Exception> _exceptions;
                /*0x30*/ bool _stopReplicating;

                static void Run<TState>(System.Threading.Tasks.TaskReplicator.ReplicatableUserAction<TState> action, System.Threading.Tasks.ParallelOptions options, bool stopOnFirstFailure);
                static /*0x1f3ea40*/ int GenerateCooperativeMultitaskingTaskTimeout();
                /*0x1f3e96c*/ TaskReplicator(System.Threading.Tasks.ParallelOptions options, bool stopOnFirstFailure);

                class ReplicatableUserAction<TState> : System.MulticastDelegate
                {
                    ReplicatableUserAction(object object, nint method);
                    void Invoke(ref TState replicaState, int timeout, ref bool yieldedBeforeCompletion);
                }

                class Replica
                {
                    /*0x10*/ System.Threading.Tasks.TaskReplicator _replicator;
                    /*0x18*/ int _timeout;
                    /*0x1c*/ int _remainingConcurrency;
                    /*0x20*/ System.Threading.Tasks.Task _pendingTask;

                    /*0x1f3eab4*/ Replica(System.Threading.Tasks.TaskReplicator replicator, int maxConcurrency, int timeout);
                    /*0x1f3ec64*/ void Start();
                    /*0x1f3ec9c*/ void Wait();
                    /*0x1f3ece4*/ void Execute();
                    void CreateNewReplica();
                    void ExecuteAction(ref bool yieldedBeforeCompletion);

                    class <>c
                    {
                        static /*0x0*/ System.Threading.Tasks.TaskReplicator.Replica.<> <>9;
                        static /*0x8*/ System.Action<object> <>9__4_0;
                        static /*0x10*/ System.Action<object> <>9__7_0;

                        static /*0x1f3f200*/ <>c();
                        /*0x1f3f264*/ <>c();
                        /*0x1f3f26c*/ void <.ctor>b__4_0(object s);
                        /*0x1f3f2ec*/ void <Execute>b__7_0(object s);
                    }
                }

                class Replica<TState> : System.Threading.Tasks.TaskReplicator.Replica
                {
                    /*0x0*/ System.Threading.Tasks.TaskReplicator.ReplicatableUserAction<TState> _action;
                    /*0x0*/ TState _state;

                    Replica(System.Threading.Tasks.TaskReplicator replicator, int maxConcurrency, int timeout, System.Threading.Tasks.TaskReplicator.ReplicatableUserAction<TState> action);
                    void CreateNewReplica();
                    void ExecuteAction(ref bool yieldedBeforeCompletion);
                }
            }

            class ConcurrentExclusiveSchedulerPair
            {
                static int UNLIMITED_PROCESSING = -1;
                static int EXCLUSIVE_PROCESSING_SENTINEL = -1;
                static int DEFAULT_MAXITEMSPERTASK = -1;
                /*0x10*/ System.Threading.ThreadLocal<System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode> m_threadProcessingMode;
                /*0x18*/ System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler m_concurrentTaskScheduler;
                /*0x20*/ System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ConcurrentExclusiveTaskScheduler m_exclusiveTaskScheduler;
                /*0x28*/ System.Threading.Tasks.TaskScheduler m_underlyingTaskScheduler;
                /*0x30*/ int m_maxConcurrencyLevel;
                /*0x34*/ int m_maxItemsPerTask;
                /*0x38*/ int m_processingCount;
                /*0x40*/ System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompletionState m_completionState;

                static /*0x1f3f36c*/ int get_DefaultMaxConcurrencyLevel();
                static /*0x1f40904*/ void ContractAssertMonitorStatus(object syncObj, bool held);
                static /*0x1f40434*/ System.Threading.Tasks.TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
                /*0x1f3f37c*/ ConcurrentExclusiveSchedulerPair();
                /*0x1f3f630*/ ConcurrentExclusiveSchedulerPair(System.Threading.Tasks.TaskScheduler taskScheduler);
                /*0x1f3f664*/ ConcurrentExclusiveSchedulerPair(System.Threading.Tasks.TaskScheduler taskScheduler, int maxConcurrencyLevel);
                /*0x1f3f420*/ ConcurrentExclusiveSchedulerPair(System.Threading.Tasks.TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
                /*0x1f3f374*/ object get_ValueLock();
                /*0x1f3f788*/ void Complete();
                /*0x1f3f8f8*/ System.Threading.Tasks.Task get_Completion();
                /*0x1f3f944*/ System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompletionState EnsureCompletionStateInitialized();
                /*0x1f3f884*/ bool get_CompletionRequested();
                /*0x1f3f8b4*/ void RequestCompletion();
                /*0x1f3f8d4*/ void CleanupStateIfCompletingAndQuiesced();
                /*0x1f3fa3c*/ bool get_ReadyToComplete();
                /*0x1f3fbb8*/ void CompleteTaskAsync();
                /*0x1f3fcc0*/ void FaultWithTask(System.Threading.Tasks.Task faultedTask);
                /*0x1f3fde0*/ System.Threading.Tasks.TaskScheduler get_ConcurrentScheduler();
                /*0x1f3fde8*/ System.Threading.Tasks.TaskScheduler get_ExclusiveScheduler();
                /*0x1f3fdf0*/ int get_ConcurrentTaskCountForDebugger();
                /*0x1f3fe9c*/ int get_ExclusiveTaskCountForDebugger();
                /*0x1f3ff48*/ void ProcessAsyncIfNecessary(bool fairly);
                /*0x1f40444*/ void ProcessExclusiveTasks();
                /*0x1f40618*/ void ProcessConcurrentTasks();
                /*0x1f4086c*/ System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode get_ModeForDebugger();

                class CompletionState : System.Threading.Tasks.TaskCompletionSource<System.Threading.Tasks.VoidTaskResult>
                {
                    /*0x18*/ bool m_completionRequested;
                    /*0x19*/ bool m_completionQueued;
                    /*0x20*/ System.Collections.Generic.List<System.Exception> m_exceptions;

                    /*0x1f40908*/ CompletionState();
                }

                class ConcurrentExclusiveTaskScheduler : System.Threading.Tasks.TaskScheduler
                {
                    static /*0x0*/ System.Func<object, bool> s_tryExecuteTaskShim;
                    /*0x18*/ System.Threading.Tasks.ConcurrentExclusiveSchedulerPair m_pair;
                    /*0x20*/ int m_maxConcurrencyLevel;
                    /*0x24*/ System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode m_processingMode;
                    /*0x28*/ System.Threading.Tasks.IProducerConsumerQueue<System.Threading.Tasks.Task> m_tasks;

                    static /*0x1f40fac*/ ConcurrentExclusiveTaskScheduler();
                    static /*0x1f40f00*/ bool TryExecuteTaskShim(object state);
                    /*0x1f3f66c*/ ConcurrentExclusiveTaskScheduler(System.Threading.Tasks.ConcurrentExclusiveSchedulerPair pair, int maxConcurrencyLevel, System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.ProcessingMode processingMode);
                    /*0x1f40950*/ int get_MaximumConcurrencyLevel();
                    /*0x1f40958*/ void QueueTask(System.Threading.Tasks.Task task);
                    /*0x1f40610*/ void ExecuteTask(System.Threading.Tasks.Task task);
                    /*0x1f40b68*/ bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                    /*0x1f40cdc*/ bool TryExecuteTaskInlineOnTargetScheduler(System.Threading.Tasks.Task task);
                    /*0x1f40fa4*/ System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks();

                    class DebugView
                    {
                    }
                }

                class DebugView
                {
                }

                enum ProcessingMode
                {
                    NotCurrentlyProcessing = 0,
                    ProcessingExclusiveTask = 1,
                    ProcessingConcurrentTasks = 2,
                    Completing = 4,
                    Completed = 8,
                }

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.<> <>9;
                    static /*0x8*/ System.Func<System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompletionState> <>9__22_0;
                    static /*0x10*/ System.Threading.WaitCallback <>9__29_0;
                    static /*0x18*/ System.Action<object> <>9__39_0;
                    static /*0x20*/ System.Action<object> <>9__39_1;

                    static /*0x1f41040*/ <>c();
                    /*0x1f410a4*/ <>c();
                    /*0x1f410ac*/ System.Threading.Tasks.ConcurrentExclusiveSchedulerPair.CompletionState <EnsureCompletionStateInitialized>b__22_0();
                    /*0x1f41104*/ void <CompleteTaskAsync>b__29_0(object state);
                    /*0x1f41208*/ void <ProcessAsyncIfNecessary>b__39_0(object thisPair);
                    /*0x1f41288*/ void <ProcessAsyncIfNecessary>b__39_1(object thisPair);
                }
            }

            class DebuggerSupport
            {
                static /*0x0*/ System.Collections.Generic.LowLevelDictionary<int, System.Threading.Tasks.Task> s_activeTasks;
                static /*0x8*/ object s_activeTasksLock;

                static /*0x1f41964*/ DebuggerSupport();
                static /*0x1f41308*/ bool get_LoggingOn();
                static /*0x1f41310*/ void TraceOperationCreation(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.Task task, string operationName, ulong relatedContext);
                static /*0x1f41314*/ void TraceOperationCompletion(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.Task task, Internal.Runtime.Augments.AsyncStatus status);
                static /*0x1f41318*/ void TraceOperationRelation(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.Task task, System.Threading.Tasks.CausalityRelation relation);
                static /*0x1f4131c*/ void TraceSynchronousWorkStart(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.Task task, System.Threading.Tasks.CausalitySynchronousWork work);
                static /*0x1f41320*/ void TraceSynchronousWorkCompletion(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.CausalitySynchronousWork work);
                static /*0x1f41324*/ void AddToActiveTasks(System.Threading.Tasks.Task task);
                static /*0x1f413b8*/ void AddToActiveTasksNonInlined(System.Threading.Tasks.Task task);
                static /*0x1f415a4*/ void RemoveFromActiveTasks(System.Threading.Tasks.Task task);
                static /*0x1f41638*/ void RemoveFromActiveTasksNonInlined(System.Threading.Tasks.Task task);
                static /*0x1f41794*/ System.Threading.Tasks.Task GetActiveTaskFromId(int taskId);
                static /*0x1f4182c*/ System.Threading.Tasks.Task GetTaskIfDebuggingEnabled(System.Runtime.CompilerServices.AsyncVoidMethodBuilder builder);
                static /*0x1f418c8*/ System.Threading.Tasks.Task GetTaskIfDebuggingEnabled(System.Runtime.CompilerServices.AsyncTaskMethodBuilder builder);
                static System.Threading.Tasks.Task GetTaskIfDebuggingEnabled<TResult>(System.Runtime.CompilerServices.AsyncTaskMethodBuilder<TResult> builder);
            }

            class Task<TResult> : System.Threading.Tasks.Task
            {
                static /*0x0*/ System.Threading.Tasks.TaskFactory<TResult> s_defaultFactory;
                /*0x0*/ TResult m_result;

                static System.Threading.Tasks.Task<TResult> StartNew(System.Threading.Tasks.Task parent, System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.Task<TResult> StartNew(System.Threading.Tasks.Task parent, System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.TaskFactory<TResult> get_Factory();
                Task();
                Task(object state, System.Threading.Tasks.TaskCreationOptions options);
                Task(TResult result);
                Task(bool canceled, TResult result, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.CancellationToken ct);
                Task(System.Func<TResult> function);
                Task(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken);
                Task(System.Func<TResult> function, System.Threading.Tasks.TaskCreationOptions creationOptions);
                Task(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);
                Task(System.Func<object, TResult> function, object state);
                Task(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken);
                Task(System.Func<object, TResult> function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                Task(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);
                Task(System.Func<TResult> valueSelector, System.Threading.Tasks.Task parent, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                Task(System.Delegate valueSelector, object state, System.Threading.Tasks.Task parent, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                string get_DebuggerDisplayResultDescription();
                string get_DebuggerDisplayMethodDescription();
                bool TrySetResult(TResult result);
                void DangerousSetResult(TResult result);
                TResult get_Result();
                TResult get_ResultOnSuccess();
                TResult GetResultCore(bool waitCompletionNotification);
                void InnerInvoke();
                System.Runtime.CompilerServices.TaskAwaiter<TResult> GetAwaiter();
                System.Runtime.CompilerServices.ConfiguredTaskAwaitable<TResult> ConfigureAwait(bool continueOnCapturedContext);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>> continuationAction, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task<TResult>, object> continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, TNewResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TNewResult> ContinueWith<TNewResult>(System.Func<System.Threading.Tasks.Task<TResult>, object, TNewResult> continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);

                class TaskWhenAnyCast<TResult>
                {
                    static /*0x0*/ System.Func<System.Threading.Tasks.Task<System.Threading.Tasks.Task>, System.Threading.Tasks.Task<TResult>> Value;

                    static TaskWhenAnyCast();

                    class <>c<TResult>
                    {
                        static /*0x0*/ System.Threading.Tasks.Task.TaskWhenAnyCast.<>c<TResult> <>9;

                        static <>c();
                        <>c();
                        System.Threading.Tasks.Task<TResult> <.cctor>b__1_0(System.Threading.Tasks.Task<System.Threading.Tasks.Task> completed);
                    }
                }
            }

            class SystemThreadingTasks_FutureDebugView<TResult>
            {
                /*0x0*/ System.Threading.Tasks.Task<TResult> m_task;

                SystemThreadingTasks_FutureDebugView(System.Threading.Tasks.Task<TResult> task);
                TResult get_Result();
                object get_AsyncState();
                System.Threading.Tasks.TaskCreationOptions get_CreationOptions();
                System.Exception get_Exception();
                int get_Id();
                bool get_CancellationPending();
                System.Threading.Tasks.TaskStatus get_Status();
            }

            class TaskFactory<TResult>
            {
                /*0x0*/ System.Threading.CancellationToken m_defaultCancellationToken;
                /*0x0*/ System.Threading.Tasks.TaskScheduler m_defaultScheduler;
                /*0x0*/ System.Threading.Tasks.TaskCreationOptions m_defaultCreationOptions;
                /*0x0*/ System.Threading.Tasks.TaskContinuationOptions m_defaultContinuationOptions;

                static void FromAsyncCoreLogic(System.IAsyncResult iar, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, System.Threading.Tasks.Task<TResult> promise, bool requiresSynchronization);
                static System.Threading.Tasks.Task<TResult> FromAsyncImpl(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.Task<TResult> FromAsyncImpl(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                static System.Threading.Tasks.Task<TResult> FromAsyncImpl<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                static System.Threading.Tasks.Task<TResult> FromAsyncImpl<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                static System.Threading.Tasks.Task<TResult> FromAsyncImpl<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endFunction, System.Action<System.IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                static System.Threading.Tasks.Task<TResult> FromAsyncTrim<TInstance, TArgs>(TInstance thisRef, TArgs args, System.Func<TInstance, TArgs, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<TInstance, System.IAsyncResult, TResult> endMethod);
                static System.Threading.Tasks.Task<TResult> CreateCanceledTask(System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.CancellationToken ct);
                static System.Threading.Tasks.Task<TResult> ContinueWhenAllImpl<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.Task<TResult> ContinueWhenAllImpl<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.Task<TResult> ContinueWhenAllImpl(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.Task<TResult> ContinueWhenAllImpl(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.Task<TResult> ContinueWhenAnyImpl(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.Task<TResult> ContinueWhenAnyImpl(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.Task<TResult> ContinueWhenAnyImpl<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler);
                static System.Threading.Tasks.Task<TResult> ContinueWhenAnyImpl<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler);
                TaskFactory();
                TaskFactory(System.Threading.CancellationToken cancellationToken);
                TaskFactory(System.Threading.Tasks.TaskScheduler scheduler);
                TaskFactory(System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                TaskFactory(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.TaskScheduler get_DefaultScheduler();
                System.Threading.Tasks.TaskScheduler GetDefaultScheduler(System.Threading.Tasks.Task currTask);
                System.Threading.CancellationToken get_CancellationToken();
                System.Threading.Tasks.TaskScheduler get_Scheduler();
                System.Threading.Tasks.TaskCreationOptions get_CreationOptions();
                System.Threading.Tasks.TaskContinuationOptions get_ContinuationOptions();
                System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function);
                System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> StartNew(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state);
                System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> StartNew(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> FromAsync(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod);
                System.Threading.Tasks.Task<TResult> FromAsync(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> FromAsync(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state);
                System.Threading.Tasks.Task<TResult> FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);

                class FromAsyncTrimPromise`1<TResult, TInstance> : System.Threading.Tasks.Task<TResult>
                {
                    static /*0x0*/ System.AsyncCallback s_completeFromAsyncResult;
                    /*0x0*/ TInstance m_thisRef;
                    /*0x0*/ System.Func<TInstance, System.IAsyncResult, TResult> m_endMethod;

                    static FromAsyncTrimPromise`1();
                    static void CompleteFromAsyncResult(System.IAsyncResult asyncResult);
                    FromAsyncTrimPromise`1(TInstance thisRef, System.Func<TInstance, System.IAsyncResult, TResult> endMethod);
                    void Complete(TInstance thisRef, System.Func<TInstance, System.IAsyncResult, TResult> endMethod, System.IAsyncResult asyncResult, bool requiresSynchronization);
                }

                class <>c__DisplayClass32_0<TResult>
                {
                    /*0x0*/ System.IAsyncResult asyncResult;
                    /*0x0*/ System.Func<System.IAsyncResult, TResult> endFunction;
                    /*0x0*/ System.Action<System.IAsyncResult> endAction;
                    /*0x0*/ System.Threading.Tasks.Task<TResult> promise;
                    /*0x0*/ System.Threading.Tasks.Task t;
                    /*0x0*/ System.Threading.Tasks.TaskScheduler scheduler;

                    <>c__DisplayClass32_0();
                    void <FromAsyncImpl>b__0(object <p0>);
                    void <FromAsyncImpl>b__1(object <p0>, bool <p1>);
                }

                class <>c__DisplayClass35_0<TResult>
                {
                    /*0x0*/ System.Func<System.IAsyncResult, TResult> endFunction;
                    /*0x0*/ System.Action<System.IAsyncResult> endAction;
                    /*0x0*/ System.Threading.Tasks.Task<TResult> promise;

                    <>c__DisplayClass35_0();
                    void <FromAsyncImpl>b__0(System.IAsyncResult iar);
                }

                class <>c__DisplayClass38_0`1<TResult, TArg1>
                {
                    /*0x0*/ System.Func<System.IAsyncResult, TResult> endFunction;
                    /*0x0*/ System.Action<System.IAsyncResult> endAction;
                    /*0x0*/ System.Threading.Tasks.Task<TResult> promise;

                    <>c__DisplayClass38_0`1();
                    void <FromAsyncImpl>b__0(System.IAsyncResult iar);
                }

                class <>c__DisplayClass41_0`2<TResult, TArg1, TArg2>
                {
                    /*0x0*/ System.Func<System.IAsyncResult, TResult> endFunction;
                    /*0x0*/ System.Action<System.IAsyncResult> endAction;
                    /*0x0*/ System.Threading.Tasks.Task<TResult> promise;

                    <>c__DisplayClass41_0`2();
                    void <FromAsyncImpl>b__0(System.IAsyncResult iar);
                }

                class <>c__DisplayClass44_0`3<TResult, TArg1, TArg2, TArg3>
                {
                    /*0x0*/ System.Func<System.IAsyncResult, TResult> endFunction;
                    /*0x0*/ System.Action<System.IAsyncResult> endAction;
                    /*0x0*/ System.Threading.Tasks.Task<TResult> promise;

                    <>c__DisplayClass44_0`3();
                    void <FromAsyncImpl>b__0(System.IAsyncResult iar);
                }

                class <>c<TResult>
                {
                    static /*0x0*/ System.Threading.Tasks.TaskFactory.<>c<TResult> <>9;
                    static /*0x0*/ System.Func<System.Threading.Tasks.Task<System.Threading.Tasks.Task[]>, object, TResult> <>9__58_0;
                    static /*0x0*/ System.Func<System.Threading.Tasks.Task<System.Threading.Tasks.Task[]>, object, TResult> <>9__59_0;
                    static /*0x0*/ System.Func<System.Threading.Tasks.Task<System.Threading.Tasks.Task>, object, TResult> <>9__68_0;
                    static /*0x0*/ System.Func<System.Threading.Tasks.Task<System.Threading.Tasks.Task>, object, TResult> <>9__69_0;

                    static <>c();
                    <>c();
                    TResult <ContinueWhenAllImpl>b__58_0(System.Threading.Tasks.Task<System.Threading.Tasks.Task[]> completedTasks, object state);
                    TResult <ContinueWhenAllImpl>b__59_0(System.Threading.Tasks.Task<System.Threading.Tasks.Task[]> completedTasks, object state);
                    TResult <ContinueWhenAnyImpl>b__68_0(System.Threading.Tasks.Task<System.Threading.Tasks.Task> completedTask, object state);
                    TResult <ContinueWhenAnyImpl>b__69_0(System.Threading.Tasks.Task<System.Threading.Tasks.Task> completedTask, object state);
                }
            }

            class GenericDelegateCache<TAntecedentResult, TResult>
            {
                static /*0x0*/ System.Func<System.Threading.Tasks.Task<System.Threading.Tasks.Task>, object, TResult> CWAnyFuncDelegate;
                static /*0x0*/ System.Func<System.Threading.Tasks.Task<System.Threading.Tasks.Task>, object, TResult> CWAnyActionDelegate;
                static /*0x0*/ System.Func<System.Threading.Tasks.Task<System.Threading.Tasks.Task<TAntecedentResult>[]>, object, TResult> CWAllFuncDelegate;
                static /*0x0*/ System.Func<System.Threading.Tasks.Task<System.Threading.Tasks.Task<TAntecedentResult>[]>, object, TResult> CWAllActionDelegate;

                static GenericDelegateCache();

                class <>c<TAntecedentResult, TResult>
                {
                    static /*0x0*/ System.Threading.Tasks.GenericDelegateCache.<>c<TAntecedentResult, TResult> <>9;

                    static <>c();
                    <>c();
                    TResult <.cctor>b__4_0(System.Threading.Tasks.Task<System.Threading.Tasks.Task> wrappedWinner, object state);
                    TResult <.cctor>b__4_1(System.Threading.Tasks.Task<System.Threading.Tasks.Task> wrappedWinner, object state);
                    TResult <.cctor>b__4_2(System.Threading.Tasks.Task<System.Threading.Tasks.Task<TAntecedentResult>[]> wrappedAntecedents, object state);
                    TResult <.cctor>b__4_3(System.Threading.Tasks.Task<System.Threading.Tasks.Task<TAntecedentResult>[]> wrappedAntecedents, object state);
                }
            }

            interface IProducerConsumerQueue<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                void Enqueue(T item);
                bool TryDequeue(ref T result);
                bool get_IsEmpty();
                int get_Count();
                int GetCountSafe(object syncObj);
            }

            class MultiProducerMultiConsumerQueue<T> : System.Collections.Concurrent.ConcurrentQueue<T>, System.Threading.Tasks.IProducerConsumerQueue<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                MultiProducerMultiConsumerQueue();
                void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item);
                bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(ref T result);
                bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty();
                int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count();
                int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
            }

            class SingleProducerSingleConsumerQueue<T> : System.Threading.Tasks.IProducerConsumerQueue<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                static int INIT_SEGMENT_SIZE = 32;
                static int MAX_SEGMENT_SIZE = 16777216;
                /*0x0*/ System.Threading.Tasks.SingleProducerSingleConsumerQueue.Segment<T> m_head;
                /*0x0*/ System.Threading.Tasks.SingleProducerSingleConsumerQueue.Segment<T> m_tail;

                SingleProducerSingleConsumerQueue();
                void Enqueue(T item);
                void EnqueueSlow(T item, ref System.Threading.Tasks.SingleProducerSingleConsumerQueue.Segment<T> segment);
                bool TryDequeue(ref T result);
                bool TryDequeueSlow(ref System.Threading.Tasks.SingleProducerSingleConsumerQueue.Segment<T> segment, ref T[] array, ref T result);
                bool TryPeek(ref T result);
                bool TryPeekSlow(ref System.Threading.Tasks.SingleProducerSingleConsumerQueue.Segment<T> segment, ref T[] array, ref T result);
                bool TryDequeueIf(System.Predicate<T> predicate, ref T result);
                bool TryDequeueIfSlow(System.Predicate<T> predicate, ref System.Threading.Tasks.SingleProducerSingleConsumerQueue.Segment<T> segment, ref T[] array, ref T result);
                void Clear();
                bool get_IsEmpty();
                System.Collections.Generic.IEnumerator<T> GetEnumerator();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                int get_Count();
                int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);

                class Segment<T>
                {
                    /*0x0*/ System.Threading.Tasks.SingleProducerSingleConsumerQueue.Segment<T> m_next;
                    /*0x0*/ T[] m_array;
                    /*0x0*/ System.Threading.Tasks.SingleProducerSingleConsumerQueue.SegmentState<T> m_state;

                    Segment(int size);
                }

                struct SegmentState<T>
                {
                    /*0x0*/ System.Threading.Tasks.PaddingFor32 m_pad0;
                    /*0x0*/ int m_first;
                    /*0x0*/ int m_lastCopy;
                    /*0x0*/ System.Threading.Tasks.PaddingFor32 m_pad1;
                    /*0x0*/ int m_firstCopy;
                    /*0x0*/ int m_last;
                    /*0x0*/ System.Threading.Tasks.PaddingFor32 m_pad2;
                }

                class SingleProducerSingleConsumerQueue_DebugView<T>
                {
                }

                class <GetEnumerator>d__16<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ int <>1__state;
                    /*0x0*/ T <>2__current;
                    /*0x0*/ System.Threading.Tasks.SingleProducerSingleConsumerQueue<T> <>4__this;
                    /*0x0*/ System.Threading.Tasks.SingleProducerSingleConsumerQueue.Segment<T> <segment>5__2;
                    /*0x0*/ int <pt>5__3;

                    <GetEnumerator>d__16(int <>1__state);
                    void System.IDisposable.Dispose();
                    bool MoveNext();
                    T System.Collections.Generic.IEnumerator<T>.get_Current();
                    void System.Collections.IEnumerator.Reset();
                    object System.Collections.IEnumerator.get_Current();
                }
            }

            class PaddingHelpers
            {
                static int CACHE_LINE_SIZE = 128;
            }

            struct PaddingFor32
            {
            }

            enum TaskStatus
            {
                Created = 0,
                WaitingForActivation = 1,
                WaitingToRun = 2,
                Running = 3,
                WaitingForChildrenToComplete = 4,
                RanToCompletion = 5,
                Canceled = 6,
                Faulted = 7,
            }

            class Task : System.Threading.IThreadPoolWorkItem, System.IAsyncResult, System.IDisposable
            {
                static int OptionsMask = 65535;
                static int TASK_STATE_STARTED = 65536;
                static int TASK_STATE_DELEGATE_INVOKED = 131072;
                static int TASK_STATE_DISPOSED = 262144;
                static int TASK_STATE_EXCEPTIONOBSERVEDBYPARENT = 524288;
                static int TASK_STATE_CANCELLATIONACKNOWLEDGED = 1048576;
                static int TASK_STATE_FAULTED = 2097152;
                static int TASK_STATE_CANCELED = 4194304;
                static int TASK_STATE_WAITING_ON_CHILDREN = 8388608;
                static int TASK_STATE_RAN_TO_COMPLETION = 16777216;
                static int TASK_STATE_WAITINGFORACTIVATION = 33554432;
                static int TASK_STATE_COMPLETION_RESERVED = 67108864;
                static int TASK_STATE_THREAD_WAS_ABORTED = 134217728;
                static int TASK_STATE_WAIT_COMPLETION_NOTIFICATION = 268435456;
                static int TASK_STATE_COMPLETED_MASK = 23068672;
                static int CANCELLATION_REQUESTED = 1;
                static /*0x0*/ int s_taskIdCounter;
                static /*0x8*/ object s_taskCompletionSentinel;
                static /*0x10*/ bool s_asyncDebuggingEnabled;
                static /*0x18*/ System.Action<object> s_taskCancelCallback;
                static /*0x20*/ System.Func<System.Threading.Tasks.Task.ContingentProperties> s_createContingentProperties;
                static /*0x28*/ System.Threading.Tasks.TaskFactory <Factory>k__BackingField;
                static /*0x30*/ System.Threading.Tasks.Task <CompletedTask>k__BackingField;
                static /*0x38*/ System.Predicate<System.Threading.Tasks.Task> s_IsExceptionObservedByParentPredicate;
                static /*0x40*/ System.Threading.ContextCallback s_ecCallback;
                static /*0x48*/ System.Predicate<object> s_IsTaskContinuationNullPredicate;
                static /*0x50*/ System.Collections.Generic.Dictionary<int, System.Threading.Tasks.Task> s_currentActiveTasks;
                static /*0x58*/ object s_activeTasksLock;
                [ThreadStatic] static System.Threading.Tasks.Task t_currentTask;
                [ThreadStatic] static System.Threading.Tasks.StackGuard t_stackGuard;
                /*0x10*/ int m_taskId;
                /*0x18*/ System.Delegate m_action;
                /*0x20*/ object m_stateObject;
                /*0x28*/ System.Threading.Tasks.TaskScheduler m_taskScheduler;
                /*0x30*/ System.Threading.Tasks.Task m_parent;
                /*0x38*/ int m_stateFlags;
                /*0x40*/ object m_continuationObject;
                /*0x48*/ System.Threading.Tasks.Task.ContingentProperties m_contingentProperties;

                static /*0x1f4bcb8*/ Task();
                static /*0x1f42730*/ void TaskCancelCallback(object o);
                static /*0x1f42e8c*/ System.Threading.Tasks.TaskCreationOptions OptionsMethod(int flags);
                static /*0x1f43040*/ bool AnyTaskRequiresNotifyDebuggerOfWaitCompletion(System.Threading.Tasks.Task[] tasks);
                static /*0x1f43894*/ System.Threading.Tasks.Task InternalStartNew(System.Threading.Tasks.Task creatingTask, System.Delegate action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.Tasks.TaskCreationOptions options, System.Threading.Tasks.InternalTaskOptions internalOptions);
                static /*0x1f3c114*/ System.Nullable<int> get_CurrentId();
                static /*0x1f439a0*/ System.Threading.Tasks.Task get_InternalCurrent();
                static /*0x1f41f5c*/ System.Threading.Tasks.Task InternalCurrentIfAttached(System.Threading.Tasks.TaskCreationOptions creationOptions);
                static /*0x1f439f8*/ System.Threading.Tasks.StackGuard get_CurrentStackGuard();
                static /*0x1f4317c*/ bool IsCompletedMethod(int flags);
                static /*0x1f43f28*/ System.Threading.Tasks.TaskFactory get_Factory();
                static /*0x1f43f80*/ System.Threading.Tasks.Task get_CompletedTask();
                static /*0x1f45a50*/ void ExecutionContextCallback(object obj);
                static /*0x1f45e6c*/ System.Runtime.CompilerServices.YieldAwaitable Yield();
                static /*0x1f46dd8*/ void CreationOptionsFromContinuationOptions(System.Threading.Tasks.TaskContinuationOptions continuationOptions, ref System.Threading.Tasks.TaskCreationOptions creationOptions, ref System.Threading.Tasks.InternalTaskOptions internalOptions);
                static /*0x1f3c480*/ void WaitAll(System.Threading.Tasks.Task[] tasks);
                static /*0x1f47730*/ bool WaitAll(System.Threading.Tasks.Task[] tasks, System.TimeSpan timeout);
                static /*0x1f4767c*/ bool WaitAll(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);
                static /*0x1f4899c*/ void WaitAll(System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);
                static /*0x1f478cc*/ bool WaitAll(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
                static void AddToList<T>(T item, ref System.Collections.Generic.LowLevelListWithIList<T> list, int initSize);
                static /*0x1f48a34*/ bool WaitAllBlockingCore(System.Collections.Generic.LowLevelListWithIList<System.Threading.Tasks.Task> tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
                static /*0x1f48e2c*/ void AddExceptionsForCompletedTask(ref System.Collections.Generic.LowLevelListWithIList<System.Exception> exceptions, System.Threading.Tasks.Task t);
                static /*0x1f48f34*/ int WaitAny(System.Threading.Tasks.Task[] tasks);
                static /*0x1f49070*/ int WaitAny(System.Threading.Tasks.Task[] tasks, System.TimeSpan timeout);
                static /*0x1f49204*/ int WaitAny(System.Threading.Tasks.Task[] tasks, System.Threading.CancellationToken cancellationToken);
                static /*0x1f48fb4*/ int WaitAny(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout);
                static /*0x1f4929c*/ int WaitAny(System.Threading.Tasks.Task[] tasks, int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
                static System.Threading.Tasks.Task<TResult> FromResult<TResult>(TResult result);
                static /*0x1f3a144*/ System.Threading.Tasks.Task FromException(System.Exception exception);
                static System.Threading.Tasks.Task<TResult> FromException<TResult>(System.Exception exception);
                static /*0x1f497f8*/ System.Threading.Tasks.Task FromCancellation(System.Threading.CancellationToken cancellationToken);
                static /*0x1f3a900*/ System.Threading.Tasks.Task FromCanceled(System.Threading.CancellationToken cancellationToken);
                static System.Threading.Tasks.Task<TResult> FromCancellation<TResult>(System.Threading.CancellationToken cancellationToken);
                static System.Threading.Tasks.Task<TResult> FromCanceled<TResult>(System.Threading.CancellationToken cancellationToken);
                static System.Threading.Tasks.Task<TResult> FromCancellation<TResult>(System.OperationCanceledException exception);
                static /*0x1f498c0*/ System.Threading.Tasks.Task Run(System.Action action);
                static /*0x1f49990*/ System.Threading.Tasks.Task Run(System.Action action, System.Threading.CancellationToken cancellationToken);
                static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<TResult> function);
                static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken);
                static /*0x1f49a6c*/ System.Threading.Tasks.Task Run(System.Func<System.Threading.Tasks.Task> function);
                static /*0x1f49ac4*/ System.Threading.Tasks.Task Run(System.Func<System.Threading.Tasks.Task> function, System.Threading.CancellationToken cancellationToken);
                static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> function);
                static System.Threading.Tasks.Task<TResult> Run<TResult>(System.Func<System.Threading.Tasks.Task<TResult>> function, System.Threading.CancellationToken cancellationToken);
                static /*0x1f49cd4*/ System.Threading.Tasks.Task Delay(System.TimeSpan delay);
                static /*0x1f49d2c*/ System.Threading.Tasks.Task Delay(System.TimeSpan delay, System.Threading.CancellationToken cancellationToken);
                static /*0x1f4a158*/ System.Threading.Tasks.Task Delay(int millisecondsDelay);
                static /*0x1f49e20*/ System.Threading.Tasks.Task Delay(int millisecondsDelay, System.Threading.CancellationToken cancellationToken);
                static /*0x1f4a1b0*/ System.Threading.Tasks.Task WhenAll(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> tasks);
                static /*0x1f4aa14*/ System.Threading.Tasks.Task WhenAll(System.Threading.Tasks.Task[] tasks);
                static /*0x1f4abcc*/ System.Threading.Tasks.Task InternalWhenAll(System.Threading.Tasks.Task[] tasks);
                static System.Threading.Tasks.Task<TResult[]> WhenAll<TResult>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TResult>> tasks);
                static System.Threading.Tasks.Task<TResult[]> WhenAll<TResult>(System.Threading.Tasks.Task<TResult> tasks);
                static System.Threading.Tasks.Task<TResult[]> InternalWhenAll<TResult>(System.Threading.Tasks.Task<TResult> tasks);
                static /*0x1f4aca0*/ System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(System.Threading.Tasks.Task[] tasks);
                static /*0x1f4ae3c*/ System.Threading.Tasks.Task<System.Threading.Tasks.Task> WhenAny(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> tasks);
                static System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> WhenAny<TResult>(System.Threading.Tasks.Task<TResult> tasks);
                static System.Threading.Tasks.Task<System.Threading.Tasks.Task<TResult>> WhenAny<TResult>(System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task<TResult>> tasks);
                static System.Threading.Tasks.Task<TResult> CreateUnwrapPromise<TResult>(System.Threading.Tasks.Task outerTask, bool lookForOce);
                static /*0x1f4b318*/ System.Delegate[] GetDelegatesFromContinuationObject(object continuationObject);
                static /*0x1f4b944*/ System.Threading.Tasks.Task GetActiveTaskFromId(int taskId);
                static /*0x1f4ba0c*/ bool AddToActiveTasks(System.Threading.Tasks.Task task);
                static /*0x1f4bb70*/ void RemoveFromActiveTasks(int taskId);
                /*0x1f41a48*/ Task(bool canceled, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.CancellationToken ct);
                /*0x1f41afc*/ Task();
                /*0x1f41b24*/ Task(object state, System.Threading.Tasks.TaskCreationOptions creationOptions, bool promiseStyle);
                /*0x1f41da0*/ Task(System.Action action);
                /*0x1f41e98*/ Task(System.Action action, System.Threading.CancellationToken cancellationToken);
                /*0x1f41ec8*/ Task(System.Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f3c384*/ Task(System.Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f3ec38*/ Task(System.Action<object> action, object state);
                /*0x1f41ff8*/ Task(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken);
                /*0x1f42024*/ Task(System.Action<object> action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f3efc4*/ Task(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f41dd0*/ Task(System.Delegate action, object state, System.Threading.Tasks.Task parent, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f41a28*/ System.Threading.Tasks.Task get_ParentForDebugger();
                /*0x1f41a30*/ int get_StateFlagsForDebugger();
                /*0x1f41c48*/ void TaskConstructorCore(System.Delegate action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f4214c*/ void AssignCancellationToken(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.Task antecedent, System.Threading.Tasks.TaskContinuation continuation);
                /*0x1f3ad28*/ bool TrySetCanceled(System.Threading.CancellationToken tokenToRecord);
                /*0x1f3a0f0*/ bool TrySetCanceled(System.Threading.CancellationToken tokenToRecord, object cancellationException);
                /*0x1f3ad30*/ bool TrySetException(object exceptionObject);
                /*0x1f42de4*/ string get_DebuggerDisplayMethodDescription();
                /*0x1f424b0*/ System.Threading.Tasks.TaskCreationOptions get_Options();
                /*0x1f42a74*/ bool AtomicStateUpdate(int newBits, int illegalBits);
                /*0x1f42e94*/ bool AtomicStateUpdate(int newBits, int illegalBits, ref int oldFlags);
                /*0x1f42f34*/ void SetNotificationForWaitCompletion(bool enabled);
                /*0x1f42fb0*/ bool NotifyDebuggerOfWaitCompletionIfNecessary();
                /*0x1f430d0*/ bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
                /*0x1f430f8*/ bool get_ShouldNotifyDebuggerOfWaitCompletion();
                /*0x1f43000*/ bool get_IsWaitNotificationEnabled();
                /*0x1f43018*/ void NotifyDebuggerOfWaitCompletion();
                /*0x1f43110*/ bool MarkStarted();
                /*0x1f420d8*/ void AddNewChild();
                /*0x1f426e8*/ void DisregardChild();
                /*0x1f4311c*/ void Start();
                /*0x1f3f068*/ void Start(System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f433a0*/ void RunSynchronously();
                /*0x1f3c424*/ void RunSynchronously(System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f43404*/ void InternalRunSynchronously(System.Threading.Tasks.TaskScheduler scheduler, bool waitForCompletion);
                /*0x1f41514*/ int get_Id();
                /*0x1f3fda4*/ System.AggregateException get_Exception();
                /*0x1f43bfc*/ System.Threading.Tasks.TaskStatus get_Status();
                /*0x1f3a730*/ bool get_IsCanceled();
                /*0x1f43c5c*/ bool get_IsCancellationRequested();
                /*0x1f42470*/ System.Threading.Tasks.Task.ContingentProperties EnsureContingentPropertiesInitialized(bool needsProtection);
                /*0x1f43cac*/ System.Threading.Tasks.Task.ContingentProperties EnsureContingentPropertiesInitializedCore(bool needsProtection);
                /*0x1f393e8*/ System.Threading.CancellationToken get_CancellationToken();
                /*0x1f43d7c*/ bool get_IsCancellationAcknowledged();
                /*0x1f39758*/ bool get_IsCompleted();
                /*0x1f3a4e4*/ bool get_IsCompletedSuccessfully();
                /*0x1f420c4*/ System.Threading.Tasks.TaskCreationOptions get_CreationOptions();
                /*0x1f43d94*/ System.Threading.WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
                /*0x1f43f10*/ object get_AsyncState();
                /*0x1f43f18*/ bool System.IAsyncResult.get_CompletedSynchronously();
                /*0x1f43f20*/ System.Threading.Tasks.TaskScheduler get_ExecutingTaskScheduler();
                /*0x1f43e1c*/ System.Threading.ManualResetEventSlim get_CompletedEvent();
                /*0x1f43fd8*/ bool get_ExceptionRecorded();
                /*0x1f3a610*/ bool get_IsFaulted();
                /*0x1f4402c*/ System.Threading.ExecutionContext get_CapturedContext();
                /*0x1f423d8*/ void set_CapturedContext(System.Threading.ExecutionContext value);
                /*0x1f4409c*/ void Dispose();
                /*0x1f44108*/ void Dispose(bool disposing);
                /*0x1f4318c*/ void ScheduleAndStart(bool needsProtection);
                /*0x1f42c50*/ void AddException(object exceptionObject);
                /*0x1f441e8*/ void AddException(object exceptionObject, bool representsCancellation);
                /*0x1f43aac*/ System.AggregateException GetExceptions(bool includeTaskCanceledExceptions);
                /*0x1f44378*/ System.Collections.ObjectModel.ReadOnlyCollection<System.Runtime.ExceptionServices.ExceptionDispatchInfo> GetExceptionDispatchInfos();
                /*0x1f44488*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
                /*0x1f444b8*/ void ThrowIfExceptional(bool includeTaskCanceledExceptions);
                /*0x1f44500*/ void UpdateExceptionObservedStatus();
                /*0x1f445d4*/ bool get_IsExceptionObservedByParent();
                /*0x1f445ec*/ bool get_IsDelegateInvoked();
                /*0x1f42c58*/ void Finish(bool bUserDelegateExecuted);
                /*0x1f44604*/ void FinishStageTwo();
                /*0x1f44cb4*/ void FinishStageThree();
                /*0x1f44d04*/ void ProcessChildCompletion(System.Threading.Tasks.Task childTask);
                /*0x1f44874*/ void AddExceptionsFromChildren();
                /*0x1f455b4*/ void Execute();
                /*0x1f45768*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                /*0x1f45770*/ bool ExecuteEntry(bool bPreventDoubleExecution);
                /*0x1f45ac8*/ void InnerInvoke();
                /*0x1f45660*/ void HandleException(System.Exception unhandledException);
                /*0x1f399dc*/ System.Runtime.CompilerServices.TaskAwaiter GetAwaiter();
                /*0x1f399e8*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
                /*0x1f45ba8*/ void SetContinuationForAwait(System.Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext);
                /*0x1f3ecd8*/ void Wait();
                /*0x1f45f90*/ bool Wait(System.TimeSpan timeout);
                /*0x1f4603c*/ void Wait(System.Threading.CancellationToken cancellationToken);
                /*0x1f46048*/ bool Wait(int millisecondsTimeout);
                /*0x1f45e74*/ bool Wait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
                /*0x1f4674c*/ bool WrappedTryRunInline();
                /*0x1f46050*/ bool InternalWait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
                /*0x1f436f4*/ bool SpinThenBlockingWait(int millisecondsTimeout, System.Threading.CancellationToken cancellationToken);
                /*0x1f46828*/ bool SpinWait(int millisecondsTimeout);
                /*0x1f4250c*/ bool InternalCancel(bool bCancelNonExecutingOnly);
                /*0x1f469b8*/ void RecordInternalCancellationRequest();
                /*0x1f46a00*/ void RecordInternalCancellationRequest(System.Threading.CancellationToken tokenToRecord);
                /*0x1f42afc*/ void RecordInternalCancellationRequest(System.Threading.CancellationToken tokenToRecord, object cancellationException);
                /*0x1f42b38*/ void CancellationCleanupLogic();
                /*0x1f45b7c*/ void SetCancellationAcknowledged();
                /*0x1f44ebc*/ void FinishContinuations();
                /*0x1f46a8c*/ void LogFinishCompletionNotification();
                /*0x1f46ae0*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction);
                /*0x1f46cc0*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken);
                /*0x1f46d3c*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f46d48*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f46dc4*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f46b58*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f47028*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state);
                /*0x1f4721c*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken);
                /*0x1f472a8*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f472b4*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f47340*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f470a8*/ System.Threading.Tasks.Task ContinueWith(System.Action<System.Threading.Tasks.Task, object> continuationAction, object state, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWith<TResult>(System.Func<System.Threading.Tasks.Task, object, TResult> continuationFunction, object state, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f46f04*/ void ContinueWithCore(System.Threading.Tasks.Task continuationTask, System.Threading.Tasks.TaskScheduler scheduler, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions options);
                /*0x1f47354*/ void AddCompletionAction(System.Threading.Tasks.ITaskCompletionAction action);
                /*0x1f468e4*/ void AddCompletionAction(System.Threading.Tasks.ITaskCompletionAction action, bool addBeforeOthers);
                /*0x1f4735c*/ bool AddTaskContinuationComplex(object tc, bool addBeforeOthers);
                /*0x1f45dd8*/ bool AddTaskContinuation(object tc, bool addBeforeOthers);
                /*0x1f42820*/ void RemoveContinuation(object continuationObject);
                /*0x1f4b2bc*/ System.Delegate[] GetDelegateContinuationsForDebugger();
                /*0x1f4bcb4*/ void MarkAborted(System.Threading.ThreadAbortException e);
                /*0x1f4588c*/ void ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot);

                class ContingentProperties
                {
                    /*0x10*/ System.Threading.ExecutionContext m_capturedContext;
                    /*0x18*/ System.Threading.ManualResetEventSlim m_completionEvent;
                    /*0x20*/ System.Threading.Tasks.TaskExceptionHolder m_exceptionsHolder;
                    /*0x28*/ System.Threading.CancellationToken m_cancellationToken;
                    /*0x30*/ object m_cancellationRegistration;
                    /*0x38*/ int m_internalCancellationRequested;
                    /*0x3c*/ int m_completionCountdown;
                    /*0x40*/ System.Collections.Generic.LowLevelListWithIList<System.Threading.Tasks.Task> m_exceptionalChildren;

                    /*0x1f4c0d8*/ ContingentProperties();
                    /*0x1f4bfa8*/ void SetCompleted();
                    /*0x1f4bfd0*/ void UnregisterCancellationCallback();
                }

                class SetOnInvokeMres : System.Threading.ManualResetEventSlim, System.Threading.Tasks.ITaskCompletionAction
                {
                    /*0x1f4c0fc*/ SetOnInvokeMres();
                    /*0x1f4c15c*/ void Invoke(System.Threading.Tasks.Task completingTask);
                    /*0x1f4c164*/ bool get_InvokeMayRunArbitraryCode();
                }

                class SetOnCountdownMres : System.Threading.ManualResetEventSlim, System.Threading.Tasks.ITaskCompletionAction
                {
                    /*0x24*/ int _count;

                    /*0x1f4c16c*/ SetOnCountdownMres(int count);
                    /*0x1f4c1d8*/ void Invoke(System.Threading.Tasks.Task completingTask);
                    /*0x1f4c208*/ bool get_InvokeMayRunArbitraryCode();
                }

                class DelayPromise : System.Threading.Tasks.Task<System.Threading.Tasks.VoidTaskResult>
                {
                    /*0x58*/ System.Threading.CancellationToken Token;
                    /*0x60*/ System.Threading.CancellationTokenRegistration Registration;
                    /*0x78*/ System.Threading.Timer Timer;

                    /*0x1f4c210*/ DelayPromise(System.Threading.CancellationToken token);
                    /*0x1f4c364*/ void Complete();
                }

                class WhenAllPromise : System.Threading.Tasks.Task<System.Threading.Tasks.VoidTaskResult>, System.Threading.Tasks.ITaskCompletionAction
                {
                    /*0x58*/ System.Threading.Tasks.Task[] m_tasks;
                    /*0x60*/ int m_count;

                    /*0x1f4c4d4*/ WhenAllPromise(System.Threading.Tasks.Task[] tasks);
                    /*0x1f4c68c*/ void Invoke(System.Threading.Tasks.Task ignored);
                    /*0x1f4c9d8*/ bool get_ShouldNotifyDebuggerOfWaitCompletion();
                    /*0x1f4ca54*/ bool get_InvokeMayRunArbitraryCode();
                }

                class WhenAllPromise<T> : System.Threading.Tasks.Task<T[]>, System.Threading.Tasks.ITaskCompletionAction
                {
                    /*0x0*/ System.Threading.Tasks.Task<T> m_tasks;
                    /*0x0*/ int m_count;

                    WhenAllPromise(System.Threading.Tasks.Task<T> tasks);
                    void Invoke(System.Threading.Tasks.Task ignored);
                    bool get_ShouldNotifyDebuggerOfWaitCompletion();
                    bool get_InvokeMayRunArbitraryCode();
                }

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.Task.<> <>9;
                    static /*0x8*/ System.Action<object> <>9__247_0;
                    static /*0x10*/ System.Threading.TimerCallback <>9__247_1;

                    static /*0x1f4ca5c*/ <>c();
                    /*0x1f4cac0*/ <>c();
                    /*0x1f4cac8*/ void <Delay>b__247_0(object state);
                    /*0x1f4cb28*/ void <Delay>b__247_1(object state);
                    /*0x1f4cb88*/ System.Threading.Tasks.Task.ContingentProperties <.cctor>b__271_0();
                    /*0x1f4cbf4*/ bool <.cctor>b__271_1(System.Threading.Tasks.Task t);
                    /*0x1f4cc0c*/ bool <.cctor>b__271_2(object tc);
                }
            }

            class CompletionActionInvoker : System.Threading.IThreadPoolWorkItem
            {
                /*0x10*/ System.Threading.Tasks.ITaskCompletionAction m_action;
                /*0x18*/ System.Threading.Tasks.Task m_completingTask;

                /*0x1f4cc18*/ CompletionActionInvoker(System.Threading.Tasks.ITaskCompletionAction action, System.Threading.Tasks.Task completingTask);
                /*0x1f4cc44*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                /*0x1f4ccec*/ void MarkAborted(System.Threading.ThreadAbortException e);
            }

            class SystemThreadingTasks_TaskDebugView
            {
                /*0x10*/ System.Threading.Tasks.Task m_task;

                /*0x1f4ccf0*/ SystemThreadingTasks_TaskDebugView(System.Threading.Tasks.Task task);
                /*0x1f4cd18*/ object get_AsyncState();
                /*0x1f4cd34*/ System.Threading.Tasks.TaskCreationOptions get_CreationOptions();
                /*0x1f4cd50*/ System.Exception get_Exception();
                /*0x1f4cd6c*/ int get_Id();
                /*0x1f4cd88*/ bool get_CancellationPending();
                /*0x1f4cdec*/ System.Threading.Tasks.TaskStatus get_Status();
            }

            enum TaskCreationOptions
            {
                None = 0,
                PreferFairness = 1,
                LongRunning = 2,
                AttachedToParent = 4,
                DenyChildAttach = 8,
                HideScheduler = 16,
                RunContinuationsAsynchronously = 64,
            }

            enum InternalTaskOptions
            {
                None = 0,
                InternalOptionsMask = 65280,
                ContinuationTask = 512,
                PromiseTask = 1024,
                LazyCancellation = 4096,
                QueuedByRuntime = 8192,
                DoNotDispose = 16384,
            }

            enum TaskContinuationOptions
            {
                None = 0,
                PreferFairness = 1,
                LongRunning = 2,
                AttachedToParent = 4,
                DenyChildAttach = 8,
                HideScheduler = 16,
                LazyCancellation = 32,
                RunContinuationsAsynchronously = 64,
                NotOnRanToCompletion = 65536,
                NotOnFaulted = 131072,
                NotOnCanceled = 262144,
                OnlyOnRanToCompletion = 393216,
                OnlyOnFaulted = 327680,
                OnlyOnCanceled = 196608,
                ExecuteSynchronously = 524288,
            }

            class StackGuard
            {
                static int MAX_UNCHECKED_INLINING_DEPTH = 20;
                /*0x10*/ int m_inliningDepth;

                /*0x1f4ce5c*/ StackGuard();
                /*0x1f4ce08*/ bool TryBeginInliningScope();
                /*0x1f4ce48*/ void EndInliningScope();
            }

            struct VoidTaskResult
            {
            }

            interface ITaskCompletionAction
            {
                void Invoke(System.Threading.Tasks.Task completingTask);
                bool get_InvokeMayRunArbitraryCode();
            }

            class UnwrapPromise<TResult> : System.Threading.Tasks.Task<TResult>, System.Threading.Tasks.ITaskCompletionAction
            {
                static byte STATE_WAITING_ON_OUTER_TASK = 0;
                static byte STATE_WAITING_ON_INNER_TASK = 1;
                static byte STATE_DONE = 2;
                /*0x0*/ byte _state;
                /*0x0*/ bool _lookForOce;

                UnwrapPromise(System.Threading.Tasks.Task outerTask, bool lookForOce);
                void Invoke(System.Threading.Tasks.Task completingTask);
                void InvokeCore(System.Threading.Tasks.Task completingTask);
                void InvokeCoreAsync(System.Threading.Tasks.Task completingTask);
                void ProcessCompletedOuterTask(System.Threading.Tasks.Task task);
                bool TrySetFromTask(System.Threading.Tasks.Task task, bool lookForOce);
                void ProcessInnerTask(System.Threading.Tasks.Task task);
                bool get_InvokeMayRunArbitraryCode();

                class <>c<TResult>
                {
                    static /*0x0*/ System.Threading.Tasks.UnwrapPromise.<>c<TResult> <>9;
                    static /*0x0*/ System.Threading.WaitCallback <>9__8_0;

                    static <>c();
                    <>c();
                    void <InvokeCoreAsync>b__8_0(object state);
                }
            }

            class ContinuationTaskFromTask : System.Threading.Tasks.Task
            {
                /*0x50*/ System.Threading.Tasks.Task m_antecedent;

                /*0x1f4ce64*/ ContinuationTaskFromTask(System.Threading.Tasks.Task antecedent, System.Delegate action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions);
                /*0x1f4cf20*/ void InnerInvoke();
            }

            class ContinuationResultTaskFromTask<TResult> : System.Threading.Tasks.Task<TResult>
            {
                /*0x0*/ System.Threading.Tasks.Task m_antecedent;

                ContinuationResultTaskFromTask(System.Threading.Tasks.Task antecedent, System.Delegate function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions);
                void InnerInvoke();
            }

            class ContinuationTaskFromResultTask<TAntecedentResult> : System.Threading.Tasks.Task
            {
                /*0x0*/ System.Threading.Tasks.Task<TAntecedentResult> m_antecedent;

                ContinuationTaskFromResultTask(System.Threading.Tasks.Task<TAntecedentResult> antecedent, System.Delegate action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions);
                void InnerInvoke();
            }

            class ContinuationResultTaskFromResultTask<TAntecedentResult, TResult> : System.Threading.Tasks.Task<TResult>
            {
                /*0x0*/ System.Threading.Tasks.Task<TAntecedentResult> m_antecedent;

                ContinuationResultTaskFromResultTask(System.Threading.Tasks.Task<TAntecedentResult> antecedent, System.Delegate function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions);
                void InnerInvoke();
            }

            class TaskContinuation
            {
                static /*0x1f4cff4*/ void InlineIfPossibleOrElseQueue(System.Threading.Tasks.Task task, bool needsProtection);
                /*0x1f4d338*/ TaskContinuation();
                void Run(System.Threading.Tasks.Task completedTask, bool bCanInlineContinuationTask);
                System.Delegate[] GetDelegateContinuationsForDebugger();
            }

            class StandardTaskContinuation : System.Threading.Tasks.TaskContinuation
            {
                /*0x10*/ System.Threading.Tasks.Task m_task;
                /*0x18*/ System.Threading.Tasks.TaskContinuationOptions m_options;
                /*0x20*/ System.Threading.Tasks.TaskScheduler m_taskScheduler;

                /*0x1f4d340*/ StandardTaskContinuation(System.Threading.Tasks.Task task, System.Threading.Tasks.TaskContinuationOptions options, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f4d4e4*/ void Run(System.Threading.Tasks.Task completedTask, bool bCanInlineContinuationTask);
                /*0x1f4d6a4*/ System.Delegate[] GetDelegateContinuationsForDebugger();
            }

            class SynchronizationContextAwaitTaskContinuation : System.Threading.Tasks.AwaitTaskContinuation
            {
                static /*0x0*/ System.Threading.SendOrPostCallback s_postCallback;
                static /*0x8*/ System.Threading.ContextCallback s_postActionCallback;
                /*0x20*/ System.Threading.SynchronizationContext m_syncContext;

                static /*0x1f4dcdc*/ SynchronizationContextAwaitTaskContinuation();
                static /*0x1f4db80*/ void PostAction(object state);
                static /*0x1f4dc14*/ System.Threading.ContextCallback GetPostActionCallback();
                /*0x1f4d768*/ SynchronizationContextAwaitTaskContinuation(System.Threading.SynchronizationContext context, System.Action action, bool flowExecutionContext);
                /*0x1f4d818*/ void Run(System.Threading.Tasks.Task ignored, bool canInlineContinuationTask);

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation.<> <>9;

                    static /*0x1f4dda0*/ <>c();
                    /*0x1f4de04*/ <>c();
                    /*0x1f4de0c*/ void <.cctor>b__7_0(object state);
                }
            }

            class TaskSchedulerAwaitTaskContinuation : System.Threading.Tasks.AwaitTaskContinuation
            {
                /*0x20*/ System.Threading.Tasks.TaskScheduler m_scheduler;

                /*0x1f4de78*/ TaskSchedulerAwaitTaskContinuation(System.Threading.Tasks.TaskScheduler scheduler, System.Action action, bool flowExecutionContext);
                /*0x1f4dea8*/ void Run(System.Threading.Tasks.Task ignored, bool canInlineContinuationTask);

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation.<> <>9;
                    static /*0x8*/ System.Action<object> <>9__2_0;

                    static /*0x1f4e358*/ <>c();
                    /*0x1f4e3bc*/ <>c();
                    /*0x1f4e3c4*/ void <Run>b__2_0(object state);
                }
            }

            class AwaitTaskContinuation : System.Threading.Tasks.TaskContinuation, System.Threading.IThreadPoolWorkItem
            {
                static /*0x0*/ System.Threading.ContextCallback s_invokeActionCallback;
                /*0x10*/ System.Threading.ExecutionContext m_capturedContext;
                /*0x18*/ System.Action m_action;

                static /*0x1f4e50c*/ bool get_IsValidLocationForInlining();
                static /*0x1f4e768*/ void InvokeAction(object state);
                static /*0x1f4e7d4*/ System.Threading.ContextCallback GetInvokeActionCallback();
                static /*0x1f4e87c*/ void RunOrScheduleAction(System.Action action, bool allowInlining, ref System.Threading.Tasks.Task currentTask);
                static /*0x1f4e9d4*/ void UnsafeScheduleAction(System.Action action);
                static /*0x1f4e4b4*/ void ThrowAsyncIfNecessary(System.Exception exc);
                /*0x1f4d798*/ AwaitTaskContinuation(System.Action action, bool flowExecutionContext);
                /*0x1f4e2c4*/ System.Threading.Tasks.Task CreateTask(System.Action<object> action, object state, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f4e0f4*/ void Run(System.Threading.Tasks.Task ignored, bool canInlineContinuationTask);
                /*0x1f4e640*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                /*0x1f4da04*/ void RunCallback(System.Threading.ContextCallback callback, object state, ref System.Threading.Tasks.Task currentTask);
                /*0x1f4ea64*/ System.Delegate[] GetDelegateContinuationsForDebugger();
                /*0x1f4eb08*/ void MarkAborted(System.Threading.ThreadAbortException e);
            }

            class TaskExceptionHolder
            {
                static /*0x0*/ bool s_failFastOnUnobservedException;
                /*0x10*/ System.Threading.Tasks.Task m_task;
                /*0x18*/ System.Collections.Generic.LowLevelListWithIList<System.Runtime.ExceptionServices.ExceptionDispatchInfo> m_faultExceptions;
                /*0x20*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo m_cancellationException;
                /*0x28*/ bool m_isHandled;

                static /*0x1f4f808*/ TaskExceptionHolder();
                static /*0x1f4eb34*/ bool ShouldFailFastOnUnobservedException();
                /*0x1f4eb0c*/ TaskExceptionHolder(System.Threading.Tasks.Task task);
                /*0x1f4eb3c*/ void Finalize();
                /*0x1f4eee0*/ bool get_ContainsFaultList();
                /*0x1f4eefc*/ void Add(object exceptionObject);
                /*0x1f4ef00*/ void Add(object exceptionObject, bool representsCancellation);
                /*0x1f4ef0c*/ void SetCancellationException(object exceptionObject);
                /*0x1f4efc8*/ void AddFaultException(object exceptionObject);
                /*0x1f4f550*/ void MarkAsUnhandled();
                /*0x1f4f4d4*/ void MarkAsHandled(bool calledFromFinalizer);
                /*0x1f4f5c0*/ System.AggregateException CreateExceptionObject(bool calledFromFinalizer, System.Exception includeThisException);
                /*0x1f4f774*/ System.Collections.ObjectModel.ReadOnlyCollection<System.Runtime.ExceptionServices.ExceptionDispatchInfo> GetExceptionDispatchInfos();
                /*0x1f4f800*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
            }

            class TaskFactory
            {
                /*0x10*/ System.Threading.CancellationToken m_defaultCancellationToken;
                /*0x18*/ System.Threading.Tasks.TaskScheduler m_defaultScheduler;
                /*0x20*/ System.Threading.Tasks.TaskCreationOptions m_defaultCreationOptions;
                /*0x24*/ System.Threading.Tasks.TaskContinuationOptions m_defaultContinuationOptions;

                static /*0x1f4fbb0*/ void CheckCreationOptions(System.Threading.Tasks.TaskCreationOptions creationOptions);
                static /*0x1f50420*/ void CheckFromAsyncOptions(System.Threading.Tasks.TaskCreationOptions creationOptions, bool hasBeginMethod);
                static /*0x1f50514*/ System.Threading.Tasks.Task<System.Threading.Tasks.Task[]> CommonCWAllLogic(System.Threading.Tasks.Task[] tasksCopy);
                static System.Threading.Tasks.Task<System.Threading.Tasks.Task<T>[]> CommonCWAllLogic<T>(System.Threading.Tasks.Task<T> tasksCopy);
                static /*0x1f50c44*/ System.Threading.Tasks.Task<System.Threading.Tasks.Task> CommonCWAnyLogic(System.Collections.Generic.IList<System.Threading.Tasks.Task> tasks);
                static /*0x1f51594*/ System.Threading.Tasks.Task[] CheckMultiContinuationTasksAndCopy(System.Threading.Tasks.Task[] tasks);
                static System.Threading.Tasks.Task<TResult> CheckMultiContinuationTasksAndCopy<TResult>(System.Threading.Tasks.Task<TResult> tasks);
                static /*0x1f4faa8*/ void CheckMultiTaskContinuationOptions(System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f4fa0c*/ TaskFactory();
                /*0x1f4fa70*/ TaskFactory(System.Threading.CancellationToken cancellationToken);
                /*0x1f4fa80*/ TaskFactory(System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f4fa94*/ TaskFactory(System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f4fa20*/ TaskFactory(System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f4f850*/ System.Threading.Tasks.TaskScheduler get_DefaultScheduler();
                /*0x1f4f954*/ System.Threading.Tasks.TaskScheduler GetDefaultScheduler(System.Threading.Tasks.Task currTask);
                /*0x1f4fc10*/ System.Threading.CancellationToken get_CancellationToken();
                /*0x1f4fc18*/ System.Threading.Tasks.TaskScheduler get_Scheduler();
                /*0x1f4fc20*/ System.Threading.Tasks.TaskCreationOptions get_CreationOptions();
                /*0x1f4fc28*/ System.Threading.Tasks.TaskContinuationOptions get_ContinuationOptions();
                /*0x1f4fc30*/ System.Threading.Tasks.Task StartNew(System.Action action);
                /*0x1f4fcf8*/ System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.CancellationToken cancellationToken);
                /*0x1f4fdc0*/ System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f4fe8c*/ System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f4ff20*/ System.Threading.Tasks.Task StartNew(System.Action action, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.InternalTaskOptions internalOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f4ffb8*/ System.Threading.Tasks.Task StartNew(System.Action<object> action, object state);
                /*0x1f50084*/ System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken);
                /*0x1f50158*/ System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f50230*/ System.Threading.Tasks.Task StartNew(System.Action<object> action, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function);
                System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<TResult> function, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state);
                System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> StartNew<TResult>(System.Func<object, TResult> function, object state, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f502c8*/ System.Threading.Tasks.Task FromAsync(System.IAsyncResult asyncResult, System.Action<System.IAsyncResult> endMethod);
                /*0x1f50370*/ System.Threading.Tasks.Task FromAsync(System.IAsyncResult asyncResult, System.Action<System.IAsyncResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f502fc*/ System.Threading.Tasks.Task FromAsync(System.IAsyncResult asyncResult, System.Action<System.IAsyncResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f503a4*/ System.Threading.Tasks.Task FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, object state);
                /*0x1f503ac*/ System.Threading.Tasks.Task FromAsync(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, object state);
                System.Threading.Tasks.Task FromAsync<TArg1>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
                System.Threading.Tasks.Task FromAsync<TArg1, TArg2>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
                System.Threading.Tasks.Task FromAsync<TArg1, TArg2, TArg3>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Action<System.IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod);
                System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.IAsyncResult asyncResult, System.Func<System.IAsyncResult, TResult> endMethod, System.Threading.Tasks.TaskCreationOptions creationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state);
                System.Threading.Tasks.Task<TResult> FromAsync<TResult>(System.Func<System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TResult>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TResult>(System.Func<TArg1, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TResult>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TResult>(System.Func<TArg1, TArg2, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
                System.Threading.Tasks.Task<TResult> FromAsync<TArg1, TArg2, TArg3, TResult>(System.Func<TArg1, TArg2, TArg3, System.AsyncCallback, object, System.IAsyncResult> beginMethod, System.Func<System.IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, System.Threading.Tasks.TaskCreationOptions creationOptions);
                /*0x1f5090c*/ System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction);
                /*0x1f509dc*/ System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.CancellationToken cancellationToken);
                /*0x1f50aac*/ System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f50b7c*/ System.Threading.Tasks.Task ContinueWhenAll(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task[]> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction);
                System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task ContinueWhenAll<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>[]> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWhenAll<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>[], TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                /*0x1f5125c*/ System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction);
                /*0x1f5132c*/ System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken);
                /*0x1f513fc*/ System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                /*0x1f514cc*/ System.Threading.Tasks.Task ContinueWhenAny(System.Threading.Tasks.Task[] tasks, System.Action<System.Threading.Tasks.Task> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TResult>(System.Threading.Tasks.Task[] tasks, System.Func<System.Threading.Tasks.Task, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task<TResult> ContinueWhenAny<TAntecedentResult, TResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Func<System.Threading.Tasks.Task<TAntecedentResult>, TResult> continuationFunction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);
                System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction);
                System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.CancellationToken cancellationToken);
                System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.Tasks.TaskContinuationOptions continuationOptions);
                System.Threading.Tasks.Task ContinueWhenAny<TAntecedentResult>(System.Threading.Tasks.Task<TAntecedentResult> tasks, System.Action<System.Threading.Tasks.Task<TAntecedentResult>> continuationAction, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.TaskContinuationOptions continuationOptions, System.Threading.Tasks.TaskScheduler scheduler);

                class CompleteOnCountdownPromise : System.Threading.Tasks.Task<System.Threading.Tasks.Task[]>, System.Threading.Tasks.ITaskCompletionAction
                {
                    /*0x58*/ System.Threading.Tasks.Task[] _tasks;
                    /*0x60*/ int _count;

                    /*0x1f505f4*/ CompleteOnCountdownPromise(System.Threading.Tasks.Task[] tasksCopy);
                    /*0x1f50758*/ void Invoke(System.Threading.Tasks.Task completingTask);
                    /*0x1f51734*/ bool get_InvokeMayRunArbitraryCode();
                    /*0x1f5173c*/ bool get_ShouldNotifyDebuggerOfWaitCompletion();
                }

                class CompleteOnCountdownPromise<T> : System.Threading.Tasks.Task<System.Threading.Tasks.Task<T>[]>, System.Threading.Tasks.ITaskCompletionAction
                {
                    /*0x0*/ System.Threading.Tasks.Task<T> _tasks;
                    /*0x0*/ int _count;

                    CompleteOnCountdownPromise(System.Threading.Tasks.Task<T> tasksCopy);
                    void Invoke(System.Threading.Tasks.Task completingTask);
                    bool get_InvokeMayRunArbitraryCode();
                    bool get_ShouldNotifyDebuggerOfWaitCompletion();
                }

                class CompleteOnInvokePromise : System.Threading.Tasks.Task<System.Threading.Tasks.Task>, System.Threading.Tasks.ITaskCompletionAction
                {
                    /*0x58*/ System.Collections.Generic.IList<System.Threading.Tasks.Task> _tasks;

                    /*0x1f50e8c*/ CompleteOnInvokePromise(System.Collections.Generic.IList<System.Threading.Tasks.Task> tasks);
                    /*0x1f50fe0*/ void Invoke(System.Threading.Tasks.Task completingTask);
                    /*0x1f517b8*/ bool get_InvokeMayRunArbitraryCode();
                }
            }

            class TaskScheduler
            {
                static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<System.Threading.Tasks.TaskScheduler, object> s_activeTaskSchedulers;
                static /*0x8*/ System.Threading.Tasks.TaskScheduler s_defaultTaskScheduler;
                static /*0x10*/ int s_taskSchedulerIdCounter;
                static /*0x18*/ System.EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs> _unobservedTaskException;
                static /*0x20*/ System.Threading.Lock _unobservedTaskExceptionLockObject;
                /*0x10*/ int m_taskSchedulerId;

                static /*0x1f52498*/ TaskScheduler();
                static /*0x1f518dc*/ System.Threading.Tasks.TaskScheduler get_Default();
                static /*0x1f4f8b4*/ System.Threading.Tasks.TaskScheduler get_Current();
                static /*0x1f4e214*/ System.Threading.Tasks.TaskScheduler get_InternalCurrent();
                static /*0x1f51934*/ System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext();
                static /*0x1f51b5c*/ void add_UnobservedTaskException(System.EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs> value);
                static /*0x1f51cf4*/ void remove_UnobservedTaskException(System.EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs> value);
                static /*0x1f4edac*/ void PublishUnobservedTaskException(object sender, System.Threading.Tasks.UnobservedTaskExceptionEventArgs ueea);
                static /*0x1f51fac*/ System.Threading.Tasks.TaskScheduler[] GetTaskSchedulersForDebugger();
                /*0x1f517dc*/ TaskScheduler();
                void QueueTask(System.Threading.Tasks.Task task);
                bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks();
                /*0x1f517c0*/ int get_MaximumConcurrencyLevel();
                /*0x1f4d13c*/ bool TryRunInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                /*0x1f517c8*/ bool TryDequeue(System.Threading.Tasks.Task task);
                /*0x1f517d0*/ void NotifyWorkItemProgress();
                /*0x1f517d4*/ bool get_RequiresAtomicStartTransition();
                /*0x1f517e4*/ void AddToActiveTaskSchedulers();
                /*0x1f51a44*/ int get_Id();
                /*0x1f51ae0*/ bool TryExecuteTask(System.Threading.Tasks.Task task);
                /*0x1f51e88*/ System.Threading.Tasks.Task[] GetScheduledTasksForDebugger();

                class SystemThreadingTasks_TaskSchedulerDebugView
                {
                }
            }

            class SynchronizationContextTaskScheduler : System.Threading.Tasks.TaskScheduler
            {
                static /*0x0*/ System.Threading.SendOrPostCallback s_postCallback;
                /*0x18*/ System.Threading.SynchronizationContext m_synchronizationContext;

                static /*0x1f52678*/ SynchronizationContextTaskScheduler();
                /*0x1f5198c*/ SynchronizationContextTaskScheduler();
                /*0x1f5259c*/ void QueueTask(System.Threading.Tasks.Task task);
                /*0x1f52620*/ bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                /*0x1f52668*/ System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks();
                /*0x1f52670*/ int get_MaximumConcurrencyLevel();

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.SynchronizationContextTaskScheduler.<> <>9;

                    static /*0x1f5273c*/ <>c();
                    /*0x1f527a0*/ <>c();
                    /*0x1f527a8*/ void <.cctor>b__8_0(object s);
                }
            }

            class UnobservedTaskExceptionEventArgs : System.EventArgs
            {
                /*0x10*/ System.AggregateException m_exception;
                /*0x18*/ bool m_observed;

                /*0x1f4ed40*/ UnobservedTaskExceptionEventArgs(System.AggregateException exception);
                /*0x1f52830*/ void SetObserved();
                /*0x1f5283c*/ bool get_Observed();
                /*0x1f52844*/ System.AggregateException get_Exception();
            }

            class ThreadPoolTaskScheduler : System.Threading.Tasks.TaskScheduler
            {
                static /*0x0*/ System.Threading.ParameterizedThreadStart s_longRunningThreadWork;

                static /*0x1f52bfc*/ ThreadPoolTaskScheduler();
                /*0x1f52544*/ ThreadPoolTaskScheduler();
                /*0x1f5284c*/ void QueueTask(System.Threading.Tasks.Task task);
                /*0x1f52a30*/ bool TryExecuteTaskInline(System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);
                /*0x1f52b1c*/ bool TryDequeue(System.Threading.Tasks.Task task);
                /*0x1f52b28*/ System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks();
                /*0x1f52b40*/ System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> FilterTasksFromWorkItems(System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem> tpwItems);
                /*0x1f52bec*/ void NotifyWorkItemProgress();
                /*0x1f52bf4*/ bool get_RequiresAtomicStartTransition();

                class <FilterTasksFromWorkItems>d__6 : System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Threading.Tasks.Task>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Threading.Tasks.Task <>2__current;
                    /*0x20*/ int <>l__initialThreadId;
                    /*0x28*/ System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem> tpwItems;
                    /*0x30*/ System.Collections.Generic.IEnumerable<System.Threading.IThreadPoolWorkItem> <>3__tpwItems;
                    /*0x38*/ System.Collections.Generic.IEnumerator<System.Threading.IThreadPoolWorkItem> <>7__wrap1;

                    /*0x1f52bb8*/ <FilterTasksFromWorkItems>d__6(int <>1__state);
                    /*0x1f52cc0*/ void System.IDisposable.Dispose();
                    /*0x1f52cdc*/ bool MoveNext();
                    /*0x1f52fec*/ void <>m__Finally1();
                    /*0x1f5309c*/ System.Threading.Tasks.Task System.Collections.Generic.IEnumerator<System.Threading.Tasks.Task>.get_Current();
                    /*0x1f530a4*/ void System.Collections.IEnumerator.Reset();
                    /*0x1f530e4*/ object System.Collections.IEnumerator.get_Current();
                    /*0x1f530ec*/ System.Collections.Generic.IEnumerator<System.Threading.Tasks.Task> System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>.GetEnumerator();
                    /*0x1f53190*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                }

                class <>c
                {
                    static /*0x0*/ System.Threading.Tasks.ThreadPoolTaskScheduler.<> <>9;

                    static /*0x1f53194*/ <>c();
                    /*0x1f531f8*/ <>c();
                    /*0x1f53200*/ void <.cctor>b__10_0(object s);
                }
            }

            enum CausalityTraceLevel
            {
                Required = 0,
                Important = 1,
                Verbose = 2,
            }

            enum AsyncCausalityStatus
            {
                Started = 0,
                Completed = 1,
                Canceled = 2,
                Error = 3,
            }

            enum CausalityRelation
            {
                AssignDelegate = 0,
                Join = 1,
                Choice = 2,
                Cancel = 3,
                Error = 4,
            }

            enum CausalitySynchronousWork
            {
                CompletionNotification = 0,
                ProgressNotification = 1,
                Execution = 2,
            }

            class AsyncCausalityTracer
            {
                static /*0x1f53288*/ void EnableToETW(bool enabled);
                static /*0x1f5328c*/ bool get_LoggingOn();
                static /*0x1f53294*/ void TraceOperationCreation(System.Threading.Tasks.CausalityTraceLevel traceLevel, int taskId, string operationName, ulong relatedContext);
                static /*0x1f53298*/ void TraceOperationCompletion(System.Threading.Tasks.CausalityTraceLevel traceLevel, int taskId, System.Threading.Tasks.AsyncCausalityStatus status);
                static /*0x1f5329c*/ void TraceOperationRelation(System.Threading.Tasks.CausalityTraceLevel traceLevel, int taskId, System.Threading.Tasks.CausalityRelation relation);
                static /*0x1f532a0*/ void TraceSynchronousWorkStart(System.Threading.Tasks.CausalityTraceLevel traceLevel, int taskId, System.Threading.Tasks.CausalitySynchronousWork work);
                static /*0x1f532a4*/ void TraceSynchronousWorkCompletion(System.Threading.Tasks.CausalityTraceLevel traceLevel, System.Threading.Tasks.CausalitySynchronousWork work);
                static /*0x1f532a8*/ ulong GetOperationId(uint taskId);
            }

            class TaskAsyncEnumerableExtensions
            {
                static /*0x1f532dc*/ System.Runtime.CompilerServices.ConfiguredAsyncDisposable ConfigureAwait(System.IAsyncDisposable source, bool continueOnCapturedContext);
                static System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> ConfigureAwait<T>(System.Collections.Generic.IAsyncEnumerable<T> source, bool continueOnCapturedContext);
                static System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> WithCancellation<T>(System.Collections.Generic.IAsyncEnumerable<T> source, System.Threading.CancellationToken cancellationToken);
            }

            namespace Sources
            {
                enum ValueTaskSourceOnCompletedFlags
                {
                    None = 0,
                    UseSchedulingContext = 1,
                    FlowExecutionContext = 2,
                }

                enum ValueTaskSourceStatus
                {
                    Pending = 0,
                    Succeeded = 1,
                    Faulted = 2,
                    Canceled = 3,
                }

                interface IValueTaskSource
                {
                    System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(short token);
                    void OnCompleted(System.Action<object> continuation, object state, short token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags);
                    void GetResult(short token);
                }

                interface IValueTaskSource<TResult>
                {
                    System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(short token);
                    void OnCompleted(System.Action<object> continuation, object state, short token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags);
                    TResult GetResult(short token);
                }

                struct ManualResetValueTaskSourceCore<TResult>
                {
                    /*0x0*/ System.Action<object> _continuation;
                    /*0x0*/ object _continuationState;
                    /*0x0*/ System.Threading.ExecutionContext _executionContext;
                    /*0x0*/ object _capturedContext;
                    /*0x0*/ bool _completed;
                    /*0x0*/ TResult _result;
                    /*0x0*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo _error;
                    /*0x0*/ short _version;
                    /*0x0*/ bool <RunContinuationsAsynchronously>k__BackingField;

                    bool get_RunContinuationsAsynchronously();
                    void set_RunContinuationsAsynchronously(bool value);
                    void Reset();
                    void SetResult(TResult result);
                    void SetException(System.Exception error);
                    short get_Version();
                    System.Threading.Tasks.Sources.ValueTaskSourceStatus GetStatus(short token);
                    TResult GetResult(short token);
                    void OnCompleted(System.Action<object> continuation, object state, short token, System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags flags);
                    void ValidateToken(short token);
                    void SignalCompletion();
                    void InvokeContinuation();

                    class <>c<TResult>
                    {
                        static /*0x0*/ System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore.<>c<TResult> <>9;
                        static /*0x0*/ System.Threading.SendOrPostCallback <>9__19_0;
                        static /*0x0*/ System.Threading.ContextCallback<System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore<TResult>> <>9__21_0;
                        static /*0x0*/ System.Threading.SendOrPostCallback <>9__22_0;

                        static <>c();
                        <>c();
                        void <OnCompleted>b__19_0(object s);
                        void <SignalCompletion>b__21_0(ref System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore<TResult> s);
                        void <InvokeContinuation>b__22_0(object s);
                    }
                }

                class ManualResetValueTaskSourceCoreShared
                {
                    static /*0x0*/ System.Action<object> s_sentinel;

                    static /*0x1f5338c*/ ManualResetValueTaskSourceCoreShared();
                    static /*0x1f53310*/ void ThrowInvalidOperationException();
                    static /*0x1f53350*/ void CompletionSentinel(object _);
                }
            }
        }
    }

    namespace Text
    {
        class ASCIIEncoding : System.Text.Encoding
        {
            static /*0x0*/ System.Text.ASCIIEncoding.ASCIIEncodingSealed s_default;

            static /*0x1f55530*/ ASCIIEncoding();
            /*0x1f53420*/ ASCIIEncoding();
            /*0x1f5342c*/ void SetDefaultFallbacks();
            /*0x1f53580*/ int GetByteCount(char[] chars, int index, int count);
            /*0x1f53704*/ int GetByteCount(string chars);
            /*0x1f53794*/ int GetByteCount(char* chars, int count);
            /*0x1f5386c*/ int GetBytes(string chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f53acc*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f53d48*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x1f53e48*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x1f53fcc*/ int GetCharCount(byte* bytes, int count);
            /*0x1f540a4*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x1f54320*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x1f54420*/ string GetString(byte[] bytes, int byteIndex, int byteCount);
            /*0x1f545e8*/ int GetByteCount(char* chars, int charCount, System.Text.EncoderNLS encoder);
            /*0x1f5497c*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x1f54da8*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS decoder);
            /*0x1f54f3c*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS decoder);
            /*0x1f551d4*/ int GetMaxByteCount(int charCount);
            /*0x1f552dc*/ int GetMaxCharCount(int byteCount);
            /*0x1f553e0*/ bool get_IsSingleByte();
            /*0x1f553e8*/ System.Text.Decoder GetDecoder();
            /*0x1f5548c*/ System.Text.Encoder GetEncoder();

            class ASCIIEncodingSealed : System.Text.ASCIIEncoding
            {
                /*0x1f555a4*/ ASCIIEncodingSealed();
            }
        }

        class Decoder
        {
            /*0x10*/ System.Text.DecoderFallback _fallback;
            /*0x18*/ System.Text.DecoderFallbackBuffer _fallbackBuffer;

            /*0x1f55600*/ Decoder();
            /*0x1f55608*/ System.Text.DecoderFallback get_Fallback();
            /*0x1f55610*/ void set_Fallback(System.Text.DecoderFallback value);
            /*0x1f54ef8*/ System.Text.DecoderFallbackBuffer get_FallbackBuffer();
            /*0x1f556e8*/ bool get_InternalHasFallbackBuffer();
            /*0x1f556f8*/ void Reset();
            int GetCharCount(byte[] bytes, int index, int count);
            /*0x1f55800*/ int GetCharCount(byte[] bytes, int index, int count, bool flush);
            /*0x1f5580c*/ int GetCharCount(byte* bytes, int count, bool flush);
            /*0x1f55970*/ int GetCharCount(System.ReadOnlySpan<byte> bytes, bool flush);
            int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x1f559e4*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
            /*0x1f559f0*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
            /*0x1f55c08*/ int GetChars(System.ReadOnlySpan<byte> bytes, System.Span<char> chars, bool flush);
            /*0x1f55cb0*/ void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, ref int bytesUsed, ref int charsUsed, ref bool completed);
            /*0x1f55fa8*/ void Convert(byte* bytes, int byteCount, char* chars, int charCount, bool flush, ref int bytesUsed, ref int charsUsed, ref bool completed);
            /*0x1f561d4*/ void Convert(System.ReadOnlySpan<byte> bytes, System.Span<char> chars, bool flush, ref int bytesUsed, ref int charsUsed, ref bool completed);
        }

        class InternalDecoderBestFitFallback : System.Text.DecoderFallback
        {
            /*0x10*/ System.Text.Encoding _encoding;
            /*0x18*/ char[] _arrayBestFit;
            /*0x20*/ char _cReplacement;

            /*0x1f562a8*/ InternalDecoderBestFitFallback(System.Text.Encoding encoding);
            /*0x1f562e0*/ System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            /*0x1f56468*/ int get_MaxCharCount();
            /*0x1f56470*/ bool Equals(object value);
            /*0x1f56518*/ int GetHashCode();
        }

        class InternalDecoderBestFitFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            static /*0x0*/ object s_InternalSyncObject;
            /*0x20*/ char _cBestFit;
            /*0x24*/ int _iCount;
            /*0x28*/ int _iSize;
            /*0x30*/ System.Text.InternalDecoderBestFitFallback _oFallback;

            static /*0x1f5653c*/ object get_InternalSyncObject();
            /*0x1f56340*/ InternalDecoderBestFitFallbackBuffer(System.Text.InternalDecoderBestFitFallback fallback);
            /*0x1f565e0*/ bool Fallback(byte[] bytesUnknown, int index);
            /*0x1f56760*/ char GetNextChar();
            /*0x1f567a0*/ bool MovePrevious();
            /*0x1f567cc*/ int get_Remaining();
            /*0x1f567d8*/ void Reset();
            /*0x1f567e8*/ int InternalFallback(byte[] bytes, byte* pBytes);
            /*0x1f56620*/ char TryBestFit(byte[] bytesCheck);
        }

        class DecoderExceptionFallback : System.Text.DecoderFallback
        {
            /*0x1f567f0*/ DecoderExceptionFallback();
            /*0x1f567f8*/ System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            /*0x1f5685c*/ int get_MaxCharCount();
            /*0x1f56864*/ bool Equals(object value);
            /*0x1f568c0*/ int GetHashCode();
        }

        class DecoderExceptionFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            /*0x1f56854*/ DecoderExceptionFallbackBuffer();
            /*0x1f568c8*/ bool Fallback(byte[] bytesUnknown, int index);
            /*0x1f56a90*/ char GetNextChar();
            /*0x1f56a98*/ bool MovePrevious();
            /*0x1f56aa0*/ int get_Remaining();
            /*0x1f568d0*/ void Throw(byte[] bytesUnknown, int index);
        }

        class DecoderFallbackException : System.ArgumentException
        {
            /*0x98*/ byte[] _bytesUnknown;
            /*0xa0*/ int _index;

            /*0x1f56c34*/ DecoderFallbackException();
            /*0x1f56c90*/ DecoderFallbackException(string message);
            /*0x1f56cb4*/ DecoderFallbackException(string message, System.Exception innerException);
            /*0x1f56c04*/ DecoderFallbackException(string message, byte[] bytesUnknown, int index);
            /*0x1f56cd8*/ DecoderFallbackException(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);
            /*0x1f56ce0*/ byte[] get_BytesUnknown();
            /*0x1f56ce8*/ int get_Index();
        }

        class DecoderFallback
        {
            static /*0x0*/ System.Text.DecoderFallback s_replacementFallback;
            static /*0x8*/ System.Text.DecoderFallback s_exceptionFallback;

            static /*0x1f534e4*/ System.Text.DecoderFallback get_ReplacementFallback();
            static /*0x1f56d38*/ System.Text.DecoderFallback get_ExceptionFallback();
            /*0x1f562d8*/ DecoderFallback();
            System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            int get_MaxCharCount();
        }

        class DecoderFallbackBuffer
        {
            /*0x10*/ byte* byteStart;
            /*0x18*/ char* charEnd;

            /*0x1f565d8*/ DecoderFallbackBuffer();
            bool Fallback(byte[] bytesUnknown, int index);
            char GetNextChar();
            bool MovePrevious();
            int get_Remaining();
            /*0x1f56ddc*/ void Reset();
            /*0x1f551c4*/ void InternalReset();
            /*0x1f54f34*/ void InternalInitialize(byte* byteStart, char* charEnd);
            /*0x1f56e04*/ bool InternalFallback(byte[] bytes, byte* pBytes, ref char* chars);
            /*0x1f56f94*/ int InternalFallback(byte[] bytes, byte* pBytes);
            /*0x1f57104*/ void ThrowLastBytesRecursive(byte[] bytesUnknown);
        }

        class DecoderNLS : System.Text.Decoder
        {
            /*0x20*/ System.Text.Encoding _encoding;
            /*0x28*/ bool _mustFlush;
            /*0x29*/ bool _throwOnOverflow;
            /*0x2c*/ int _bytesUsed;

            /*0x1f55448*/ DecoderNLS(System.Text.Encoding encoding);
            /*0x1f57380*/ DecoderNLS();
            /*0x1f573a8*/ void Reset();
            /*0x1f573c0*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x1f573d0*/ int GetCharCount(byte[] bytes, int index, int count, bool flush);
            /*0x1f575a8*/ int GetCharCount(byte* bytes, int count, bool flush);
            /*0x1f576a0*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x1f576b0*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
            /*0x1f57948*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
            /*0x1f57a68*/ void Convert(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, int charCount, bool flush, ref int bytesUsed, ref int charsUsed, ref bool completed);
            /*0x1f57d38*/ void Convert(byte* bytes, int byteCount, char* chars, int charCount, bool flush, ref int bytesUsed, ref int charsUsed, ref bool completed);
            /*0x1f57ee4*/ bool get_MustFlush();
            /*0x1f57eec*/ bool get_HasState();
            /*0x1f57ef4*/ void ClearMustFlush();
        }

        class DecoderReplacementFallback : System.Text.DecoderFallback, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ string _strDefault;

            /*0x1f56cf0*/ DecoderReplacementFallback();
            /*0x1f580a4*/ DecoderReplacementFallback(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f57efc*/ DecoderReplacementFallback(string replacement);
            /*0x1f581a8*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f58204*/ string get_DefaultString();
            /*0x1f5820c*/ System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
            /*0x1f582a8*/ int get_MaxCharCount();
            /*0x1f582c4*/ bool Equals(object value);
            /*0x1f58344*/ int GetHashCode();
        }

        class DecoderReplacementFallbackBuffer : System.Text.DecoderFallbackBuffer
        {
            /*0x20*/ string _strDefault;
            /*0x28*/ int _fallbackCount;
            /*0x2c*/ int _fallbackIndex;

            /*0x1f5826c*/ DecoderReplacementFallbackBuffer(System.Text.DecoderReplacementFallback fallback);
            /*0x1f58364*/ bool Fallback(byte[] bytesUnknown, int index);
            /*0x1f583a8*/ char GetNextChar();
            /*0x1f583f8*/ bool MovePrevious();
            /*0x1f58428*/ int get_Remaining();
            /*0x1f58434*/ void Reset();
            /*0x1f58444*/ int InternalFallback(byte[] bytes, byte* pBytes);
        }

        class Encoder
        {
            /*0x10*/ System.Text.EncoderFallback _fallback;
            /*0x18*/ System.Text.EncoderFallbackBuffer _fallbackBuffer;

            /*0x1f58460*/ Encoder();
            /*0x1f58468*/ System.Text.EncoderFallback get_Fallback();
            /*0x1f58470*/ void set_Fallback(System.Text.EncoderFallback value);
            /*0x1f548f0*/ System.Text.EncoderFallbackBuffer get_FallbackBuffer();
            /*0x1f548e0*/ bool get_InternalHasFallbackBuffer();
            /*0x1f58548*/ void Reset();
            int GetByteCount(char[] chars, int index, int count, bool flush);
            /*0x1f5862c*/ int GetByteCount(char* chars, int count, bool flush);
            /*0x1f58798*/ int GetByteCount(System.ReadOnlySpan<char> chars, bool flush);
            int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
            /*0x1f5880c*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
            /*0x1f58a24*/ int GetBytes(System.ReadOnlySpan<char> chars, System.Span<byte> bytes, bool flush);
            /*0x1f58acc*/ void Convert(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, ref int charsUsed, ref int bytesUsed, ref bool completed);
            /*0x1f58dc4*/ void Convert(char* chars, int charCount, byte* bytes, int byteCount, bool flush, ref int charsUsed, ref int bytesUsed, ref bool completed);
            /*0x1f58ff0*/ void Convert(System.ReadOnlySpan<char> chars, System.Span<byte> bytes, bool flush, ref int charsUsed, ref int bytesUsed, ref bool completed);
        }

        class InternalEncoderBestFitFallback : System.Text.EncoderFallback
        {
            /*0x10*/ System.Text.Encoding _encoding;
            /*0x18*/ char[] _arrayBestFit;

            /*0x1f590c0*/ InternalEncoderBestFitFallback(System.Text.Encoding encoding);
            /*0x1f590f0*/ System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            /*0x1f59278*/ int get_MaxCharCount();
            /*0x1f59280*/ bool Equals(object value);
            /*0x1f59344*/ int GetHashCode();
        }

        class InternalEncoderBestFitFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            static /*0x0*/ object s_InternalSyncObject;
            /*0x30*/ char _cBestFit;
            /*0x38*/ System.Text.InternalEncoderBestFitFallback _oFallback;
            /*0x40*/ int _iCount;
            /*0x44*/ int _iSize;

            static /*0x1f59368*/ object get_InternalSyncObject();
            /*0x1f59150*/ InternalEncoderBestFitFallbackBuffer(System.Text.InternalEncoderBestFitFallback fallback);
            /*0x1f5940c*/ bool Fallback(char charUnknown, int index);
            /*0x1f59510*/ bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
            /*0x1f596f0*/ char GetNextChar();
            /*0x1f59730*/ bool MovePrevious();
            /*0x1f5975c*/ int get_Remaining();
            /*0x1f59768*/ void Reset();
            /*0x1f5943c*/ char TryBestFit(char cUnknown);
        }

        class EncoderExceptionFallback : System.Text.EncoderFallback
        {
            /*0x1f5977c*/ EncoderExceptionFallback();
            /*0x1f59784*/ System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            /*0x1f597e8*/ int get_MaxCharCount();
            /*0x1f597f0*/ bool Equals(object value);
            /*0x1f5984c*/ int GetHashCode();
        }

        class EncoderExceptionFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            /*0x1f597e0*/ EncoderExceptionFallbackBuffer();
            /*0x1f59854*/ bool Fallback(char charUnknown, int index);
            /*0x1f59938*/ bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
            /*0x1f59d90*/ char GetNextChar();
            /*0x1f59d98*/ bool MovePrevious();
            /*0x1f59da0*/ int get_Remaining();
        }

        class EncoderFallbackException : System.ArgumentException
        {
            /*0x98*/ char _charUnknown;
            /*0x9a*/ char _charUnknownHigh;
            /*0x9c*/ char _charUnknownLow;
            /*0xa0*/ int _index;

            /*0x1f59da8*/ EncoderFallbackException();
            /*0x1f59e04*/ EncoderFallbackException(string message);
            /*0x1f59e28*/ EncoderFallbackException(string message, System.Exception innerException);
            /*0x1f59908*/ EncoderFallbackException(string message, char charUnknown, int index);
            /*0x1f59b98*/ EncoderFallbackException(string message, char charUnknownHigh, char charUnknownLow, int index);
            /*0x1f59e4c*/ EncoderFallbackException(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);
            /*0x1f59e54*/ char get_CharUnknown();
            /*0x1f59e5c*/ char get_CharUnknownHigh();
            /*0x1f59e64*/ char get_CharUnknownLow();
            /*0x1f59e6c*/ int get_Index();
            /*0x1f59e74*/ bool IsUnknownSurrogate();
        }

        class EncoderFallback
        {
            static /*0x0*/ System.Text.EncoderFallback s_replacementFallback;
            static /*0x8*/ System.Text.EncoderFallback s_exceptionFallback;

            static /*0x1f5344c*/ System.Text.EncoderFallback get_ReplacementFallback();
            static /*0x1f59ecc*/ System.Text.EncoderFallback get_ExceptionFallback();
            /*0x1f590e8*/ EncoderFallback();
            System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            int get_MaxCharCount();
        }

        class EncoderFallbackBuffer
        {
            static int iMaxRecursion = 250;
            /*0x10*/ char* charStart;
            /*0x18*/ char* charEnd;
            /*0x20*/ System.Text.EncoderNLS encoder;
            /*0x28*/ bool setEncoder;
            /*0x29*/ bool bUsedEncoder;
            /*0x2a*/ bool bFallingBack;
            /*0x2c*/ int iRecursionCount;

            /*0x1f59404*/ EncoderFallbackBuffer();
            bool Fallback(char charUnknown, int index);
            bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
            char GetNextChar();
            bool MovePrevious();
            int get_Remaining();
            /*0x1f59f6c*/ void Reset();
            /*0x1f59f94*/ void InternalReset();
            /*0x1f5492c*/ void InternalInitialize(char* charStart, char* charEnd, System.Text.EncoderNLS encoder, bool setEncoder);
            /*0x1f54948*/ char InternalGetNextChar();
            /*0x1f59fac*/ bool InternalFallback(char ch, ref char* chars);
            /*0x1f5a154*/ void ThrowLastCharRecursive(int charRecursive);
        }

        class EncoderNLS : System.Text.Encoder
        {
            /*0x20*/ char _charLeftOver;
            /*0x28*/ System.Text.Encoding _encoding;
            /*0x30*/ bool _mustFlush;
            /*0x31*/ bool _throwOnOverflow;
            /*0x34*/ int _charsUsed;

            /*0x1f554ec*/ EncoderNLS(System.Text.Encoding encoding);
            /*0x1f5a1e4*/ EncoderNLS();
            /*0x1f5a20c*/ void Reset();
            /*0x1f5a22c*/ int GetByteCount(char[] chars, int index, int count, bool flush);
            /*0x1f5a404*/ int GetByteCount(char* chars, int count, bool flush);
            /*0x1f5a4fc*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
            /*0x1f5a794*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
            /*0x1f5a8b4*/ void Convert(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, int byteCount, bool flush, ref int charsUsed, ref int bytesUsed, ref bool completed);
            /*0x1f5ab80*/ void Convert(char* chars, int charCount, byte* bytes, int byteCount, bool flush, ref int charsUsed, ref int bytesUsed, ref bool completed);
            /*0x1f5ad2c*/ System.Text.Encoding get_Encoding();
            /*0x1f5ad34*/ bool get_MustFlush();
            /*0x1f5ad3c*/ bool get_HasState();
            /*0x1f5ad4c*/ void ClearMustFlush();
        }

        class EncoderReplacementFallback : System.Text.EncoderFallback, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ string _strDefault;

            /*0x1f59e84*/ EncoderReplacementFallback();
            /*0x1f5aefc*/ EncoderReplacementFallback(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f5ad54*/ EncoderReplacementFallback(string replacement);
            /*0x1f5b000*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f5b05c*/ string get_DefaultString();
            /*0x1f5b064*/ System.Text.EncoderFallbackBuffer CreateFallbackBuffer();
            /*0x1f5b10c*/ int get_MaxCharCount();
            /*0x1f5b128*/ bool Equals(object value);
            /*0x1f5b1a8*/ int GetHashCode();
        }

        class EncoderReplacementFallbackBuffer : System.Text.EncoderFallbackBuffer
        {
            /*0x30*/ string _strDefault;
            /*0x38*/ int _fallbackCount;
            /*0x3c*/ int _fallbackIndex;

            /*0x1f5b0c4*/ EncoderReplacementFallbackBuffer(System.Text.EncoderReplacementFallback fallback);
            /*0x1f5b1c8*/ bool Fallback(char charUnknown, int index);
            /*0x1f5b308*/ bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
            /*0x1f5b520*/ char GetNextChar();
            /*0x1f5b570*/ bool MovePrevious();
            /*0x1f5b5a0*/ int get_Remaining();
            /*0x1f5b5ac*/ void Reset();
        }

        class EncodingInfo
        {
            /*0x10*/ int iCodePage;
            /*0x18*/ string strEncodingName;
            /*0x20*/ string strDisplayName;

            /*0x1f5b5c0*/ EncodingInfo(int codePage, string name, string displayName);
            /*0x1f5b6a4*/ EncodingInfo();
            /*0x1f5b5fc*/ int get_CodePage();
            /*0x1f5b604*/ string get_Name();
            /*0x1f5b60c*/ string get_DisplayName();
            /*0x1f5b614*/ System.Text.Encoding GetEncoding();
            /*0x1f5b620*/ bool Equals(object value);
            /*0x1f5b69c*/ int GetHashCode();
        }

        class EncodingNLS : System.Text.Encoding
        {
            /*0x1f5b6dc*/ EncodingNLS(int codePage);
            /*0x1f5b6e4*/ int GetByteCount(char[] chars, int index, int count);
            /*0x1f5b868*/ int GetByteCount(string s);
            /*0x1f5b8f8*/ int GetByteCount(char* chars, int count);
            /*0x1f5b9d0*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f5bc30*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f5beac*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x1f5bfac*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x1f5c130*/ int GetCharCount(byte* bytes, int count);
            /*0x1f5c208*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x1f5c484*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x1f5c584*/ string GetString(byte[] bytes, int index, int count);
            /*0x1f5c74c*/ System.Text.Decoder GetDecoder();
            /*0x1f5c7ac*/ System.Text.Encoder GetEncoder();
        }

        class EncodingProvider
        {
            static /*0x0*/ object s_InternalSyncObject;
            static /*0x8*/ System.Text.EncodingProvider[] s_providers;

            static /*0x1f5d0f0*/ EncodingProvider();
            static /*0x1f5ca14*/ void AddProvider(System.Text.EncodingProvider provider);
            static /*0x1f5cd50*/ System.Text.Encoding GetEncodingFromProvider(int codepage);
            static /*0x1f5ce2c*/ System.Text.Encoding GetEncodingFromProvider(string encodingName);
            static /*0x1f5cf08*/ System.Text.Encoding GetEncodingFromProvider(int codepage, System.Text.EncoderFallback enc, System.Text.DecoderFallback dec);
            static /*0x1f5cffc*/ System.Text.Encoding GetEncodingFromProvider(string encodingName, System.Text.EncoderFallback enc, System.Text.DecoderFallback dec);
            /*0x1f5c80c*/ EncodingProvider();
            System.Text.Encoding GetEncoding(string name);
            System.Text.Encoding GetEncoding(int codepage);
            /*0x1f5c814*/ System.Text.Encoding GetEncoding(string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);
            /*0x1f5c914*/ System.Text.Encoding GetEncoding(int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);
        }

        class Latin1Encoding : System.Text.EncodingNLS, System.Runtime.Serialization.ISerializable
        {
            static /*0x0*/ System.Text.Latin1Encoding s_default;
            static /*0x8*/ char[] arrayCharBestFit;

            static /*0x1f5db04*/ Latin1Encoding();
            /*0x1f5d168*/ Latin1Encoding();
            /*0x1f5d174*/ Latin1Encoding(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f5d1c0*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f5d2a8*/ int GetByteCount(char* chars, int charCount, System.Text.EncoderNLS encoder);
            /*0x1f5d4a0*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x1f5d810*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS decoder);
            /*0x1f5d818*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS decoder);
            /*0x1f5d88c*/ int GetMaxByteCount(int charCount);
            /*0x1f5d994*/ int GetMaxCharCount(int byteCount);
            /*0x1f5da98*/ bool get_IsSingleByte();
            /*0x1f5daa0*/ bool IsAlwaysNormalized(System.Text.NormalizationForm form);
            /*0x1f5daac*/ char[] GetBestFitUnicodeToBytesData();
        }

        enum NormalizationForm
        {
            FormC = 1,
            FormD = 2,
            FormKC = 5,
            FormKD = 6,
        }

        class StringBuilder : System.Runtime.Serialization.ISerializable
        {
            static int DefaultCapacity = 16;
            static string CapacityField = "Capacity";
            static string MaxCapacityField = "m_MaxCapacity";
            static string StringValueField = "m_StringValue";
            static string ThreadIDField = "m_currentThread";
            static int MaxChunkSize = 8000;
            static int IndexLimit = 1000000;
            static int WidthLimit = 1000000;
            /*0x10*/ char[] m_ChunkChars;
            /*0x18*/ System.Text.StringBuilder m_ChunkPrevious;
            /*0x20*/ int m_ChunkLength;
            /*0x24*/ int m_ChunkOffset;
            /*0x28*/ int m_MaxCapacity;

            static /*0x1f624b8*/ void FormatError();
            static /*0x1f5e090*/ void ThreadSafeCopy(char* sourcePtr, char[] destination, int destinationIndex, int count);
            static /*0x1f5fda4*/ void ThreadSafeCopy(char[] source, int sourceIndex, System.Span<char> destination, int destinationIndex, int count);
            /*0x1f5dbc4*/ StringBuilder();
            /*0x1f56aa8*/ StringBuilder(int capacity);
            /*0x1f5ddfc*/ StringBuilder(string value);
            /*0x1f5de18*/ StringBuilder(string value, int capacity);
            /*0x1f5de34*/ StringBuilder(string value, int startIndex, int length, int capacity);
            /*0x1f5dc28*/ StringBuilder(int capacity, int maxCapacity);
            /*0x1f5e15c*/ StringBuilder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f63114*/ StringBuilder(System.Text.StringBuilder from);
            /*0x1f63158*/ StringBuilder(int size, int maxCapacity, System.Text.StringBuilder previousBlock);
            /*0x1f5e458*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f5e5c4*/ void AssertInvariants();
            /*0x1f5e5a0*/ int get_Capacity();
            /*0x1f5e5e0*/ void set_Capacity(int value);
            /*0x1f5e75c*/ int get_MaxCapacity();
            /*0x1f5e764*/ int EnsureCapacity(int capacity);
            /*0x1f5e81c*/ string ToString();
            /*0x1f5e95c*/ string ToString(int startIndex, int length);
            /*0x1f5ed08*/ System.Text.StringBuilder Clear();
            /*0x1f57318*/ int get_Length();
            /*0x1f5ed24*/ void set_Length(int value);
            /*0x1f5f0e0*/ char get_Chars(int index);
            /*0x1f5f170*/ void set_Chars(int index, char value);
            /*0x1f5ef74*/ System.Text.StringBuilder Append(char value, int repeatCount);
            /*0x1f5f3cc*/ System.Text.StringBuilder Append(char[] value, int startIndex, int charCount);
            /*0x1f56b00*/ System.Text.StringBuilder Append(string value);
            /*0x1f5f670*/ void AppendHelper(string value);
            /*0x1f5f6a8*/ System.Text.StringBuilder Append(string value, int startIndex, int count);
            /*0x1f5f7ec*/ System.Text.StringBuilder Append(System.Text.StringBuilder value);
            /*0x1f5fa5c*/ System.Text.StringBuilder Append(System.Text.StringBuilder value, int startIndex, int count);
            /*0x1f5f808*/ System.Text.StringBuilder AppendCore(System.Text.StringBuilder value, int startIndex, int count);
            /*0x1f5fb74*/ System.Text.StringBuilder AppendLine();
            /*0x1f5fb94*/ System.Text.StringBuilder AppendLine(string value);
            /*0x1f5fbb8*/ void CopyTo(int sourceIndex, char[] destination, int destinationIndex, int count);
            /*0x1f5eb30*/ void CopyTo(int sourceIndex, System.Span<char> destination, int count);
            /*0x1f5ff14*/ System.Text.StringBuilder Insert(int index, string value, int count);
            /*0x1f60464*/ System.Text.StringBuilder Remove(int startIndex, int length);
            /*0x1f606f4*/ System.Text.StringBuilder Append(bool value);
            /*0x1f56ab0*/ System.Text.StringBuilder Append(char value);
            /*0x1f6072c*/ System.Text.StringBuilder Append(sbyte value);
            /*0x1f60784*/ System.Text.StringBuilder Append(byte value);
            /*0x1f607dc*/ System.Text.StringBuilder Append(short value);
            /*0x1f60834*/ System.Text.StringBuilder Append(int value);
            /*0x1f6088c*/ System.Text.StringBuilder Append(long value);
            /*0x1f608e4*/ System.Text.StringBuilder Append(float value);
            /*0x1f6093c*/ System.Text.StringBuilder Append(double value);
            /*0x1f60994*/ System.Text.StringBuilder Append(decimal value);
            /*0x1f609f4*/ System.Text.StringBuilder Append(ushort value);
            /*0x1f60a4c*/ System.Text.StringBuilder Append(uint value);
            /*0x1f60aa4*/ System.Text.StringBuilder Append(ulong value);
            System.Text.StringBuilder AppendSpanFormattable<T>(T value);
            /*0x1f60afc*/ System.Text.StringBuilder Append(object value);
            /*0x1f60b34*/ System.Text.StringBuilder Append(char[] value);
            /*0x1f60b5c*/ System.Text.StringBuilder Append(System.ReadOnlySpan<char> value);
            /*0x1f60be4*/ System.Text.StringBuilder AppendJoin(string separator, object[] values);
            System.Text.StringBuilder AppendJoin<T>(string separator, System.Collections.Generic.IEnumerable<T> values);
            /*0x1f60c7c*/ System.Text.StringBuilder AppendJoin(string separator, string[] values);
            /*0x1f60d14*/ System.Text.StringBuilder AppendJoin(char separator, object[] values);
            System.Text.StringBuilder AppendJoin<T>(char separator, System.Collections.Generic.IEnumerable<T> values);
            /*0x1f60d7c*/ System.Text.StringBuilder AppendJoin(char separator, string[] values);
            System.Text.StringBuilder AppendJoinCore<T>(char* separator, int separatorLength, System.Collections.Generic.IEnumerable<T> values);
            System.Text.StringBuilder AppendJoinCore<T>(char* separator, int separatorLength, T[] values);
            /*0x1f60de4*/ System.Text.StringBuilder Insert(int index, string value);
            /*0x1f60f6c*/ System.Text.StringBuilder Insert(int index, bool value);
            /*0x1f60fb0*/ System.Text.StringBuilder Insert(int index, sbyte value);
            /*0x1f60ff0*/ System.Text.StringBuilder Insert(int index, byte value);
            /*0x1f61030*/ System.Text.StringBuilder Insert(int index, short value);
            /*0x1f61070*/ System.Text.StringBuilder Insert(int index, char value);
            /*0x1f6109c*/ System.Text.StringBuilder Insert(int index, char[] value);
            /*0x1f61130*/ System.Text.StringBuilder Insert(int index, char[] value, int startIndex, int charCount);
            /*0x1f612e4*/ System.Text.StringBuilder Insert(int index, int value);
            /*0x1f61324*/ System.Text.StringBuilder Insert(int index, long value);
            /*0x1f61364*/ System.Text.StringBuilder Insert(int index, float value);
            /*0x1f613a4*/ System.Text.StringBuilder Insert(int index, double value);
            /*0x1f613e4*/ System.Text.StringBuilder Insert(int index, decimal value);
            /*0x1f61450*/ System.Text.StringBuilder Insert(int index, ushort value);
            /*0x1f61490*/ System.Text.StringBuilder Insert(int index, uint value);
            /*0x1f614d0*/ System.Text.StringBuilder Insert(int index, ulong value);
            /*0x1f61510*/ System.Text.StringBuilder Insert(int index, object value);
            /*0x1f61558*/ System.Text.StringBuilder Insert(int index, System.ReadOnlySpan<char> value);
            /*0x1f61658*/ System.Text.StringBuilder AppendFormat(string format, object arg0);
            /*0x1f621bc*/ System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1);
            /*0x1f62218*/ System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
            /*0x1f62278*/ System.Text.StringBuilder AppendFormat(string format, object[] args);
            /*0x1f57324*/ System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0);
            /*0x1f62334*/ System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1);
            /*0x1f62394*/ System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object arg0, object arg1, object arg2);
            /*0x1f623f8*/ System.Text.StringBuilder AppendFormat(System.IFormatProvider provider, string format, object[] args);
            /*0x1f616b0*/ System.Text.StringBuilder AppendFormatHelper(System.IFormatProvider provider, string format, System.ParamsArray args);
            /*0x1f62508*/ System.Text.StringBuilder Replace(string oldValue, string newValue);
            /*0x1f62848*/ bool Equals(System.Text.StringBuilder sb);
            /*0x1f62974*/ bool Equals(System.ReadOnlySpan<char> span);
            /*0x1f62518*/ System.Text.StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
            /*0x1f62e24*/ System.Text.StringBuilder Replace(char oldChar, char newChar);
            /*0x1f62e34*/ System.Text.StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
            /*0x1f5f518*/ System.Text.StringBuilder Append(char* value, int valueCount);
            /*0x1f60e98*/ void Insert(int index, char* value, int valueCount);
            /*0x1f62c68*/ void ReplaceAllInChunk(int[] replacements, int replacementsCount, System.Text.StringBuilder sourceChunk, int removeCount, string value);
            /*0x1f62b90*/ bool StartsWith(System.Text.StringBuilder chunk, int indexInChunk, int count, string value);
            /*0x1f6035c*/ void ReplaceInPlaceAtChunk(ref System.Text.StringBuilder chunk, ref int indexInChunk, char* value, int count);
            /*0x1f5f0b8*/ System.Text.StringBuilder FindChunkForIndex(int index);
            /*0x1f63040*/ System.Text.StringBuilder FindChunkForByte(int byteIndex);
            /*0x1f63068*/ System.Span<char> get_RemainingCurrentChunk();
            /*0x1f63000*/ System.Text.StringBuilder Next(System.Text.StringBuilder chunk);
            /*0x1f5f22c*/ void ExpandByABlock(int minBlockCharCount);
            /*0x1f600ac*/ void MakeRoom(int index, int count, ref System.Text.StringBuilder chunk, ref int indexInChunk, bool doNotMoveFollowingChars);
            /*0x1f605a4*/ void Remove(int startIndex, int count, ref System.Text.StringBuilder chunk, ref int indexInChunk);
        }

        class StringBuilderCache
        {
            static int MaxBuilderSize = 360;
            static int DefaultCapacity = 16;
            [ThreadStatic] static System.Text.StringBuilder t_cachedInstance;

            static /*0x1f631e4*/ System.Text.StringBuilder Acquire(int capacity);
            static /*0x1f632ac*/ void Release(System.Text.StringBuilder sb);
            static /*0x1f63324*/ string GetStringAndRelease(System.Text.StringBuilder sb);
        }

        class UTF32Encoding : System.Text.Encoding
        {
            static /*0x0*/ System.Text.UTF32Encoding s_default;
            static /*0x8*/ System.Text.UTF32Encoding s_bigEndianDefault;
            static /*0x10*/ byte[] s_bigEndianPreamble;
            static /*0x18*/ byte[] s_littleEndianPreamble;
            /*0x38*/ bool _emitUTF32ByteOrderMark;
            /*0x39*/ bool _isThrowException;
            /*0x3a*/ bool _bigEndian;

            static /*0x1f65b84*/ UTF32Encoding();
            /*0x1f63360*/ UTF32Encoding();
            /*0x1f63414*/ UTF32Encoding(bool bigEndian, bool byteOrderMark);
            /*0x1f633a8*/ UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
            /*0x1f634dc*/ void SetDefaultFallbacks();
            /*0x1f635b4*/ int GetByteCount(char[] chars, int index, int count);
            /*0x1f63738*/ int GetByteCount(string s);
            /*0x1f637c8*/ int GetByteCount(char* chars, int count);
            /*0x1f638a0*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f63b00*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f63d7c*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x1f63e7c*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x1f64000*/ int GetCharCount(byte* bytes, int count);
            /*0x1f640d8*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x1f64354*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x1f64454*/ string GetString(byte[] bytes, int index, int count);
            /*0x1f6461c*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS encoder);
            /*0x1f648f4*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x1f64d50*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS baseDecoder);
            /*0x1f65098*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS baseDecoder);
            /*0x1f64cb8*/ uint GetSurrogate(char cHigh, char cLow);
            /*0x1f65508*/ char GetHighSurrogate(uint iChar);
            /*0x1f6551c*/ char GetLowSurrogate(uint iChar);
            /*0x1f65528*/ System.Text.Decoder GetDecoder();
            /*0x1f65594*/ System.Text.Encoder GetEncoder();
            /*0x1f655f8*/ int GetMaxByteCount(int charCount);
            /*0x1f65700*/ int GetMaxCharCount(int byteCount);
            /*0x1f657d0*/ byte[] GetPreamble();
            /*0x1f658d4*/ System.ReadOnlySpan<byte> get_Preamble();
            /*0x1f65a44*/ bool Equals(object value);
            /*0x1f65b08*/ int GetHashCode();

            class UTF32Decoder : System.Text.DecoderNLS
            {
                /*0x30*/ int iChar;
                /*0x34*/ int readByteCount;

                /*0x1f6558c*/ UTF32Decoder(System.Text.UTF32Encoding encoding);
                /*0x1f65cf4*/ void Reset();
                /*0x1f65d14*/ bool get_HasState();
            }
        }

        class UTF7Encoding : System.Text.Encoding
        {
            static string base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            static string directChars = "	
 '(),-./0123456789:?ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            static string optionalChars = "!"#$%&*;<=>@[]^_`{|}";
            static int UTF7_CODEPAGE = 65000;
            static /*0x0*/ System.Text.UTF7Encoding s_default;
            /*0x38*/ byte[] _base64Bytes;
            /*0x40*/ sbyte[] _base64Values;
            /*0x48*/ bool[] _directEncode;
            /*0x50*/ bool _allowOptionals;

            static /*0x1f67ae0*/ UTF7Encoding();
            /*0x1f65d24*/ UTF7Encoding();
            /*0x1f65d2c*/ UTF7Encoding(bool allowOptionals);
            /*0x1f65d78*/ void MakeTables();
            /*0x1f65ffc*/ void SetDefaultFallbacks();
            /*0x1f660c0*/ bool Equals(object value);
            /*0x1f66190*/ int GetHashCode();
            /*0x1f661fc*/ int GetByteCount(char[] chars, int index, int count);
            /*0x1f66380*/ int GetByteCount(string s);
            /*0x1f66410*/ int GetByteCount(char* chars, int count);
            /*0x1f664e8*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f66748*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f669c4*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x1f66ac4*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x1f66c48*/ int GetCharCount(byte* bytes, int count);
            /*0x1f66d20*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x1f66f9c*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x1f6709c*/ string GetString(byte[] bytes, int index, int count);
            /*0x1f67264*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS baseEncoder);
            /*0x1f67280*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS baseEncoder);
            /*0x1f67618*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS baseDecoder);
            /*0x1f67634*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS baseDecoder);
            /*0x1f678cc*/ System.Text.Decoder GetDecoder();
            /*0x1f67938*/ System.Text.Encoder GetEncoder();
            /*0x1f679a4*/ int GetMaxByteCount(int charCount);
            /*0x1f67a68*/ int GetMaxCharCount(int byteCount);

            class Decoder : System.Text.DecoderNLS
            {
                /*0x30*/ int bits;
                /*0x34*/ int bitCount;
                /*0x38*/ bool firstByte;

                /*0x1f67930*/ Decoder(System.Text.UTF7Encoding encoding);
                /*0x1f67b44*/ void Reset();
                /*0x1f67b6c*/ bool get_HasState();
            }

            class Encoder : System.Text.EncoderNLS
            {
                /*0x38*/ int bits;
                /*0x3c*/ int bitCount;

                /*0x1f6799c*/ Encoder(System.Text.UTF7Encoding encoding);
                /*0x1f67b7c*/ void Reset();
                /*0x1f67ba0*/ bool get_HasState();
            }

            class DecoderUTF7Fallback : System.Text.DecoderFallback
            {
                /*0x1f660b8*/ DecoderUTF7Fallback();
                /*0x1f67bc0*/ System.Text.DecoderFallbackBuffer CreateFallbackBuffer();
                /*0x1f67c34*/ int get_MaxCharCount();
                /*0x1f67c3c*/ bool Equals(object value);
                /*0x1f67c98*/ int GetHashCode();
            }

            class DecoderUTF7FallbackBuffer : System.Text.DecoderFallbackBuffer
            {
                /*0x20*/ char cFallback;
                /*0x24*/ int iCount;
                /*0x28*/ int iSize;

                /*0x1f67c24*/ DecoderUTF7FallbackBuffer(System.Text.UTF7Encoding.DecoderUTF7Fallback fallback);
                /*0x1f67ca0*/ bool Fallback(byte[] bytesUnknown, int index);
                /*0x1f67ce0*/ char GetNextChar();
                /*0x1f67d00*/ bool MovePrevious();
                /*0x1f67d2c*/ int get_Remaining();
                /*0x1f67d38*/ void Reset();
                /*0x1f67d48*/ int InternalFallback(byte[] bytes, byte* pBytes);
            }
        }

        class UTF8Encoding : System.Text.Encoding
        {
            static int UTF8_CODEPAGE = 65001;
            static int FinalByte = 536870912;
            static int SupplimentarySeq = 268435456;
            static int ThreeByteSeq = 134217728;
            static /*0x0*/ System.Text.UTF8Encoding.UTF8EncodingSealed s_default;
            static /*0x8*/ byte[] s_preamble;
            /*0x38*/ bool _emitUTF8Identifier;
            /*0x39*/ bool _isThrowException;

            static /*0x1f6b32c*/ UTF8Encoding();
            static /*0x1f69624*/ int PtrDiff(char* a, char* b);
            static /*0x1f69630*/ int PtrDiff(byte* a, byte* b);
            static /*0x1f69610*/ bool InRange(int ch, int start, int end);
            /*0x1f67dc0*/ UTF8Encoding();
            /*0x1f67dfc*/ UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
            /*0x1f67e48*/ UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
            /*0x1f67ec4*/ void SetDefaultFallbacks();
            /*0x1f67f9c*/ int GetByteCount(char[] chars, int index, int count);
            /*0x1f68120*/ int GetByteCount(string chars);
            /*0x1f681b0*/ int GetByteCount(char* chars, int count);
            /*0x1f68288*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f684e8*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f68764*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x1f68864*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x1f689e8*/ int GetCharCount(byte* bytes, int count);
            /*0x1f68ac0*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x1f68d3c*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x1f68e3c*/ string GetString(byte[] bytes, int index, int count);
            /*0x1f69004*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS baseEncoder);
            /*0x1f69638*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS baseEncoder);
            /*0x1f69d7c*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS baseDecoder);
            /*0x1f6a2fc*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS baseDecoder);
            /*0x1f6aa78*/ bool FallbackInvalidByteSequence(ref byte* pSrc, int ch, System.Text.DecoderFallbackBuffer fallback, ref char* pTarget);
            /*0x1f6a2bc*/ int FallbackInvalidByteSequence(byte* pSrc, int ch, System.Text.DecoderFallbackBuffer fallback);
            /*0x1f6aaec*/ byte[] GetBytesUnknown(ref byte* pSrc, int ch);
            /*0x1f6ace0*/ System.Text.Decoder GetDecoder();
            /*0x1f6ad4c*/ System.Text.Encoder GetEncoder();
            /*0x1f6adb8*/ int GetMaxByteCount(int charCount);
            /*0x1f6aec0*/ int GetMaxCharCount(int byteCount);
            /*0x1f6afc8*/ byte[] GetPreamble();
            /*0x1f6b09c*/ System.ReadOnlySpan<byte> get_Preamble();
            /*0x1f6b1fc*/ bool Equals(object value);
            /*0x1f6b2cc*/ int GetHashCode();

            class UTF8EncodingSealed : System.Text.UTF8Encoding
            {
                /*0x1f6b3fc*/ UTF8EncodingSealed(bool encoderShouldEmitUTF8Identifier);
                /*0x1f6b490*/ System.ReadOnlySpan<byte> get_Preamble();
            }

            class UTF8Encoder : System.Text.EncoderNLS
            {
                /*0x38*/ int surrogateChar;

                /*0x1f6adb0*/ UTF8Encoder(System.Text.UTF8Encoding encoding);
                /*0x1f6b564*/ void Reset();
                /*0x1f6b584*/ bool get_HasState();
            }

            class UTF8Decoder : System.Text.DecoderNLS
            {
                /*0x30*/ int bits;

                /*0x1f6ad44*/ UTF8Decoder(System.Text.UTF8Encoding encoding);
                /*0x1f6b594*/ void Reset();
                /*0x1f6b5b4*/ bool get_HasState();
            }
        }

        class UnicodeEncoding : System.Text.Encoding
        {
            static int CharSize = 2;
            static /*0x0*/ System.Text.UnicodeEncoding s_bigEndianDefault;
            static /*0x8*/ System.Text.UnicodeEncoding s_littleEndianDefault;
            static /*0x10*/ byte[] s_bigEndianPreamble;
            static /*0x18*/ byte[] s_littleEndianPreamble;
            static /*0x20*/ ulong highLowPatternMask;
            /*0x38*/ bool isThrowException;
            /*0x39*/ bool bigEndian;
            /*0x3a*/ bool byteOrderMark;

            static /*0x1f6eb5c*/ UnicodeEncoding();
            /*0x1f6b5c4*/ UnicodeEncoding();
            /*0x1f6b610*/ UnicodeEncoding(bool bigEndian, bool byteOrderMark);
            /*0x1f6b654*/ UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
            /*0x1f6b6c8*/ void SetDefaultFallbacks();
            /*0x1f6b7a0*/ int GetByteCount(char[] chars, int index, int count);
            /*0x1f6b924*/ int GetByteCount(string s);
            /*0x1f6b9b4*/ int GetByteCount(char* chars, int count);
            /*0x1f6ba8c*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f6bcec*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f6bf68*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x1f6c068*/ int GetCharCount(byte[] bytes, int index, int count);
            /*0x1f6c1ec*/ int GetCharCount(byte* bytes, int count);
            /*0x1f6c2c4*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x1f6c540*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x1f6c640*/ string GetString(byte[] bytes, int index, int count);
            /*0x1f6c808*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS encoder);
            /*0x1f6cd74*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x1f6d4a4*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS baseDecoder);
            /*0x1f6db64*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS baseDecoder);
            /*0x1f6e46c*/ System.Text.Encoder GetEncoder();
            /*0x1f6e4d0*/ System.Text.Decoder GetDecoder();
            /*0x1f6e54c*/ byte[] GetPreamble();
            /*0x1f6e648*/ System.ReadOnlySpan<byte> get_Preamble();
            /*0x1f6e7b8*/ int GetMaxByteCount(int charCount);
            /*0x1f6e8c0*/ int GetMaxCharCount(int byteCount);
            /*0x1f6e9cc*/ bool Equals(object value);
            /*0x1f6eae0*/ int GetHashCode();

            class Decoder : System.Text.DecoderNLS
            {
                /*0x30*/ int lastByte;
                /*0x34*/ char lastChar;

                /*0x1f6e53c*/ Decoder(System.Text.UnicodeEncoding encoding);
                /*0x1f6ed38*/ void Reset();
                /*0x1f6ed60*/ bool get_HasState();
            }
        }

        struct ValueStringBuilder
        {
            /*0x10*/ char[] _arrayToReturnToPool;
            /*0x18*/ System.Span<char> _chars;
            /*0x28*/ int _pos;

            /*0x1f6ed84*/ ValueStringBuilder(System.Span<char> initialBuffer);
            /*0x1f6ed94*/ int get_Length();
            /*0x1f6ed9c*/ void set_Length(int value);
            /*0x1f6eda4*/ int get_Capacity();
            /*0x1f6ede0*/ void EnsureCapacity(int capacity);
            /*0x1f6f080*/ ref char GetPinnableReference(bool terminate);
            /*0x1f6f0fc*/ ref char get_Item(int index);
            /*0x1f6f120*/ string ToString();
            /*0x1f6f2b8*/ System.Span<char> get_RawChars();
            /*0x1f6f2c4*/ System.ReadOnlySpan<char> AsSpan(bool terminate);
            /*0x1f6f38c*/ System.ReadOnlySpan<char> AsSpan();
            /*0x1f6f41c*/ System.ReadOnlySpan<char> AsSpan(int start);
            /*0x1f6f4c8*/ System.ReadOnlySpan<char> AsSpan(int start, int length);
            /*0x1f6f570*/ bool TryCopyTo(System.Span<char> destination, ref int charsWritten);
            /*0x1f6f7fc*/ void Insert(int index, char value, int count);
            /*0x1f6f9cc*/ void Append(char c);
            /*0x1f6fac8*/ void Append(string s);
            /*0x1f6fb74*/ void AppendSlow(string s);
            /*0x1f6fca4*/ void Append(char c, int count);
            /*0x1f6fd80*/ void Append(char* value, int length);
            /*0x1f6fe60*/ void Append(System.ReadOnlySpan<char> value);
            /*0x1f6ff64*/ System.Span<char> AppendSpan(int length);
            /*0x1f6fa48*/ void GrowAndAppend(char c);
            /*0x1f6ee3c*/ void Grow(int requiredAdditionalCapacity);
            /*0x1f70024*/ void Dispose();
        }

        struct ValueUtf8Converter
        {
            /*0x10*/ byte[] _arrayToReturnToPool;
            /*0x18*/ System.Span<byte> _bytes;

            /*0x1f7011c*/ ValueUtf8Converter(System.Span<byte> initialBuffer);
            /*0x1f70128*/ System.Span<byte> ConvertAndTerminateString(System.ReadOnlySpan<char> value);
            /*0x1f70418*/ void Dispose();
        }

        class Encoding : System.ICloneable
        {
            static int MIMECONTF_MAILNEWS = 1;
            static int MIMECONTF_BROWSER = 2;
            static int MIMECONTF_SAVABLE_MAILNEWS = 256;
            static int MIMECONTF_SAVABLE_BROWSER = 512;
            static int CodePageDefault = 0;
            static int CodePageNoOEM = 1;
            static int CodePageNoMac = 2;
            static int CodePageNoThread = 3;
            static int CodePageNoSymbol = 42;
            static int CodePageUnicode = 1200;
            static int CodePageBigEndian = 1201;
            static int CodePageWindows1252 = 1252;
            static int CodePageMacGB2312 = 10008;
            static int CodePageGB2312 = 20936;
            static int CodePageMacKorean = 10003;
            static int CodePageDLLKorean = 20949;
            static int ISO2022JP = 50220;
            static int ISO2022JPESC = 50221;
            static int ISO2022JPSISO = 50222;
            static int ISOKorean = 50225;
            static int ISOSimplifiedCN = 50227;
            static int EUCJP = 51932;
            static int ChineseHZ = 52936;
            static int DuplicateEUCCN = 51936;
            static int EUCCN = 936;
            static int EUCKR = 51949;
            static int CodePageASCII = 20127;
            static int ISO_8859_1 = 28591;
            static int ISCIIAssemese = 57006;
            static int ISCIIBengali = 57003;
            static int ISCIIDevanagari = 57002;
            static int ISCIIGujarathi = 57010;
            static int ISCIIKannada = 57008;
            static int ISCIIMalayalam = 57009;
            static int ISCIIOriya = 57007;
            static int ISCIIPanjabi = 57011;
            static int ISCIITamil = 57004;
            static int ISCIITelugu = 57005;
            static int GB18030 = 54936;
            static int ISO_8859_8I = 38598;
            static int ISO_8859_8_Visual = 28598;
            static int ENC50229 = 50229;
            static int CodePageUTF7 = 65000;
            static int CodePageUTF8 = 65001;
            static int CodePageUTF32 = 12000;
            static int CodePageUTF32BE = 12001;
            static /*0x0*/ System.Text.Encoding defaultEncoding;
            static /*0x8*/ System.Text.Encoding unicodeEncoding;
            static /*0x10*/ System.Text.Encoding bigEndianUnicode;
            static /*0x18*/ System.Text.Encoding utf7Encoding;
            static /*0x20*/ System.Text.Encoding utf8Encoding;
            static /*0x28*/ System.Text.Encoding utf32Encoding;
            static /*0x30*/ System.Text.Encoding asciiEncoding;
            static /*0x38*/ System.Text.Encoding latin1Encoding;
            static /*0x40*/ System.Collections.Generic.Dictionary<int, System.Text.Encoding> encodings;
            static /*0x48*/ object s_InternalSyncObject;
            /*0x10*/ int m_codePage;
            /*0x18*/ System.Globalization.CodePageDataItem dataItem;
            /*0x20*/ bool m_deserializedFromEverett;
            /*0x21*/ bool m_isReadOnly;
            /*0x28*/ System.Text.EncoderFallback encoderFallback;
            /*0x30*/ System.Text.DecoderFallback decoderFallback;

            static /*0x1f70d3c*/ byte[] Convert(System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);
            static /*0x1f70da0*/ byte[] Convert(System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);
            static /*0x1f70ee4*/ object get_InternalSyncObject();
            static /*0x1f70f84*/ void RegisterProvider(System.Text.EncodingProvider provider);
            static /*0x1f70fdc*/ System.Text.Encoding GetEncoding(int codepage);
            static /*0x1f71df8*/ System.Text.Encoding GetEncoding(int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);
            static /*0x1f72090*/ System.Text.Encoding GetEncoding(string name);
            static /*0x1f7212c*/ System.Text.Encoding GetEncoding(string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);
            static /*0x1f721ec*/ System.Text.EncodingInfo[] GetEncodings();
            static /*0x1f71ca8*/ System.Text.Encoding get_ASCII();
            static /*0x1f71d50*/ System.Text.Encoding get_Latin1();
            static /*0x1f736ac*/ System.Text.Encoding CreateDefaultEncoding();
            static /*0x1f71908*/ System.Text.Encoding get_Default();
            static /*0x1f71984*/ System.Text.Encoding get_Unicode();
            static /*0x1f71a58*/ System.Text.Encoding get_BigEndianUnicode();
            static /*0x1f71b30*/ System.Text.Encoding get_UTF7();
            static /*0x1f7034c*/ System.Text.Encoding get_UTF8();
            static /*0x1f71bd8*/ System.Text.Encoding get_UTF32();
            /*0x1f7050c*/ Encoding();
            /*0x1f63450*/ Encoding(int codePage);
            /*0x1f7053c*/ Encoding(int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);
            /*0x1f70658*/ void SetDefaultFallbacks();
            /*0x1f706f0*/ void OnDeserializing();
            /*0x1f70700*/ void OnDeserialized();
            /*0x1f7073c*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x1f7074c*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x1f70788*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x1f70790*/ void DeserializeEncoding(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f70b90*/ void SerializeEncoding(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f7223c*/ byte[] GetPreamble();
            /*0x1f72294*/ System.ReadOnlySpan<byte> get_Preamble();
            /*0x1f722e8*/ void GetDataItem();
            /*0x1f72410*/ string get_BodyName();
            /*0x1f72440*/ string get_EncodingName();
            /*0x1f7244c*/ string get_HeaderName();
            /*0x1f7247c*/ string get_WebName();
            /*0x1f724ac*/ int get_WindowsCodePage();
            /*0x1f724e0*/ bool get_IsBrowserDisplay();
            /*0x1f72510*/ bool get_IsBrowserSave();
            /*0x1f72540*/ bool get_IsMailNewsDisplay();
            /*0x1f72570*/ bool get_IsMailNewsSave();
            /*0x1f725a0*/ bool get_IsSingleByte();
            /*0x1f725a8*/ System.Text.EncoderFallback get_EncoderFallback();
            /*0x1f71f00*/ void set_EncoderFallback(System.Text.EncoderFallback value);
            /*0x1f725b0*/ System.Text.DecoderFallback get_DecoderFallback();
            /*0x1f71fc8*/ void set_DecoderFallback(System.Text.DecoderFallback value);
            /*0x1f725b8*/ object Clone();
            /*0x1f72640*/ bool get_IsReadOnly();
            /*0x1f72648*/ int GetByteCount(char[] chars);
            /*0x1f726dc*/ int GetByteCount(string s);
            int GetByteCount(char[] chars, int index, int count);
            /*0x1f7276c*/ int GetByteCount(string str, int index, int count);
            /*0x1f727bc*/ int GetByteCount(char* chars, int count);
            /*0x1f72934*/ int GetByteCount(char* chars, int count, System.Text.EncoderNLS encoder);
            /*0x1f72944*/ byte[] GetBytes(char[] chars);
            /*0x1f729d8*/ byte[] GetBytes(char[] chars, int index, int count);
            int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f72a94*/ byte[] GetBytes(string s);
            /*0x1f72b9c*/ int GetBytes(string s, int charIndex, int charCount, byte[] bytes, int byteIndex);
            /*0x1f72c4c*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, System.Text.EncoderNLS encoder);
            /*0x1f72c5c*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount);
            /*0x1f72e88*/ int GetCharCount(byte[] bytes);
            int GetCharCount(byte[] bytes, int index, int count);
            /*0x1f72f1c*/ int GetCharCount(byte* bytes, int count);
            /*0x1f73094*/ int GetCharCount(byte* bytes, int count, System.Text.DecoderNLS decoder);
            /*0x1f730a4*/ char[] GetChars(byte[] bytes);
            /*0x1f73138*/ char[] GetChars(byte[] bytes, int index, int count);
            int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
            /*0x1f731f4*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount);
            /*0x1f73420*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, System.Text.DecoderNLS decoder);
            /*0x1f73430*/ string GetString(byte* bytes, int byteCount);
            /*0x1f7351c*/ int GetChars(System.ReadOnlySpan<byte> bytes, System.Span<char> chars);
            /*0x1f735c0*/ string GetString(System.ReadOnlySpan<byte> bytes);
            /*0x1f73624*/ int get_CodePage();
            /*0x1f7362c*/ bool IsAlwaysNormalized();
            /*0x1f73640*/ bool IsAlwaysNormalized(System.Text.NormalizationForm form);
            /*0x1f73648*/ System.Text.Decoder GetDecoder();
            /*0x1f73710*/ void setReadOnly(bool value);
            /*0x1f7371c*/ System.Text.Encoder GetEncoder();
            int GetMaxByteCount(int charCount);
            int GetMaxCharCount(int byteCount);
            /*0x1f73780*/ string GetString(byte[] bytes);
            /*0x1f73814*/ string GetString(byte[] bytes, int index, int count);
            /*0x1f7383c*/ bool Equals(object value);
            /*0x1f7390c*/ int GetHashCode();
            /*0x1f73964*/ char[] GetBestFitUnicodeToBytesData();
            /*0x1f739bc*/ char[] GetBestFitBytesToUnicodeData();
            /*0x1f73a14*/ void ThrowBytesOverflow();
            /*0x1f64cd4*/ void ThrowBytesOverflow(System.Text.EncoderNLS encoder, bool nothingEncoded);
            /*0x1f73b1c*/ void ThrowCharsOverflow();
            /*0x1f6548c*/ void ThrowCharsOverflow(System.Text.DecoderNLS decoder, bool nothingDecoded);
            /*0x1f73c24*/ int GetCharCount(System.ReadOnlySpan<byte> bytes);
            /*0x1f73c94*/ int GetByteCount(System.ReadOnlySpan<char> chars);
            /*0x1f73d04*/ int GetBytes(System.ReadOnlySpan<char> chars, System.Span<byte> bytes);
            /*0x1f73da8*/ byte[] GetBytes(string s, int index, int count);

            class DefaultEncoder : System.Text.Encoder, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
            {
                /*0x20*/ System.Text.Encoding m_encoding;
                /*0x28*/ bool m_hasInitializedEncoding;
                /*0x2a*/ char charLeftOver;

                /*0x1f74ff4*/ DefaultEncoder(System.Text.Encoding encoding);
                /*0x1f75024*/ DefaultEncoder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f7537c*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
                /*0x1f75434*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f754d8*/ int GetByteCount(char[] chars, int index, int count, bool flush);
                /*0x1f754fc*/ int GetByteCount(char* chars, int count, bool flush);
                /*0x1f75520*/ int GetBytes(char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex, bool flush);
                /*0x1f75544*/ int GetBytes(char* chars, int charCount, byte* bytes, int byteCount, bool flush);
            }

            class DefaultDecoder : System.Text.Decoder, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
            {
                /*0x20*/ System.Text.Encoding m_encoding;
                /*0x28*/ bool m_hasInitializedEncoding;

                /*0x1f75568*/ DefaultDecoder(System.Text.Encoding encoding);
                /*0x1f75598*/ DefaultDecoder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f75850*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
                /*0x1f7589c*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f75940*/ int GetCharCount(byte[] bytes, int index, int count);
                /*0x1f75950*/ int GetCharCount(byte[] bytes, int index, int count, bool flush);
                /*0x1f75974*/ int GetCharCount(byte* bytes, int count, bool flush);
                /*0x1f75998*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);
                /*0x1f759a8*/ int GetChars(byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex, bool flush);
                /*0x1f759cc*/ int GetChars(byte* bytes, int byteCount, char* chars, int charCount, bool flush);
            }

            class EncodingCharBuffer
            {
                /*0x10*/ char* chars;
                /*0x18*/ char* charStart;
                /*0x20*/ char* charEnd;
                /*0x28*/ int charCountResult;
                /*0x30*/ System.Text.Encoding enc;
                /*0x38*/ System.Text.DecoderNLS decoder;
                /*0x40*/ byte* byteStart;
                /*0x48*/ byte* byteEnd;
                /*0x50*/ byte* bytes;
                /*0x58*/ System.Text.DecoderFallbackBuffer fallbackBuffer;

                /*0x1f759f0*/ EncodingCharBuffer(System.Text.Encoding enc, System.Text.DecoderNLS decoder, char* charStart, int charCount, byte* byteStart, int byteCount);
                /*0x1f75a98*/ bool AddChar(char ch, int numBytes);
                /*0x1f75b0c*/ bool AddChar(char ch);
                /*0x1f75b14*/ void AdjustBytes(int count);
                /*0x1f75b24*/ bool get_MoreData();
                /*0x1f75b34*/ byte GetNextByte();
                /*0x1f75b58*/ int get_BytesUsed();
                /*0x1f75b68*/ bool Fallback(byte fallbackByte);
                /*0x1f75be0*/ bool Fallback(byte[] byteBuffer);
                /*0x1f75cc0*/ int get_Count();
            }

            class EncodingByteBuffer
            {
                /*0x10*/ byte* bytes;
                /*0x18*/ byte* byteStart;
                /*0x20*/ byte* byteEnd;
                /*0x28*/ char* chars;
                /*0x30*/ char* charStart;
                /*0x38*/ char* charEnd;
                /*0x40*/ int byteCountResult;
                /*0x48*/ System.Text.Encoding enc;
                /*0x50*/ System.Text.EncoderNLS encoder;
                /*0x58*/ System.Text.EncoderFallbackBuffer fallbackBuffer;

                /*0x1f75cc8*/ EncodingByteBuffer(System.Text.Encoding inEncoding, System.Text.EncoderNLS inEncoder, byte* inByteStart, int inByteCount, char* inCharStart, int inCharCount);
                /*0x1f75ecc*/ bool AddByte(byte b, int moreBytesExpected);
                /*0x1f75fa0*/ bool AddByte(byte b1);
                /*0x1f75fa8*/ bool AddByte(byte b1, byte b2);
                /*0x1f75fb0*/ bool AddByte(byte b1, byte b2, int moreBytesExpected);
                /*0x1f75f1c*/ void MovePrevious(bool bThrow);
                /*0x1f75ff8*/ bool get_MoreData();
                /*0x1f76040*/ char GetNextChar();
                /*0x1f76090*/ int get_CharsUsed();
                /*0x1f760a8*/ int get_Count();
            }
        }

        enum NormalizationCheck
        {
            Yes = 0,
            No = 1,
            Maybe = 2,
        }

        class Normalization
        {
            static int NoNfd = 1;
            static int NoNfkd = 2;
            static int NoNfc = 4;
            static int MaybeNfc = 8;
            static int NoNfkc = 16;
            static int MaybeNfkc = 32;
            static int FullCompositionExclusion = 64;
            static int IsUnsafe = 128;
            static int HangulSBase = 44032;
            static int HangulLBase = 4352;
            static int HangulVBase = 4449;
            static int HangulTBase = 4519;
            static int HangulLCount = 19;
            static int HangulVCount = 21;
            static int HangulTCount = 28;
            static int HangulNCount = 588;
            static int HangulSCount = 11172;
            static /*0x0*/ byte* props;
            static /*0x8*/ int* mappedChars;
            static /*0x10*/ short* charMapIndex;
            static /*0x18*/ short* helperIndex;
            static /*0x20*/ ushort* mapIdxToComposite;
            static /*0x28*/ byte* combiningClass;
            static /*0x30*/ object forLock;
            static /*0x38*/ bool isReady;

            static /*0x1f77a30*/ Normalization();
            static /*0x1f760b0*/ uint PropValue(int cp);
            static /*0x1f76144*/ int CharMapIdx(int cp);
            static /*0x1f761d8*/ byte GetCombiningClass(int c);
            static /*0x1f76280*/ int GetPrimaryCompositeFromMapIndex(int src);
            static /*0x1f76328*/ int GetPrimaryCompositeHelperIndex(int cp);
            static /*0x1f763d0*/ string Compose(string source, int checkType);
            static /*0x1f765e0*/ System.Text.StringBuilder Combine(string source, int start, int checkType);
            static /*0x1f7671c*/ void Combine(System.Text.StringBuilder sb, int i, int checkType);
            static /*0x1f76948*/ int CombineHangul(System.Text.StringBuilder sb, string s, int current);
            static /*0x1f76d40*/ int Fetch(System.Text.StringBuilder sb, string s, int i);
            static /*0x1f76b0c*/ int TryComposeWithPreviousStarter(System.Text.StringBuilder sb, string s, int current);
            static /*0x1f76d7c*/ int TryCompose(int i, int starter, int candidate);
            static /*0x1f76e94*/ string Decompose(string source, int checkType);
            static /*0x1f764b0*/ void Decompose(string source, ref System.Text.StringBuilder sb, int checkType);
            static /*0x1f770f8*/ void ReorderCanonical(string src, ref System.Text.StringBuilder sb, int start);
            static /*0x1f76f20*/ void DecomposeChar(ref System.Text.StringBuilder sb, ref int[] buf, string s, int i, int checkType, ref int start);
            static /*0x1f7682c*/ System.Text.NormalizationCheck QuickCheck(char c, int type);
            static /*0x1f77520*/ int GetCanonicalHangul(int s, int[] buf, int bufIdx);
            static /*0x1f77368*/ int GetCanonical(int c, int[] buf, int bufIdx, int checkType);
            static /*0x1f7760c*/ bool IsNormalized(string source, System.Text.NormalizationForm normalizationForm);
            static /*0x1f776c8*/ bool IsNormalized(string source, int type);
            static /*0x1f77918*/ string Normalize(string source, System.Text.NormalizationForm normalizationForm);
            static /*0x1f77880*/ string Normalize(string source, int type);
            static /*0x1f779d4*/ bool get_IsReady();
            static /*0x1f77a2c*/ void load_normalization_resource(ref nint props, ref nint mappedChars, ref nint charMapIndex, ref nint helperIndex, ref nint mapIdxToComposite, ref nint combiningClass);
            /*0x1f77c30*/ Normalization();
        }

        class EncodingHelper
        {
            static /*0x0*/ System.Text.Encoding utf8EncodingWithoutMarkers;
            static /*0x8*/ System.Text.Encoding utf8EncodingUnsafe;
            static /*0x10*/ System.Text.Encoding bigEndianUTF32Encoding;
            static /*0x18*/ object lockobj;
            static /*0x20*/ System.Reflection.Assembly i18nAssembly;
            static /*0x28*/ bool i18nDisabled;

            static /*0x1f78b24*/ EncodingHelper();
            static /*0x1f77c38*/ System.Text.Encoding get_UTF8Unmarked();
            static /*0x1f77e28*/ System.Text.Encoding get_UTF8UnmarkedUnsafe();
            static /*0x1f780b4*/ System.Text.Encoding get_BigEndianUTF32();
            static /*0x1f78290*/ string InternalCodePage(ref int code_page);
            static /*0x1f78294*/ System.Text.Encoding GetDefaultEncoding();
            static /*0x1f78418*/ object InvokeI18N(string name, object[] args);
        }
    }

    namespace Security
    {
        class VerificationException : System.SystemException
        {
            /*0x1f78b9c*/ VerificationException();
            /*0x1f78bf8*/ VerificationException(string message);
            /*0x1f78c1c*/ VerificationException(string message, System.Exception innerException);
            /*0x1f78c40*/ VerificationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        interface IPermission : System.Security.ISecurityEncodable
        {
            System.Security.IPermission Copy();
            void Demand();
            System.Security.IPermission Intersect(System.Security.IPermission target);
            bool IsSubsetOf(System.Security.IPermission target);
            System.Security.IPermission Union(System.Security.IPermission target);
        }

        interface ISecurityEncodable
        {
            void FromXml(System.Security.SecurityElement e);
            System.Security.SecurityElement ToXml();
        }

        interface IEvidenceFactory
        {
            System.Security.Policy.Evidence get_Evidence();
        }

        interface ISecurityPolicyEncodable
        {
            void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
            System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
        }

        interface IStackWalk
        {
            void Assert();
            void Demand();
            void Deny();
            void PermitOnly();
        }

        enum PolicyLevelType
        {
            AppDomain = 3,
            Enterprise = 2,
            Machine = 1,
            User = 0,
        }

        enum SecurityZone
        {
            Internet = 3,
            Intranet = 1,
            MyComputer = 0,
            NoZone = -1,
            Trusted = 2,
            Untrusted = 4,
        }

        class XmlSyntaxException : System.SystemException
        {
            /*0x1f78c48*/ XmlSyntaxException();
            /*0x1f78c50*/ XmlSyntaxException(int lineNumber);
            /*0x1f78c58*/ XmlSyntaxException(int lineNumber, string message);
            /*0x1f78c60*/ XmlSyntaxException(string message);
            /*0x1f78c68*/ XmlSyntaxException(string message, System.Exception inner);
            /*0x1f78c70*/ XmlSyntaxException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class DynamicSecurityMethodAttribute : System.Attribute
        {
            /*0x1f78c78*/ DynamicSecurityMethodAttribute();
        }

        class SuppressUnmanagedCodeSecurityAttribute : System.Attribute
        {
            /*0x1f78c80*/ SuppressUnmanagedCodeSecurityAttribute();
        }

        class UnverifiableCodeAttribute : System.Attribute
        {
            /*0x1f78c88*/ UnverifiableCodeAttribute();
        }

        class AllowPartiallyTrustedCallersAttribute : System.Attribute
        {
            /*0x10*/ System.Security.PartialTrustVisibilityLevel _visibilityLevel;

            /*0x1f78c90*/ AllowPartiallyTrustedCallersAttribute();
            /*0x1f78c98*/ System.Security.PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
            /*0x1f78ca0*/ void set_PartialTrustVisibilityLevel(System.Security.PartialTrustVisibilityLevel value);
        }

        enum PartialTrustVisibilityLevel
        {
            VisibleToAllHosts = 0,
            NotVisibleByDefault = 1,
        }

        enum SecurityCriticalScope
        {
            Explicit = 0,
            Everything = 1,
        }

        class SecurityCriticalAttribute : System.Attribute
        {
            /*0x10*/ System.Security.SecurityCriticalScope _val;

            /*0x1f78ca8*/ SecurityCriticalAttribute();
            /*0x1f78cb0*/ SecurityCriticalAttribute(System.Security.SecurityCriticalScope scope);
            /*0x1f78cd8*/ System.Security.SecurityCriticalScope get_Scope();
        }

        class SecurityTreatAsSafeAttribute : System.Attribute
        {
            /*0x1f78ce0*/ SecurityTreatAsSafeAttribute();
        }

        class SecuritySafeCriticalAttribute : System.Attribute
        {
            /*0x1f78ce8*/ SecuritySafeCriticalAttribute();
        }

        class SecurityTransparentAttribute : System.Attribute
        {
            /*0x1f78cf0*/ SecurityTransparentAttribute();
        }

        enum SecurityRuleSet
        {
            None = 0,
            Level1 = 1,
            Level2 = 2,
        }

        class SecurityRulesAttribute : System.Attribute
        {
            /*0x10*/ System.Security.SecurityRuleSet m_ruleSet;
            /*0x11*/ bool m_skipVerificationInFullTrust;

            /*0x1f78cf8*/ SecurityRulesAttribute(System.Security.SecurityRuleSet ruleSet);
            /*0x1f78d20*/ bool get_SkipVerificationInFullTrust();
            /*0x1f78d28*/ void set_SkipVerificationInFullTrust(bool value);
            /*0x1f78d34*/ System.Security.SecurityRuleSet get_RuleSet();
        }

        enum SecurityContextSource
        {
            CurrentAppDomain = 0,
            CurrentAssembly = 1,
        }

        enum SecurityContextDisableFlow
        {
            Nothing = 0,
            WI = 1,
            All = 16383,
        }

        class SecurityDocument
        {
            static byte c_element = 1;
            static byte c_attribute = 2;
            static byte c_text = 3;
            static byte c_children = 4;
            static int c_growthSize = 32;
            /*0x10*/ byte[] m_data;

            static /*0x1f792dc*/ int EncodedStringSize(string str);
            /*0x1f78d3c*/ SecurityDocument(int numData);
            /*0x1f78da4*/ SecurityDocument(byte[] data);
            /*0x1f78dcc*/ SecurityDocument(System.Security.SecurityElement elRoot);
            /*0x1f79054*/ void GuaranteeSize(int size);
            /*0x1f790f8*/ void AddString(string str, ref int position);
            /*0x1f79244*/ void AppendString(string str, ref int position);
            /*0x1f792fc*/ string GetString(ref int position);
            /*0x1f79304*/ string GetString(ref int position, bool bCreate);
            /*0x1f79880*/ void AddToken(byte b, ref int position);
            /*0x1f78e48*/ void ConvertElement(System.Security.SecurityElement elCurrent, ref int position);
            /*0x1f798dc*/ System.Security.SecurityElement GetRootElement();
            /*0x1f798f8*/ System.Security.SecurityElement GetElement(int position, bool bCreate);
            /*0x1f79914*/ System.Security.SecurityElement InternalGetElement(ref int position, bool bCreate);
            /*0x1f79da0*/ string GetTagForElement(int position);
            /*0x1f79e34*/ System.Collections.ArrayList GetChildrenPositionForElement(int position);
            /*0x1f7a01c*/ string GetAttributeForElement(int position, string attributeName);
        }

        class SecurityContext : System.IDisposable
        {
            static /*0x1f7a144*/ System.Security.SecurityContext Capture();
            static /*0x1f7a1a4*/ bool IsFlowSuppressed();
            static /*0x1f7a1ac*/ bool IsWindowsIdentityFlowSuppressed();
            static /*0x1f7a1b4*/ void RestoreFlow();
            static /*0x1f7a1b8*/ void Run(System.Security.SecurityContext securityContext, System.Threading.ContextCallback callback, object state);
            static /*0x1f7a1e0*/ System.Threading.AsyncFlowControl SuppressFlow();
            static /*0x1f7a220*/ System.Threading.AsyncFlowControl SuppressFlowWindowsIdentity();
            /*0x1f7a138*/ SecurityContext();
            /*0x1f7a140*/ System.Security.SecurityContext CreateCopy();
            /*0x1f7a1a0*/ void Dispose();
        }

        class CodeAccessPermission : System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.IStackWalk
        {
            static /*0x1f7a9b8*/ void RevertAll();
            static /*0x1f7a9bc*/ void RevertAssert();
            static /*0x1f7a9c0*/ void RevertDeny();
            static /*0x1f7a9c4*/ void RevertPermitOnly();
            static /*0x1f7ab30*/ System.Security.Permissions.PermissionState CheckPermissionState(System.Security.Permissions.PermissionState state, bool allowUnrestricted);
            static /*0x1f7abe0*/ int CheckSecurityElement(System.Security.SecurityElement se, string parameterName, int minimumVersion, int maximumVersion);
            static /*0x1f7af28*/ bool IsUnrestricted(System.Security.SecurityElement se);
            static /*0x1f7b004*/ void ThrowInvalidPermission(System.Security.IPermission target, System.Type expected);
            /*0x1f7a260*/ CodeAccessPermission();
            /*0x1f7a268*/ void Assert();
            System.Security.IPermission Copy();
            /*0x1f7a610*/ void Demand();
            /*0x1f7a6bc*/ void Deny();
            /*0x1f7a764*/ bool Equals(object obj);
            void FromXml(System.Security.SecurityElement elem);
            /*0x1f7a890*/ int GetHashCode();
            System.Security.IPermission Intersect(System.Security.IPermission target);
            bool IsSubsetOf(System.Security.IPermission target);
            /*0x1f7a898*/ string ToString();
            System.Security.SecurityElement ToXml();
            /*0x1f7a8c4*/ System.Security.IPermission Union(System.Security.IPermission other);
            /*0x1f7a910*/ void PermitOnly();
            /*0x1f7a9c8*/ System.Security.SecurityElement Element(int version);
            /*0x1f7b0a8*/ void System.Security.IStackWalk.Assert();
            /*0x1f7b0ac*/ void System.Security.IStackWalk.Deny();
            /*0x1f7b0b0*/ void System.Security.IStackWalk.PermitOnly();
            /*0x1f7b0b4*/ void System.Security.IStackWalk.Demand();
            /*0x1f7b0b8*/ void System.Security.IPermission.Demand();
        }

        class HostProtectionException : System.SystemException
        {
            /*0x8c*/ System.Security.Permissions.HostProtectionResource _protected;
            /*0x90*/ System.Security.Permissions.HostProtectionResource _demanded;

            /*0x1f7b0bc*/ HostProtectionException();
            /*0x1f7b0c4*/ HostProtectionException(string message);
            /*0x1f7b0cc*/ HostProtectionException(string message, System.Exception e);
            /*0x1f7b0d4*/ HostProtectionException(string message, System.Security.Permissions.HostProtectionResource protectedResources, System.Security.Permissions.HostProtectionResource demandedResources);
            /*0x1f7b100*/ HostProtectionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f7b150*/ System.Security.Permissions.HostProtectionResource get_DemandedResources();
            /*0x1f7b158*/ System.Security.Permissions.HostProtectionResource get_ProtectedResources();
            /*0x1f7b160*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f7b1b8*/ string ToString();
        }

        class HostSecurityManager
        {
            /*0x1f7b1c0*/ HostSecurityManager();
            /*0x1f7b1c8*/ System.Security.Policy.PolicyLevel get_DomainPolicy();
            /*0x1f7b1d0*/ System.Security.HostSecurityManagerOptions get_Flags();
            /*0x1f7b1d8*/ System.Security.Policy.ApplicationTrust DetermineApplicationTrust(System.Security.Policy.Evidence applicationEvidence, System.Security.Policy.Evidence activatorEvidence, System.Security.Policy.TrustManagerContext context);
            /*0x1f7b828*/ System.Security.Policy.Evidence ProvideAppDomainEvidence(System.Security.Policy.Evidence inputEvidence);
            /*0x1f7b830*/ System.Security.Policy.Evidence ProvideAssemblyEvidence(System.Reflection.Assembly loadedAssembly, System.Security.Policy.Evidence inputEvidence);
            /*0x1f7b838*/ System.Security.PermissionSet ResolvePolicy(System.Security.Policy.Evidence evidence);
            /*0x1f7b8d0*/ System.Security.Policy.EvidenceBase GenerateAppDomainEvidence(System.Type evidenceType);
            /*0x1f7b908*/ System.Security.Policy.EvidenceBase GenerateAssemblyEvidence(System.Type evidenceType, System.Reflection.Assembly assembly);
            /*0x1f7b940*/ System.Type[] GetHostSuppliedAppDomainEvidenceTypes();
            /*0x1f7b978*/ System.Type[] GetHostSuppliedAssemblyEvidenceTypes(System.Reflection.Assembly assembly);
        }

        enum HostSecurityManagerOptions
        {
            None = 0,
            HostAppDomainEvidence = 1,
            HostPolicyLevel = 2,
            HostAssemblyEvidence = 4,
            HostDetermineApplicationTrust = 8,
            HostResolvePolicy = 16,
            AllFlags = 31,
        }

        class NamedPermissionSet : System.Security.PermissionSet
        {
            /*0x38*/ string name;
            /*0x40*/ string description;

            /*0x1f7b9b0*/ NamedPermissionSet();
            /*0x1f7ba70*/ NamedPermissionSet(string name, System.Security.PermissionSet permSet);
            /*0x1f7bea8*/ NamedPermissionSet(string name, System.Security.Permissions.PermissionState state);
            /*0x1f7bf58*/ NamedPermissionSet(System.Security.NamedPermissionSet permSet);
            /*0x1f7bfd0*/ NamedPermissionSet(string name);
            /*0x1f7bfd8*/ string get_Description();
            /*0x1f7bfe0*/ void set_Description(string value);
            /*0x1f7bfe8*/ string get_Name();
            /*0x1f7bde8*/ void set_Name(string value);
            /*0x1f7bff0*/ System.Security.PermissionSet Copy();
            /*0x1f7c050*/ System.Security.NamedPermissionSet Copy(string name);
            /*0x1f7c0c8*/ void FromXml(System.Security.SecurityElement et);
            /*0x1f7c698*/ System.Security.SecurityElement ToXml();
            /*0x1f7cb90*/ bool Equals(object obj);
            /*0x1f7cdbc*/ int GetHashCode();
        }

        class PermissionBuilder
        {
            static /*0x0*/ object[] psNone;

            static /*0x1f7d41c*/ PermissionBuilder();
            static /*0x1f7ce38*/ System.Security.IPermission Create(string fullname, System.Security.Permissions.PermissionState state);
            static /*0x1f7d198*/ System.Security.IPermission Create(System.Security.SecurityElement se);
            static /*0x1f7d2a8*/ System.Security.IPermission Create(string fullname, System.Security.SecurityElement se);
            static /*0x1f7d37c*/ System.Security.IPermission Create(System.Type type);
            static /*0x1f7cfd8*/ System.Security.IPermission CreatePermission(string fullname, System.Security.SecurityElement se);
        }

        class PermissionSet : System.Security.ISecurityEncodable, System.Collections.ICollection, System.Collections.IEnumerable, System.Security.IStackWalk, System.Runtime.Serialization.IDeserializationCallback
        {
            static string tagName = "PermissionSet";
            static int version = 1;
            static /*0x0*/ object[] psUnrestricted;
            static /*0x8*/ object[] action;
            /*0x10*/ System.Security.Permissions.PermissionState state;
            /*0x18*/ System.Collections.ArrayList list;
            /*0x20*/ System.Security.Policy.PolicyLevel _policyLevel;
            /*0x28*/ bool _declsec;
            /*0x29*/ bool _readOnly;
            /*0x30*/ bool[] _ignored;

            static /*0x1f80cfc*/ PermissionSet();
            static /*0x1f7f048*/ byte[] ConvertPermissionSet(string inFormat, byte[] inData, string outFormat);
            static /*0x1f800bc*/ void RevertAssert();
            static /*0x1f8017c*/ System.Security.PermissionSet CreateFromBinaryFormat(byte[] data);
            static /*0x1f802f8*/ int ReadEncodedInt(byte[] data, ref int position);
            static /*0x1f803ac*/ System.Security.IPermission ProcessAttribute(byte[] data, ref int position);
            /*0x1f7ba04*/ PermissionSet();
            /*0x1f7bf28*/ PermissionSet(System.Security.Permissions.PermissionState state);
            /*0x1f7bae4*/ PermissionSet(System.Security.PermissionSet permSet);
            /*0x1f7d4f4*/ PermissionSet(string xml);
            /*0x1f7a2c8*/ PermissionSet(System.Security.IPermission perm);
            /*0x1f7d704*/ System.Security.IPermission AddPermission(System.Security.IPermission perm);
            /*0x1f7a314*/ void Assert();
            /*0x1f7dc20*/ void Clear();
            /*0x1f7dc44*/ System.Security.PermissionSet Copy();
            /*0x1f7dca4*/ void CopyTo(System.Array array, int index);
            /*0x1f7de1c*/ void Demand();
            /*0x1f7a644*/ void CasOnlyDemand(int skip);
            /*0x1f7a714*/ void Deny();
            /*0x1f7c17c*/ void FromXml(System.Security.SecurityElement et);
            /*0x1f7e3f8*/ System.Collections.IEnumerator GetEnumerator();
            /*0x1f7e41c*/ bool IsSubsetOf(System.Security.PermissionSet target);
            /*0x1f7a968*/ void PermitOnly();
            /*0x1f7ec80*/ bool ContainsNonCodeAccessPermissions();
            /*0x1f7e900*/ System.Security.IPermission GetPermission(System.Type permClass);
            /*0x1f7f6b4*/ System.Security.PermissionSet Intersect(System.Security.PermissionSet other);
            /*0x1f7f7d0*/ void InternalIntersect(System.Security.PermissionSet intersect, System.Security.PermissionSet a, System.Security.PermissionSet b, bool unrestricted);
            /*0x1f7e048*/ bool IsEmpty();
            /*0x1f7e3e8*/ bool IsUnrestricted();
            /*0x1f7d880*/ System.Security.IPermission RemovePermission(System.Type permClass);
            /*0x1f7fb90*/ System.Security.IPermission SetPermission(System.Security.IPermission perm);
            /*0x1f7fca8*/ string ToString();
            /*0x1f7c730*/ System.Security.SecurityElement ToXml();
            /*0x1f7fcd4*/ System.Security.PermissionSet Union(System.Security.PermissionSet other);
            /*0x1f80050*/ int get_Count();
            /*0x1f80074*/ bool get_IsSynchronized();
            /*0x1f80098*/ bool get_IsReadOnly();
            /*0x1f800a0*/ object get_SyncRoot();
            /*0x1f800a4*/ bool get_DeclarativeSecurity();
            /*0x1f800ac*/ void set_DeclarativeSecurity(bool value);
            /*0x1f800b8*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x1f7cc20*/ bool Equals(object obj);
            /*0x1f7cdf4*/ int GetHashCode();
            /*0x1f800c0*/ System.Security.Policy.PolicyLevel get_Resolver();
            /*0x1f800c8*/ void set_Resolver(System.Security.Policy.PolicyLevel value);
            /*0x1f800d0*/ void SetReadOnly(bool value);
            /*0x1f800dc*/ bool AllIgnored();
            /*0x1f80e44*/ System.Security.IPermission AddPermissionImpl(System.Security.IPermission perm);
            /*0x1f80e7c*/ System.Collections.IEnumerator GetEnumeratorImpl();
            /*0x1f80eb4*/ System.Security.IPermission GetPermissionImpl(System.Type permClass);
            /*0x1f80eec*/ System.Security.IPermission RemovePermissionImpl(System.Type permClass);
            /*0x1f80f24*/ System.Security.IPermission SetPermissionImpl(System.Security.IPermission perm);
        }

        class SecureString : System.IDisposable
        {
            static int BlockSize = 16;
            static int MaxSize = 65536;
            /*0x10*/ int length;
            /*0x14*/ bool disposed;
            /*0x15*/ bool read_only;
            /*0x18*/ byte[] data;

            static /*0x1f80f5c*/ SecureString();
            /*0x1f80f60*/ SecureString();
            /*0x1f81100*/ SecureString(char* value, int length);
            /*0x1f81250*/ int get_Length();
            /*0x1f812b4*/ void AppendChar(char c);
            /*0x1f81488*/ void Clear();
            /*0x1f81574*/ System.Security.SecureString Copy();
            /*0x1f81658*/ void Dispose();
            /*0x1f81690*/ void InsertAt(int index, char c);
            /*0x1f81960*/ bool IsReadOnly();
            /*0x1f819c4*/ void MakeReadOnly();
            /*0x1f819d0*/ void RemoveAt(int index);
            /*0x1f81b7c*/ void SetAt(int index, char c);
            /*0x1f8124c*/ void Encrypt();
            /*0x1f81484*/ void Decrypt();
            /*0x1f80f84*/ void Alloc(int length, bool realloc);
            /*0x1f81d30*/ byte[] GetBuffer();
        }

        enum SecurityElementType
        {
            Regular = 0,
            Format = 1,
            Comment = 2,
        }

        class SecurityElement
        {
            static /*0x0*/ char[] invalid_tag_chars;
            static /*0x8*/ char[] invalid_text_chars;
            static /*0x10*/ char[] invalid_attr_name_chars;
            static /*0x18*/ char[] invalid_attr_value_chars;
            static /*0x20*/ char[] invalid_chars;
            /*0x10*/ string text;
            /*0x18*/ string tag;
            /*0x20*/ System.Collections.ArrayList attributes;
            /*0x28*/ System.Collections.ArrayList children;

            static /*0x1f84b48*/ SecurityElement();
            static /*0x1f83cd4*/ string Escape(string str);
            static /*0x1f83224*/ string Unescape(string str);
            static /*0x1f7d580*/ System.Security.SecurityElement FromString(string xml);
            static /*0x1f83ec0*/ bool IsValidAttributeName(string name);
            static /*0x1f83f3c*/ bool IsValidAttributeValue(string value);
            static /*0x1f81f30*/ bool IsValidTag(string tag);
            static /*0x1f831a8*/ bool IsValidText(string text);
            /*0x1f79b1c*/ SecurityElement(string tag);
            /*0x1f81de0*/ SecurityElement(string tag, string text);
            /*0x1f820a8*/ SecurityElement(System.Security.SecurityElement se);
            /*0x1f8273c*/ System.Collections.Hashtable get_Attributes();
            /*0x1f82a7c*/ void set_Attributes(System.Collections.Hashtable value);
            /*0x1f82ecc*/ System.Collections.ArrayList get_Children();
            /*0x1f82ed4*/ void set_Children(System.Collections.ArrayList value);
            /*0x1f83198*/ string get_Tag();
            /*0x1f8260c*/ void set_Tag(string value);
            /*0x1f831a0*/ string get_Text();
            /*0x1f81fac*/ void set_Text(string value);
            /*0x1f79b24*/ void AddAttribute(string name, string value);
            /*0x1f79cd0*/ void AddChild(System.Security.SecurityElement child);
            /*0x1f7aec0*/ string Attribute(string name);
            /*0x1f83710*/ System.Security.SecurityElement Copy();
            /*0x1f83770*/ bool Equal(System.Security.SecurityElement other);
            /*0x1f83fb8*/ System.Security.SecurityElement SearchForChildByTag(string tag);
            /*0x1f840e0*/ string SearchForTextOfTag(string tag);
            /*0x1f84210*/ string ToString();
            /*0x1f84298*/ void ToXml(ref System.Text.StringBuilder s, int level);
            /*0x1f83400*/ System.Security.SecurityElement.SecurityAttribute GetAttribute(string name);
            /*0x1f848e4*/ string get_m_strTag();
            /*0x1f848ec*/ string get_m_strText();
            /*0x1f848f4*/ void set_m_strText(string value);
            /*0x1f848fc*/ System.Collections.ArrayList get_m_lAttributes();
            /*0x1f84904*/ System.Collections.ArrayList get_InternalChildren();
            /*0x1f8490c*/ string SearchForTextOfLocalName(string strLocalName);

            class SecurityAttribute
            {
                /*0x10*/ string _name;
                /*0x18*/ string _value;

                /*0x1f82d68*/ SecurityAttribute(string name, string value);
                /*0x1f84cc8*/ string get_Name();
                /*0x1f84cd0*/ string get_Value();
            }
        }

        class SecurityException : System.SystemException
        {
            /*0x90*/ string permissionState;
            /*0x98*/ System.Type permissionType;
            /*0xa0*/ string _granted;
            /*0xa8*/ string _refused;
            /*0xb0*/ object _demanded;
            /*0xb8*/ System.Security.IPermission _firstperm;
            /*0xc0*/ System.Reflection.MethodInfo _method;
            /*0xc8*/ System.Security.Permissions.SecurityAction _action;
            /*0xd0*/ object _denyset;
            /*0xd8*/ object _permitset;
            /*0xe0*/ System.Reflection.AssemblyName _assembly;
            /*0xe8*/ string _url;
            /*0xf0*/ System.Security.SecurityZone _zone;

            /*0x1f84da8*/ SecurityException();
            /*0x1f802d4*/ SecurityException(string message);
            /*0x1f84e10*/ SecurityException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f84f1c*/ SecurityException(string message, System.Exception inner);
            /*0x1f84f40*/ SecurityException(string message, System.Type type);
            /*0x1f84f74*/ SecurityException(string message, System.Type type, string state);
            /*0x1f84fac*/ SecurityException(string message, System.Security.PermissionSet granted, System.Security.PermissionSet refused);
            /*0x1f85014*/ SecurityException(string message, object deny, object permitOnly, System.Reflection.MethodInfo method, object demanded, System.Security.IPermission permThatFailed);
            /*0x1f85178*/ SecurityException(string message, System.Reflection.AssemblyName assemblyName, System.Security.PermissionSet grant, System.Security.PermissionSet refused, System.Reflection.MethodInfo method, System.Security.Permissions.SecurityAction action, object demanded, System.Security.IPermission permThatFailed, System.Security.Policy.Evidence evidence);
            /*0x1f84cd8*/ System.Security.Permissions.SecurityAction get_Action();
            /*0x1f84ce0*/ void set_Action(System.Security.Permissions.SecurityAction value);
            /*0x1f84ce8*/ object get_DenySetInstance();
            /*0x1f84cf0*/ void set_DenySetInstance(object value);
            /*0x1f84cf8*/ System.Reflection.AssemblyName get_FailedAssemblyInfo();
            /*0x1f84d00*/ void set_FailedAssemblyInfo(System.Reflection.AssemblyName value);
            /*0x1f84d08*/ System.Reflection.MethodInfo get_Method();
            /*0x1f84d10*/ void set_Method(System.Reflection.MethodInfo value);
            /*0x1f84d18*/ object get_PermitOnlySetInstance();
            /*0x1f84d20*/ void set_PermitOnlySetInstance(object value);
            /*0x1f84d28*/ string get_Url();
            /*0x1f84d30*/ void set_Url(string value);
            /*0x1f84d38*/ System.Security.SecurityZone get_Zone();
            /*0x1f84d40*/ void set_Zone(System.Security.SecurityZone value);
            /*0x1f84d48*/ object get_Demanded();
            /*0x1f84d50*/ void set_Demanded(object value);
            /*0x1f84d58*/ System.Security.IPermission get_FirstPermissionThatFailed();
            /*0x1f84d60*/ void set_FirstPermissionThatFailed(System.Security.IPermission value);
            /*0x1f84d68*/ string get_PermissionState();
            /*0x1f84d70*/ void set_PermissionState(string value);
            /*0x1f84d78*/ System.Type get_PermissionType();
            /*0x1f84d80*/ void set_PermissionType(System.Type value);
            /*0x1f84d88*/ string get_GrantedSet();
            /*0x1f84d90*/ void set_GrantedSet(string value);
            /*0x1f84d98*/ string get_RefusedSet();
            /*0x1f84da0*/ void set_RefusedSet(string value);
            /*0x1f85070*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x1f85170*/ string ToString();
        }

        struct RuntimeDeclSecurityEntry
        {
            /*0x10*/ nint blob;
            /*0x18*/ int size;
            /*0x1c*/ int index;
        }

        struct RuntimeDeclSecurityActions
        {
            /*0x10*/ System.Security.RuntimeDeclSecurityEntry cas;
            /*0x20*/ System.Security.RuntimeDeclSecurityEntry noncas;
            /*0x30*/ System.Security.RuntimeDeclSecurityEntry choice;
        }

        class SecurityManager
        {
            static /*0x1f851b0*/ bool get_CheckExecutionRights();
            static /*0x1f851b8*/ void set_CheckExecutionRights(bool value);
            static /*0x1f7a63c*/ bool get_SecurityEnabled();
            static /*0x1f851bc*/ void set_SecurityEnabled(bool value);
            static /*0x1f851c0*/ bool get_HasElevatedPermissions();
            static /*0x1f851c8*/ bool CheckElevatedPermissions();
            static /*0x1f851d0*/ void EnsureElevatedPermissions();
            static /*0x1f851d4*/ void GetZoneAndOrigin(ref System.Collections.ArrayList zone, ref System.Collections.ArrayList origin);
            static /*0x1f7dc18*/ bool IsGranted(System.Security.IPermission perm);
            static /*0x1f8525c*/ System.Security.Policy.PolicyLevel LoadPolicyLevelFromFile(string path, System.Security.PolicyLevelType type);
            static /*0x1f8529c*/ System.Security.Policy.PolicyLevel LoadPolicyLevelFromString(string str, System.Security.PolicyLevelType type);
            static /*0x1f852dc*/ System.Collections.IEnumerator PolicyHierarchy();
            static /*0x1f7b890*/ System.Security.PermissionSet ResolvePolicy(System.Security.Policy.Evidence evidence);
            static /*0x1f8531c*/ System.Security.PermissionSet ResolvePolicy(System.Security.Policy.Evidence[] evidences);
            static /*0x1f8535c*/ System.Security.PermissionSet ResolveSystemPolicy(System.Security.Policy.Evidence evidence);
            static /*0x1f8539c*/ System.Security.PermissionSet ResolvePolicy(System.Security.Policy.Evidence evidence, System.Security.PermissionSet reqdPset, System.Security.PermissionSet optPset, System.Security.PermissionSet denyPset, ref System.Security.PermissionSet denied);
            static /*0x1f853dc*/ System.Collections.IEnumerator ResolvePolicyGroups(System.Security.Policy.Evidence evidence);
            static /*0x1f8541c*/ void SavePolicy();
            static /*0x1f8545c*/ void SavePolicyLevel(System.Security.Policy.PolicyLevel level);
            static /*0x1f8549c*/ bool ResolvePolicyLevel(ref System.Security.PermissionSet ps, System.Security.Policy.PolicyLevel pl, System.Security.Policy.Evidence evidence);
            static /*0x1f854dc*/ void ResolveIdentityPermissions(System.Security.PermissionSet ps, System.Security.Policy.Evidence evidence);
            static /*0x1f8551c*/ System.Security.Policy.PolicyLevel get_ResolvingPolicyLevel();
            static /*0x1f85524*/ void set_ResolvingPolicyLevel(System.Security.Policy.PolicyLevel value);
            static /*0x1f85528*/ System.Security.IPermission CheckPermissionSet(System.Reflection.Assembly a, System.Security.PermissionSet ps, bool noncas);
            static /*0x1f85530*/ System.Security.IPermission CheckPermissionSet(System.AppDomain ad, System.Security.PermissionSet ps);
            static /*0x1f85538*/ System.Security.PermissionSet Decode(nint permissions, int length);
            static /*0x1f85578*/ System.Security.PermissionSet Decode(byte[] encodedPermissions);
            static /*0x1f855b8*/ System.Security.PermissionSet GetStandardSandbox(System.Security.Policy.Evidence evidence);
            static /*0x1f85634*/ bool CurrentThreadRequiresSecurityContextCapture();
        }

        class SecurityState
        {
            /*0x1f85674*/ SecurityState();
            void EnsureState();
            /*0x1f8567c*/ bool IsStateAvailable();
        }

        namespace Util
        {
            class Hex
            {
                static /*0x1f856c0*/ char HexDigit(int num);
                static /*0x1f856d8*/ string EncodeHexString(byte[] sArray);
                static /*0x1f857e4*/ string EncodeHexStringFromInt(byte[] sArray);
                static /*0x1f858f4*/ int ConvertHexDigit(char val);
                static /*0x1f859a4*/ byte[] DecodeHexString(string hexString);
            }

            class Parser
            {
                static short c_flag = 16384;
                static short c_elementtag = 16640;
                static short c_attributetag = 16896;
                static short c_texttag = 17152;
                static short c_additionaltexttag = 25344;
                static short c_childrentag = 17408;
                static short c_wastedstringtag = 20480;
                /*0x10*/ System.Security.SecurityDocument _doc;
                /*0x18*/ System.Security.Util.Tokenizer _t;

                /*0x1f87210*/ Parser(System.Security.Util.Tokenizer t);
                /*0x1f872b4*/ Parser(string input);
                /*0x1f8736c*/ Parser(string input, string[] searchStrings, string[] replaceStrings);
                /*0x1f87450*/ Parser(byte[] array, System.Security.Util.Tokenizer.ByteTokenEncoding encoding);
                /*0x1f875dc*/ Parser(byte[] array, System.Security.Util.Tokenizer.ByteTokenEncoding encoding, int startIndex);
                /*0x1f87664*/ Parser(System.IO.StreamReader input);
                /*0x1f8775c*/ Parser(char[] array);
                /*0x1f85c2c*/ System.Security.SecurityElement GetTopElement();
                /*0x1f85c54*/ void GetRequiredSizes(System.Security.Util.TokenizerStream stream, ref int index);
                /*0x1f861ac*/ int DetermineFormat(System.Security.Util.TokenizerStream stream);
                /*0x1f86dd4*/ void ParseContents();
            }

            class Tokenizer
            {
                static byte bra = 0;
                static byte ket = 1;
                static byte slash = 2;
                static byte cstr = 3;
                static byte equals = 4;
                static byte quest = 5;
                static byte bang = 6;
                static byte dash = 7;
                static int intOpenBracket = 60;
                static int intCloseBracket = 62;
                static int intSlash = 47;
                static int intEquals = 61;
                static int intQuote = 34;
                static int intQuest = 63;
                static int intBang = 33;
                static int intDash = 45;
                static int intTab = 9;
                static int intCR = 13;
                static int intLF = 10;
                static int intSpace = 32;
                /*0x10*/ int LineNo;
                /*0x14*/ int _inProcessingTag;
                /*0x18*/ byte[] _inBytes;
                /*0x20*/ char[] _inChars;
                /*0x28*/ string _inString;
                /*0x30*/ int _inIndex;
                /*0x34*/ int _inSize;
                /*0x38*/ int _inSavedCharacter;
                /*0x3c*/ System.Security.Util.Tokenizer.TokenSource _inTokenSource;
                /*0x40*/ System.Security.Util.Tokenizer.ITokenReader _inTokenReader;
                /*0x48*/ System.Security.Util.Tokenizer.StringMaker _maker;
                /*0x50*/ string[] _searchStrings;
                /*0x58*/ string[] _replaceStrings;
                /*0x60*/ int _inNestedIndex;
                /*0x64*/ int _inNestedSize;
                /*0x68*/ string _inNestedString;

                /*0x1f87324*/ Tokenizer(string input);
                /*0x1f873f4*/ Tokenizer(string input, string[] searchStrings, string[] replaceStrings);
                /*0x1f874cc*/ Tokenizer(byte[] array, System.Security.Util.Tokenizer.ByteTokenEncoding encoding, int startIndex);
                /*0x1f877cc*/ Tokenizer(char[] array);
                /*0x1f876d4*/ Tokenizer(System.IO.StreamReader input);
                /*0x1f87814*/ void BasicInitialization();
                /*0x1f8788c*/ void Recycle();
                /*0x1f86ba0*/ void ChangeFormat(System.Text.Encoding encoding);
                /*0x1f86360*/ void GetTokens(System.Security.Util.TokenizerStream stream, int maxNum, bool endAfterKet);
                /*0x1f879fc*/ string GetStringToken();

                enum TokenSource
                {
                    UnicodeByteArray = 0,
                    UTF8ByteArray = 1,
                    ASCIIByteArray = 2,
                    CharArray = 3,
                    String = 4,
                    NestedStrings = 5,
                    Other = 6,
                }

                enum ByteTokenEncoding
                {
                    UnicodeTokens = 0,
                    UTF8Tokens = 1,
                    ByteTokens = 2,
                }

                class StringMaker
                {
                    /*0x10*/ string[] aStrings;
                    /*0x18*/ uint cStringsMax;
                    /*0x1c*/ uint cStringsUsed;
                    /*0x20*/ System.Text.StringBuilder _outStringBuilder;
                    /*0x28*/ char[] _outChars;
                    /*0x30*/ int _outIndex;

                    static /*0x1f87b04*/ uint HashString(string str);
                    static /*0x1f87b70*/ uint HashCharArray(char[] a, int l);
                    /*0x1f87bcc*/ StringMaker();
                    /*0x1f87c60*/ bool CompareStringAndChars(string str, char[] a, int l);
                    /*0x1f79614*/ string MakeString();
                }

                interface ITokenReader
                {
                    int Read();
                }

                class StreamTokenReader : System.Security.Util.Tokenizer.ITokenReader
                {
                    /*0x10*/ System.IO.StreamReader _in;
                    /*0x18*/ int _numCharRead;

                    /*0x1f878e8*/ StreamTokenReader(System.IO.StreamReader input);
                    /*0x1f87cf4*/ int Read();
                    /*0x1f87d30*/ int get_NumCharEncountered();
                }
            }

            class TokenizerShortBlock
            {
                /*0x10*/ short[] m_block;
                /*0x18*/ System.Security.Util.TokenizerShortBlock m_next;

                /*0x1f87d38*/ TokenizerShortBlock();
            }

            class TokenizerStringBlock
            {
                /*0x10*/ string[] m_block;
                /*0x18*/ System.Security.Util.TokenizerStringBlock m_next;

                /*0x1f87d90*/ TokenizerStringBlock();
            }

            class TokenizerStream
            {
                /*0x10*/ int m_countTokens;
                /*0x18*/ System.Security.Util.TokenizerShortBlock m_headTokens;
                /*0x20*/ System.Security.Util.TokenizerShortBlock m_lastTokens;
                /*0x28*/ System.Security.Util.TokenizerShortBlock m_currentTokens;
                /*0x30*/ int m_indexTokens;
                /*0x38*/ System.Security.Util.TokenizerStringBlock m_headStrings;
                /*0x40*/ System.Security.Util.TokenizerStringBlock m_currentStrings;
                /*0x48*/ int m_indexStrings;

                /*0x1f870dc*/ TokenizerStream();
                /*0x1f87914*/ void AddToken(short token);
                /*0x1f87a14*/ void AddString(string str);
                /*0x1f87184*/ void Reset();
                /*0x1f871a0*/ short GetNextFullToken();
                /*0x1f860b4*/ short GetNextToken();
                /*0x1f86140*/ string GetNextString();
                /*0x1f860c8*/ void ThrowAwayNextString();
                /*0x1f860cc*/ void TagLastToken(short tag);
                /*0x1f87de8*/ int GetTokenCount();
                /*0x1f86b40*/ void GoToPosition(int position);
            }
        }

        namespace Policy
        {
            enum ApplicationVersionMatch
            {
                MatchAllVersions = 1,
                MatchExactVersion = 0,
            }

            interface IIdentityPermissionFactory
            {
                System.Security.IPermission CreateIdentityPermission(System.Security.Policy.Evidence evidence);
            }

            interface IMembershipCondition : System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
            {
                bool Check(System.Security.Policy.Evidence evidence);
                System.Security.Policy.IMembershipCondition Copy();
                bool Equals(object obj);
                string ToString();
            }

            enum PolicyStatementAttribute
            {
                All = 3,
                Exclusive = 1,
                LevelFinal = 2,
                Nothing = 0,
            }

            class Publisher : System.Security.Policy.EvidenceBase, System.Security.Policy.IIdentityPermissionFactory
            {
                /*0x1f87df0*/ Publisher(System.Security.Cryptography.X509Certificates.X509Certificate cert);
                /*0x1f87df8*/ System.Security.Cryptography.X509Certificates.X509Certificate get_Certificate();
                /*0x1f87e00*/ object Copy();
                /*0x1f87e08*/ System.Security.IPermission CreateIdentityPermission(System.Security.Policy.Evidence evidence);
                /*0x1f87e10*/ bool Equals(object o);
                /*0x1f87e18*/ int GetHashCode();
                /*0x1f87e20*/ string ToString();
            }

            class PublisherMembershipCondition : System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable, System.Security.Policy.IMembershipCondition
            {
                /*0x10*/ System.Security.Cryptography.X509Certificates.X509Certificate <Certificate>k__BackingField;

                /*0x1f87e28*/ PublisherMembershipCondition(System.Security.Cryptography.X509Certificates.X509Certificate certificate);
                /*0x1f87e30*/ System.Security.Cryptography.X509Certificates.X509Certificate get_Certificate();
                /*0x1f87e38*/ void set_Certificate(System.Security.Cryptography.X509Certificates.X509Certificate value);
                /*0x1f87e40*/ bool Check(System.Security.Policy.Evidence evidence);
                /*0x1f87e48*/ System.Security.Policy.IMembershipCondition Copy();
                /*0x1f87e4c*/ bool Equals(object o);
                /*0x1f87e54*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f87e58*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f87e5c*/ int GetHashCode();
                /*0x1f87e64*/ string ToString();
                /*0x1f87e6c*/ System.Security.SecurityElement ToXml();
                /*0x1f87e74*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
            }

            class AllMembershipCondition : System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable, System.Security.Policy.IConstantMembershipCondition
            {
                /*0x10*/ int version;

                /*0x1f87e7c*/ AllMembershipCondition();
                /*0x1f87e8c*/ bool Check(System.Security.Policy.Evidence evidence);
                /*0x1f87e94*/ System.Security.Policy.IMembershipCondition Copy();
                /*0x1f87ef8*/ bool Equals(object o);
                /*0x1f87f54*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f87f58*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f87fe0*/ int GetHashCode();
                /*0x1f88060*/ string ToString();
                /*0x1f880a0*/ System.Security.SecurityElement ToXml();
                /*0x1f880a4*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
            }

            class ApplicationDirectory : System.Security.Policy.EvidenceBase, System.Security.Policy.IBuiltInEvidence
            {
                /*0x10*/ string directory;

                /*0x1f8815c*/ ApplicationDirectory(string name);
                /*0x1f88238*/ string get_Directory();
                /*0x1f88240*/ object Copy();
                /*0x1f882a4*/ bool Equals(object o);
                /*0x1f88418*/ int GetHashCode();
                /*0x1f88438*/ string ToString();
                /*0x1f88540*/ int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
                /*0x1f8856c*/ int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(char[] buffer, int position);
                /*0x1f88574*/ int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(char[] buffer, int position, bool verbose);
                /*0x1f8832c*/ void ThrowOnInvalid(string appdir);
            }

            class ApplicationDirectoryMembershipCondition : System.Security.Policy.IConstantMembershipCondition, System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
            {
                /*0x10*/ int version;

                /*0x1f8857c*/ ApplicationDirectoryMembershipCondition();
                /*0x1f8858c*/ bool Check(System.Security.Policy.Evidence evidence);
                /*0x1f88860*/ System.Security.Policy.IMembershipCondition Copy();
                /*0x1f888c4*/ bool Equals(object o);
                /*0x1f88920*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f88924*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f889ac*/ int GetHashCode();
                /*0x1f88a2c*/ string ToString();
                /*0x1f88a6c*/ System.Security.SecurityElement ToXml();
                /*0x1f88a70*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
            }

            class ApplicationSecurityInfo
            {
                /*0x10*/ System.Security.Policy.Evidence _evidence;
                /*0x18*/ System.ApplicationId _appid;
                /*0x20*/ System.Security.PermissionSet _defaultSet;
                /*0x28*/ System.ApplicationId _deployid;

                /*0x1f88b28*/ ApplicationSecurityInfo(System.ActivationContext activationContext);
                /*0x1f88b90*/ System.Security.Policy.Evidence get_ApplicationEvidence();
                /*0x1f88b98*/ void set_ApplicationEvidence(System.Security.Policy.Evidence value);
                /*0x1f88bf8*/ System.ApplicationId get_ApplicationId();
                /*0x1f88c00*/ void set_ApplicationId(System.ApplicationId value);
                /*0x1f88c60*/ System.Security.PermissionSet get_DefaultRequestSet();
                /*0x1f88cc8*/ void set_DefaultRequestSet(System.Security.PermissionSet value);
                /*0x1f88d28*/ System.ApplicationId get_DeploymentId();
                /*0x1f88d30*/ void set_DeploymentId(System.ApplicationId value);
            }

            class ApplicationSecurityManager
            {
                static /*0x0*/ System.Security.Policy.IApplicationTrustManager _appTrustManager;
                static /*0x8*/ System.Security.Policy.ApplicationTrustCollection _userAppTrusts;

                static /*0x1f88d90*/ System.Security.Policy.IApplicationTrustManager get_ApplicationTrustManager();
                static /*0x1f88e24*/ System.Security.Policy.ApplicationTrustCollection get_UserApplicationTrusts();
                static /*0x1f7b624*/ bool DetermineApplicationTrust(System.ActivationContext activationContext, System.Security.Policy.TrustManagerContext context);
            }

            class ApplicationTrust : System.Security.Policy.EvidenceBase, System.Security.ISecurityEncodable
            {
                /*0x10*/ System.ApplicationIdentity _appid;
                /*0x18*/ System.Security.Policy.PolicyStatement _defaultPolicy;
                /*0x20*/ object _xtranfo;
                /*0x28*/ bool _trustrun;
                /*0x29*/ bool _persist;
                /*0x30*/ System.Collections.Generic.IList<System.Security.Policy.StrongName> fullTrustAssemblies;

                /*0x1f7b730*/ ApplicationTrust();
                /*0x1f7b7b4*/ ApplicationTrust(System.ApplicationIdentity applicationIdentity);
                /*0x1f88f18*/ ApplicationTrust(System.Security.PermissionSet defaultGrantSet, System.Collections.Generic.IEnumerable<System.Security.Policy.StrongName> fullTrustAssemblies);
                /*0x1f8940c*/ System.ApplicationIdentity get_ApplicationIdentity();
                /*0x1f89414*/ void set_ApplicationIdentity(System.ApplicationIdentity value);
                /*0x1f89474*/ System.Security.Policy.PolicyStatement get_DefaultGrantSet();
                /*0x1f89520*/ void set_DefaultGrantSet(System.Security.Policy.PolicyStatement value);
                /*0x1f89528*/ object get_ExtraInfo();
                /*0x1f89530*/ void set_ExtraInfo(object value);
                /*0x1f89538*/ bool get_IsApplicationTrustedToRun();
                /*0x1f89540*/ void set_IsApplicationTrustedToRun(bool value);
                /*0x1f8954c*/ bool get_Persist();
                /*0x1f89554*/ void set_Persist(bool value);
                /*0x1f89560*/ void FromXml(System.Security.SecurityElement element);
                /*0x1f89a48*/ System.Security.SecurityElement ToXml();
                /*0x1f89e3c*/ System.Collections.Generic.IList<System.Security.Policy.StrongName> get_FullTrustAssemblies();
                /*0x1f89494*/ System.Security.Policy.PolicyStatement GetDefaultGrantSet();
            }

            class ApplicationTrustCollection : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.ArrayList _list;

                /*0x1f88eac*/ ApplicationTrustCollection();
                /*0x1f89e44*/ int get_Count();
                /*0x1f89e68*/ bool get_IsSynchronized();
                /*0x1f89e70*/ object get_SyncRoot();
                /*0x1f89e74*/ System.Security.Policy.ApplicationTrust get_Item(int index);
                /*0x1f89ef0*/ System.Security.Policy.ApplicationTrust get_Item(string appFullName);
                /*0x1f89fc8*/ int Add(System.Security.Policy.ApplicationTrust trust);
                /*0x1f8a0b4*/ void AddRange(System.Security.Policy.ApplicationTrust[] trusts);
                /*0x1f8a1ec*/ void AddRange(System.Security.Policy.ApplicationTrustCollection trusts);
                /*0x1f8a400*/ void Clear();
                /*0x1f8a424*/ void CopyTo(System.Security.Policy.ApplicationTrust[] array, int index);
                /*0x1f8a448*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x1f8a46c*/ System.Security.Policy.ApplicationTrustCollection Find(System.ApplicationIdentity applicationIdentity, System.Security.Policy.ApplicationVersionMatch versionMatch);
                /*0x1f8a310*/ System.Security.Policy.ApplicationTrustEnumerator GetEnumerator();
                /*0x1f8a8a8*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x1f8a914*/ void Remove(System.Security.Policy.ApplicationTrust trust);
                /*0x1f8aa84*/ void Remove(System.ApplicationIdentity applicationIdentity, System.Security.Policy.ApplicationVersionMatch versionMatch);
                /*0x1f8aad8*/ void RemoveRange(System.Security.Policy.ApplicationTrust[] trusts);
                /*0x1f8ab8c*/ void RemoveRange(System.Security.Policy.ApplicationTrustCollection trusts);
                /*0x1f8a9e8*/ void RemoveAllInstances(System.Security.Policy.ApplicationTrust trust);
            }

            class ApplicationTrustEnumerator : System.Collections.IEnumerator
            {
                /*0x10*/ System.Security.Policy.ApplicationTrustCollection trusts;
                /*0x18*/ int current;

                /*0x1f8a878*/ ApplicationTrustEnumerator(System.Security.Policy.ApplicationTrustCollection atc);
                /*0x1f8ac58*/ ApplicationTrustEnumerator();
                /*0x1f8a37c*/ System.Security.Policy.ApplicationTrust get_Current();
                /*0x1f8ac2c*/ object System.Collections.IEnumerator.get_Current();
                /*0x1f8ac4c*/ void Reset();
                /*0x1f8a39c*/ bool MoveNext();
            }

            class CodeConnectAccess
            {
                static /*0x0*/ string AnyScheme;
                static /*0x8*/ int DefaultPort;
                static /*0xc*/ int OriginPort;
                static /*0x10*/ string OriginScheme;
                /*0x10*/ string _scheme;
                /*0x18*/ int _port;

                static /*0x1f8af28*/ CodeConnectAccess();
                static /*0x1f8ae30*/ System.Security.Policy.CodeConnectAccess CreateAnySchemeAccess(int allowPort);
                static /*0x1f8aeac*/ System.Security.Policy.CodeConnectAccess CreateOriginSchemeAccess(int allowPort);
                /*0x1f8ac90*/ CodeConnectAccess(string allowScheme, int allowPort);
                /*0x1f8ad44*/ int get_Port();
                /*0x1f8ad4c*/ string get_Scheme();
                /*0x1f8ad54*/ bool Equals(object o);
                /*0x1f8ae00*/ int GetHashCode();
            }

            class CodeGroup
            {
                /*0x10*/ System.Security.Policy.PolicyStatement m_policy;
                /*0x18*/ System.Security.Policy.IMembershipCondition m_membershipCondition;
                /*0x20*/ string m_description;
                /*0x28*/ string m_name;
                /*0x30*/ System.Collections.ArrayList m_children;

                static /*0x1f8c04c*/ System.Security.Policy.CodeGroup CreateFromXml(System.Security.SecurityElement se, System.Security.Policy.PolicyLevel level);
                /*0x1f8afc0*/ CodeGroup(System.Security.Policy.IMembershipCondition membershipCondition, System.Security.Policy.PolicyStatement policy);
                /*0x1f8b114*/ CodeGroup(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                System.Security.Policy.CodeGroup Copy();
                string get_MergeLogic();
                System.Security.Policy.PolicyStatement Resolve(System.Security.Policy.Evidence evidence);
                System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(System.Security.Policy.Evidence evidence);
                /*0x1f8b914*/ System.Security.Policy.PolicyStatement get_PolicyStatement();
                /*0x1f8b91c*/ void set_PolicyStatement(System.Security.Policy.PolicyStatement value);
                /*0x1f8b924*/ string get_Description();
                /*0x1f8b92c*/ void set_Description(string value);
                /*0x1f8b934*/ System.Security.Policy.IMembershipCondition get_MembershipCondition();
                /*0x1f8b93c*/ void set_MembershipCondition(System.Security.Policy.IMembershipCondition value);
                /*0x1f8b99c*/ string get_Name();
                /*0x1f8b9a4*/ void set_Name(string value);
                /*0x1f8b9ac*/ System.Collections.IList get_Children();
                /*0x1f8b9b4*/ void set_Children(System.Collections.IList value);
                /*0x1f8ba6c*/ string get_AttributeString();
                /*0x1f8ba80*/ string get_PermissionSetName();
                /*0x1f8bb1c*/ void AddChild(System.Security.Policy.CodeGroup group);
                /*0x1f8bbac*/ bool Equals(object o);
                /*0x1f8bc3c*/ bool Equals(System.Security.Policy.CodeGroup cg, bool compareChildren);
                /*0x1f8bfc8*/ void RemoveChild(System.Security.Policy.CodeGroup group);
                /*0x1f8bff8*/ int GetHashCode();
                /*0x1f8c044*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f8b19c*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f8c388*/ void ParseXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f8c38c*/ System.Security.SecurityElement ToXml();
                /*0x1f8c394*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
                /*0x1f8c8cc*/ void CreateXml(System.Security.SecurityElement element, System.Security.Policy.PolicyLevel level);
            }

            class DefaultPolicies
            {
                static string DnsPermissionClass = "System.Net.DnsPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
                static string EventLogPermissionClass = "System.Diagnostics.EventLogPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
                static string PrintingPermissionClass = "System.Drawing.Printing.PrintingPermission, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
                static string SocketPermissionClass = "System.Net.SocketPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
                static string WebPermissionClass = "System.Net.WebPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
                static string PerformanceCounterPermissionClass = "System.Diagnostics.PerformanceCounterPermission, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
                static string DirectoryServicesPermissionClass = "System.DirectoryServices.DirectoryServicesPermission, System.DirectoryServices, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
                static string MessageQueuePermissionClass = "System.Messaging.MessageQueuePermission, System.Messaging, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
                static string ServiceControllerPermissionClass = "System.ServiceProcess.ServiceControllerPermission, System.ServiceProcess, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a";
                static string OleDbPermissionClass = "System.Data.OleDb.OleDbPermission, System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
                static string SqlClientPermissionClass = "System.Data.SqlClient.SqlClientPermission, System.Data, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
                static /*0x0*/ System.Version _fxVersion;
                static /*0x8*/ byte[] _ecmaKey;
                static /*0x10*/ System.Security.Permissions.StrongNamePublicKeyBlob _ecma;
                static /*0x18*/ byte[] _msFinalKey;
                static /*0x20*/ System.Security.Permissions.StrongNamePublicKeyBlob _msFinal;
                static /*0x28*/ System.Security.NamedPermissionSet _fullTrust;
                static /*0x30*/ System.Security.NamedPermissionSet _localIntranet;
                static /*0x38*/ System.Security.NamedPermissionSet _internet;
                static /*0x40*/ System.Security.NamedPermissionSet _skipVerification;
                static /*0x48*/ System.Security.NamedPermissionSet _execution;
                static /*0x50*/ System.Security.NamedPermissionSet _nothing;
                static /*0x58*/ System.Security.NamedPermissionSet _everything;

                static /*0x1f8f550*/ DefaultPolicies();
                static /*0x1f8d8d0*/ System.Security.PermissionSet GetSpecialPermissionSet(string name);
                static /*0x1f8dbd0*/ System.Security.PermissionSet get_FullTrust();
                static /*0x1f8dc6c*/ System.Security.PermissionSet get_LocalIntranet();
                static /*0x1f8dd08*/ System.Security.PermissionSet get_Internet();
                static /*0x1f8dda4*/ System.Security.PermissionSet get_SkipVerification();
                static /*0x1f8de40*/ System.Security.PermissionSet get_Execution();
                static /*0x1f8dedc*/ System.Security.PermissionSet get_Nothing();
                static /*0x1f8df78*/ System.Security.PermissionSet get_Everything();
                static /*0x1f8ecd0*/ System.Security.Policy.StrongNameMembershipCondition FullTrustMembership(string name, System.Security.Policy.DefaultPolicies.Key key);
                static /*0x1f8e014*/ System.Security.NamedPermissionSet BuildFullTrust();
                static /*0x1f8e08c*/ System.Security.NamedPermissionSet BuildLocalIntranet();
                static /*0x1f8e37c*/ System.Security.NamedPermissionSet BuildInternet();
                static /*0x1f8e5a4*/ System.Security.NamedPermissionSet BuildSkipVerification();
                static /*0x1f8e65c*/ System.Security.NamedPermissionSet BuildExecution();
                static /*0x1f8e714*/ System.Security.NamedPermissionSet BuildNothing();
                static /*0x1f8e78c*/ System.Security.NamedPermissionSet BuildEverything();
                static /*0x1f8f2c0*/ System.Security.SecurityElement PrintingPermission(string level);

                class ReservedNames
                {
                    static /*0x1f8f614*/ bool IsReserved(string name);
                }

                enum Key
                {
                    Ecma = 0,
                    MsFinal = 1,
                }
            }

            class Evidence : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ bool _locked;
                /*0x18*/ System.Collections.ArrayList hostEvidenceList;
                /*0x20*/ System.Collections.ArrayList assemblyEvidenceList;

                static /*0x1f90370*/ bool IsAuthenticodePresent(System.Reflection.Assembly a);
                static /*0x1f90374*/ System.Security.Policy.Evidence GetDefaultHostEvidence(System.Reflection.Assembly a);
                /*0x1f8f794*/ Evidence();
                /*0x1f8f79c*/ Evidence(System.Security.Policy.Evidence evidence);
                /*0x1f8fcac*/ Evidence(System.Security.Policy.EvidenceBase[] hostEvidence, System.Security.Policy.EvidenceBase[] assemblyEvidence);
                /*0x1f8fe10*/ Evidence(object[] hostEvidence, object[] assemblyEvidence);
                /*0x1f8fe8c*/ int get_Count();
                /*0x1f8fee8*/ bool get_IsReadOnly();
                /*0x1f8fef0*/ bool get_IsSynchronized();
                /*0x1f8fef8*/ bool get_Locked();
                /*0x1f8ff00*/ void set_Locked(bool value);
                /*0x1f8ff0c*/ object get_SyncRoot();
                /*0x1f8fd28*/ System.Collections.ArrayList get_HostEvidenceList();
                /*0x1f8fd9c*/ System.Collections.ArrayList get_AssemblyEvidenceList();
                /*0x1f8ff10*/ void AddAssembly(object id);
                /*0x1f8ff3c*/ void AddHost(object id);
                /*0x1f8ff88*/ void Clear();
                /*0x1f8ffcc*/ System.Security.Policy.Evidence Clone();
                /*0x1f9002c*/ void CopyTo(System.Array array, int index);
                /*0x1f900f0*/ System.Collections.IEnumerator GetEnumerator();
                /*0x1f901d0*/ System.Collections.IEnumerator GetAssemblyEnumerator();
                /*0x1f901f4*/ System.Collections.IEnumerator GetHostEnumerator();
                /*0x1f8f7d8*/ void Merge(System.Security.Policy.Evidence evidence);
                /*0x1f90218*/ void RemoveType(System.Type t);
                void AddAssemblyEvidence<T>(T evidence);
                void AddHostEvidence<T>(T evidence);
                T GetAssemblyEvidence<T>();
                T GetHostEvidence<T>();

                class EvidenceEnumerator : System.Collections.IEnumerator
                {
                    /*0x10*/ System.Collections.IEnumerator currentEnum;
                    /*0x18*/ System.Collections.IEnumerator hostEnum;
                    /*0x20*/ System.Collections.IEnumerator assemblyEnum;

                    /*0x1f901a0*/ EvidenceEnumerator(System.Collections.IEnumerator hostenum, System.Collections.IEnumerator assemblyenum);
                    /*0x1f903d0*/ bool MoveNext();
                    /*0x1f904f8*/ void Reset();
                    /*0x1f90618*/ object get_Current();
                }
            }

            class EvidenceBase
            {
                /*0x1f906fc*/ EvidenceBase();
                /*0x1f906bc*/ System.Security.Policy.EvidenceBase Clone();
            }

            class FileCodeGroup : System.Security.Policy.CodeGroup
            {
                /*0x38*/ System.Security.Permissions.FileIOPermissionAccess m_access;

                /*0x1f90704*/ FileCodeGroup(System.Security.Policy.IMembershipCondition membershipCondition, System.Security.Permissions.FileIOPermissionAccess access);
                /*0x1f90730*/ FileCodeGroup(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f90738*/ System.Security.Policy.CodeGroup Copy();
                /*0x1f90ac0*/ string get_MergeLogic();
                /*0x1f90b00*/ System.Security.Policy.PolicyStatement Resolve(System.Security.Policy.Evidence evidence);
                /*0x1f911f4*/ System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(System.Security.Policy.Evidence evidence);
                /*0x1f91690*/ string get_AttributeString();
                /*0x1f91698*/ string get_PermissionSetName();
                /*0x1f91730*/ bool Equals(object o);
                /*0x1f917fc*/ int GetHashCode();
                /*0x1f91808*/ void ParseXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f91944*/ void CreateXml(System.Security.SecurityElement element, System.Security.Policy.PolicyLevel level);
            }

            class FirstMatchCodeGroup : System.Security.Policy.CodeGroup
            {
                /*0x1f919e8*/ FirstMatchCodeGroup(System.Security.Policy.IMembershipCondition membershipCondition, System.Security.Policy.PolicyStatement policy);
                /*0x1f919f0*/ FirstMatchCodeGroup(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f919f8*/ string get_MergeLogic();
                /*0x1f91a38*/ System.Security.Policy.CodeGroup Copy();
                /*0x1f91e0c*/ System.Security.Policy.PolicyStatement Resolve(System.Security.Policy.Evidence evidence);
                /*0x1f92280*/ System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(System.Security.Policy.Evidence evidence);
                /*0x1f91d90*/ System.Security.Policy.FirstMatchCodeGroup CopyNoChildren();
            }

            class GacInstalled : System.Security.Policy.EvidenceBase, System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
            {
                /*0x1f92700*/ GacInstalled();
                /*0x1f92708*/ object Copy();
                /*0x1f92764*/ System.Security.IPermission CreateIdentityPermission(System.Security.Policy.Evidence evidence);
                /*0x1f927c8*/ bool Equals(object o);
                /*0x1f92824*/ int GetHashCode();
                /*0x1f9282c*/ string ToString();
                /*0x1f92904*/ int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
                /*0x1f9290c*/ int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(char[] buffer, int position);
                /*0x1f92914*/ int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(char[] buffer, int position, bool verbose);
            }

            class GacMembershipCondition : System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable, System.Security.Policy.IConstantMembershipCondition
            {
                /*0x10*/ int version;

                /*0x1f92948*/ GacMembershipCondition();
                /*0x1f92958*/ bool Check(System.Security.Policy.Evidence evidence);
                /*0x1f92a9c*/ System.Security.Policy.IMembershipCondition Copy();
                /*0x1f92b00*/ bool Equals(object o);
                /*0x1f92b5c*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f92b60*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f92e5c*/ int GetHashCode();
                /*0x1f92e64*/ string ToString();
                /*0x1f92ea4*/ System.Security.SecurityElement ToXml();
                /*0x1f92ea8*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
            }

            class Hash : System.Security.Policy.EvidenceBase, System.Runtime.Serialization.ISerializable, System.Security.Policy.IBuiltInEvidence
            {
                /*0x10*/ System.Reflection.Assembly assembly;
                /*0x18*/ byte[] data;
                /*0x20*/ byte[] _md5;
                /*0x28*/ byte[] _sha1;

                static /*0x1f9388c*/ System.Security.Policy.Hash CreateMD5(byte[] md5);
                static /*0x1f93940*/ System.Security.Policy.Hash CreateSHA1(byte[] sha1);
                static /*0x1f93a2c*/ System.Security.Policy.Hash CreateSHA256(byte[] sha256);
                /*0x1f930dc*/ Hash(System.Reflection.Assembly assembly);
                /*0x1f93164*/ Hash();
                /*0x1f9316c*/ Hash(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f93288*/ byte[] get_MD5();
                /*0x1f933a4*/ byte[] get_SHA1();
                /*0x1f93334*/ byte[] GenerateHash(System.Security.Cryptography.HashAlgorithm hashAlg);
                /*0x1f935e0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f9368c*/ string ToString();
                /*0x1f93450*/ byte[] GetData();
                /*0x1f9386c*/ int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
                /*0x1f9387c*/ int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(char[] buffer, int position);
                /*0x1f93884*/ int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(char[] buffer, int position, bool verbose);
                /*0x1f939f4*/ byte[] get_SHA256();
            }

            class HashMembershipCondition : System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
            {
                /*0x10*/ int version;
                /*0x18*/ System.Security.Cryptography.HashAlgorithm hash_algorithm;
                /*0x20*/ byte[] hash_value;

                /*0x1f93a64*/ HashMembershipCondition();
                /*0x1f93a74*/ HashMembershipCondition(System.Security.Cryptography.HashAlgorithm hashAlg, byte[] value);
                /*0x1f93bac*/ System.Security.Cryptography.HashAlgorithm get_HashAlgorithm();
                /*0x1f93c18*/ void set_HashAlgorithm(System.Security.Cryptography.HashAlgorithm value);
                /*0x1f93c78*/ byte[] get_HashValue();
                /*0x1f93d44*/ void set_HashValue(byte[] value);
                /*0x1f93e38*/ bool Check(System.Security.Policy.Evidence evidence);
                /*0x1f94014*/ System.Security.Policy.IMembershipCondition Copy();
                /*0x1f9407c*/ bool Equals(object o);
                /*0x1f9410c*/ System.Security.SecurityElement ToXml();
                /*0x1f94110*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
                /*0x1f9425c*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f94260*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f94350*/ int GetHashCode();
                /*0x1f943c8*/ string ToString();
                /*0x1f93fa0*/ bool Compare(byte[] expected, byte[] actual);
                /*0x1f94484*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
                /*0x1f94488*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            interface IApplicationTrustManager : System.Security.ISecurityEncodable
            {
                System.Security.Policy.ApplicationTrust DetermineApplicationTrust(System.ActivationContext activationContext, System.Security.Policy.TrustManagerContext context);
            }

            interface IBuiltInEvidence
            {
                int GetRequiredSize(bool verbose);
                int InitFromBuffer(char[] buffer, int position);
                int OutputToBuffer(char[] buffer, int position, bool verbose);
            }

            interface IConstantMembershipCondition
            {
            }

            class MembershipConditionHelper
            {
                static /*0x0*/ string XmlTag;

                static /*0x1f94494*/ MembershipConditionHelper();
                static /*0x1f92be0*/ int CheckSecurityElement(System.Security.SecurityElement se, string parameterName, int minimumVersion, int maximumVersion);
                static /*0x1f92f5c*/ System.Security.SecurityElement Element(System.Type type, int version);
                /*0x1f9448c*/ MembershipConditionHelper();
            }

            class MonoTrustManager : System.Security.Policy.IApplicationTrustManager, System.Security.ISecurityEncodable
            {
                static string tag = "IApplicationTrustManager";

                /*0x1f94798*/ MonoTrustManager();
                /*0x1f944f4*/ System.Security.Policy.ApplicationTrust DetermineApplicationTrust(System.ActivationContext activationContext, System.Security.Policy.TrustManagerContext context);
                /*0x1f94550*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f9465c*/ System.Security.SecurityElement ToXml();
            }

            class NetCodeGroup : System.Security.Policy.CodeGroup
            {
                static /*0x0*/ string AbsentOriginScheme;
                static /*0x8*/ string AnyOtherOriginScheme;
                /*0x38*/ System.Collections.Hashtable _rules;
                /*0x40*/ int _hashcode;

                static /*0x1f962c0*/ NetCodeGroup();
                /*0x1f947a0*/ NetCodeGroup(System.Security.Policy.IMembershipCondition membershipCondition);
                /*0x1f9481c*/ NetCodeGroup(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f9489c*/ string get_AttributeString();
                /*0x1f948a4*/ string get_MergeLogic();
                /*0x1f948e4*/ string get_PermissionSetName();
                /*0x1f94924*/ void AddConnectAccess(string originScheme, System.Security.Policy.CodeConnectAccess connectAccess);
                /*0x1f94c1c*/ System.Security.Policy.CodeGroup Copy();
                /*0x1f94f9c*/ bool Equals(System.Security.Policy.CodeConnectAccess[] rules1, System.Security.Policy.CodeConnectAccess[] rules2);
                /*0x1f95068*/ bool Equals(object o);
                /*0x1f95468*/ System.Collections.DictionaryEntry[] GetConnectAccessRules();
                /*0x1f95500*/ int GetHashCode();
                /*0x1f95890*/ System.Security.Policy.PolicyStatement Resolve(System.Security.Policy.Evidence evidence);
                /*0x1f95e10*/ void ResetConnectAccess();
                /*0x1f95e34*/ System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(System.Security.Policy.Evidence evidence);
                /*0x1f962b0*/ void CreateXml(System.Security.SecurityElement element, System.Security.Policy.PolicyLevel level);
                /*0x1f962b8*/ void ParseXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
            }

            class PermissionRequestEvidence : System.Security.Policy.EvidenceBase, System.Security.Policy.IBuiltInEvidence
            {
                /*0x10*/ System.Security.PermissionSet requested;
                /*0x18*/ System.Security.PermissionSet optional;
                /*0x20*/ System.Security.PermissionSet denied;

                /*0x1f96354*/ PermissionRequestEvidence(System.Security.PermissionSet request, System.Security.PermissionSet optional, System.Security.PermissionSet denied);
                /*0x1f9642c*/ System.Security.PermissionSet get_DeniedPermissions();
                /*0x1f96434*/ System.Security.PermissionSet get_OptionalPermissions();
                /*0x1f9643c*/ System.Security.PermissionSet get_RequestedPermissions();
                /*0x1f96444*/ System.Security.Policy.PermissionRequestEvidence Copy();
                /*0x1f964bc*/ string ToString();
                /*0x1f966d0*/ int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
                /*0x1f967c8*/ int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(char[] buffer, int position);
                /*0x1f967d0*/ int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(char[] buffer, int position, bool verbose);
            }

            class PolicyException : System.SystemException
            {
                /*0x1f967d8*/ PolicyException();
                /*0x1f96830*/ PolicyException(string message);
                /*0x1f96838*/ PolicyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x1f96840*/ PolicyException(string message, System.Exception exception);
            }

            class PolicyLevel
            {
                /*0x10*/ string label;
                /*0x18*/ System.Security.Policy.CodeGroup root_code_group;
                /*0x20*/ System.Collections.ArrayList full_trust_assemblies;
                /*0x28*/ System.Collections.ArrayList named_permission_sets;
                /*0x30*/ string _location;
                /*0x38*/ System.Security.PolicyLevelType _type;
                /*0x40*/ System.Collections.Hashtable fullNames;
                /*0x48*/ System.Security.SecurityElement xml;

                static /*0x1f99474*/ System.Security.Policy.PolicyLevel CreateAppDomainLevel();
                /*0x1f96848*/ PolicyLevel(string label, System.Security.PolicyLevelType type);
                /*0x1f9b730*/ PolicyLevel();
                /*0x1f968e8*/ void LoadFromFile(string filename);
                /*0x1f986f8*/ void LoadFromString(string xml);
                /*0x1f96ca0*/ System.Security.SecurityElement FromString(string xml);
                /*0x1f98714*/ System.Collections.IList get_FullTrustAssemblies();
                /*0x1f9871c*/ string get_Label();
                /*0x1f98724*/ System.Collections.IList get_NamedPermissionSets();
                /*0x1f9872c*/ System.Security.Policy.CodeGroup get_RootCodeGroup();
                /*0x1f98734*/ void set_RootCodeGroup(System.Security.Policy.CodeGroup value);
                /*0x1f98794*/ string get_StoreLocation();
                /*0x1f9879c*/ System.Security.PolicyLevelType get_Type();
                /*0x1f987a4*/ void AddFullTrustAssembly(System.Security.Policy.StrongName sn);
                /*0x1f98874*/ void AddFullTrustAssembly(System.Security.Policy.StrongNameMembershipCondition snMC);
                /*0x1f98c44*/ void AddNamedPermissionSet(System.Security.NamedPermissionSet permSet);
                /*0x1f99024*/ System.Security.NamedPermissionSet ChangeNamedPermissionSet(string name, System.Security.PermissionSet pSet);
                /*0x1f96f1c*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f99744*/ System.Security.NamedPermissionSet GetNamedPermissionSet(string name);
                /*0x1f99ac4*/ void Recover();
                /*0x1f99c64*/ void RemoveFullTrustAssembly(System.Security.Policy.StrongName sn);
                /*0x1f99d34*/ void RemoveFullTrustAssembly(System.Security.Policy.StrongNameMembershipCondition snMC);
                /*0x1f99efc*/ System.Security.NamedPermissionSet RemoveNamedPermissionSet(System.Security.NamedPermissionSet permSet);
                /*0x1f99f5c*/ System.Security.NamedPermissionSet RemoveNamedPermissionSet(string name);
                /*0x1f995f0*/ void Reset();
                /*0x1f9a394*/ System.Security.Policy.PolicyStatement Resolve(System.Security.Policy.Evidence evidence);
                /*0x1f9a414*/ System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(System.Security.Policy.Evidence evidence);
                /*0x1f9a484*/ System.Security.SecurityElement ToXml();
                /*0x1f98524*/ void Save();
                /*0x1f98080*/ void CreateDefaultLevel(System.Security.PolicyLevelType type);
                /*0x1f97c14*/ void CreateDefaultFullTrustAssemblies();
                /*0x1f97e3c*/ void CreateDefaultNamedPermissionSets();
                /*0x1f9b330*/ string ResolveClassName(string className);
                /*0x1f9b3b0*/ bool IsFullTrustAssembly(System.Reflection.Assembly a);
            }

            class PolicyStatement : System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable
            {
                /*0x10*/ System.Security.PermissionSet perms;
                /*0x18*/ System.Security.Policy.PolicyStatementAttribute attrs;

                static /*0x1f91164*/ System.Security.Policy.PolicyStatement Empty();
                /*0x1f995e0*/ PolicyStatement(System.Security.PermissionSet permSet);
                /*0x1f9b768*/ PolicyStatement(System.Security.PermissionSet permSet, System.Security.Policy.PolicyStatementAttribute attributes);
                /*0x1f91080*/ System.Security.PermissionSet get_PermissionSet();
                /*0x1f9b7c0*/ void set_PermissionSet(System.Security.PermissionSet value);
                /*0x1f9b7c8*/ System.Security.Policy.PolicyStatementAttribute get_Attributes();
                /*0x1f9b7d0*/ void set_Attributes(System.Security.Policy.PolicyStatementAttribute value);
                /*0x1f9b868*/ string get_AttributeString();
                /*0x1f910f8*/ System.Security.Policy.PolicyStatement Copy();
                /*0x1f9b8f8*/ void FromXml(System.Security.SecurityElement et);
                /*0x1f9b8fc*/ void FromXml(System.Security.SecurityElement et, System.Security.Policy.PolicyLevel level);
                /*0x1f9bb3c*/ System.Security.SecurityElement ToXml();
                /*0x1f9bb40*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
                /*0x1f9bc90*/ bool Equals(object obj);
                /*0x1f9bd2c*/ int GetHashCode();
            }

            class Site : System.Security.Policy.EvidenceBase, System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
            {
                /*0x10*/ string origin_site;

                static /*0x1f9c030*/ System.Security.Policy.Site CreateFromUrl(string url);
                static /*0x1f9be38*/ bool IsValid(string name);
                static /*0x1f9c1b0*/ string UrlToSite(string url);
                /*0x1f9bd5c*/ Site(string name);
                /*0x1f9c260*/ object Copy();
                /*0x1f9c2c4*/ System.Security.IPermission CreateIdentityPermission(System.Security.Policy.Evidence evidence);
                /*0x1f9c32c*/ bool Equals(object o);
                /*0x1f9c3ec*/ int GetHashCode();
                /*0x1f9c40c*/ string ToString();
                /*0x1f9c518*/ string get_Name();
                /*0x1f9c520*/ int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
                /*0x1f9c54c*/ int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(char[] buffer, int position);
                /*0x1f9c554*/ int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(char[] buffer, int position, bool verbose);
            }

            class SiteMembershipCondition : System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable, System.Security.Policy.IConstantMembershipCondition
            {
                /*0x10*/ int version;
                /*0x18*/ string _site;

                /*0x1f9c55c*/ SiteMembershipCondition();
                /*0x1f9c56c*/ SiteMembershipCondition(string site);
                /*0x1f9c654*/ string get_Site();
                /*0x1f9c5a0*/ void set_Site(string value);
                /*0x1f9c65c*/ bool Check(System.Security.Policy.Evidence evidence);
                /*0x1f9c960*/ System.Security.Policy.IMembershipCondition Copy();
                /*0x1f9c9d8*/ bool Equals(object o);
                /*0x1f9caac*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f9cab0*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f9cb64*/ int GetHashCode();
                /*0x1f9cb84*/ string ToString();
                /*0x1f9cbd0*/ System.Security.SecurityElement ToXml();
                /*0x1f9cbd4*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
            }

            class StrongName : System.Security.Policy.EvidenceBase, System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
            {
                /*0x10*/ System.Security.Permissions.StrongNamePublicKeyBlob publickey;
                /*0x18*/ string name;
                /*0x20*/ System.Version version;

                /*0x1f9ccc0*/ StrongName(System.Security.Permissions.StrongNamePublicKeyBlob blob, string name, System.Version version);
                /*0x1f9ce1c*/ string get_Name();
                /*0x1f9ce24*/ System.Security.Permissions.StrongNamePublicKeyBlob get_PublicKey();
                /*0x1f9ce2c*/ System.Version get_Version();
                /*0x1f9ce34*/ object Copy();
                /*0x1f9ceac*/ System.Security.IPermission CreateIdentityPermission(System.Security.Policy.Evidence evidence);
                /*0x1f9cf28*/ bool Equals(object o);
                /*0x1f9cfdc*/ int GetHashCode();
                /*0x1f9cffc*/ string ToString();
                /*0x1f9d1b0*/ int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
                /*0x1f9d1dc*/ int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(char[] buffer, int position);
                /*0x1f9d1e4*/ int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(char[] buffer, int position, bool verbose);
            }

            class StrongNameMembershipCondition : System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable, System.Security.Policy.IConstantMembershipCondition
            {
                /*0x10*/ int version;
                /*0x18*/ System.Security.Permissions.StrongNamePublicKeyBlob blob;
                /*0x20*/ string name;
                /*0x28*/ System.Version assemblyVersion;

                /*0x1f8ef1c*/ StrongNameMembershipCondition(System.Security.Permissions.StrongNamePublicKeyBlob blob, string name, System.Version version);
                /*0x1f99710*/ StrongNameMembershipCondition(System.Security.SecurityElement e);
                /*0x1f9d1f0*/ StrongNameMembershipCondition();
                /*0x1f9d200*/ string get_Name();
                /*0x1f9d208*/ void set_Name(string value);
                /*0x1f9d210*/ System.Version get_Version();
                /*0x1f9d218*/ void set_Version(System.Version value);
                /*0x1f9d220*/ System.Security.Permissions.StrongNamePublicKeyBlob get_PublicKey();
                /*0x1f9d228*/ void set_PublicKey(System.Security.Permissions.StrongNamePublicKeyBlob value);
                /*0x1f9d288*/ bool Check(System.Security.Policy.Evidence evidence);
                /*0x1f9d43c*/ System.Security.Policy.IMembershipCondition Copy();
                /*0x1f9d4b4*/ bool Equals(object o);
                /*0x1f9d594*/ int GetHashCode();
                /*0x1f9d1ec*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f9d5b4*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f9d700*/ string ToString();
                /*0x1f9d7f8*/ System.Security.SecurityElement ToXml();
                /*0x1f9b148*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
            }

            class TrustManagerContext
            {
                /*0x10*/ bool _ignorePersistedDecision;
                /*0x11*/ bool _noPrompt;
                /*0x12*/ bool _keepAlive;
                /*0x13*/ bool _persist;
                /*0x18*/ System.ApplicationIdentity _previousId;
                /*0x20*/ System.Security.Policy.TrustManagerUIContext _ui;

                /*0x1f9d7fc*/ TrustManagerContext();
                /*0x1f9d820*/ TrustManagerContext(System.Security.Policy.TrustManagerUIContext uiContext);
                /*0x1f9d84c*/ bool get_IgnorePersistedDecision();
                /*0x1f9d854*/ void set_IgnorePersistedDecision(bool value);
                /*0x1f9d860*/ bool get_KeepAlive();
                /*0x1f9d868*/ void set_KeepAlive(bool value);
                /*0x1f9d874*/ bool get_NoPrompt();
                /*0x1f9d87c*/ void set_NoPrompt(bool value);
                /*0x1f9d888*/ bool get_Persist();
                /*0x1f9d890*/ void set_Persist(bool value);
                /*0x1f9d89c*/ System.ApplicationIdentity get_PreviousApplicationIdentity();
                /*0x1f9d8a4*/ void set_PreviousApplicationIdentity(System.ApplicationIdentity value);
                /*0x1f9d8ac*/ System.Security.Policy.TrustManagerUIContext get_UIContext();
                /*0x1f9d8b4*/ void set_UIContext(System.Security.Policy.TrustManagerUIContext value);
            }

            enum TrustManagerUIContext
            {
                Install = 0,
                Upgrade = 1,
                Run = 2,
            }

            class UnionCodeGroup : System.Security.Policy.CodeGroup
            {
                /*0x1f995e8*/ UnionCodeGroup(System.Security.Policy.IMembershipCondition membershipCondition, System.Security.Policy.PolicyStatement policy);
                /*0x1f9d8bc*/ UnionCodeGroup(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f9d8c4*/ System.Security.Policy.CodeGroup Copy();
                /*0x1f9d8cc*/ System.Security.Policy.CodeGroup Copy(bool childs);
                /*0x1f9dc58*/ System.Security.Policy.PolicyStatement Resolve(System.Security.Policy.Evidence evidence);
                /*0x1f9e1b8*/ System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(System.Security.Policy.Evidence evidence);
                /*0x1f9e6b0*/ string get_MergeLogic();
            }

            class Url : System.Security.Policy.EvidenceBase, System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
            {
                /*0x10*/ string origin_url;

                /*0x1f9e6f0*/ Url(string name);
                /*0x1f9e6f8*/ Url(string name, bool validated);
                /*0x1f9e954*/ object Copy();
                /*0x1f9e9bc*/ System.Security.IPermission CreateIdentityPermission(System.Security.Policy.Evidence evidence);
                /*0x1f9ea24*/ bool Equals(object o);
                /*0x1f9eb9c*/ int GetHashCode();
                /*0x1f9ec4c*/ string ToString();
                /*0x1f9ed58*/ string get_Value();
                /*0x1f9ed60*/ int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
                /*0x1f9ed8c*/ int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(char[] buffer, int position);
                /*0x1f9ed94*/ int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(char[] buffer, int position, bool verbose);
                /*0x1f9e73c*/ string Prepare(string url);
            }

            class UrlMembershipCondition : System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable, System.Security.Policy.IConstantMembershipCondition
            {
                /*0x10*/ int version;
                /*0x18*/ System.Security.Policy.Url url;
                /*0x20*/ string userUrl;

                /*0x1f9ed9c*/ UrlMembershipCondition(string url);
                /*0x1f9efb8*/ UrlMembershipCondition(System.Security.Policy.Url url, string userUrl);
                /*0x1f9f05c*/ string get_Url();
                /*0x1f9f088*/ void set_Url(string value);
                /*0x1f9f0f8*/ bool Check(System.Security.Policy.Evidence evidence);
                /*0x1f9f378*/ System.Security.Policy.IMembershipCondition Copy();
                /*0x1f9f3e0*/ bool Equals(object o);
                /*0x1f9f514*/ void FromXml(System.Security.SecurityElement e);
                /*0x1f9f518*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1f9f618*/ int GetHashCode();
                /*0x1f9f638*/ string ToString();
                /*0x1f9f69c*/ System.Security.SecurityElement ToXml();
                /*0x1f9f6a0*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
                /*0x1f9ee74*/ void CheckUrl(string url);
            }

            class Zone : System.Security.Policy.EvidenceBase, System.Security.Policy.IIdentityPermissionFactory, System.Security.Policy.IBuiltInEvidence
            {
                /*0x10*/ System.Security.SecurityZone zone;

                static /*0x1f9f9f4*/ System.Security.Policy.Zone CreateFromUrl(string url);
                /*0x1f9f78c*/ Zone(System.Security.SecurityZone zone);
                /*0x1f9f920*/ System.Security.SecurityZone get_SecurityZone();
                /*0x1f9f928*/ object Copy();
                /*0x1f9f98c*/ System.Security.IPermission CreateIdentityPermission(System.Security.Policy.Evidence evidence);
                /*0x1f9fc38*/ bool Equals(object o);
                /*0x1f9fcb4*/ int GetHashCode();
                /*0x1f9fcbc*/ string ToString();
                /*0x1f9fe14*/ int System.Security.Policy.IBuiltInEvidence.GetRequiredSize(bool verbose);
                /*0x1f9fe1c*/ int System.Security.Policy.IBuiltInEvidence.InitFromBuffer(char[] buffer, int position);
                /*0x1f9fe50*/ int System.Security.Policy.IBuiltInEvidence.OutputToBuffer(char[] buffer, int position, bool verbose);
            }

            class ZoneMembershipCondition : System.Security.Policy.IMembershipCondition, System.Security.ISecurityEncodable, System.Security.ISecurityPolicyEncodable, System.Security.Policy.IConstantMembershipCondition
            {
                /*0x10*/ int version;
                /*0x14*/ System.Security.SecurityZone zone;

                /*0x1f9feb4*/ ZoneMembershipCondition();
                /*0x1f9b2fc*/ ZoneMembershipCondition(System.Security.SecurityZone zone);
                /*0x1fa0024*/ System.Security.SecurityZone get_SecurityZone();
                /*0x1f9fec4*/ void set_SecurityZone(System.Security.SecurityZone value);
                /*0x1fa002c*/ bool Check(System.Security.Policy.Evidence evidence);
                /*0x1fa018c*/ System.Security.Policy.IMembershipCondition Copy();
                /*0x1fa0204*/ bool Equals(object o);
                /*0x1fa0280*/ void FromXml(System.Security.SecurityElement e);
                /*0x1fa0284*/ void FromXml(System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);
                /*0x1fa0400*/ int GetHashCode();
                /*0x1fa040c*/ string ToString();
                /*0x1fa04a4*/ System.Security.SecurityElement ToXml();
                /*0x1fa04a8*/ System.Security.SecurityElement ToXml(System.Security.Policy.PolicyLevel level);
            }
        }

        namespace Permissions
        {
            enum FileDialogPermissionAccess
            {
                None = 0,
                Open = 1,
                OpenSave = 3,
                Save = 2,
            }

            enum HostProtectionResource
            {
                All = 511,
                ExternalProcessMgmt = 4,
                ExternalThreading = 16,
                MayLeakOnAbort = 256,
                None = 0,
                SecurityInfrastructure = 64,
                SelfAffectingProcessMgmt = 8,
                SelfAffectingThreading = 32,
                SharedState = 2,
                Synchronization = 1,
                UI = 128,
            }

            interface IUnrestrictedPermission
            {
                bool IsUnrestricted();
            }

            enum IsolatedStorageContainment
            {
                None = 0,
                DomainIsolationByUser = 16,
                ApplicationIsolationByUser = 21,
                AssemblyIsolationByUser = 32,
                DomainIsolationByMachine = 48,
                AssemblyIsolationByMachine = 64,
                ApplicationIsolationByMachine = 69,
                DomainIsolationByRoamingUser = 80,
                AssemblyIsolationByRoamingUser = 96,
                ApplicationIsolationByRoamingUser = 101,
                AdministerIsolatedStorageByUser = 112,
                UnrestrictedIsolatedStorage = 240,
            }

            enum PermissionState
            {
                None = 0,
                Unrestricted = 1,
            }

            enum ReflectionPermissionFlag
            {
                AllFlags = 7,
                MemberAccess = 2,
                NoFlags = 0,
                ReflectionEmit = 4,
                RestrictedMemberAccess = 8,
                TypeInformation = 1,
            }

            enum RegistryPermissionAccess
            {
                AllAccess = 7,
                Create = 4,
                NoAccess = 0,
                Read = 1,
                Write = 2,
            }

            enum UIPermissionClipboard
            {
                AllClipboard = 2,
                NoClipboard = 0,
                OwnClipboard = 1,
            }

            enum UIPermissionWindow
            {
                AllWindows = 3,
                NoWindows = 0,
                SafeSubWindows = 1,
                SafeTopLevelWindows = 2,
            }

            class CodeAccessSecurityAttribute : System.Security.Permissions.SecurityAttribute
            {
                /*0x1fa05d4*/ CodeAccessSecurityAttribute(System.Security.Permissions.SecurityAction action);
            }

            class EnvironmentPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.Permissions.PermissionState _state;
                /*0x18*/ System.Collections.ArrayList readList;
                /*0x20*/ System.Collections.ArrayList writeList;

                /*0x1f8f414*/ EnvironmentPermission(System.Security.Permissions.PermissionState state);
                /*0x1f8f02c*/ EnvironmentPermission(System.Security.Permissions.EnvironmentPermissionAccess flag, string pathList);
                /*0x1fa0844*/ void AddPathList(System.Security.Permissions.EnvironmentPermissionAccess flag, string pathList);
                /*0x1fa0b80*/ System.Security.IPermission Copy();
                /*0x1fa0c74*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fa0c24*/ string GetPathList(System.Security.Permissions.EnvironmentPermissionAccess flag);
                /*0x1fa1134*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fa1404*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fa13f4*/ bool IsUnrestricted();
                /*0x1fa05dc*/ void SetPathList(System.Security.Permissions.EnvironmentPermissionAccess flag, string pathList);
                /*0x1fa19d4*/ System.Security.SecurityElement ToXml();
                /*0x1fa1ad8*/ System.Security.IPermission Union(System.Security.IPermission other);
                /*0x1fa1c80*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fa1c20*/ bool IsEmpty();
                /*0x1fa1340*/ System.Security.Permissions.EnvironmentPermission Cast(System.Security.IPermission target);
                /*0x1fa0ad0*/ void ThrowInvalidFlag(System.Security.Permissions.EnvironmentPermissionAccess flag, bool context);
                /*0x1fa0d8c*/ string GetPathList(System.Collections.ArrayList list);
            }

            enum EnvironmentPermissionAccess
            {
                NoAccess = 0,
                Read = 1,
                Write = 2,
                AllAccess = 3,
            }

            class EnvironmentPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ string read;
                /*0x20*/ string write;

                /*0x1fa1c88*/ EnvironmentPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fa1c90*/ string get_All();
                /*0x1fa1ce0*/ void set_All(string value);
                /*0x1fa1ce8*/ string get_Read();
                /*0x1fa1cf0*/ void set_Read(string value);
                /*0x1fa1cf8*/ string get_Write();
                /*0x1fa1d00*/ void set_Write(string value);
                /*0x1fa1d08*/ System.Security.IPermission CreatePermission();
            }

            class FileDialogPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.Permissions.FileDialogPermissionAccess _access;

                /*0x1f8f0d0*/ FileDialogPermission(System.Security.Permissions.PermissionState state);
                /*0x1f8f3e8*/ FileDialogPermission(System.Security.Permissions.FileDialogPermissionAccess access);
                /*0x1fa1e98*/ System.Security.Permissions.FileDialogPermissionAccess get_Access();
                /*0x1fa1d10*/ void set_Access(System.Security.Permissions.FileDialogPermissionAccess value);
                /*0x1fa1ea0*/ System.Security.IPermission Copy();
                /*0x1fa1f10*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fa208c*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fa21d4*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fa21fc*/ bool IsUnrestricted();
                /*0x1fa220c*/ System.Security.SecurityElement ToXml();
                /*0x1fa2300*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fa23f0*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fa2120*/ System.Security.Permissions.FileDialogPermission Cast(System.Security.IPermission target);
            }

            class FileDialogPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x15*/ bool canOpen;
                /*0x16*/ bool canSave;

                /*0x1fa23f8*/ FileDialogPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fa2400*/ bool get_Open();
                /*0x1fa2408*/ void set_Open(bool value);
                /*0x1fa2414*/ bool get_Save();
                /*0x1fa241c*/ void set_Save(bool value);
                /*0x1fa2428*/ System.Security.IPermission CreatePermission();
            }

            class FileIOPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IBuiltInPermission, System.Security.Permissions.IUnrestrictedPermission
            {
                static int version = 1;
                static /*0x0*/ char[] BadPathNameCharacters;
                static /*0x8*/ char[] BadFileNameCharacters;
                /*0x10*/ bool m_Unrestricted;
                /*0x14*/ System.Security.Permissions.FileIOPermissionAccess m_AllFilesAccess;
                /*0x18*/ System.Security.Permissions.FileIOPermissionAccess m_AllLocalFilesAccess;
                /*0x20*/ System.Collections.ArrayList readList;
                /*0x28*/ System.Collections.ArrayList writeList;
                /*0x30*/ System.Collections.ArrayList appendList;
                /*0x38*/ System.Collections.ArrayList pathList;

                static /*0x1fa24ec*/ FileIOPermission();
                static /*0x1fa34a4*/ System.Security.Permissions.FileIOPermission Cast(System.Security.IPermission target);
                static /*0x1fa2968*/ void ThrowInvalidFlag(System.Security.Permissions.FileIOPermissionAccess access, bool context);
                static /*0x1fa2a18*/ void ThrowIfInvalidPath(string path);
                static /*0x1fa2ccc*/ void ThrowIfInvalidPath(string[] paths);
                static /*0x1fa3ee0*/ bool KeyIsSubsetOf(System.Collections.IList local, System.Collections.IList target);
                static /*0x1fa4b30*/ void UnionKeys(System.Collections.IList list, string[] paths);
                static /*0x1fa3558*/ void IntersectKeys(System.Collections.IList local, System.Collections.IList target, System.Collections.IList result);
                /*0x1f8f4bc*/ FileIOPermission(System.Security.Permissions.PermissionState state);
                /*0x1fa2628*/ FileIOPermission(System.Security.Permissions.FileIOPermissionAccess access, string path);
                /*0x1fa2740*/ FileIOPermission(System.Security.Permissions.FileIOPermissionAccess access, string[] pathList);
                /*0x1fa2898*/ FileIOPermission(System.Security.Permissions.FileIOPermissionAccess access, System.Security.AccessControl.AccessControlActions control, string path);
                /*0x1fa28e0*/ FileIOPermission(System.Security.Permissions.FileIOPermissionAccess access, System.Security.AccessControl.AccessControlActions control, string[] pathList);
                /*0x1fa2928*/ FileIOPermission(System.Security.Permissions.FileIOPermissionAccess access, string[] pathList, bool checkForDuplicates, bool needFullPath);
                /*0x1fa2574*/ void CreateLists();
                /*0x1fa2930*/ System.Security.Permissions.FileIOPermissionAccess get_AllFiles();
                /*0x1fa2938*/ void set_AllFiles(System.Security.Permissions.FileIOPermissionAccess value);
                /*0x1fa294c*/ System.Security.Permissions.FileIOPermissionAccess get_AllLocalFiles();
                /*0x1fa2954*/ void set_AllLocalFiles(System.Security.Permissions.FileIOPermissionAccess value);
                /*0x1fa26b4*/ void AddPathList(System.Security.Permissions.FileIOPermissionAccess access, string path);
                /*0x1fa27cc*/ void AddPathList(System.Security.Permissions.FileIOPermissionAccess access, string[] pathList);
                /*0x1fa2bcc*/ void AddPathInternal(System.Security.Permissions.FileIOPermissionAccess access, string path);
                /*0x1fa2d6c*/ System.Security.IPermission Copy();
                /*0x1fa2fd4*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fa318c*/ string[] GetPathList(System.Security.Permissions.FileIOPermissionAccess access);
                /*0x1fa3350*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fa3d64*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fa4538*/ bool IsUnrestricted();
                /*0x1fa4540*/ void SetPathList(System.Security.Permissions.FileIOPermissionAccess access, string path);
                /*0x1fa4670*/ void SetPathList(System.Security.Permissions.FileIOPermissionAccess access, string[] pathList);
                /*0x1fa4748*/ System.Security.SecurityElement ToXml();
                /*0x1fa4934*/ System.Security.IPermission Union(System.Security.IPermission other);
                /*0x1fa4e60*/ bool Equals(object obj);
                /*0x1fa4e68*/ int GetHashCode();
                /*0x1fa4e70*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fa3ccc*/ bool IsEmpty();
                /*0x1fa45d8*/ void Clear(System.Security.Permissions.FileIOPermissionAccess access);
            }

            enum FileIOPermissionAccess
            {
                NoAccess = 0,
                Read = 1,
                Write = 2,
                Append = 4,
                PathDiscovery = 8,
                AllAccess = 15,
            }

            class FileIOPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ string append;
                /*0x20*/ string path;
                /*0x28*/ string read;
                /*0x30*/ string write;
                /*0x38*/ System.Security.Permissions.FileIOPermissionAccess allFiles;
                /*0x3c*/ System.Security.Permissions.FileIOPermissionAccess allLocalFiles;
                /*0x40*/ string changeAccessControl;
                /*0x48*/ string viewAccessControl;

                /*0x1fa4e78*/ FileIOPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fa4e80*/ string get_All();
                /*0x1fa4ed0*/ void set_All(string value);
                /*0x1fa4edc*/ string get_Append();
                /*0x1fa4ee4*/ void set_Append(string value);
                /*0x1fa4eec*/ string get_PathDiscovery();
                /*0x1fa4ef4*/ void set_PathDiscovery(string value);
                /*0x1fa4efc*/ string get_Read();
                /*0x1fa4f04*/ void set_Read(string value);
                /*0x1fa4f0c*/ string get_Write();
                /*0x1fa4f14*/ void set_Write(string value);
                /*0x1fa4f1c*/ System.Security.Permissions.FileIOPermissionAccess get_AllFiles();
                /*0x1fa4f24*/ void set_AllFiles(System.Security.Permissions.FileIOPermissionAccess value);
                /*0x1fa4f2c*/ System.Security.Permissions.FileIOPermissionAccess get_AllLocalFiles();
                /*0x1fa4f34*/ void set_AllLocalFiles(System.Security.Permissions.FileIOPermissionAccess value);
                /*0x1fa4f3c*/ string get_ChangeAccessControl();
                /*0x1fa4f44*/ void set_ChangeAccessControl(string value);
                /*0x1fa4f4c*/ string get_ViewAccessControl();
                /*0x1fa4f54*/ void set_ViewAccessControl(string value);
                /*0x1fa4f5c*/ string get_ViewAndModify();
                /*0x1fa4f9c*/ void set_ViewAndModify(string value);
                /*0x1fa4fa8*/ System.Security.IPermission CreatePermission();
            }

            class GacIdentityPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;

                /*0x1f927c0*/ GacIdentityPermission();
                /*0x1fa4fb0*/ GacIdentityPermission(System.Security.Permissions.PermissionState state);
                /*0x1fa4fd4*/ System.Security.IPermission Copy();
                /*0x1fa5030*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fa5114*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fa512c*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fa5150*/ void FromXml(System.Security.SecurityElement securityElement);
                /*0x1fa51a4*/ System.Security.SecurityElement ToXml();
                /*0x1fa51b0*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fa5060*/ System.Security.Permissions.GacIdentityPermission Cast(System.Security.IPermission target);
            }

            class GacIdentityPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x1fa51b8*/ GacIdentityPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fa51c0*/ System.Security.IPermission CreatePermission();
            }

            class HostProtectionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ System.Security.Permissions.HostProtectionResource _resources;

                /*0x1fa521c*/ HostProtectionAttribute();
                /*0x1fa5228*/ HostProtectionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fa52e8*/ bool get_ExternalProcessMgmt();
                /*0x1fa52f4*/ void set_ExternalProcessMgmt(bool value);
                /*0x1fa5310*/ bool get_ExternalThreading();
                /*0x1fa531c*/ void set_ExternalThreading(bool value);
                /*0x1fa5338*/ bool get_MayLeakOnAbort();
                /*0x1fa5344*/ void set_MayLeakOnAbort(bool value);
                /*0x1fa5360*/ bool get_SecurityInfrastructure();
                /*0x1fa536c*/ void set_SecurityInfrastructure(bool value);
                /*0x1fa5388*/ bool get_SelfAffectingProcessMgmt();
                /*0x1fa5394*/ void set_SelfAffectingProcessMgmt(bool value);
                /*0x1fa53b0*/ bool get_SelfAffectingThreading();
                /*0x1fa53bc*/ void set_SelfAffectingThreading(bool value);
                /*0x1fa53d8*/ bool get_SharedState();
                /*0x1fa53e4*/ void set_SharedState(bool value);
                /*0x1fa5400*/ bool get_Synchronization();
                /*0x1fa540c*/ void set_Synchronization(bool value);
                /*0x1fa5428*/ bool get_UI();
                /*0x1fa5434*/ void set_UI(bool value);
                /*0x1fa5450*/ System.Security.Permissions.HostProtectionResource get_Resources();
                /*0x1fa5458*/ void set_Resources(System.Security.Permissions.HostProtectionResource value);
                /*0x1fa5460*/ System.Security.IPermission CreatePermission();
            }

            class HostProtectionPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.Permissions.HostProtectionResource _resources;

                /*0x1fa5468*/ HostProtectionPermission(System.Security.Permissions.PermissionState state);
                /*0x1fa54ac*/ HostProtectionPermission(System.Security.Permissions.HostProtectionResource resources);
                /*0x1fa5654*/ System.Security.Permissions.HostProtectionResource get_Resources();
                /*0x1fa54cc*/ void set_Resources(System.Security.Permissions.HostProtectionResource value);
                /*0x1fa565c*/ System.Security.IPermission Copy();
                /*0x1fa56c4*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fa588c*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fa5978*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fa59cc*/ void FromXml(System.Security.SecurityElement e);
                /*0x1fa5b2c*/ System.Security.SecurityElement ToXml();
                /*0x1fa587c*/ bool IsUnrestricted();
                /*0x1fa5bdc*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fa57c8*/ System.Security.Permissions.HostProtectionPermission Cast(System.Security.IPermission target);
            }

            interface IBuiltInPermission
            {
                int GetTokenIndex();
            }

            enum BuiltInToken
            {
                Environment = 0,
                FileDialog = 1,
                FileIO = 2,
                IsolatedStorageFile = 3,
                Reflection = 4,
                Registry = 5,
                Security = 6,
                UI = 7,
                Principal = 8,
                HostProtection = 9,
                PublisherIdentity = 10,
                SiteIdentity = 11,
                StrongNameIdentity = 12,
                UrlIdentity = 13,
                ZoneIdentity = 14,
                GacIdentity = 15,
                KeyContainer = 16,
            }

            class IsolatedStorageFilePermission : System.Security.Permissions.IsolatedStoragePermission, System.Security.Permissions.IBuiltInPermission
            {
                /*0x1f8f114*/ IsolatedStorageFilePermission(System.Security.Permissions.PermissionState state);
                /*0x1fa5c34*/ System.Security.IPermission Copy();
                /*0x1fa5cb4*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fa5e88*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fa5f30*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fa602c*/ System.Security.SecurityElement ToXml();
                /*0x1fa6160*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fa5db4*/ System.Security.Permissions.IsolatedStorageFilePermission Cast(System.Security.IPermission target);
            }

            class IsolatedStorageFilePermissionAttribute : System.Security.Permissions.IsolatedStoragePermissionAttribute
            {
                /*0x1fa6168*/ IsolatedStorageFilePermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fa6178*/ System.Security.IPermission CreatePermission();
            }

            class IsolatedStoragePermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission
            {
                static int version = 1;
                /*0x10*/ long m_userQuota;
                /*0x18*/ long m_machineQuota;
                /*0x20*/ long m_expirationDays;
                /*0x28*/ bool m_permanentData;
                /*0x2c*/ System.Security.Permissions.IsolatedStorageContainment m_allowed;

                /*0x1fa5be4*/ IsolatedStoragePermission(System.Security.Permissions.PermissionState state);
                /*0x1fa6208*/ long get_UserQuota();
                /*0x1fa6210*/ void set_UserQuota(long value);
                /*0x1fa6218*/ System.Security.Permissions.IsolatedStorageContainment get_UsageAllowed();
                /*0x1f8f118*/ void set_UsageAllowed(System.Security.Permissions.IsolatedStorageContainment value);
                /*0x1fa5f20*/ bool IsUnrestricted();
                /*0x1fa6030*/ System.Security.SecurityElement ToXml();
                /*0x1fa6220*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fa5e68*/ bool IsEmpty();
            }

            class IsolatedStoragePermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ System.Security.Permissions.IsolatedStorageContainment usage_allowed;
                /*0x20*/ long user_quota;

                /*0x1fa6170*/ IsolatedStoragePermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fa6434*/ System.Security.Permissions.IsolatedStorageContainment get_UsageAllowed();
                /*0x1fa643c*/ void set_UsageAllowed(System.Security.Permissions.IsolatedStorageContainment value);
                /*0x1fa6444*/ long get_UserQuota();
                /*0x1fa644c*/ void set_UserQuota(long value);
            }

            class KeyContainerPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.Permissions.KeyContainerPermissionAccessEntryCollection _accessEntries;
                /*0x18*/ System.Security.Permissions.KeyContainerPermissionFlags _flags;

                /*0x1f8f50c*/ KeyContainerPermission(System.Security.Permissions.PermissionState state);
                /*0x1fa6454*/ KeyContainerPermission(System.Security.Permissions.KeyContainerPermissionFlags flags);
                /*0x1fa653c*/ KeyContainerPermission(System.Security.Permissions.KeyContainerPermissionFlags flags, System.Security.Permissions.KeyContainerPermissionAccessEntry[] accessList);
                /*0x1fa66ac*/ System.Security.Permissions.KeyContainerPermissionAccessEntryCollection get_AccessEntries();
                /*0x1fa66b4*/ System.Security.Permissions.KeyContainerPermissionFlags get_Flags();
                /*0x1fa66bc*/ System.Security.IPermission Copy();
                /*0x1fa6834*/ void FromXml(System.Security.SecurityElement securityElement);
                /*0x1fa69a4*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fa69ac*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fa69b4*/ bool IsUnrestricted();
                /*0x1fa69c8*/ System.Security.SecurityElement ToXml();
                /*0x1fa6a60*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fa7000*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fa6480*/ void SetFlags(System.Security.Permissions.KeyContainerPermissionFlags flags);
                /*0x1fa6c98*/ System.Security.Permissions.KeyContainerPermission Cast(System.Security.IPermission target);
            }

            class KeyContainerPermissionAccessEntry
            {
                /*0x10*/ System.Security.Permissions.KeyContainerPermissionFlags _flags;
                /*0x18*/ string _containerName;
                /*0x20*/ int _spec;
                /*0x28*/ string _store;
                /*0x30*/ string _providerName;
                /*0x38*/ int _type;

                /*0x1fa7008*/ KeyContainerPermissionAccessEntry(System.Security.Cryptography.CspParameters parameters, System.Security.Permissions.KeyContainerPermissionFlags flags);
                /*0x1fa7164*/ KeyContainerPermissionAccessEntry(string keyContainerName, System.Security.Permissions.KeyContainerPermissionFlags flags);
                /*0x1fa7198*/ KeyContainerPermissionAccessEntry(string keyStore, string providerName, int providerType, string keyContainerName, int keySpec, System.Security.Permissions.KeyContainerPermissionFlags flags);
                /*0x1fa71f8*/ System.Security.Permissions.KeyContainerPermissionFlags get_Flags();
                /*0x1fa70a8*/ void set_Flags(System.Security.Permissions.KeyContainerPermissionFlags value);
                /*0x1fa7200*/ string get_KeyContainerName();
                /*0x1fa7208*/ void set_KeyContainerName(string value);
                /*0x1fa7210*/ int get_KeySpec();
                /*0x1fa7218*/ void set_KeySpec(int value);
                /*0x1fa7220*/ string get_KeyStore();
                /*0x1fa7228*/ void set_KeyStore(string value);
                /*0x1fa7230*/ string get_ProviderName();
                /*0x1fa7238*/ void set_ProviderName(string value);
                /*0x1fa7240*/ int get_ProviderType();
                /*0x1fa7248*/ void set_ProviderType(int value);
                /*0x1fa7250*/ bool Equals(object o);
                /*0x1fa7318*/ int GetHashCode();
            }

            class KeyContainerPermissionAccessEntryCollection : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.ArrayList _list;

                /*0x1fa661c*/ KeyContainerPermissionAccessEntryCollection();
                /*0x1fa7390*/ KeyContainerPermissionAccessEntryCollection(System.Security.Permissions.KeyContainerPermissionAccessEntry[] entries);
                /*0x1fa67ec*/ int get_Count();
                /*0x1fa7414*/ bool get_IsSynchronized();
                /*0x1fa741c*/ System.Security.Permissions.KeyContainerPermissionAccessEntry get_Item(int index);
                /*0x1fa7498*/ object get_SyncRoot();
                /*0x1fa6688*/ int Add(System.Security.Permissions.KeyContainerPermissionAccessEntry accessEntry);
                /*0x1fa749c*/ void Clear();
                /*0x1fa6810*/ void CopyTo(System.Security.Permissions.KeyContainerPermissionAccessEntry[] array, int index);
                /*0x1fa74c0*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x1fa6d4c*/ System.Security.Permissions.KeyContainerPermissionAccessEntryEnumerator GetEnumerator();
                /*0x1fa7528*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x1fa6f24*/ int IndexOf(System.Security.Permissions.KeyContainerPermissionAccessEntry accessEntry);
                /*0x1fa758c*/ void Remove(System.Security.Permissions.KeyContainerPermissionAccessEntry accessEntry);
            }

            class KeyContainerPermissionAccessEntryEnumerator : System.Collections.IEnumerator
            {
                /*0x10*/ System.Collections.IEnumerator e;

                /*0x1fa74e4*/ KeyContainerPermissionAccessEntryEnumerator(System.Collections.ArrayList list);
                /*0x1fa77c4*/ KeyContainerPermissionAccessEntryEnumerator();
                /*0x1fa6db0*/ System.Security.Permissions.KeyContainerPermissionAccessEntry get_Current();
                /*0x1fa767c*/ object System.Collections.IEnumerator.get_Current();
                /*0x1fa6e84*/ bool MoveNext();
                /*0x1fa7720*/ void Reset();
            }

            class KeyContainerPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ System.Security.Permissions.KeyContainerPermissionFlags _flags;
                /*0x20*/ string _containerName;
                /*0x28*/ int _spec;
                /*0x30*/ string _store;
                /*0x38*/ string _providerName;
                /*0x40*/ int _type;

                /*0x1fa77fc*/ KeyContainerPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fa7820*/ System.Security.Permissions.KeyContainerPermissionFlags get_Flags();
                /*0x1fa7828*/ void set_Flags(System.Security.Permissions.KeyContainerPermissionFlags value);
                /*0x1fa7830*/ string get_KeyContainerName();
                /*0x1fa7838*/ void set_KeyContainerName(string value);
                /*0x1fa7840*/ int get_KeySpec();
                /*0x1fa7848*/ void set_KeySpec(int value);
                /*0x1fa7850*/ string get_KeyStore();
                /*0x1fa7858*/ void set_KeyStore(string value);
                /*0x1fa7860*/ string get_ProviderName();
                /*0x1fa7868*/ void set_ProviderName(string value);
                /*0x1fa7870*/ int get_ProviderType();
                /*0x1fa7878*/ void set_ProviderType(int value);
                /*0x1fa7880*/ System.Security.IPermission CreatePermission();
                /*0x1fa7a38*/ bool EmptyEntry();
            }

            enum KeyContainerPermissionFlags
            {
                NoFlags = 0,
                Create = 1,
                Open = 2,
                Delete = 4,
                Import = 16,
                Export = 32,
                Sign = 256,
                Decrypt = 512,
                ViewAcl = 4096,
                ChangeAcl = 8192,
                AllFlags = 13111,
            }

            class PermissionSetAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ string file;
                /*0x20*/ string name;
                /*0x28*/ bool isUnicodeEncoded;
                /*0x30*/ string xml;
                /*0x38*/ string hex;

                /*0x1fa7a70*/ PermissionSetAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fa7a78*/ string get_File();
                /*0x1fa7a80*/ void set_File(string value);
                /*0x1fa7a88*/ string get_Hex();
                /*0x1fa7a90*/ void set_Hex(string value);
                /*0x1fa7a98*/ string get_Name();
                /*0x1fa7aa0*/ void set_Name(string value);
                /*0x1fa7aa8*/ bool get_UnicodeEncoded();
                /*0x1fa7ab0*/ void set_UnicodeEncoded(bool value);
                /*0x1fa7abc*/ string get_XML();
                /*0x1fa7ac4*/ void set_XML(string value);
                /*0x1fa7acc*/ System.Security.IPermission CreatePermission();
                /*0x1fa7ad4*/ System.Security.PermissionSet CreateFromXml(string xml);
                /*0x1fa7adc*/ System.Security.PermissionSet CreatePermissionSet();
            }

            class PrincipalPermission : System.Security.IPermission, System.Security.ISecurityEncodable, System.Security.Permissions.IUnrestrictedPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Collections.ArrayList principals;

                /*0x1fa7ae4*/ PrincipalPermission(System.Security.Permissions.PermissionState state);
                /*0x1fa7bd4*/ PrincipalPermission(string name, string role);
                /*0x1fa7bdc*/ PrincipalPermission(string name, string role, bool isAuthenticated);
                /*0x1fa7cb4*/ PrincipalPermission(System.Collections.ArrayList principals);
                /*0x1fa7d7c*/ System.Security.IPermission Copy();
                /*0x1fa7de0*/ void Demand();
                /*0x1fa83f0*/ void FromXml(System.Security.SecurityElement elem);
                /*0x1fa8c34*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fa9760*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fa9458*/ bool IsUnrestricted();
                /*0x1fa9dfc*/ string ToString();
                /*0x1fa9e1c*/ System.Security.SecurityElement ToXml();
                /*0x1faa350*/ System.Security.IPermission Union(System.Security.IPermission other);
                /*0x1faa6d0*/ bool Equals(object obj);
                /*0x1faad60*/ int GetHashCode();
                /*0x1faad68*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fa93a4*/ System.Security.Permissions.PrincipalPermission Cast(System.Security.IPermission target);
                /*0x1fa9dcc*/ bool IsEmpty();
                /*0x1fa8950*/ int CheckSecurityElement(System.Security.SecurityElement se, string parameterName, int minimumVersion, int maximumVersion);

                class PrincipalInfo
                {
                    /*0x10*/ string _name;
                    /*0x18*/ string _role;
                    /*0x20*/ bool _isAuthenticated;

                    /*0x1faad70*/ PrincipalInfo(string name, string role, bool isAuthenticated);
                    /*0x1faadac*/ string get_Name();
                    /*0x1faadb4*/ string get_Role();
                    /*0x1faadbc*/ bool get_IsAuthenticated();
                }
            }

            class PrincipalPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x15*/ bool authenticated;
                /*0x18*/ string name;
                /*0x20*/ string role;

                /*0x1faadc4*/ PrincipalPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1faade4*/ bool get_Authenticated();
                /*0x1faadec*/ void set_Authenticated(bool value);
                /*0x1faadf8*/ string get_Name();
                /*0x1faae00*/ void set_Name(string value);
                /*0x1faae08*/ string get_Role();
                /*0x1faae10*/ void set_Role(string value);
                /*0x1faae18*/ System.Security.IPermission CreatePermission();
            }

            class PublisherIdentityPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.Cryptography.X509Certificates.X509Certificate x509;

                /*0x1faaec0*/ PublisherIdentityPermission(System.Security.Permissions.PermissionState state);
                /*0x1faaee4*/ PublisherIdentityPermission(System.Security.Cryptography.X509Certificates.X509Certificate certificate);
                /*0x1faaf70*/ System.Security.Cryptography.X509Certificates.X509Certificate get_Certificate();
                /*0x1faaf10*/ void set_Certificate(System.Security.Cryptography.X509Certificates.X509Certificate value);
                /*0x1faaf78*/ System.Security.IPermission Copy();
                /*0x1faaff8*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fab108*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fab2a0*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fab32c*/ System.Security.SecurityElement ToXml();
                /*0x1fab3bc*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fab518*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fab1ec*/ System.Security.Permissions.PublisherIdentityPermission Cast(System.Security.IPermission target);
            }

            class PublisherIdentityPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ string certFile;
                /*0x20*/ string signedFile;
                /*0x28*/ string x509data;

                /*0x1fab520*/ PublisherIdentityPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fab528*/ string get_CertFile();
                /*0x1fab530*/ void set_CertFile(string value);
                /*0x1fab538*/ string get_SignedFile();
                /*0x1fab540*/ void set_SignedFile(string value);
                /*0x1fab548*/ string get_X509Certificate();
                /*0x1fab550*/ void set_X509Certificate(string value);
                /*0x1fab558*/ System.Security.IPermission CreatePermission();
            }

            class ReflectionPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.Permissions.ReflectionPermissionFlag flags;

                /*0x1fab694*/ ReflectionPermission(System.Security.Permissions.PermissionState state);
                /*0x1fab6d8*/ ReflectionPermission(System.Security.Permissions.ReflectionPermissionFlag flag);
                /*0x1fab7bc*/ System.Security.Permissions.ReflectionPermissionFlag get_Flags();
                /*0x1fab704*/ void set_Flags(System.Security.Permissions.ReflectionPermissionFlag value);
                /*0x1fab7c4*/ System.Security.IPermission Copy();
                /*0x1fab834*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fab9bc*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fabb70*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fabb60*/ bool IsUnrestricted();
                /*0x1fabbc0*/ System.Security.SecurityElement ToXml();
                /*0x1fabdb0*/ System.Security.IPermission Union(System.Security.IPermission other);
                /*0x1fabec0*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fabaac*/ System.Security.Permissions.ReflectionPermission Cast(System.Security.IPermission target);
            }

            class ReflectionPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ System.Security.Permissions.ReflectionPermissionFlag flags;
                /*0x1c*/ bool memberAccess;
                /*0x1d*/ bool reflectionEmit;
                /*0x1e*/ bool typeInfo;

                /*0x1fabec8*/ ReflectionPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fabed0*/ System.Security.Permissions.ReflectionPermissionFlag get_Flags();
                /*0x1fabed8*/ void set_Flags(System.Security.Permissions.ReflectionPermissionFlag value);
                /*0x1fabefc*/ bool get_MemberAccess();
                /*0x1fabf04*/ void set_MemberAccess(bool value);
                /*0x1fabf28*/ bool get_ReflectionEmit();
                /*0x1fabf30*/ void set_ReflectionEmit(bool value);
                /*0x1fabf54*/ bool get_RestrictedMemberAccess();
                /*0x1fabf60*/ void set_RestrictedMemberAccess(bool value);
                /*0x1fabf7c*/ bool get_TypeInformation();
                /*0x1fabf84*/ void set_TypeInformation(bool value);
                /*0x1fabfa8*/ System.Security.IPermission CreatePermission();
            }

            class RegistryPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.Permissions.PermissionState _state;
                /*0x18*/ System.Collections.ArrayList createList;
                /*0x20*/ System.Collections.ArrayList readList;
                /*0x28*/ System.Collections.ArrayList writeList;

                /*0x1fabfb0*/ RegistryPermission(System.Security.Permissions.PermissionState state);
                /*0x1fac074*/ RegistryPermission(System.Security.Permissions.RegistryPermissionAccess access, string pathList);
                /*0x1fac210*/ RegistryPermission(System.Security.Permissions.RegistryPermissionAccess access, System.Security.AccessControl.AccessControlActions control, string pathList);
                /*0x1fac138*/ void AddPathList(System.Security.Permissions.RegistryPermissionAccess access, string pathList);
                /*0x1fac394*/ void AddPathList(System.Security.Permissions.RegistryPermissionAccess access, System.Security.AccessControl.AccessControlActions control, string pathList);
                /*0x1fac7c0*/ string GetPathList(System.Security.Permissions.RegistryPermissionAccess access);
                /*0x1facbc0*/ void SetPathList(System.Security.Permissions.RegistryPermissionAccess access, string pathList);
                /*0x1facee0*/ System.Security.IPermission Copy();
                /*0x1facfa4*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fad118*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fada68*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fad2bc*/ bool IsUnrestricted();
                /*0x1fae13c*/ System.Security.SecurityElement ToXml();
                /*0x1fae27c*/ System.Security.IPermission Union(System.Security.IPermission other);
                /*0x1fae3e8*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fad9ec*/ bool IsEmpty();
                /*0x1fad208*/ System.Security.Permissions.RegistryPermission Cast(System.Security.IPermission target);
                /*0x1fac710*/ void ThrowInvalidFlag(System.Security.Permissions.RegistryPermissionAccess flag, bool context);
                /*0x1fac818*/ string GetPathList(System.Collections.ArrayList list);
                /*0x1fadb04*/ bool KeyIsSubsetOf(System.Collections.IList local, System.Collections.IList target);
                /*0x1fac3d4*/ void AddWithUnionKey(System.Collections.IList list, string pathList);
                /*0x1fad2cc*/ void IntersectKeys(System.Collections.IList local, System.Collections.IList target, System.Collections.IList result);
            }

            class RegistryPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ string create;
                /*0x20*/ string read;
                /*0x28*/ string write;
                /*0x30*/ string changeAccessControl;
                /*0x38*/ string viewAccessControl;

                /*0x1fae3f0*/ RegistryPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fae3f8*/ string get_All();
                /*0x1fae448*/ void set_All(string value);
                /*0x1fae454*/ string get_Create();
                /*0x1fae45c*/ void set_Create(string value);
                /*0x1fae464*/ string get_Read();
                /*0x1fae46c*/ void set_Read(string value);
                /*0x1fae474*/ string get_Write();
                /*0x1fae47c*/ void set_Write(string value);
                /*0x1fae484*/ string get_ChangeAccessControl();
                /*0x1fae48c*/ void set_ChangeAccessControl(string value);
                /*0x1fae494*/ string get_ViewAccessControl();
                /*0x1fae49c*/ void set_ViewAccessControl(string value);
                /*0x1fae4a4*/ string get_ViewAndModify();
                /*0x1fae4e4*/ void set_ViewAndModify(string value);
                /*0x1fae4f0*/ System.Security.IPermission CreatePermission();
            }

            enum SecurityAction
            {
                Demand = 2,
                Assert = 3,
                Deny = 4,
                PermitOnly = 5,
                LinkDemand = 6,
                InheritanceDemand = 7,
                RequestMinimum = 8,
                RequestOptional = 9,
                RequestRefuse = 10,
            }

            class SecurityAttribute : System.Attribute
            {
                /*0x10*/ System.Security.Permissions.SecurityAction m_Action;
                /*0x14*/ bool m_Unrestricted;

                /*0x1fae5a8*/ SecurityAttribute(System.Security.Permissions.SecurityAction action);
                System.Security.IPermission CreatePermission();
                /*0x1fae5d0*/ bool get_Unrestricted();
                /*0x1fae5d8*/ void set_Unrestricted(bool value);
                /*0x1fae5e4*/ System.Security.Permissions.SecurityAction get_Action();
                /*0x1fae5ec*/ void set_Action(System.Security.Permissions.SecurityAction value);
            }

            class SecurityPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.Permissions.SecurityPermissionFlag flags;

                /*0x1fae5f4*/ SecurityPermission(System.Security.Permissions.PermissionState state);
                /*0x1fae638*/ SecurityPermission(System.Security.Permissions.SecurityPermissionFlag flag);
                /*0x1fae71c*/ System.Security.Permissions.SecurityPermissionFlag get_Flags();
                /*0x1fae664*/ void set_Flags(System.Security.Permissions.SecurityPermissionFlag value);
                /*0x1fae724*/ bool IsUnrestricted();
                /*0x1fae738*/ System.Security.IPermission Copy();
                /*0x1fae7a8*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fae984*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1faea78*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1faead0*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1faec4c*/ System.Security.SecurityElement ToXml();
                /*0x1faed40*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fae974*/ bool IsEmpty();
                /*0x1fae8c0*/ System.Security.Permissions.SecurityPermission Cast(System.Security.IPermission target);
            }

            class SecurityPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ System.Security.Permissions.SecurityPermissionFlag m_Flags;

                /*0x1faed48*/ SecurityPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1faed64*/ bool get_Assertion();
                /*0x1faed70*/ void set_Assertion(bool value);
                /*0x1faed8c*/ bool get_BindingRedirects();
                /*0x1faed98*/ void set_BindingRedirects(bool value);
                /*0x1faedb4*/ bool get_ControlAppDomain();
                /*0x1faedc0*/ void set_ControlAppDomain(bool value);
                /*0x1faeddc*/ bool get_ControlDomainPolicy();
                /*0x1faede8*/ void set_ControlDomainPolicy(bool value);
                /*0x1faee04*/ bool get_ControlEvidence();
                /*0x1faee10*/ void set_ControlEvidence(bool value);
                /*0x1faee2c*/ bool get_ControlPolicy();
                /*0x1faee38*/ void set_ControlPolicy(bool value);
                /*0x1faee54*/ bool get_ControlPrincipal();
                /*0x1faee60*/ void set_ControlPrincipal(bool value);
                /*0x1faee7c*/ bool get_ControlThread();
                /*0x1faee88*/ void set_ControlThread(bool value);
                /*0x1faeea4*/ bool get_Execution();
                /*0x1faeeb0*/ void set_Execution(bool value);
                /*0x1faeecc*/ bool get_Infrastructure();
                /*0x1faeed8*/ void set_Infrastructure(bool value);
                /*0x1faeef4*/ bool get_RemotingConfiguration();
                /*0x1faef00*/ void set_RemotingConfiguration(bool value);
                /*0x1faef1c*/ bool get_SerializationFormatter();
                /*0x1faef28*/ void set_SerializationFormatter(bool value);
                /*0x1faef44*/ bool get_SkipVerification();
                /*0x1faef50*/ void set_SkipVerification(bool value);
                /*0x1faef6c*/ bool get_UnmanagedCode();
                /*0x1faef78*/ void set_UnmanagedCode(bool value);
                /*0x1faef94*/ System.Security.IPermission CreatePermission();
                /*0x1faef9c*/ System.Security.Permissions.SecurityPermissionFlag get_Flags();
                /*0x1faefa4*/ void set_Flags(System.Security.Permissions.SecurityPermissionFlag value);
            }

            enum SecurityPermissionFlag
            {
                NoFlags = 0,
                Assertion = 1,
                UnmanagedCode = 2,
                SkipVerification = 4,
                Execution = 8,
                ControlThread = 16,
                ControlEvidence = 32,
                ControlPolicy = 64,
                SerializationFormatter = 128,
                ControlDomainPolicy = 256,
                ControlPrincipal = 512,
                ControlAppDomain = 1024,
                RemotingConfiguration = 2048,
                Infrastructure = 4096,
                BindingRedirects = 8192,
                AllFlags = 16383,
            }

            class SiteIdentityPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                static /*0x0*/ bool[] valid;
                /*0x10*/ string _site;

                static /*0x1faf88c*/ SiteIdentityPermission();
                /*0x1faefac*/ SiteIdentityPermission(System.Security.Permissions.PermissionState state);
                /*0x1faefd0*/ SiteIdentityPermission(string site);
                /*0x1faf070*/ string get_Site();
                /*0x1faeffc*/ void set_Site(string value);
                /*0x1faf220*/ System.Security.IPermission Copy();
                /*0x1faf2bc*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1faf368*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1faf604*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1faf6bc*/ System.Security.SecurityElement ToXml();
                /*0x1faf734*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1faf884*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1faf0d0*/ bool IsEmpty();
                /*0x1faf430*/ System.Security.Permissions.SiteIdentityPermission Cast(System.Security.IPermission target);
                /*0x1faf0e0*/ bool IsValid(string s);
                /*0x1faf4e4*/ bool Match(string target);
            }

            class SiteIdentityPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ string site;

                /*0x1faf920*/ SiteIdentityPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1faf928*/ string get_Site();
                /*0x1faf930*/ void set_Site(string value);
                /*0x1faf938*/ System.Security.IPermission CreatePermission();
            }

            class StrongNameIdentityPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                static /*0x0*/ System.Version defaultVersion;
                /*0x10*/ System.Security.Permissions.PermissionState _state;
                /*0x18*/ System.Collections.ArrayList _list;

                static /*0x1fb2928*/ StrongNameIdentityPermission();
                /*0x1faf9fc*/ StrongNameIdentityPermission(System.Security.Permissions.PermissionState state);
                /*0x1fafbb0*/ StrongNameIdentityPermission(System.Security.Permissions.StrongNamePublicKeyBlob blob, string name, System.Version version);
                /*0x1fafd24*/ StrongNameIdentityPermission(System.Security.Permissions.StrongNameIdentityPermission snip);
                /*0x1fb00a8*/ string get_Name();
                /*0x1fb018c*/ void set_Name(string value);
                /*0x1fb0384*/ System.Security.Permissions.StrongNamePublicKeyBlob get_PublicKey();
                /*0x1fb0468*/ void set_PublicKey(System.Security.Permissions.StrongNamePublicKeyBlob value);
                /*0x1fb05b8*/ System.Version get_Version();
                /*0x1fb069c*/ void set_Version(System.Version value);
                /*0x1fb02dc*/ void ResetToDefault();
                /*0x1fb079c*/ System.Security.IPermission Copy();
                /*0x1fb0920*/ void FromXml(System.Security.SecurityElement e);
                /*0x1fb0d18*/ System.Security.Permissions.StrongNameIdentityPermission.SNIP FromSecurityElement(System.Security.SecurityElement se);
                /*0x1fb0f7c*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fb12d4*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fb1a24*/ System.Security.SecurityElement ToXml();
                /*0x1fb1e80*/ void ToSecurityElement(System.Security.SecurityElement se, System.Security.Permissions.StrongNameIdentityPermission.SNIP snip);
                /*0x1fb2058*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fb2838*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fb1978*/ bool IsUnrestricted();
                /*0x1fb245c*/ bool Contains(System.Security.Permissions.StrongNameIdentityPermission.SNIP snip);
                /*0x1fb1f80*/ bool IsEmpty(System.Security.Permissions.StrongNameIdentityPermission.SNIP snip);
                /*0x1fb081c*/ bool IsEmpty();
                /*0x1fb18c4*/ System.Security.Permissions.StrongNameIdentityPermission Cast(System.Security.IPermission target);
                /*0x1fb114c*/ bool Match(string target);

                struct SNIP
                {
                    /*0x10*/ System.Security.Permissions.StrongNamePublicKeyBlob PublicKey;
                    /*0x18*/ string Name;
                    /*0x20*/ System.Version AssemblyVersion;

                    static /*0x1fafae0*/ System.Security.Permissions.StrongNameIdentityPermission.SNIP CreateDefault();
                    /*0x1fafd18*/ SNIP(System.Security.Permissions.StrongNamePublicKeyBlob pk, string name, System.Version version);
                    /*0x1fb2840*/ bool IsNameSubsetOf(string target);
                    /*0x1fb1988*/ bool IsSubsetOf(System.Security.Permissions.StrongNameIdentityPermission.SNIP target);
                }
            }

            class StrongNameIdentityPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ string name;
                /*0x20*/ string key;
                /*0x28*/ string version;

                /*0x1fb29a8*/ StrongNameIdentityPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fb29b0*/ string get_Name();
                /*0x1fb29b8*/ void set_Name(string value);
                /*0x1fb29c0*/ string get_PublicKey();
                /*0x1fb29c8*/ void set_PublicKey(string value);
                /*0x1fb29d0*/ string get_Version();
                /*0x1fb29d8*/ void set_Version(string value);
                /*0x1fb29e0*/ System.Security.IPermission CreatePermission();
            }

            class StrongNamePublicKeyBlob
            {
                /*0x10*/ byte[] pubkey;

                static /*0x1fb0e18*/ System.Security.Permissions.StrongNamePublicKeyBlob FromString(string s);
                static /*0x1fb2a60*/ byte CharToByte(char c);
                /*0x1fb29e8*/ StrongNamePublicKeyBlob(byte[] publicKey);
                /*0x1fb2adc*/ bool Equals(object obj);
                /*0x1fb2bac*/ int GetHashCode();
                /*0x1fb2c68*/ string ToString();
            }

            class UIPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IUnrestrictedPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.Permissions.UIPermissionWindow _window;
                /*0x14*/ System.Security.Permissions.UIPermissionClipboard _clipboard;

                /*0x1fb2d40*/ UIPermission(System.Security.Permissions.PermissionState state);
                /*0x1fb2d88*/ UIPermission(System.Security.Permissions.UIPermissionClipboard clipboardFlag);
                /*0x1fb2f3c*/ UIPermission(System.Security.Permissions.UIPermissionWindow windowFlag);
                /*0x1fb30f0*/ UIPermission(System.Security.Permissions.UIPermissionWindow windowFlag, System.Security.Permissions.UIPermissionClipboard clipboardFlag);
                /*0x1fb312c*/ System.Security.Permissions.UIPermissionClipboard get_Clipboard();
                /*0x1fb2db4*/ void set_Clipboard(System.Security.Permissions.UIPermissionClipboard value);
                /*0x1fb3134*/ System.Security.Permissions.UIPermissionWindow get_Window();
                /*0x1fb2f68*/ void set_Window(System.Security.Permissions.UIPermissionWindow value);
                /*0x1fb313c*/ System.Security.IPermission Copy();
                /*0x1fb31a4*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fb33fc*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fb355c*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fb35cc*/ bool IsUnrestricted();
                /*0x1fb35f0*/ System.Security.SecurityElement ToXml();
                /*0x1fb3754*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fb380c*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fb354c*/ bool IsEmpty(System.Security.Permissions.UIPermissionWindow w, System.Security.Permissions.UIPermissionClipboard c);
                /*0x1fb3498*/ System.Security.Permissions.UIPermission Cast(System.Security.IPermission target);
            }

            class UIPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ System.Security.Permissions.UIPermissionClipboard clipboard;
                /*0x1c*/ System.Security.Permissions.UIPermissionWindow window;

                /*0x1fb3814*/ UIPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fb381c*/ System.Security.Permissions.UIPermissionClipboard get_Clipboard();
                /*0x1fb3824*/ void set_Clipboard(System.Security.Permissions.UIPermissionClipboard value);
                /*0x1fb382c*/ System.Security.Permissions.UIPermissionWindow get_Window();
                /*0x1fb3834*/ void set_Window(System.Security.Permissions.UIPermissionWindow value);
                /*0x1fb383c*/ System.Security.IPermission CreatePermission();
            }

            class UrlIdentityPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ string url;

                /*0x1fb38c8*/ UrlIdentityPermission(System.Security.Permissions.PermissionState state);
                /*0x1fb3940*/ UrlIdentityPermission(string site);
                /*0x1fb39b8*/ string get_Url();
                /*0x1fb39c0*/ void set_Url(string value);
                /*0x1fb3a28*/ System.Security.IPermission Copy();
                /*0x1fb3aa8*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fb3b78*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fb3e44*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fb3f3c*/ System.Security.SecurityElement ToXml();
                /*0x1fb3fbc*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fb40e4*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fb3cc0*/ bool IsEmpty();
                /*0x1fb3c0c*/ System.Security.Permissions.UrlIdentityPermission Cast(System.Security.IPermission target);
                /*0x1fb3ce0*/ bool Match(string target);
            }

            class UrlIdentityPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ string url;

                /*0x1fb40ec*/ UrlIdentityPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fb40f4*/ string get_Url();
                /*0x1fb40fc*/ void set_Url(string value);
                /*0x1fb4104*/ System.Security.IPermission CreatePermission();
            }

            class ZoneIdentityPermission : System.Security.CodeAccessPermission, System.Security.Permissions.IBuiltInPermission
            {
                static int version = 1;
                /*0x10*/ System.Security.SecurityZone zone;

                /*0x1fb41a4*/ ZoneIdentityPermission(System.Security.Permissions.PermissionState state);
                /*0x1fb41e0*/ ZoneIdentityPermission(System.Security.SecurityZone zone);
                /*0x1fb4394*/ System.Security.IPermission Copy();
                /*0x1fb4404*/ bool IsSubsetOf(System.Security.IPermission target);
                /*0x1fb4500*/ System.Security.IPermission Union(System.Security.IPermission target);
                /*0x1fb45c8*/ System.Security.IPermission Intersect(System.Security.IPermission target);
                /*0x1fb4614*/ void FromXml(System.Security.SecurityElement esd);
                /*0x1fb4778*/ System.Security.SecurityElement ToXml();
                /*0x1fb4830*/ System.Security.SecurityZone get_SecurityZone();
                /*0x1fb420c*/ void set_SecurityZone(System.Security.SecurityZone value);
                /*0x1fb4838*/ int System.Security.Permissions.IBuiltInPermission.GetTokenIndex();
                /*0x1fb444c*/ System.Security.Permissions.ZoneIdentityPermission Cast(System.Security.IPermission target);
            }

            class ZoneIdentityPermissionAttribute : System.Security.Permissions.CodeAccessSecurityAttribute
            {
                /*0x18*/ System.Security.SecurityZone zone;

                /*0x1fb4840*/ ZoneIdentityPermissionAttribute(System.Security.Permissions.SecurityAction action);
                /*0x1fb4860*/ System.Security.SecurityZone get_Zone();
                /*0x1fb4868*/ void set_Zone(System.Security.SecurityZone value);
                /*0x1fb4870*/ System.Security.IPermission CreatePermission();
            }
        }

        namespace Cryptography
        {
            class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes
            {
                static int MinimumSaltSize = 8;
                /*0x10*/ byte[] _password;
                /*0x18*/ byte[] _salt;
                /*0x20*/ uint _iterations;
                /*0x28*/ System.Security.Cryptography.HMAC _hmac;
                /*0x30*/ int _blockSize;
                /*0x38*/ byte[] _buffer;
                /*0x40*/ uint _block;
                /*0x44*/ int _startIndex;
                /*0x48*/ int _endIndex;
                /*0x50*/ System.Security.Cryptography.HashAlgorithmName <HashAlgorithm>k__BackingField;

                /*0x1fb4924*/ Rfc2898DeriveBytes(byte[] password, byte[] salt, int iterations);
                /*0x1fb49d4*/ Rfc2898DeriveBytes(byte[] password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fb4ec4*/ Rfc2898DeriveBytes(string password, byte[] salt);
                /*0x1fb4ecc*/ Rfc2898DeriveBytes(string password, byte[] salt, int iterations);
                /*0x1fb4f3c*/ Rfc2898DeriveBytes(string password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fb4fa4*/ Rfc2898DeriveBytes(string password, int saltSize);
                /*0x1fb4fac*/ Rfc2898DeriveBytes(string password, int saltSize, int iterations);
                /*0x1fb501c*/ Rfc2898DeriveBytes(string password, int saltSize, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fb491c*/ System.Security.Cryptography.HashAlgorithmName get_HashAlgorithm();
                /*0x1fb51b0*/ int get_IterationCount();
                /*0x1fb51b8*/ void set_IterationCount(int value);
                /*0x1fb5238*/ byte[] get_Salt();
                /*0x1fb5244*/ void set_Salt(byte[] value);
                /*0x1fb52fc*/ void Dispose(bool disposing);
                /*0x1fb53e0*/ byte[] GetBytes(int cb);
                /*0x1fb5a5c*/ byte[] CryptDeriveKey(string algname, string alghashname, int keySize, byte[] rgbIV);
                /*0x1fb5a9c*/ void Reset();
                /*0x1fb4b90*/ System.Security.Cryptography.HMAC OpenHmac();
                /*0x1fb4e4c*/ void Initialize();
                /*0x1fb55a8*/ byte[] Func();
            }

            interface ICspAsymmetricAlgorithm
            {
                System.Security.Cryptography.CspKeyContainerInfo get_CspKeyContainerInfo();
                byte[] ExportCspBlob(bool includePrivateParameters);
                void ImportCspBlob(byte[] rawData);
            }

            enum KeyNumber
            {
                Exchange = 1,
                Signature = 2,
            }

            class CryptoStream : System.IO.Stream, System.IDisposable
            {
                /*0x28*/ System.IO.Stream _stream;
                /*0x30*/ System.Security.Cryptography.ICryptoTransform _transform;
                /*0x38*/ System.Security.Cryptography.CryptoStreamMode _transformMode;
                /*0x40*/ byte[] _inputBuffer;
                /*0x48*/ int _inputBufferIndex;
                /*0x4c*/ int _inputBlockSize;
                /*0x50*/ byte[] _outputBuffer;
                /*0x58*/ int _outputBufferIndex;
                /*0x5c*/ int _outputBlockSize;
                /*0x60*/ bool _canRead;
                /*0x61*/ bool _canWrite;
                /*0x62*/ bool _finalBlockTransformed;
                /*0x68*/ System.Threading.SemaphoreSlim _lazyAsyncActiveSemaphore;
                /*0x70*/ bool _leaveOpen;

                /*0x1fb5d58*/ CryptoStream(System.IO.Stream stream, System.Security.Cryptography.ICryptoTransform transform, System.Security.Cryptography.CryptoStreamMode mode);
                /*0x1fb5d60*/ CryptoStream(System.IO.Stream stream, System.Security.Cryptography.ICryptoTransform transform, System.Security.Cryptography.CryptoStreamMode mode, bool leaveOpen);
                /*0x1fb6074*/ bool get_CanRead();
                /*0x1fb607c*/ bool get_CanSeek();
                /*0x1fb6084*/ bool get_CanWrite();
                /*0x1fb608c*/ long get_Length();
                /*0x1fb60dc*/ long get_Position();
                /*0x1fb612c*/ void set_Position(long value);
                /*0x1fb617c*/ bool get_HasFlushedFinalBlock();
                /*0x1fb6184*/ void FlushFinalBlock();
                /*0x1fb63b4*/ void Flush();
                /*0x1fb63b8*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
                /*0x1fb6520*/ long Seek(long offset, System.IO.SeekOrigin origin);
                /*0x1fb6570*/ void SetLength(long value);
                /*0x1fb65c0*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x1fb6874*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x1fb6928*/ int EndRead(System.IAsyncResult asyncResult);
                /*0x1fb6750*/ System.Threading.Tasks.Task<int> ReadAsyncInternal(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x1fb6970*/ int ReadByte();
                /*0x1fb69ec*/ void WriteByte(byte value);
                /*0x1fb6a40*/ int Read(byte[] buffer, int offset, int count);
                /*0x1fb6608*/ void CheckReadArguments(byte[] buffer, int offset, int count);
                /*0x1fb6b04*/ System.Threading.Tasks.Task<int> ReadAsyncCore(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken, bool useAsync);
                /*0x1fb6c48*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x1fb6ed4*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x1fb6f88*/ void EndWrite(System.IAsyncResult asyncResult);
                /*0x1fb6dd8*/ System.Threading.Tasks.Task WriteAsyncInternal(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x1fb6f94*/ void Write(byte[] buffer, int offset, int count);
                /*0x1fb6c90*/ void CheckWriteArguments(byte[] buffer, int offset, int count);
                /*0x1fb7004*/ System.Threading.Tasks.Task WriteAsyncCore(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken, bool useAsync);
                /*0x1fb7120*/ void Clear();
                /*0x1fb7130*/ void Dispose(bool disposing);
                /*0x1fb5f28*/ void InitializeBuffer();
                /*0x1fb71e0*/ System.Threading.SemaphoreSlim get_AsyncActiveSemaphore();

                struct <ReadAsyncInternal>d__37 : System.Runtime.CompilerServices.IAsyncStateMachine
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<int> <>t__builder;
                    /*0x30*/ System.Security.Cryptography.CryptoStream <>4__this;
                    /*0x38*/ byte[] buffer;
                    /*0x40*/ int offset;
                    /*0x44*/ int count;
                    /*0x48*/ System.Threading.CancellationToken cancellationToken;
                    /*0x50*/ System.Threading.SemaphoreSlim <semaphore>5__2;
                    /*0x58*/ System.Threading.Tasks.ForceAsyncAwaiter <>u__1;
                    /*0x60*/ System.Runtime.CompilerServices.TaskAwaiter<int> <>u__2;

                    /*0x1fb72d8*/ void MoveNext();
                    /*0x1fb769c*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                }

                struct <ReadAsyncCore>d__42 : System.Runtime.CompilerServices.IAsyncStateMachine
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<int> <>t__builder;
                    /*0x30*/ int count;
                    /*0x34*/ int offset;
                    /*0x38*/ System.Security.Cryptography.CryptoStream <>4__this;
                    /*0x40*/ byte[] buffer;
                    /*0x48*/ bool useAsync;
                    /*0x50*/ System.Threading.CancellationToken cancellationToken;
                    /*0x58*/ int <bytesToDeliver>5__2;
                    /*0x5c*/ int <currentOutputIndex>5__3;
                    /*0x60*/ int <numWholeBlocksInBytes>5__4;
                    /*0x68*/ byte[] <tempInputBuffer>5__5;
                    /*0x70*/ byte[] <tempOutputBuffer>5__6;
                    /*0x78*/ System.Runtime.CompilerServices.ValueTaskAwaiter<int> <>u__1;

                    /*0x1fb76f4*/ void MoveNext();
                    /*0x1fb885c*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                }

                struct <WriteAsyncInternal>d__46 : System.Runtime.CompilerServices.IAsyncStateMachine
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                    /*0x30*/ System.Security.Cryptography.CryptoStream <>4__this;
                    /*0x38*/ byte[] buffer;
                    /*0x40*/ int offset;
                    /*0x44*/ int count;
                    /*0x48*/ System.Threading.CancellationToken cancellationToken;
                    /*0x50*/ System.Threading.SemaphoreSlim <semaphore>5__2;
                    /*0x58*/ System.Threading.Tasks.ForceAsyncAwaiter <>u__1;
                    /*0x60*/ System.Runtime.CompilerServices.TaskAwaiter <>u__2;

                    /*0x1fb88b4*/ void MoveNext();
                    /*0x1fb8bd4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                }

                struct <WriteAsyncCore>d__49 : System.Runtime.CompilerServices.IAsyncStateMachine
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                    /*0x30*/ int count;
                    /*0x34*/ int offset;
                    /*0x38*/ System.Security.Cryptography.CryptoStream <>4__this;
                    /*0x40*/ byte[] buffer;
                    /*0x48*/ bool useAsync;
                    /*0x50*/ System.Threading.CancellationToken cancellationToken;
                    /*0x58*/ int <bytesToWrite>5__2;
                    /*0x5c*/ int <currentInputIndex>5__3;
                    /*0x60*/ int <numOutputBytes>5__4;
                    /*0x68*/ System.Runtime.CompilerServices.ValueTaskAwaiter <>u__1;
                    /*0x78*/ int <numWholeBlocksInBytes>5__5;
                    /*0x80*/ byte[] <tempOutputBuffer>5__6;

                    /*0x1fb8be0*/ void MoveNext();
                    /*0x1fb9dac*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                }

                class <>c
                {
                    static /*0x0*/ System.Security.Cryptography.CryptoStream.<> <>9;
                    static /*0x8*/ System.Func<System.Threading.SemaphoreSlim> <>9__54_0;

                    static /*0x1fb9db8*/ <>c();
                    /*0x1fb9e1c*/ <>c();
                    /*0x1fb9e24*/ System.Threading.SemaphoreSlim <get_AsyncActiveSemaphore>b__54_0();
                }
            }

            enum CryptoStreamMode
            {
                Read = 0,
                Write = 1,
            }

            class CryptographicOperations
            {
                static /*0x1fb9e88*/ bool FixedTimeEquals(System.ReadOnlySpan<byte> left, System.ReadOnlySpan<byte> right);
                static /*0x1fb87f4*/ void ZeroMemory(System.Span<byte> buffer);
            }

            class HashAlgorithm : System.IDisposable, System.Security.Cryptography.ICryptoTransform
            {
                /*0x10*/ bool _disposed;
                /*0x14*/ int HashSizeValue;
                /*0x18*/ byte[] HashValue;
                /*0x20*/ int State;

                static /*0x1fba0b0*/ System.Security.Cryptography.HashAlgorithm Create();
                static /*0x1fba0b8*/ System.Security.Cryptography.HashAlgorithm Create(string hashName);
                /*0x1fba0a8*/ HashAlgorithm();
                /*0x1fba138*/ int get_HashSize();
                /*0x1fba140*/ byte[] get_Hash();
                /*0x1fba280*/ byte[] ComputeHash(byte[] buffer);
                /*0x1fb5b90*/ bool TryComputeHash(System.ReadOnlySpan<byte> source, System.Span<byte> destination, ref int bytesWritten);
                /*0x1fba3d8*/ byte[] ComputeHash(byte[] buffer, int offset, int count);
                /*0x1fba550*/ byte[] ComputeHash(System.IO.Stream inputStream);
                /*0x1fba330*/ byte[] CaptureHashCodeAndReinitialize();
                /*0x1fb536c*/ void Dispose();
                /*0x1fba760*/ void Clear();
                /*0x1fba7f4*/ void Dispose(bool disposing);
                /*0x1fba804*/ int get_InputBlockSize();
                /*0x1fba80c*/ int get_OutputBlockSize();
                /*0x1fba814*/ bool get_CanTransformMultipleBlocks();
                /*0x1fba81c*/ bool get_CanReuseTransform();
                /*0x1fba824*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1fbaa1c*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1fba8c0*/ void ValidateTransformBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                void HashCore(byte[] array, int ibStart, int cbSize);
                byte[] HashFinal();
                void Initialize();
                /*0x1fbab40*/ void HashCore(System.ReadOnlySpan<byte> source);
                /*0x1fbad10*/ bool TryHashFinal(System.Span<byte> destination, ref int bytesWritten);
            }

            struct HashAlgorithmName : System.IEquatable<System.Security.Cryptography.HashAlgorithmName>
            {
                /*0x10*/ string _name;

                static /*0x1fbae54*/ System.Security.Cryptography.HashAlgorithmName get_MD5();
                static /*0x1fb4994*/ System.Security.Cryptography.HashAlgorithmName get_SHA1();
                static /*0x1fb5ad0*/ System.Security.Cryptography.HashAlgorithmName get_SHA256();
                static /*0x1fb5b10*/ System.Security.Cryptography.HashAlgorithmName get_SHA384();
                static /*0x1fb5b50*/ System.Security.Cryptography.HashAlgorithmName get_SHA512();
                static /*0x1fb5ac8*/ bool op_Equality(System.Security.Cryptography.HashAlgorithmName left, System.Security.Cryptography.HashAlgorithmName right);
                static /*0x1fbaf98*/ bool op_Inequality(System.Security.Cryptography.HashAlgorithmName left, System.Security.Cryptography.HashAlgorithmName right);
                /*0x1fbae94*/ HashAlgorithmName(string name);
                /*0x1fbae9c*/ string get_Name();
                /*0x1fbaea4*/ string ToString();
                /*0x1fbaef8*/ bool Equals(object obj);
                /*0x1fbaf74*/ bool Equals(System.Security.Cryptography.HashAlgorithmName other);
                /*0x1fbaf80*/ int GetHashCode();
            }

            class RSAEncryptionPadding : System.IEquatable<System.Security.Cryptography.RSAEncryptionPadding>
            {
                static /*0x0*/ System.Security.Cryptography.RSAEncryptionPadding s_pkcs1;
                static /*0x8*/ System.Security.Cryptography.RSAEncryptionPadding s_oaepSHA1;
                static /*0x10*/ System.Security.Cryptography.RSAEncryptionPadding s_oaepSHA256;
                static /*0x18*/ System.Security.Cryptography.RSAEncryptionPadding s_oaepSHA384;
                static /*0x20*/ System.Security.Cryptography.RSAEncryptionPadding s_oaepSHA512;
                /*0x10*/ System.Security.Cryptography.RSAEncryptionPaddingMode _mode;
                /*0x18*/ System.Security.Cryptography.HashAlgorithmName _oaepHashAlgorithm;

                static /*0x1fbb528*/ RSAEncryptionPadding();
                static /*0x1fbafb4*/ System.Security.Cryptography.RSAEncryptionPadding get_Pkcs1();
                static /*0x1fbb00c*/ System.Security.Cryptography.RSAEncryptionPadding get_OaepSHA1();
                static /*0x1fbb064*/ System.Security.Cryptography.RSAEncryptionPadding get_OaepSHA256();
                static /*0x1fbb0bc*/ System.Security.Cryptography.RSAEncryptionPadding get_OaepSHA384();
                static /*0x1fbb114*/ System.Security.Cryptography.RSAEncryptionPadding get_OaepSHA512();
                static /*0x1fbb19c*/ System.Security.Cryptography.RSAEncryptionPadding CreateOaep(System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                static /*0x1fbb31c*/ int CombineHashCodes(int h1, int h2);
                static /*0x1fbb4a0*/ bool op_Equality(System.Security.Cryptography.RSAEncryptionPadding left, System.Security.Cryptography.RSAEncryptionPadding right);
                static /*0x1fbb430*/ bool op_Inequality(System.Security.Cryptography.RSAEncryptionPadding left, System.Security.Cryptography.RSAEncryptionPadding right);
                /*0x1fbb16c*/ RSAEncryptionPadding(System.Security.Cryptography.RSAEncryptionPaddingMode mode, System.Security.Cryptography.HashAlgorithmName oaepHashAlgorithm);
                /*0x1fbb684*/ RSAEncryptionPadding();
                /*0x1fbb280*/ System.Security.Cryptography.RSAEncryptionPaddingMode get_Mode();
                /*0x1fbb288*/ System.Security.Cryptography.HashAlgorithmName get_OaepHashAlgorithm();
                /*0x1fbb290*/ int GetHashCode();
                /*0x1fbb328*/ bool Equals(object obj);
                /*0x1fbb38c*/ bool Equals(System.Security.Cryptography.RSAEncryptionPadding other);
                /*0x1fbb4b4*/ string ToString();
            }

            enum RSAEncryptionPaddingMode
            {
                Pkcs1 = 0,
                Oaep = 1,
            }

            class RSASignaturePadding : System.IEquatable<System.Security.Cryptography.RSASignaturePadding>
            {
                static /*0x0*/ System.Security.Cryptography.RSASignaturePadding s_pkcs1;
                static /*0x8*/ System.Security.Cryptography.RSASignaturePadding s_pss;
                /*0x10*/ System.Security.Cryptography.RSASignaturePaddingMode _mode;

                static /*0x1fbb984*/ RSASignaturePadding();
                static /*0x1fbb6e4*/ System.Security.Cryptography.RSASignaturePadding get_Pkcs1();
                static /*0x1fbb73c*/ System.Security.Cryptography.RSASignaturePadding get_Pss();
                static /*0x1fbb908*/ bool op_Equality(System.Security.Cryptography.RSASignaturePadding left, System.Security.Cryptography.RSASignaturePadding right);
                static /*0x1fbb898*/ bool op_Inequality(System.Security.Cryptography.RSASignaturePadding left, System.Security.Cryptography.RSASignaturePadding right);
                /*0x1fbb6bc*/ RSASignaturePadding(System.Security.Cryptography.RSASignaturePaddingMode mode);
                /*0x1fbba18*/ RSASignaturePadding();
                /*0x1fbb794*/ System.Security.Cryptography.RSASignaturePaddingMode get_Mode();
                /*0x1fbb79c*/ int GetHashCode();
                /*0x1fbb7a8*/ bool Equals(object obj);
                /*0x1fbb80c*/ bool Equals(System.Security.Cryptography.RSASignaturePadding other);
                /*0x1fbb91c*/ string ToString();
            }

            enum RSASignaturePaddingMode
            {
                Pkcs1 = 0,
                Pss = 1,
            }

            class Aes : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;

                static /*0x1fbbc30*/ Aes();
                static /*0x1fbbad4*/ System.Security.Cryptography.Aes Create();
                static /*0x1fbbb38*/ System.Security.Cryptography.Aes Create(string algorithmName);
                /*0x1fbba50*/ Aes();
            }

            class AsymmetricAlgorithm : System.IDisposable
            {
                /*0x10*/ int KeySizeValue;
                /*0x18*/ System.Security.Cryptography.KeySizes[] LegalKeySizesValue;

                static /*0x1fbc01c*/ System.Security.Cryptography.AsymmetricAlgorithm Create();
                static /*0x1fbc078*/ System.Security.Cryptography.AsymmetricAlgorithm Create(string algName);
                /*0x1fbbdc4*/ AsymmetricAlgorithm();
                /*0x1fbbdcc*/ void Dispose();
                /*0x1fbbdd0*/ void Clear();
                /*0x1fbbe3c*/ void Dispose(bool disposing);
                /*0x1fbbe40*/ int get_KeySize();
                /*0x1fbbe48*/ void set_KeySize(int value);
                /*0x1fbbf24*/ System.Security.Cryptography.KeySizes[] get_LegalKeySizes();
                /*0x1fbbf9c*/ string get_SignatureAlgorithm();
                /*0x1fbbfdc*/ string get_KeyExchangeAlgorithm();
                /*0x1fbc11c*/ void FromXmlString(string xmlString);
                /*0x1fbc15c*/ string ToXmlString(bool includePrivateParameters);
                /*0x1fbc19c*/ byte[] ExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<byte> passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters);
                /*0x1fbc1dc*/ byte[] ExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<char> password, System.Security.Cryptography.PbeParameters pbeParameters);
                /*0x1fbc21c*/ byte[] ExportPkcs8PrivateKey();
                /*0x1fbc25c*/ byte[] ExportSubjectPublicKeyInfo();
                /*0x1fbc29c*/ void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<byte> passwordBytes, System.ReadOnlySpan<byte> source, ref int bytesRead);
                /*0x1fbc2dc*/ void ImportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<char> password, System.ReadOnlySpan<byte> source, ref int bytesRead);
                /*0x1fbc31c*/ void ImportPkcs8PrivateKey(System.ReadOnlySpan<byte> source, ref int bytesRead);
                /*0x1fbc35c*/ void ImportSubjectPublicKeyInfo(System.ReadOnlySpan<byte> source, ref int bytesRead);
                /*0x1fbc39c*/ bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<byte> passwordBytes, System.Security.Cryptography.PbeParameters pbeParameters, System.Span<byte> destination, ref int bytesWritten);
                /*0x1fbc3dc*/ bool TryExportEncryptedPkcs8PrivateKey(System.ReadOnlySpan<char> password, System.Security.Cryptography.PbeParameters pbeParameters, System.Span<byte> destination, ref int bytesWritten);
                /*0x1fbc41c*/ bool TryExportPkcs8PrivateKey(System.Span<byte> destination, ref int bytesWritten);
                /*0x1fbc45c*/ bool TryExportSubjectPublicKeyInfo(System.Span<byte> destination, ref int bytesWritten);
            }

            class AsymmetricKeyExchangeDeformatter
            {
                /*0x1fbc49c*/ AsymmetricKeyExchangeDeformatter();
                string get_Parameters();
                void set_Parameters(string value);
                void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                byte[] DecryptKeyExchange(byte[] rgb);
            }

            class AsymmetricKeyExchangeFormatter
            {
                /*0x1fbc4a4*/ AsymmetricKeyExchangeFormatter();
                string get_Parameters();
                void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                byte[] CreateKeyExchange(byte[] data);
                byte[] CreateKeyExchange(byte[] data, System.Type symAlgType);
            }

            class AsymmetricSignatureDeformatter
            {
                /*0x1fbc4ac*/ AsymmetricSignatureDeformatter();
                void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                void SetHashAlgorithm(string strName);
                /*0x1fbc4b4*/ bool VerifySignature(System.Security.Cryptography.HashAlgorithm hash, byte[] rgbSignature);
                bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
            }

            class AsymmetricSignatureFormatter
            {
                /*0x1fbc56c*/ AsymmetricSignatureFormatter();
                void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                void SetHashAlgorithm(string strName);
                /*0x1fbc574*/ byte[] CreateSignature(System.Security.Cryptography.HashAlgorithm hash);
                byte[] CreateSignature(byte[] rgbHash);
            }

            enum FromBase64TransformMode
            {
                IgnoreWhiteSpaces = 0,
                DoNotIgnoreWhiteSpaces = 1,
            }

            class ToBase64Transform : System.Security.Cryptography.ICryptoTransform, System.IDisposable
            {
                /*0x1fbcbf4*/ ToBase64Transform();
                /*0x1fbc624*/ int get_InputBlockSize();
                /*0x1fbc62c*/ int get_OutputBlockSize();
                /*0x1fbc634*/ bool get_CanTransformMultipleBlocks();
                /*0x1fbc63c*/ bool get_CanReuseTransform();
                /*0x1fbc644*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1fbc8b4*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1fbcae0*/ void Dispose();
                /*0x1fbcae4*/ void Clear();
                /*0x1fbcb50*/ void Dispose(bool disposing);
                /*0x1fbcb54*/ void Finalize();
            }

            class FromBase64Transform : System.Security.Cryptography.ICryptoTransform, System.IDisposable
            {
                /*0x10*/ byte[] _inputBuffer;
                /*0x18*/ int _inputIndex;
                /*0x1c*/ System.Security.Cryptography.FromBase64TransformMode _whitespaces;

                /*0x1fbcbfc*/ FromBase64Transform();
                /*0x1fbcc04*/ FromBase64Transform(System.Security.Cryptography.FromBase64TransformMode whitespaces);
                /*0x1fbcc70*/ int get_InputBlockSize();
                /*0x1fbcc78*/ int get_OutputBlockSize();
                /*0x1fbcc80*/ bool get_CanTransformMultipleBlocks();
                /*0x1fbcc88*/ bool get_CanReuseTransform();
                /*0x1fbcc90*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1fbd1d0*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1fbd018*/ byte[] DiscardWhiteSpaces(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1fbd53c*/ void Dispose();
                /*0x1fbd534*/ void Reset();
                /*0x1fbd5a8*/ void Clear();
                /*0x1fbd5ac*/ void Dispose(bool disposing);
                /*0x1fbd5e0*/ void Finalize();
            }

            enum CipherMode
            {
                CBC = 1,
                ECB = 2,
                OFB = 3,
                CFB = 4,
                CTS = 5,
            }

            enum PaddingMode
            {
                None = 1,
                PKCS7 = 2,
                Zeros = 3,
                ANSIX923 = 4,
                ISO10126 = 5,
            }

            class KeySizes
            {
                /*0x10*/ int m_minSize;
                /*0x14*/ int m_maxSize;
                /*0x18*/ int m_skipSize;

                static /*0x1fbd6e4*/ bool IsLegalKeySize(System.Security.Cryptography.KeySizes[] legalKeys, int size);
                /*0x1fbbd88*/ KeySizes(int minSize, int maxSize, int skipSize);
                /*0x1fbd680*/ int get_MinSize();
                /*0x1fbd688*/ int get_MaxSize();
                /*0x1fbd690*/ int get_SkipSize();
                /*0x1fbd698*/ bool IsLegal(int keySize);
            }

            class CryptographicException : System.SystemException
            {
                static int FORMAT_MESSAGE_IGNORE_INSERTS = 512;
                static int FORMAT_MESSAGE_FROM_SYSTEM = 4096;
                static int FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192;

                static /*0x1fbd890*/ void ThrowCryptographicException(int hr);
                /*0x1fb5cec*/ CryptographicException();
                /*0x1fb5aa0*/ CryptographicException(string message);
                /*0x1fbd764*/ CryptographicException(string format, string insert);
                /*0x1fbd7fc*/ CryptographicException(string message, System.Exception inner);
                /*0x1fbd824*/ CryptographicException(int hr);
                /*0x1fbd888*/ CryptographicException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class CryptographicUnexpectedOperationException : System.Security.Cryptography.CryptographicException
            {
                /*0x1fbd8d8*/ CryptographicUnexpectedOperationException();
                /*0x1fba238*/ CryptographicUnexpectedOperationException(string message);
                /*0x1fbd8fc*/ CryptographicUnexpectedOperationException(string format, string insert);
                /*0x1fbd9ac*/ CryptographicUnexpectedOperationException(string message, System.Exception inner);
                /*0x1fbd9f4*/ CryptographicUnexpectedOperationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            enum CspProviderFlags
            {
                NoFlags = 0,
                UseMachineKeyStore = 1,
                UseDefaultKeyContainer = 2,
                UseNonExportableKey = 4,
                UseExistingKey = 8,
                UseArchivableKey = 16,
                UseUserProtectedKey = 32,
                NoPrompt = 64,
                CreateEphemeralKey = 128,
            }

            class CspParameters
            {
                /*0x10*/ int ProviderType;
                /*0x18*/ string ProviderName;
                /*0x20*/ string KeyContainerName;
                /*0x28*/ int KeyNumber;
                /*0x2c*/ int m_flags;
                /*0x30*/ System.Security.AccessControl.CryptoKeySecurity m_cryptoKeySecurity;
                /*0x38*/ System.Security.SecureString m_keyPassword;
                /*0x40*/ nint m_parentWindowHandle;

                /*0x1fbdb74*/ CspParameters();
                /*0x1fbdbe4*/ CspParameters(int dwTypeIn);
                /*0x1fbdc18*/ CspParameters(int dwTypeIn, string strProviderNameIn);
                /*0x1fbdba0*/ CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
                /*0x1fbdca0*/ CspParameters(int providerType, string providerName, string keyContainerName, System.Security.AccessControl.CryptoKeySecurity cryptoKeySecurity, System.Security.SecureString keyPassword);
                /*0x1fbdcf8*/ CspParameters(int providerType, string providerName, string keyContainerName, System.Security.AccessControl.CryptoKeySecurity cryptoKeySecurity, nint parentWindowHandle);
                /*0x1fbdc50*/ CspParameters(int providerType, string providerName, string keyContainerName, System.Security.Cryptography.CspProviderFlags flags);
                /*0x1fbdd54*/ CspParameters(System.Security.Cryptography.CspParameters parameters);
                /*0x1fbd9fc*/ System.Security.Cryptography.CspProviderFlags get_Flags();
                /*0x1fbda04*/ void set_Flags(System.Security.Cryptography.CspProviderFlags value);
                /*0x1fbdaec*/ System.Security.AccessControl.CryptoKeySecurity get_CryptoKeySecurity();
                /*0x1fbdaf4*/ void set_CryptoKeySecurity(System.Security.AccessControl.CryptoKeySecurity value);
                /*0x1fbdafc*/ System.Security.SecureString get_KeyPassword();
                /*0x1fbdb04*/ void set_KeyPassword(System.Security.SecureString value);
                /*0x1fbdb64*/ nint get_ParentWindowHandle();
                /*0x1fbdb6c*/ void set_ParentWindowHandle(nint value);
            }

            class DeriveBytes : System.IDisposable
            {
                /*0x1fb4b88*/ DeriveBytes();
                byte[] GetBytes(int cb);
                void Reset();
                /*0x1fbddb4*/ void Dispose();
                /*0x1fb53dc*/ void Dispose(bool disposing);
            }

            class DES : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;

                static /*0x1fbe7b4*/ DES();
                static /*0x1fbe514*/ System.Security.Cryptography.DES Create();
                static /*0x1fbe658*/ System.Security.Cryptography.DES Create(string algName);
                static /*0x1fbdf84*/ bool IsWeakKey(byte[] rgbKey);
                static /*0x1fbe0d0*/ bool IsSemiWeakKey(byte[] rgbKey);
                static /*0x1fbe6fc*/ bool IsLegalKeySize(byte[] rgbKey);
                static /*0x1fbe71c*/ ulong QuadWordFromBigEndian(byte[] block);
                /*0x1fbde20*/ DES();
                /*0x1fbde9c*/ byte[] get_Key();
                /*0x1fbe308*/ void set_Key(byte[] value);
            }

            class DESCryptoServiceProvider : System.Security.Cryptography.DES
            {
                /*0x1fbe56c*/ DESCryptoServiceProvider();
                /*0x1fbe904*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1fbea40*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1fbeb7c*/ void GenerateKey();
                /*0x1fbec98*/ void GenerateIV();
            }

            struct DSAParameters
            {
                /*0x10*/ byte[] P;
                /*0x18*/ byte[] Q;
                /*0x20*/ byte[] G;
                /*0x28*/ byte[] Y;
                /*0x30*/ byte[] J;
                /*0x38*/ byte[] X;
                /*0x40*/ byte[] Seed;
                /*0x48*/ int Counter;
            }

            class DSA : System.Security.Cryptography.AsymmetricAlgorithm
            {
                static /*0x1fbed38*/ System.Security.Cryptography.DSA Create();
                static /*0x1fbed94*/ System.Security.Cryptography.DSA Create(string algName);
                static /*0x1fbee5c*/ System.Exception DerivedClassMustOverride();
                static /*0x1fbf0c8*/ System.Exception HashAlgorithmNameNullOrEmpty();
                static /*0x1fc0104*/ System.Security.Cryptography.DSA Create(int keySizeInBits);
                static /*0x1fc01cc*/ System.Security.Cryptography.DSA Create(System.Security.Cryptography.DSAParameters parameters);
                /*0x1fbed30*/ DSA();
                byte[] CreateSignature(byte[] rgbHash);
                bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
                /*0x1fbee38*/ byte[] HashData(byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fbeee4*/ byte[] HashData(System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fbef08*/ byte[] SignData(byte[] data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fbef7c*/ byte[] SignData(byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fbf168*/ byte[] SignData(System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fbf224*/ bool VerifyData(byte[] data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fbf29c*/ bool VerifyData(byte[] data, int offset, int count, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fbf420*/ bool VerifyData(System.IO.Stream data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fbf514*/ void FromXmlString(string xmlString);
                /*0x1fbfc74*/ string ToXmlString(bool includePrivateParameters);
                System.Security.Cryptography.DSAParameters ExportParameters(bool includePrivateParameters);
                void ImportParameters(System.Security.Cryptography.DSAParameters parameters);
                /*0x1fc02c0*/ bool TryCreateSignature(System.ReadOnlySpan<byte> hash, System.Span<byte> destination, ref int bytesWritten);
                /*0x1fc03cc*/ bool TryHashData(System.ReadOnlySpan<byte> data, System.Span<byte> destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, ref int bytesWritten);
                /*0x1fc063c*/ bool TrySignData(System.ReadOnlySpan<byte> data, System.Span<byte> destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, ref int bytesWritten);
                /*0x1fc07a0*/ bool VerifyData(System.ReadOnlySpan<byte> data, System.ReadOnlySpan<byte> signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fc0a5c*/ bool VerifySignature(System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> signature);
            }

            class DSASignatureDeformatter : System.Security.Cryptography.AsymmetricSignatureDeformatter
            {
                /*0x10*/ System.Security.Cryptography.DSA _dsaKey;
                /*0x18*/ string _oid;

                /*0x1fc0ae8*/ DSASignatureDeformatter();
                /*0x1fc0b68*/ DSASignatureDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fc0c5c*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fc0d48*/ void SetHashAlgorithm(string strName);
                /*0x1fc0e14*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
            }

            class DSASignatureFormatter : System.Security.Cryptography.AsymmetricSignatureFormatter
            {
                /*0x10*/ System.Security.Cryptography.DSA _dsaKey;
                /*0x18*/ string _oid;

                /*0x1fc0f08*/ DSASignatureFormatter();
                /*0x1fc0f88*/ DSASignatureFormatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fc107c*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fc1168*/ void SetHashAlgorithm(string strName);
                /*0x1fc1234*/ byte[] CreateSignature(byte[] rgbHash);
            }

            class HMAC : System.Security.Cryptography.KeyedHashAlgorithm
            {
                /*0x30*/ int blockSizeValue;
                /*0x38*/ string m_hashName;
                /*0x40*/ System.Security.Cryptography.HashAlgorithm m_hash1;
                /*0x48*/ System.Security.Cryptography.HashAlgorithm m_hash2;
                /*0x50*/ byte[] m_inner;
                /*0x58*/ byte[] m_outer;
                /*0x60*/ bool m_hashing;

                static /*0x1fc16dc*/ System.Security.Cryptography.HMAC Create();
                static /*0x1fc1738*/ System.Security.Cryptography.HMAC Create(string algorithmName);
                static /*0x1fc1b20*/ System.Security.Cryptography.HashAlgorithm GetHashAlgorithmWithFipsFallback(System.Func<System.Security.Cryptography.HashAlgorithm> createStandardHashAlgorithmCallback, System.Func<System.Security.Cryptography.HashAlgorithm> createFipsHashAlgorithmCallback);
                /*0x1fc1c9c*/ HMAC();
                /*0x1fc1314*/ int get_BlockSizeValue();
                /*0x1fc131c*/ void set_BlockSizeValue(int value);
                /*0x1fc1324*/ void UpdateIOPadBuffers();
                /*0x1fc1488*/ void InitializeKey(byte[] key);
                /*0x1fc1558*/ byte[] get_Key();
                /*0x1fc15d0*/ void set_Key(byte[] value);
                /*0x1fc1640*/ string get_HashName();
                /*0x1fc1648*/ void set_HashName(string value);
                /*0x1fc17dc*/ void Initialize();
                /*0x1fc1824*/ void HashCore(byte[] rgb, int ib, int cb);
                /*0x1fc18a4*/ byte[] HashFinal();
                /*0x1fc19d4*/ void Dispose(bool disposing);
            }

            class HMACMD5 : System.Security.Cryptography.HMAC
            {
                /*0x1fc1cac*/ HMACMD5();
                /*0x1fc1d10*/ HMACMD5(byte[] key);
            }

            class HMACRIPEMD160 : System.Security.Cryptography.HMAC
            {
                /*0x1fc1dd4*/ HMACRIPEMD160();
                /*0x1fc1e38*/ HMACRIPEMD160(byte[] key);
            }

            class HMACSHA1 : System.Security.Cryptography.HMAC
            {
                /*0x1fc2018*/ HMACSHA1();
                /*0x1fc2080*/ HMACSHA1(byte[] key);
                /*0x1fc2088*/ HMACSHA1(byte[] key, bool useManagedSha1);
            }

            class HMACSHA256 : System.Security.Cryptography.HMAC
            {
                /*0x1fc214c*/ HMACSHA256();
                /*0x1fc21b0*/ HMACSHA256(byte[] key);
            }

            class HMACSHA384 : System.Security.Cryptography.HMAC
            {
                /*0x61*/ bool m_useLegacyBlockSize;

                /*0x1fc2274*/ HMACSHA384();
                /*0x1fc22d8*/ HMACSHA384(byte[] key);
                /*0x1fc23e8*/ int get_BlockSize();
                /*0x1fc2400*/ bool get_ProduceLegacyHmacValues();
                /*0x1fc2408*/ void set_ProduceLegacyHmacValues(bool value);
            }

            class HMACSHA512 : System.Security.Cryptography.HMAC
            {
                /*0x61*/ bool m_useLegacyBlockSize;

                /*0x1fc2430*/ HMACSHA512();
                /*0x1fc2494*/ HMACSHA512(byte[] key);
                /*0x1fc25a4*/ int get_BlockSize();
                /*0x1fc25bc*/ bool get_ProduceLegacyHmacValues();
                /*0x1fc25c4*/ void set_ProduceLegacyHmacValues(bool value);
            }

            interface ICryptoTransform : System.IDisposable
            {
                int get_InputBlockSize();
                int get_OutputBlockSize();
                bool get_CanTransformMultipleBlocks();
                bool get_CanReuseTransform();
                int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
            }

            class KeyedHashAlgorithm : System.Security.Cryptography.HashAlgorithm
            {
                /*0x28*/ byte[] KeyValue;

                static /*0x1fc27c0*/ System.Security.Cryptography.KeyedHashAlgorithm Create();
                static /*0x1fc2818*/ System.Security.Cryptography.KeyedHashAlgorithm Create(string algName);
                /*0x1fc25ec*/ KeyedHashAlgorithm();
                /*0x1fc25f4*/ void Dispose(bool disposing);
                /*0x1fc263c*/ byte[] get_Key();
                /*0x1fc26b4*/ void set_Key(byte[] value);
            }

            class MACTripleDES : System.Security.Cryptography.KeyedHashAlgorithm
            {
                static int m_bitsPerByte = 8;
                /*0x30*/ System.Security.Cryptography.ICryptoTransform m_encryptor;
                /*0x38*/ System.Security.Cryptography.CryptoStream _cs;
                /*0x40*/ System.Security.Cryptography.TailStream _ts;
                /*0x48*/ int m_bytesPerBlock;
                /*0x50*/ System.Security.Cryptography.TripleDES des;

                /*0x1fc28bc*/ MACTripleDES();
                /*0x1fc2a18*/ MACTripleDES(byte[] rgbKey);
                /*0x1fc2a70*/ MACTripleDES(string strTripleDES, byte[] rgbKey);
                /*0x1fc2c34*/ void Initialize();
                /*0x1fc2c3c*/ System.Security.Cryptography.PaddingMode get_Padding();
                /*0x1fc2c60*/ void set_Padding(System.Security.Cryptography.PaddingMode value);
                /*0x1fc2cf0*/ void HashCore(byte[] rgbData, int ibStart, int cbSize);
                /*0x1fc2ef4*/ byte[] HashFinal();
                /*0x1fc30bc*/ void Dispose(bool disposing);
            }

            class TailStream : System.IO.Stream
            {
                /*0x28*/ byte[] _Buffer;
                /*0x30*/ int _BufferSize;
                /*0x34*/ int _BufferIndex;
                /*0x38*/ bool _BufferFull;

                /*0x1fc2e64*/ TailStream(int bufferSize);
                /*0x1fc31a4*/ void Clear();
                /*0x1fc31b4*/ void Dispose(bool disposing);
                /*0x1fc3044*/ byte[] get_Buffer();
                /*0x1fc3274*/ bool get_CanRead();
                /*0x1fc327c*/ bool get_CanSeek();
                /*0x1fc3284*/ bool get_CanWrite();
                /*0x1fc3294*/ long get_Length();
                /*0x1fc32f4*/ long get_Position();
                /*0x1fc3354*/ void set_Position(long value);
                /*0x1fc33b4*/ void Flush();
                /*0x1fc33b8*/ long Seek(long offset, System.IO.SeekOrigin origin);
                /*0x1fc3418*/ void SetLength(long value);
                /*0x1fc3478*/ int Read(byte[] buffer, int offset, int count);
                /*0x1fc34d8*/ void Write(byte[] buffer, int offset, int count);
            }

            class MaskGenerationMethod
            {
                /*0x1fc364c*/ MaskGenerationMethod();
                byte[] GenerateMask(byte[] rgbSeed, int cbReturn);
            }

            class MD5 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x1fc3674*/ System.Security.Cryptography.MD5 Create();
                static /*0x1fc36d0*/ System.Security.Cryptography.MD5 Create(string algName);
                /*0x1fc3654*/ MD5();
            }

            class PasswordDeriveBytes : System.Security.Cryptography.DeriveBytes
            {
                /*0x10*/ int _extraCount;
                /*0x14*/ int _prefix;
                /*0x18*/ int _iterations;
                /*0x20*/ byte[] _baseValue;
                /*0x28*/ byte[] _extra;
                /*0x30*/ byte[] _salt;
                /*0x38*/ string _hashName;
                /*0x40*/ byte[] _password;
                /*0x48*/ System.Security.Cryptography.HashAlgorithm _hash;

                /*0x1fc3774*/ PasswordDeriveBytes(string strPassword, byte[] rgbSalt);
                /*0x1fc3864*/ PasswordDeriveBytes(byte[] password, byte[] salt);
                /*0x1fc3944*/ PasswordDeriveBytes(string strPassword, byte[] rgbSalt, string strHashName, int iterations);
                /*0x1fc3a84*/ PasswordDeriveBytes(byte[] password, byte[] salt, string hashName, int iterations);
                /*0x1fc37f0*/ PasswordDeriveBytes(string strPassword, byte[] rgbSalt, System.Security.Cryptography.CspParameters cspParams);
                /*0x1fc38e0*/ PasswordDeriveBytes(byte[] password, byte[] salt, System.Security.Cryptography.CspParameters cspParams);
                /*0x1fc39d8*/ PasswordDeriveBytes(string strPassword, byte[] rgbSalt, string strHashName, int iterations, System.Security.Cryptography.CspParameters cspParams);
                /*0x1fc3b10*/ PasswordDeriveBytes(byte[] password, byte[] salt, string hashName, int iterations, System.Security.Cryptography.CspParameters cspParams);
                /*0x1fc3f7c*/ string get_HashName();
                /*0x1fc3df4*/ void set_HashName(string value);
                /*0x1fc3f84*/ int get_IterationCount();
                /*0x1fc3b70*/ void set_IterationCount(int value);
                /*0x1fc3f8c*/ byte[] get_Salt();
                /*0x1fc3c98*/ void set_Salt(byte[] value);
                /*0x1fc4000*/ byte[] GetBytes(int cb);
                /*0x1fc47d0*/ void Reset();
                /*0x1fc47dc*/ void Dispose(bool disposing);
                /*0x1fc4880*/ byte[] CryptDeriveKey(string algname, string alghashname, int keySize, byte[] rgbIV);
                /*0x1fc418c*/ byte[] ComputeBaseValue();
                /*0x1fc4300*/ byte[] ComputeBytes(int cb);
                /*0x1fc4930*/ void HashPrefix(System.Security.Cryptography.CryptoStream cs);
            }

            class PKCS1MaskGenerationMethod : System.Security.Cryptography.MaskGenerationMethod
            {
                /*0x10*/ string HashNameValue;

                /*0x1fc4b28*/ PKCS1MaskGenerationMethod();
                /*0x1fc4b7c*/ string get_HashName();
                /*0x1fc4b84*/ void set_HashName(string value);
                /*0x1fc4bd8*/ byte[] GenerateMask(byte[] rgbSeed, int cbReturn);
            }

            class RandomNumberGenerator : System.IDisposable
            {
                static /*0x1fc4c64*/ System.Security.Cryptography.RandomNumberGenerator Create();
                static /*0x1fc4cc0*/ System.Security.Cryptography.RandomNumberGenerator Create(string rngName);
                static /*0x1fc500c*/ void Fill(System.Span<byte> data);
                static /*0x1fc5010*/ void FillSpan(System.Span<byte> data);
                static /*0x1fc5480*/ int GetInt32(int fromInclusive, int toExclusive);
                static /*0x1fc5614*/ int GetInt32(int toExclusive);
                /*0x1fc4c5c*/ RandomNumberGenerator();
                /*0x1fc4d64*/ void Dispose();
                /*0x1fc4dd0*/ void Dispose(bool disposing);
                void GetBytes(byte[] data);
                /*0x1fc4dd4*/ void GetBytes(byte[] data, int offset, int count);
                /*0x1fc4fcc*/ void GetNonZeroBytes(byte[] data);
                /*0x1fc5088*/ void GetBytes(System.Span<byte> data);
                /*0x1fc5288*/ void GetNonZeroBytes(System.Span<byte> data);
            }

            class RC2 : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;
                /*0x44*/ int EffectiveKeySizeValue;

                static /*0x1fc5afc*/ RC2();
                static /*0x1fc5868*/ System.Security.Cryptography.RC2 Create();
                static /*0x1fc5a58*/ System.Security.Cryptography.RC2 Create(string AlgName);
                /*0x1fc5690*/ RC2();
                /*0x1fc570c*/ int get_EffectiveKeySize();
                /*0x1fc5728*/ void set_EffectiveKeySize(int value);
                /*0x1fc57e4*/ int get_KeySize();
                /*0x1fc57ec*/ void set_KeySize(int value);
            }

            class RC2CryptoServiceProvider : System.Security.Cryptography.RC2
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;
                /*0x48*/ bool m_use40bitSalt;

                static /*0x1fc5fc8*/ RC2CryptoServiceProvider();
                /*0x1fc58c0*/ RC2CryptoServiceProvider();
                /*0x1fc5c4c*/ int get_EffectiveKeySize();
                /*0x1fc5c54*/ void set_EffectiveKeySize(int value);
                /*0x1fc5ccc*/ bool get_UseSalt();
                /*0x1fc5cd4*/ void set_UseSalt(bool value);
                /*0x1fc5ce0*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1fc5db4*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1fc5e88*/ void GenerateKey();
                /*0x1fc5f30*/ void GenerateIV();
            }

            class Rijndael : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;

                static /*0x1fc6300*/ Rijndael();
                static /*0x1fc6124*/ System.Security.Cryptography.Rijndael Create();
                static /*0x1fc625c*/ System.Security.Cryptography.Rijndael Create(string algName);
                /*0x1fc60a8*/ Rijndael();
            }

            class RijndaelManaged : System.Security.Cryptography.Rijndael
            {
                /*0x1fc617c*/ RijndaelManaged();
                /*0x1fc6450*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1fc6594*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1fc65a8*/ void GenerateKey();
                /*0x1fc6618*/ void GenerateIV();
                /*0x1fc6464*/ System.Security.Cryptography.ICryptoTransform NewEncryptor(byte[] rgbKey, System.Security.Cryptography.CipherMode mode, byte[] rgbIV, int feedbackSize, System.Security.Cryptography.RijndaelManagedTransformMode encryptMode);
            }

            enum RijndaelManagedTransformMode
            {
                Encrypt = 0,
                Decrypt = 1,
            }

            class RijndaelManagedTransform : System.Security.Cryptography.ICryptoTransform, System.IDisposable
            {
                static /*0x0*/ byte[] s_Sbox;
                static /*0x8*/ int[] s_Rcon;
                static /*0x10*/ int[] s_T;
                static /*0x18*/ int[] s_TF;
                static /*0x20*/ int[] s_iT;
                static /*0x28*/ int[] s_iTF;
                /*0x10*/ System.Security.Cryptography.CipherMode m_cipherMode;
                /*0x14*/ System.Security.Cryptography.PaddingMode m_paddingValue;
                /*0x18*/ System.Security.Cryptography.RijndaelManagedTransformMode m_transformMode;
                /*0x1c*/ int m_blockSizeBits;
                /*0x20*/ int m_blockSizeBytes;
                /*0x24*/ int m_inputBlockSize;
                /*0x28*/ int m_outputBlockSize;
                /*0x30*/ int[] m_encryptKeyExpansion;
                /*0x38*/ int[] m_decryptKeyExpansion;
                /*0x40*/ int m_Nr;
                /*0x44*/ int m_Nb;
                /*0x48*/ int m_Nk;
                /*0x50*/ int[] m_encryptindex;
                /*0x58*/ int[] m_decryptindex;
                /*0x60*/ int[] m_IV;
                /*0x68*/ int[] m_lastBlockBuffer;
                /*0x70*/ byte[] m_depadBuffer;
                /*0x78*/ byte[] m_shiftRegister;

                static /*0x1fc93f4*/ RijndaelManagedTransform();
                static /*0x1fc93ec*/ int rot1(int val);
                static /*0x1fc93e4*/ int rot2(int val);
                static /*0x1fc92f4*/ int rot3(int val);
                static /*0x1fc92fc*/ int SubWord(int a);
                static /*0x1fc93c0*/ int MulX(int x);
                /*0x1fc6688*/ RijndaelManagedTransform(byte[] rgbKey, System.Security.Cryptography.CipherMode mode, byte[] rgbIV, int blockSize, int feedbackSize, System.Security.Cryptography.PaddingMode PaddingValue, System.Security.Cryptography.RijndaelManagedTransformMode transformMode);
                /*0x1fc95e0*/ RijndaelManagedTransform();
                /*0x1fc71f4*/ void Dispose();
                /*0x1fc72b8*/ void Clear();
                /*0x1fc71fc*/ void Dispose(bool disposing);
                /*0x1fc72c0*/ int get_BlockSizeValue();
                /*0x1fc72c8*/ int get_InputBlockSize();
                /*0x1fc72d0*/ int get_OutputBlockSize();
                /*0x1fc72d8*/ bool get_CanTransformMultipleBlocks();
                /*0x1fc72e0*/ bool get_CanReuseTransform();
                /*0x1fc72e8*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1fc8c00*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1fc8ee8*/ void Reset();
                /*0x1fc75c0*/ int EncryptData(byte[] inputBuffer, int inputOffset, int inputCount, ref byte[] outputBuffer, int outputOffset, System.Security.Cryptography.PaddingMode paddingMode, bool fLast);
                /*0x1fc8194*/ int DecryptData(byte[] inputBuffer, int inputOffset, int inputCount, ref byte[] outputBuffer, int outputOffset, System.Security.Cryptography.PaddingMode paddingMode, bool fLast);
                /*0x1fc8f50*/ void Enc(int* encryptindex, int* encryptKeyExpansion, int* T, int* TF, int* work, int* temp);
                /*0x1fc9114*/ void Dec(int* decryptindex, int* decryptKeyExpansion, int* iT, int* iTF, int* work, int* temp);
                /*0x1fc6c98*/ void GenerateKeyExpansion(byte[] rgbKey);
            }

            class RIPEMD160 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x1fc9638*/ System.Security.Cryptography.RIPEMD160 Create();
                static /*0x1fc9690*/ System.Security.Cryptography.RIPEMD160 Create(string hashName);
                /*0x1fc9618*/ RIPEMD160();
            }

            class RIPEMD160Managed : System.Security.Cryptography.RIPEMD160
            {
                /*0x28*/ byte[] _buffer;
                /*0x30*/ long _count;
                /*0x38*/ uint[] _stateMD160;
                /*0x40*/ uint[] _blockDWords;

                static /*0x1fc9b50*/ void MDTransform(uint* blockDWords, uint* state, byte* block);
                static /*0x1fcb290*/ uint F(uint x, uint y, uint z);
                static /*0x1fcb29c*/ uint G(uint x, uint y, uint z);
                static /*0x1fcb2ac*/ uint H(uint x, uint y, uint z);
                static /*0x1fcb2b8*/ uint I(uint x, uint y, uint z);
                static /*0x1fcb2c8*/ uint J(uint x, uint y, uint z);
                /*0x1fc1ef4*/ RIPEMD160Managed();
                /*0x1fc97b8*/ void Initialize();
                /*0x1fc97fc*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x1fc997c*/ byte[] HashFinal();
                /*0x1fc9734*/ void InitializeState();
                /*0x1fc9800*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x1fc9980*/ byte[] _EndHash();
            }

            struct RSAParameters
            {
                /*0x10*/ byte[] Exponent;
                /*0x18*/ byte[] Modulus;
                /*0x20*/ byte[] P;
                /*0x28*/ byte[] Q;
                /*0x30*/ byte[] DP;
                /*0x38*/ byte[] DQ;
                /*0x40*/ byte[] InverseQ;
                /*0x48*/ byte[] D;
            }

            class RSA : System.Security.Cryptography.AsymmetricAlgorithm
            {
                static /*0x1fcb2dc*/ System.Security.Cryptography.RSA Create();
                static /*0x1fcb37c*/ System.Security.Cryptography.RSA Create(string algName);
                static /*0x1fcb444*/ System.Exception DerivedClassMustOverride();
                static /*0x1fcb7c8*/ System.Exception HashAlgorithmNameNullOrEmpty();
                static /*0x1fcc944*/ System.Security.Cryptography.RSA Create(int keySizeInBits);
                static /*0x1fcca10*/ System.Security.Cryptography.RSA Create(System.Security.Cryptography.RSAParameters parameters);
                /*0x1fcb2d4*/ RSA();
                /*0x1fcb420*/ byte[] Encrypt(byte[] data, System.Security.Cryptography.RSAEncryptionPadding padding);
                /*0x1fcb4cc*/ byte[] Decrypt(byte[] data, System.Security.Cryptography.RSAEncryptionPadding padding);
                /*0x1fcb4f0*/ byte[] SignHash(byte[] hash, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcb514*/ bool VerifyHash(byte[] hash, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcb538*/ byte[] HashData(byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fcb55c*/ byte[] HashData(System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fcb580*/ byte[] SignData(byte[] data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcb5f8*/ byte[] SignData(byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcb868*/ byte[] SignData(System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcb9a8*/ bool VerifyData(byte[] data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcba24*/ bool VerifyData(byte[] data, int offset, int count, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcbc2c*/ bool VerifyData(System.IO.Stream data, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcbda4*/ byte[] DecryptValue(byte[] rgb);
                /*0x1fcbe04*/ byte[] EncryptValue(byte[] rgb);
                /*0x1fcbe64*/ string get_KeyExchangeAlgorithm();
                /*0x1fcbea4*/ string get_SignatureAlgorithm();
                /*0x1fcbee4*/ void FromXmlString(string xmlString);
                /*0x1fcc504*/ string ToXmlString(bool includePrivateParameters);
                System.Security.Cryptography.RSAParameters ExportParameters(bool includePrivateParameters);
                void ImportParameters(System.Security.Cryptography.RSAParameters parameters);
                /*0x1fccb08*/ bool TryDecrypt(System.ReadOnlySpan<byte> data, System.Span<byte> destination, System.Security.Cryptography.RSAEncryptionPadding padding, ref int bytesWritten);
                /*0x1fccc1c*/ bool TryEncrypt(System.ReadOnlySpan<byte> data, System.Span<byte> destination, System.Security.Cryptography.RSAEncryptionPadding padding, ref int bytesWritten);
                /*0x1fccd30*/ bool TryHashData(System.ReadOnlySpan<byte> data, System.Span<byte> destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, ref int bytesWritten);
                /*0x1fccf90*/ bool TrySignHash(System.ReadOnlySpan<byte> hash, System.Span<byte> destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding, ref int bytesWritten);
                /*0x1fcd0b4*/ bool TrySignData(System.ReadOnlySpan<byte> data, System.Span<byte> destination, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding, ref int bytesWritten);
                /*0x1fcd2a0*/ bool VerifyData(System.ReadOnlySpan<byte> data, System.ReadOnlySpan<byte> signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcd5d8*/ bool VerifyHash(System.ReadOnlySpan<byte> hash, System.ReadOnlySpan<byte> signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fcd67c*/ byte[] ExportRSAPrivateKey();
                /*0x1fcd6bc*/ byte[] ExportRSAPublicKey();
                /*0x1fcd6fc*/ void ImportRSAPrivateKey(System.ReadOnlySpan<byte> source, ref int bytesRead);
                /*0x1fcd73c*/ void ImportRSAPublicKey(System.ReadOnlySpan<byte> source, ref int bytesRead);
                /*0x1fcd77c*/ bool TryExportRSAPrivateKey(System.Span<byte> destination, ref int bytesWritten);
                /*0x1fcd7bc*/ bool TryExportRSAPublicKey(System.Span<byte> destination, ref int bytesWritten);
            }

            class RSACryptoServiceProvider : System.Security.Cryptography.RSA, System.Security.Cryptography.ICspAsymmetricAlgorithm
            {
                static int PROV_RSA_FULL = 1;
                static int AT_KEYEXCHANGE = 1;
                static int AT_SIGNATURE = 2;
                static /*0x0*/ System.Security.Cryptography.CspProviderFlags s_UseMachineKeyStore;
                /*0x20*/ Mono.Security.Cryptography.KeyPairPersistence store;
                /*0x28*/ bool persistKey;
                /*0x29*/ bool persisted;
                /*0x2a*/ bool privateKeyExportable;
                /*0x2b*/ bool m_disposed;
                /*0x30*/ Mono.Security.Cryptography.RSAManaged rsa;

                static /*0x1fcd83c*/ bool get_UseMachineKeyStore();
                static /*0x1fcd890*/ void set_UseMachineKeyStore(bool value);
                static /*0x1fcd954*/ int GetAlgorithmId(System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                static /*0x1fcdd7c*/ System.Exception PaddingModeNotSupported();
                static /*0x1fcf724*/ System.Security.Cryptography.HashAlgorithm InternalHashToHashAlgorithm(int calgHash);
                /*0x1fcb350*/ RSACryptoServiceProvider();
                /*0x1fce690*/ RSACryptoServiceProvider(System.Security.Cryptography.CspParameters parameters);
                /*0x1fce658*/ RSACryptoServiceProvider(int dwKeySize);
                /*0x1fce69c*/ RSACryptoServiceProvider(int dwKeySize, System.Security.Cryptography.CspParameters parameters);
                /*0x1fcd7fc*/ string get_SignatureAlgorithm();
                /*0x1fcd8e4*/ byte[] HashData(byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fcd928*/ byte[] HashData(System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1fcdb00*/ byte[] Encrypt(byte[] data, System.Security.Cryptography.RSAEncryptionPadding padding);
                /*0x1fcde04*/ byte[] Decrypt(byte[] data, System.Security.Cryptography.RSAEncryptionPadding padding);
                /*0x1fce208*/ byte[] SignHash(byte[] hash, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fce410*/ bool VerifyHash(byte[] hash, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);
                /*0x1fce6f8*/ void Common(int dwKeySize, bool parameters);
                /*0x1fce914*/ void Common(System.Security.Cryptography.CspParameters p);
                /*0x1fcea34*/ void Finalize();
                /*0x1fcead4*/ string get_KeyExchangeAlgorithm();
                /*0x1fceb14*/ int get_KeySize();
                /*0x1fceb34*/ bool get_PersistKeyInCsp();
                /*0x1fceb3c*/ void set_PersistKeyInCsp(bool value);
                /*0x1fcebd4*/ bool get_PublicOnly();
                /*0x1fcdfc4*/ byte[] Decrypt(byte[] rgb, bool fOAEP);
                /*0x1fcece8*/ byte[] DecryptValue(byte[] rgb);
                /*0x1fcdcc0*/ byte[] Encrypt(byte[] rgb, bool fOAEP);
                /*0x1fced80*/ byte[] EncryptValue(byte[] rgb);
                /*0x1fceda4*/ System.Security.Cryptography.RSAParameters ExportParameters(bool includePrivateParameters);
                /*0x1fceee8*/ void ImportParameters(System.Security.Cryptography.RSAParameters parameters);
                /*0x1fcef3c*/ System.Security.Cryptography.HashAlgorithm GetHash(object halg);
                /*0x1fcf188*/ System.Security.Cryptography.HashAlgorithm GetHashFromString(string name);
                /*0x1fcf474*/ byte[] SignData(byte[] buffer, object halg);
                /*0x1fcf590*/ byte[] SignData(System.IO.Stream inputStream, object halg);
                /*0x1fcf4dc*/ byte[] SignData(byte[] buffer, int offset, int count, object halg);
                /*0x1fcf2a8*/ string GetHashNameFromOID(string oid);
                /*0x1fcf62c*/ byte[] SignHash(byte[] rgbHash, string str);
                /*0x1fce390*/ byte[] SignHash(byte[] rgbHash, int calgHash);
                /*0x1fcf7f4*/ bool VerifyData(byte[] buffer, object halg, byte[] signature);
                /*0x1fcf910*/ bool VerifyHash(byte[] rgbHash, string str, byte[] rgbSignature);
                /*0x1fce5c8*/ bool VerifyHash(byte[] rgbHash, int calgHash, byte[] rgbSignature);
                /*0x1fcfa38*/ void Dispose(bool disposing);
                /*0x1fceb50*/ void OnKeyGenerated(object sender, System.EventArgs e);
                /*0x1fcfa8c*/ System.Security.Cryptography.CspKeyContainerInfo get_CspKeyContainerInfo();
                /*0x1fcfb08*/ byte[] ExportCspBlob(bool includePrivateParameters);
                /*0x1fcfb8c*/ void ImportCspBlob(byte[] keyBlob);
            }

            class RSAOAEPKeyExchangeDeformatter : System.Security.Cryptography.AsymmetricKeyExchangeDeformatter
            {
                /*0x10*/ System.Security.Cryptography.RSA _rsaKey;
                /*0x18*/ System.Nullable<bool> _rsaOverridesDecrypt;

                /*0x1fcfe7c*/ RSAOAEPKeyExchangeDeformatter();
                /*0x1fcebf0*/ RSAOAEPKeyExchangeDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fcfe84*/ string get_Parameters();
                /*0x1fcfe8c*/ void set_Parameters(string value);
                /*0x1fcfe90*/ byte[] DecryptKeyExchange(byte[] rgbData);
                /*0x1fd0228*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fd0034*/ bool get_OverridesDecrypt();
            }

            class RSAOAEPKeyExchangeFormatter : System.Security.Cryptography.AsymmetricKeyExchangeFormatter
            {
                /*0x10*/ byte[] ParameterValue;
                /*0x18*/ System.Security.Cryptography.RSA _rsaKey;
                /*0x20*/ System.Nullable<bool> _rsaOverridesEncrypt;
                /*0x28*/ System.Security.Cryptography.RandomNumberGenerator RngValue;

                /*0x1fe9fa4*/ RSAOAEPKeyExchangeFormatter();
                /*0x1fe9fac*/ RSAOAEPKeyExchangeFormatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fea0a4*/ byte[] get_Parameter();
                /*0x1fea118*/ void set_Parameter(byte[] value);
                /*0x1fea1c0*/ string get_Parameters();
                /*0x1fea1c8*/ System.Security.Cryptography.RandomNumberGenerator get_Rng();
                /*0x1fea1d0*/ void set_Rng(System.Security.Cryptography.RandomNumberGenerator value);
                /*0x1fea1d8*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fea2c8*/ byte[] CreateKeyExchange(byte[] rgbData);
                /*0x1fea740*/ byte[] CreateKeyExchange(byte[] rgbData, System.Type symAlgType);
                /*0x1fea474*/ bool get_OverridesEncrypt();
            }

            class RSAPKCS1KeyExchangeDeformatter : System.Security.Cryptography.AsymmetricKeyExchangeDeformatter
            {
                /*0x10*/ System.Security.Cryptography.RSA _rsaKey;
                /*0x18*/ System.Nullable<bool> _rsaOverridesDecrypt;
                /*0x20*/ System.Security.Cryptography.RandomNumberGenerator RngValue;

                /*0x1fea844*/ RSAPKCS1KeyExchangeDeformatter();
                /*0x1fea84c*/ RSAPKCS1KeyExchangeDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fea944*/ System.Security.Cryptography.RandomNumberGenerator get_RNG();
                /*0x1fea94c*/ void set_RNG(System.Security.Cryptography.RandomNumberGenerator value);
                /*0x1fea954*/ string get_Parameters();
                /*0x1fea95c*/ void set_Parameters(string value);
                /*0x1fea960*/ byte[] DecryptKeyExchange(byte[] rgbIn);
                /*0x1fead34*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1feab44*/ bool get_OverridesDecrypt();
            }

            class RSAPKCS1KeyExchangeFormatter : System.Security.Cryptography.AsymmetricKeyExchangeFormatter
            {
                /*0x10*/ System.Security.Cryptography.RandomNumberGenerator RngValue;
                /*0x18*/ System.Security.Cryptography.RSA _rsaKey;
                /*0x20*/ System.Nullable<bool> _rsaOverridesEncrypt;

                /*0x1feae24*/ RSAPKCS1KeyExchangeFormatter();
                /*0x1feae2c*/ RSAPKCS1KeyExchangeFormatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1feaf24*/ string get_Parameters();
                /*0x1feaf64*/ System.Security.Cryptography.RandomNumberGenerator get_Rng();
                /*0x1feaf6c*/ void set_Rng(System.Security.Cryptography.RandomNumberGenerator value);
                /*0x1feaf74*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1feb064*/ byte[] CreateKeyExchange(byte[] rgbData);
                /*0x1feb578*/ byte[] CreateKeyExchange(byte[] rgbData, System.Type symAlgType);
                /*0x1feb388*/ bool get_OverridesEncrypt();
            }

            class SHA1 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x1fea664*/ System.Security.Cryptography.SHA1 Create();
                static /*0x1feb5a4*/ System.Security.Cryptography.SHA1 Create(string hashName);
                /*0x1feb584*/ SHA1();
            }

            class SHA1Managed : System.Security.Cryptography.SHA1
            {
                /*0x28*/ byte[] _buffer;
                /*0x30*/ long _count;
                /*0x38*/ uint[] _stateSHA1;
                /*0x40*/ uint[] _expandedBuffer;

                static /*0x1febb84*/ void SHATransform(uint* expandedBuffer, uint* state, byte* block);
                static /*0x1fec0fc*/ void SHAExpand(uint* x);
                /*0x1feb69c*/ SHA1Managed();
                /*0x1feb7f0*/ void Initialize();
                /*0x1feb834*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x1feb9b4*/ byte[] HashFinal();
                /*0x1feb76c*/ void InitializeState();
                /*0x1feb838*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x1feb9b8*/ byte[] _EndHash();
            }

            class SHA256 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x1fec158*/ System.Security.Cryptography.SHA256 Create();
                static /*0x1fec278*/ System.Security.Cryptography.SHA256 Create(string hashName);
                /*0x1fec138*/ SHA256();
            }

            class SHA256Managed : System.Security.Cryptography.SHA256
            {
                static /*0x0*/ uint[] _K;
                /*0x28*/ byte[] _buffer;
                /*0x30*/ long _count;
                /*0x38*/ uint[] _stateSHA256;
                /*0x40*/ uint[] _W;

                static /*0x1fecf8c*/ SHA256Managed();
                static /*0x1fec7bc*/ void SHATransform(uint* expandedBuffer, uint* state, byte* block);
                static /*0x1fececc*/ uint RotateRight(uint x, int n);
                static /*0x1fece4c*/ uint Ch(uint x, uint y, uint z);
                static /*0x1feceb8*/ uint Maj(uint x, uint y, uint z);
                static /*0x1feced4*/ uint sigma_0(uint x);
                static /*0x1fecf30*/ uint sigma_1(uint x);
                static /*0x1fece5c*/ uint Sigma_0(uint x);
                static /*0x1fecdf0*/ uint Sigma_1(uint x);
                static /*0x1fecd48*/ void SHA256Expand(uint* x);
                /*0x1fec1b0*/ SHA256Managed();
                /*0x1fec3d8*/ void Initialize();
                /*0x1fec41c*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x1fec5ec*/ byte[] HashFinal();
                /*0x1fec318*/ void InitializeState();
                /*0x1fec420*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x1fec5f0*/ byte[] _EndHash();
            }

            class SHA384 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x1fed040*/ System.Security.Cryptography.SHA384 Create();
                static /*0x1fed160*/ System.Security.Cryptography.SHA384 Create(string hashName);
                /*0x1fed020*/ SHA384();
            }

            class SHA384Managed : System.Security.Cryptography.SHA384
            {
                static /*0x0*/ ulong[] _K;
                /*0x28*/ byte[] _buffer;
                /*0x30*/ ulong _count;
                /*0x38*/ ulong[] _stateSHA384;
                /*0x40*/ ulong[] _W;

                static /*0x1fee0e8*/ SHA384Managed();
                static /*0x1fed6e4*/ void SHATransform(ulong* expandedBuffer, ulong* state, byte* block);
                static /*0x1fee028*/ ulong RotateRight(ulong x, int n);
                static /*0x1fedfa8*/ ulong Ch(ulong x, ulong y, ulong z);
                static /*0x1fee014*/ ulong Maj(ulong x, ulong y, ulong z);
                static /*0x1fedfb8*/ ulong Sigma_0(ulong x);
                static /*0x1fedf4c*/ ulong Sigma_1(ulong x);
                static /*0x1fee030*/ ulong sigma_0(ulong x);
                static /*0x1fee08c*/ ulong sigma_1(ulong x);
                static /*0x1fedea4*/ void SHA384Expand(ulong* x);
                /*0x1fed098*/ SHA384Managed();
                /*0x1fed300*/ void Initialize();
                /*0x1fed344*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x1fed514*/ byte[] HashFinal();
                /*0x1fed200*/ void InitializeState();
                /*0x1fed348*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x1fed518*/ byte[] _EndHash();
            }

            class SHA512 : System.Security.Cryptography.HashAlgorithm
            {
                static /*0x1fee19c*/ System.Security.Cryptography.SHA512 Create();
                static /*0x1fee2bc*/ System.Security.Cryptography.SHA512 Create(string hashName);
                /*0x1fee17c*/ SHA512();
            }

            class SHA512Managed : System.Security.Cryptography.SHA512
            {
                static /*0x0*/ ulong[] _K;
                /*0x28*/ byte[] _buffer;
                /*0x30*/ ulong _count;
                /*0x38*/ ulong[] _stateSHA512;
                /*0x40*/ ulong[] _W;

                static /*0x1fef008*/ SHA512Managed();
                static /*0x1fee840*/ void SHATransform(ulong* expandedBuffer, ulong* state, byte* block);
                static /*0x1feef48*/ ulong RotateRight(ulong x, int n);
                static /*0x1feeec8*/ ulong Ch(ulong x, ulong y, ulong z);
                static /*0x1feef34*/ ulong Maj(ulong x, ulong y, ulong z);
                static /*0x1feeed8*/ ulong Sigma_0(ulong x);
                static /*0x1feee6c*/ ulong Sigma_1(ulong x);
                static /*0x1feef50*/ ulong sigma_0(ulong x);
                static /*0x1feefac*/ ulong sigma_1(ulong x);
                static /*0x1feedc4*/ void SHA512Expand(ulong* x);
                /*0x1fee1f4*/ SHA512Managed();
                /*0x1fee45c*/ void Initialize();
                /*0x1fee4a0*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x1fee670*/ byte[] HashFinal();
                /*0x1fee35c*/ void InitializeState();
                /*0x1fee4a4*/ void _HashData(byte[] partIn, int ibStart, int cbSize);
                /*0x1fee674*/ byte[] _EndHash();
            }

            class SignatureDescription
            {
                /*0x10*/ string _strKey;
                /*0x18*/ string _strDigest;
                /*0x20*/ string _strFormatter;
                /*0x28*/ string _strDeformatter;

                /*0x1fef09c*/ SignatureDescription();
                /*0x1fef0a4*/ SignatureDescription(System.Security.SecurityElement el);
                /*0x1fef1d8*/ string get_KeyAlgorithm();
                /*0x1fef1e0*/ void set_KeyAlgorithm(string value);
                /*0x1fef1e8*/ string get_DigestAlgorithm();
                /*0x1fef1f0*/ void set_DigestAlgorithm(string value);
                /*0x1fef1f8*/ string get_FormatterAlgorithm();
                /*0x1fef200*/ void set_FormatterAlgorithm(string value);
                /*0x1fef208*/ string get_DeformatterAlgorithm();
                /*0x1fef210*/ void set_DeformatterAlgorithm(string value);
                /*0x1fef218*/ System.Security.Cryptography.AsymmetricSignatureDeformatter CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fef2e8*/ System.Security.Cryptography.AsymmetricSignatureFormatter CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fef3b8*/ System.Security.Cryptography.HashAlgorithm CreateDigest();
            }

            class RSAPKCS1SignatureDescription : System.Security.Cryptography.SignatureDescription
            {
                /*0x30*/ string _hashAlgorithm;

                /*0x1fef45c*/ RSAPKCS1SignatureDescription(string hashAlgorithm, string digestAlgorithm);
                /*0x1fef500*/ System.Security.Cryptography.AsymmetricSignatureDeformatter CreateDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1fef53c*/ System.Security.Cryptography.AsymmetricSignatureFormatter CreateFormatter(System.Security.Cryptography.AsymmetricAlgorithm key);
            }

            class RSAPKCS1SHA1SignatureDescription : System.Security.Cryptography.RSAPKCS1SignatureDescription
            {
                /*0x1fef578*/ RSAPKCS1SHA1SignatureDescription();
            }

            class RSAPKCS1SHA256SignatureDescription : System.Security.Cryptography.RSAPKCS1SignatureDescription
            {
                /*0x1fef5e0*/ RSAPKCS1SHA256SignatureDescription();
            }

            class RSAPKCS1SHA384SignatureDescription : System.Security.Cryptography.RSAPKCS1SignatureDescription
            {
                /*0x1fef648*/ RSAPKCS1SHA384SignatureDescription();
            }

            class RSAPKCS1SHA512SignatureDescription : System.Security.Cryptography.RSAPKCS1SignatureDescription
            {
                /*0x1fef6b0*/ RSAPKCS1SHA512SignatureDescription();
            }

            class DSASignatureDescription : System.Security.Cryptography.SignatureDescription
            {
                /*0x1fef718*/ DSASignatureDescription();
            }

            class SymmetricAlgorithm : System.IDisposable
            {
                /*0x10*/ int BlockSizeValue;
                /*0x14*/ int FeedbackSizeValue;
                /*0x18*/ byte[] IVValue;
                /*0x20*/ byte[] KeyValue;
                /*0x28*/ System.Security.Cryptography.KeySizes[] LegalBlockSizesValue;
                /*0x30*/ System.Security.Cryptography.KeySizes[] LegalKeySizesValue;
                /*0x38*/ int KeySizeValue;
                /*0x3c*/ System.Security.Cryptography.CipherMode ModeValue;
                /*0x40*/ System.Security.Cryptography.PaddingMode PaddingValue;

                static /*0x1ff01dc*/ System.Security.Cryptography.SymmetricAlgorithm Create();
                static /*0x1ff0238*/ System.Security.Cryptography.SymmetricAlgorithm Create(string algName);
                /*0x1fef7d0*/ SymmetricAlgorithm();
                /*0x1fef7f4*/ void Dispose();
                /*0x1fef860*/ void Clear();
                /*0x1fef8f4*/ void Dispose(bool disposing);
                /*0x1fef940*/ int get_BlockSize();
                /*0x1fef948*/ void set_BlockSize(int value);
                /*0x1fefa38*/ int get_FeedbackSize();
                /*0x1fefa40*/ void set_FeedbackSize(int value);
                /*0x1fefacc*/ byte[] get_IV();
                /*0x1fefb60*/ void set_IV(byte[] value);
                /*0x1fefcc8*/ byte[] get_Key();
                /*0x1fefd5c*/ void set_Key(byte[] value);
                /*0x1feff58*/ System.Security.Cryptography.KeySizes[] get_LegalBlockSizes();
                /*0x1feffd0*/ System.Security.Cryptography.KeySizes[] get_LegalKeySizes();
                /*0x1ff0048*/ int get_KeySize();
                /*0x1ff0050*/ void set_KeySize(int value);
                /*0x1ff00d4*/ System.Security.Cryptography.CipherMode get_Mode();
                /*0x1ff00dc*/ void set_Mode(System.Security.Cryptography.CipherMode value);
                /*0x1ff0158*/ System.Security.Cryptography.PaddingMode get_Padding();
                /*0x1ff0160*/ void set_Padding(System.Security.Cryptography.PaddingMode value);
                /*0x1fefebc*/ bool ValidKeySize(int bitLength);
                /*0x1ff02d8*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor();
                System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1ff0328*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor();
                System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                void GenerateKey();
                void GenerateIV();
            }

            class TripleDES : System.Security.Cryptography.SymmetricAlgorithm
            {
                static /*0x0*/ System.Security.Cryptography.KeySizes[] s_legalBlockSizes;
                static /*0x8*/ System.Security.Cryptography.KeySizes[] s_legalKeySizes;

                static /*0x1ff0c14*/ TripleDES();
                static /*0x1ff080c*/ System.Security.Cryptography.TripleDES Create();
                static /*0x1ff08e8*/ System.Security.Cryptography.TripleDES Create(string str);
                static /*0x1ff04c8*/ bool IsWeakKey(byte[] rgbKey);
                static /*0x1ff0a74*/ bool EqualBytes(byte[] rgbKey, int start1, int start2, int count);
                static /*0x1ff0988*/ bool IsLegalKeySize(byte[] rgbKey);
                /*0x1ff0378*/ TripleDES();
                /*0x1ff0400*/ byte[] get_Key();
                /*0x1ff0628*/ void set_Key(byte[] value);
            }

            class TripleDESCryptoServiceProvider : System.Security.Cryptography.TripleDES
            {
                /*0x1ff0864*/ TripleDESCryptoServiceProvider();
                /*0x1ff0d6c*/ System.Security.Cryptography.ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1ff0e84*/ System.Security.Cryptography.ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);
                /*0x1ff0f9c*/ void GenerateKey();
                /*0x1ff1174*/ void GenerateIV();
            }

            enum CspAlgorithmType
            {
                Rsa = 0,
                Dss = 1,
            }

            class Constants
            {
                static int S_OK = 0;
                static int NTE_FILENOTFOUND = -2147024894;
                static int NTE_NO_KEY = -2146893811;
                static int NTE_BAD_KEYSET = -2146893802;
                static int NTE_KEYSET_NOT_DEF = -2146893799;
                static int KP_IV = 1;
                static int KP_MODE = 4;
                static int KP_MODE_BITS = 5;
                static int KP_EFFECTIVE_KEYLEN = 19;
                static int ALG_CLASS_SIGNATURE = 8192;
                static int ALG_CLASS_DATA_ENCRYPT = 24576;
                static int ALG_CLASS_HASH = 32768;
                static int ALG_CLASS_KEY_EXCHANGE = 40960;
                static int ALG_TYPE_DSS = 512;
                static int ALG_TYPE_RSA = 1024;
                static int ALG_TYPE_BLOCK = 1536;
                static int ALG_TYPE_STREAM = 2048;
                static int ALG_TYPE_ANY = 0;
                static int CALG_MD5 = 32771;
                static int CALG_SHA1 = 32772;
                static int CALG_SHA_256 = 32780;
                static int CALG_SHA_384 = 32781;
                static int CALG_SHA_512 = 32782;
                static int CALG_RSA_KEYX = 41984;
                static int CALG_RSA_SIGN = 9216;
                static int CALG_DSS_SIGN = 8704;
                static int CALG_DES = 26113;
                static int CALG_RC2 = 26114;
                static int CALG_3DES = 26115;
                static int CALG_3DES_112 = 26121;
                static int CALG_AES_128 = 26126;
                static int CALG_AES_192 = 26127;
                static int CALG_AES_256 = 26128;
                static int CALG_RC4 = 26625;
                static int PROV_RSA_FULL = 1;
                static int PROV_DSS_DH = 13;
                static int PROV_RSA_AES = 24;
                static int AT_KEYEXCHANGE = 1;
                static int AT_SIGNATURE = 2;
                static int PUBLICKEYBLOB = 6;
                static int PRIVATEKEYBLOB = 7;
                static int CRYPT_OAEP = 64;
                static uint CRYPT_VERIFYCONTEXT = 4026531840;
                static uint CRYPT_NEWKEYSET = 8;
                static uint CRYPT_DELETEKEYSET = 16;
                static uint CRYPT_MACHINE_KEYSET = 32;
                static uint CRYPT_SILENT = 64;
                static uint CRYPT_EXPORTABLE = 1;
                static uint CLR_KEYLEN = 1;
                static uint CLR_PUBLICKEYONLY = 2;
                static uint CLR_EXPORTABLE = 3;
                static uint CLR_REMOVABLE = 4;
                static uint CLR_HARDWARE = 5;
                static uint CLR_ACCESSIBLE = 6;
                static uint CLR_PROTECTED = 7;
                static uint CLR_UNIQUE_CONTAINER = 8;
                static uint CLR_ALGID = 9;
                static uint CLR_PP_CLIENT_HWND = 10;
                static uint CLR_PP_PIN = 11;
                static string OID_RSA_SMIMEalgCMS3DESwrap = "1.2.840.113549.1.9.16.3.6";
                static string OID_RSA_MD5 = "1.2.840.113549.2.5";
                static string OID_RSA_RC2CBC = "1.2.840.113549.3.2";
                static string OID_RSA_DES_EDE3_CBC = "1.2.840.113549.3.7";
                static string OID_OIWSEC_desCBC = "1.3.14.3.2.7";
                static string OID_OIWSEC_SHA1 = "1.3.14.3.2.26";
                static string OID_OIWSEC_SHA256 = "2.16.840.1.101.3.4.2.1";
                static string OID_OIWSEC_SHA384 = "2.16.840.1.101.3.4.2.2";
                static string OID_OIWSEC_SHA512 = "2.16.840.1.101.3.4.2.3";
                static string OID_OIWSEC_RIPEMD160 = "1.3.36.3.2.1";
            }

            class Utils
            {
                static int DefaultRsaProviderType = 1;
                static /*0x0*/ System.Security.Cryptography.RNGCryptoServiceProvider _rng;

                static /*0x1ff1208*/ Utils();
                static /*0x1ff10a0*/ System.Security.Cryptography.RNGCryptoServiceProvider get_StaticRandomNumberGenerator();
                static /*0x1ff120c*/ byte[] GenerateRandom(int keySize);
                static /*0x1ff0d64*/ bool HasAlgorithm(int dwCalg, int dwKeySize);
                static /*0x1ff12ac*/ string DiscardWhiteSpaces(string inputBuffer);
                static /*0x1ff1314*/ string DiscardWhiteSpaces(string inputBuffer, int inputOffset, int inputCount);
                static /*0x1ff149c*/ int ConvertByteArrayToInt(byte[] input);
                static /*0x1ff14fc*/ byte[] ConvertIntToByteArray(int dwInput);
                static /*0x1ff161c*/ void ConvertIntToByteArray(uint dwInput, ref byte[] counter);
                static /*0x1ff09ac*/ byte[] FixupKeyParity(byte[] key);
                static /*0x1ff168c*/ void DWORDFromLittleEndian(uint* x, int digits, byte* block);
                static /*0x1ff16d8*/ void DWORDToLittleEndian(byte[] block, uint[] x, int digits);
                static /*0x1fec0ac*/ void DWORDFromBigEndian(uint* x, int digits, byte* block);
                static /*0x1febfb8*/ void DWORDToBigEndian(byte[] block, uint[] x, int digits);
                static /*0x1fede24*/ void QuadWordFromBigEndian(ulong* x, int digits, byte* block);
                static /*0x1fedc68*/ void QuadWordToBigEndian(byte[] block, ulong[] x, int digits);
                static /*0x1ff17cc*/ byte[] Int(uint i);
                static /*0x1fea6c0*/ byte[] RsaOaepEncrypt(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.HashAlgorithm hash, System.Security.Cryptography.PKCS1MaskGenerationMethod mgf, System.Security.Cryptography.RandomNumberGenerator rng, byte[] data);
                static /*0x1ff1860*/ byte[] RsaOaepDecrypt(System.Security.Cryptography.RSA rsa, System.Security.Cryptography.HashAlgorithm hash, System.Security.Cryptography.PKCS1MaskGenerationMethod mgf, byte[] encryptedData);
                static /*0x1ff1930*/ byte[] RsaPkcs1Padding(System.Security.Cryptography.RSA rsa, byte[] oid, byte[] hash);
                static /*0x1ff1bdc*/ bool CompareBigIntArrays(byte[] lhs, byte[] rhs);
                static /*0x1ff1cf0*/ System.Security.Cryptography.HashAlgorithmName OidToHashAlgorithmName(string oid);
                static /*0x1fea74c*/ bool DoesRsaKeyOverride(System.Security.Cryptography.RSA rsaKey, string methodName, System.Type[] parameterTypes);
                static /*0x1ff1e2c*/ bool DoesRsaKeyOverrideSlowPath(System.Type t, string methodName, System.Type[] parameterTypes);
                static /*0x1ff1f0c*/ bool _ProduceLegacyHmacValues();
            }

            class CryptoAPITransform : System.Security.Cryptography.ICryptoTransform, System.IDisposable
            {
                /*0x10*/ bool m_disposed;

                /*0x1ff1f14*/ CryptoAPITransform();
                /*0x1ff1f30*/ bool get_CanReuseTransform();
                /*0x1ff1f38*/ bool get_CanTransformMultipleBlocks();
                /*0x1ff1f40*/ int get_InputBlockSize();
                /*0x1ff1f48*/ nint get_KeyHandle();
                /*0x1ff1f90*/ int get_OutputBlockSize();
                /*0x1ff1f98*/ void Dispose();
                /*0x1ff2018*/ void Clear();
                /*0x1ff2000*/ void Dispose(bool disposing);
                /*0x1ff2030*/ int TransformBlock(byte[] inputBuffer, int inputOffset, int inputCount, byte[] outputBuffer, int outputOffset);
                /*0x1ff2038*/ byte[] TransformFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1ff2040*/ void Reset();
            }

            class CryptoConfig
            {
                static /*0x0*/ object lockObject;
                static /*0x8*/ System.Collections.Generic.Dictionary<string, System.Type> algorithms;

                static /*0x1ff52b8*/ CryptoConfig();
                static /*0x1ff2044*/ void AddOID(string oid, string[] names);
                static /*0x1feb644*/ object CreateFromName(string name);
                static /*0x1ff2084*/ object CreateFromName(string name, object[] args);
                static /*0x1ff406c*/ string MapNameToOID(string name, object arg);
                static /*0x1ff40c0*/ string MapNameToOID(string name);
                static /*0x1ff4874*/ void Initialize();
                static /*0x1ff4974*/ void AddAlgorithm(System.Type algorithm, string[] names);
                static /*0x1ff4d14*/ byte[] EncodeOID(string str);
                static /*0x1ff5120*/ byte[] EncodeLongNumber(long x);
                static /*0x1feb764*/ bool get_AllowOnlyFipsAlgorithms();
                /*0x1ff52b0*/ CryptoConfig();
            }

            class CspKeyContainerInfo
            {
                /*0x10*/ System.Security.Cryptography.CspParameters _params;
                /*0x18*/ bool _random;

                /*0x1ff5330*/ CspKeyContainerInfo(System.Security.Cryptography.CspParameters parameters);
                /*0x1ff5360*/ bool get_Accessible();
                /*0x1ff5368*/ System.Security.AccessControl.CryptoKeySecurity get_CryptoKeySecurity();
                /*0x1ff5370*/ bool get_Exportable();
                /*0x1ff5378*/ bool get_HardwareDevice();
                /*0x1ff5380*/ string get_KeyContainerName();
                /*0x1ff539c*/ System.Security.Cryptography.KeyNumber get_KeyNumber();
                /*0x1ff53b8*/ bool get_MachineKeyStore();
                /*0x1ff53c0*/ bool get_Protected();
                /*0x1ff53c8*/ string get_ProviderName();
                /*0x1ff53e4*/ int get_ProviderType();
                /*0x1ff5400*/ bool get_RandomlyGenerated();
                /*0x1ff5408*/ bool get_Removable();
                /*0x1ff5410*/ string get_UniqueKeyContainerName();
            }

            class DESTransform : Mono.Security.Cryptography.SymmetricTransform
            {
                static /*0x0*/ int KEY_BIT_SIZE;
                static /*0x4*/ int KEY_BYTE_SIZE;
                static /*0x8*/ int BLOCK_BIT_SIZE;
                static /*0xc*/ int BLOCK_BYTE_SIZE;
                static /*0x10*/ uint[] spBoxes;
                static /*0x18*/ byte[] PC1;
                static /*0x20*/ byte[] leftRotTotal;
                static /*0x28*/ byte[] PC2;
                static /*0x30*/ uint[] ipTab;
                static /*0x38*/ uint[] fpTab;
                /*0x58*/ byte[] keySchedule;
                /*0x60*/ byte[] byteBuff;
                /*0x68*/ uint[] dwordBuff;

                static /*0x1ff64ec*/ DESTransform();
                static /*0x1ff5d24*/ void Permutation(byte[] input, byte[] output, uint[] permTab, bool preSwap);
                static /*0x1ff6048*/ void BSwap(byte[] byteBuff);
                static /*0x1ff5690*/ byte[] GetStrongKey();
                /*0x1ff5468*/ DESTransform(System.Security.Cryptography.SymmetricAlgorithm symmAlgo, bool encryption, byte[] key, byte[] iv);
                /*0x1ff5af4*/ uint CipherFunct(uint r, int n);
                /*0x1ff5768*/ void SetKey(byte[] key);
                /*0x1ff60c0*/ void ProcessBlock(byte[] input, byte[] output);
                /*0x1ff6448*/ void ECB(byte[] input, byte[] output);
            }

            class DSACryptoServiceProvider : System.Security.Cryptography.DSA, System.Security.Cryptography.ICspAsymmetricAlgorithm
            {
                static int PROV_DSS_DH = 13;
                static /*0x0*/ bool useMachineKeyStore;
                /*0x20*/ Mono.Security.Cryptography.KeyPairPersistence store;
                /*0x28*/ bool persistKey;
                /*0x29*/ bool persisted;
                /*0x2a*/ bool privateKeyExportable;
                /*0x2b*/ bool m_disposed;
                /*0x30*/ Mono.Security.Cryptography.DSAManaged dsa;

                static /*0x1ff6ba0*/ bool get_UseMachineKeyStore();
                static /*0x1ff6be8*/ void set_UseMachineKeyStore(bool value);
                /*0x1ff3f98*/ DSACryptoServiceProvider();
                /*0x1ff6724*/ DSACryptoServiceProvider(System.Security.Cryptography.CspParameters parameters);
                /*0x1ff66ec*/ DSACryptoServiceProvider(int dwKeySize);
                /*0x1ff6730*/ DSACryptoServiceProvider(int dwKeySize, System.Security.Cryptography.CspParameters parameters);
                /*0x1ff678c*/ void Common(int dwKeySize, bool parameters);
                /*0x1ff69b0*/ void Common(System.Security.Cryptography.CspParameters parameters);
                /*0x1ff6a68*/ void Finalize();
                /*0x1ff6b08*/ string get_KeyExchangeAlgorithm();
                /*0x1ff6b10*/ int get_KeySize();
                /*0x1ff6b30*/ bool get_PersistKeyInCsp();
                /*0x1ff6b38*/ void set_PersistKeyInCsp(bool value);
                /*0x1ff6b44*/ bool get_PublicOnly();
                /*0x1ff6b60*/ string get_SignatureAlgorithm();
                /*0x1ff6c34*/ System.Security.Cryptography.DSAParameters ExportParameters(bool includePrivateParameters);
                /*0x1ff6cec*/ void ImportParameters(System.Security.Cryptography.DSAParameters parameters);
                /*0x1ff6d40*/ byte[] CreateSignature(byte[] rgbHash);
                /*0x1ff6d64*/ byte[] SignData(byte[] buffer);
                /*0x1ff6db4*/ byte[] SignData(byte[] buffer, int offset, int count);
                /*0x1ff6e1c*/ byte[] SignData(System.IO.Stream inputStream);
                /*0x1ff6e6c*/ byte[] SignHash(byte[] rgbHash, string str);
                /*0x1ff6f78*/ bool VerifyData(byte[] rgbData, byte[] rgbSignature);
                /*0x1ff6fd0*/ bool VerifyHash(byte[] rgbHash, string str, byte[] rgbSignature);
                /*0x1ff70f8*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
                /*0x1ff711c*/ byte[] HashData(byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1ff721c*/ byte[] HashData(System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                /*0x1ff7304*/ void Dispose(bool disposing);
                /*0x1ff7358*/ void OnKeyGenerated(object sender, System.EventArgs e);
                /*0x1ff73dc*/ System.Security.Cryptography.CspKeyContainerInfo get_CspKeyContainerInfo();
                /*0x1ff73e4*/ byte[] ExportCspBlob(bool includePrivateParameters);
                /*0x1ff73f8*/ void ImportCspBlob(byte[] keyBlob);
            }

            class MD5CryptoServiceProvider : System.Security.Cryptography.MD5
            {
                static int BLOCK_SIZE_BYTES = 64;
                static /*0x0*/ uint[] K;
                /*0x28*/ uint[] _H;
                /*0x30*/ uint[] buff;
                /*0x38*/ ulong count;
                /*0x40*/ byte[] _ProcessingBuffer;
                /*0x48*/ int _ProcessingBufferCount;

                static /*0x1ff88cc*/ MD5CryptoServiceProvider();
                /*0x1ff3fc4*/ MD5CryptoServiceProvider();
                /*0x1ff7658*/ void Finalize();
                /*0x1ff76fc*/ void Dispose(bool disposing);
                /*0x1ff776c*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x1ff84e4*/ byte[] HashFinal();
                /*0x1ff8768*/ void Initialize();
                /*0x1ff786c*/ void ProcessBlock(byte[] inputBuffer, int inputOffset);
                /*0x1ff85bc*/ void ProcessFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1ff87dc*/ void AddLength(ulong length, byte[] buffer, int position);
            }

            class RC2Transform : Mono.Security.Cryptography.SymmetricTransform
            {
                static /*0x0*/ byte[] pitable;
                /*0x58*/ ushort R0;
                /*0x5a*/ ushort R1;
                /*0x5c*/ ushort R2;
                /*0x5e*/ ushort R3;
                /*0x60*/ ushort[] K;
                /*0x68*/ int j;

                static /*0x1ff97d8*/ RC2Transform();
                /*0x1ff8960*/ RC2Transform(System.Security.Cryptography.RC2 rc2Algo, bool encryption, byte[] key, byte[] iv);
                /*0x1ff8ea8*/ void ECB(byte[] input, byte[] output);
            }

            class RNGCryptoServiceProvider : System.Security.Cryptography.RandomNumberGenerator
            {
                static /*0x0*/ object _lock;
                /*0x10*/ nint _handle;

                static /*0x1ff986c*/ RNGCryptoServiceProvider();
                static /*0x1ff98ec*/ bool RngOpen();
                static /*0x1ff9988*/ nint RngInitialize(byte* seed, nint seed_length);
                static /*0x1ff9ca0*/ nint RngGetBytes(nint handle, byte* data, nint data_length);
                static /*0x1ff9ca4*/ void RngClose(nint handle);
                /*0x1ff98f0*/ RNGCryptoServiceProvider();
                /*0x1ff9a40*/ RNGCryptoServiceProvider(byte[] rgb);
                /*0x1ff9b08*/ RNGCryptoServiceProvider(System.Security.Cryptography.CspParameters cspParams);
                /*0x1ff9ba0*/ RNGCryptoServiceProvider(string str);
                /*0x1ff998c*/ void Check();
                /*0x1ff9ca8*/ void GetBytes(byte[] data);
                /*0x1ff9ec4*/ void GetBytes(byte* data, nint data_length);
                /*0x1ffa05c*/ void GetNonZeroBytes(byte[] data);
                /*0x1ffa208*/ void Finalize();
                /*0x1ffa320*/ void Dispose(bool disposing);
            }

            class RSAPKCS1SignatureDeformatter : System.Security.Cryptography.AsymmetricSignatureDeformatter
            {
                /*0x10*/ System.Security.Cryptography.RSA rsa;
                /*0x18*/ string hashName;

                /*0x1ffa32c*/ RSAPKCS1SignatureDeformatter();
                /*0x1ffa334*/ RSAPKCS1SignatureDeformatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1ffa368*/ void SetHashAlgorithm(string strName);
                /*0x1ffa3c8*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1ffa4b4*/ bool VerifySignature(byte[] rgbHash, byte[] rgbSignature);
            }

            class RSAPKCS1SignatureFormatter : System.Security.Cryptography.AsymmetricSignatureFormatter
            {
                /*0x10*/ System.Security.Cryptography.RSA rsa;
                /*0x18*/ string hash;

                /*0x1ffa614*/ RSAPKCS1SignatureFormatter();
                /*0x1ffa61c*/ RSAPKCS1SignatureFormatter(System.Security.Cryptography.AsymmetricAlgorithm key);
                /*0x1ffa650*/ byte[] CreateSignature(byte[] rgbHash);
                /*0x1ffa778*/ void SetHashAlgorithm(string strName);
                /*0x1ffa7d8*/ void SetKey(System.Security.Cryptography.AsymmetricAlgorithm key);
            }

            class SHA1Internal
            {
                static int BLOCK_SIZE_BYTES = 64;
                /*0x10*/ uint[] _H;
                /*0x18*/ ulong count;
                /*0x20*/ byte[] _ProcessingBuffer;
                /*0x28*/ int _ProcessingBufferCount;
                /*0x30*/ uint[] buff;

                static /*0x1ffb294*/ void InitialiseBuff(uint[] buff, byte[] input, uint inputOffset);
                static /*0x1ffb934*/ void FillBuff(uint[] buff);
                /*0x1ffa8c4*/ SHA1Internal();
                /*0x1ffa9e8*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x1ffb000*/ byte[] HashFinal();
                /*0x1ffa960*/ void Initialize();
                /*0x1ffaae8*/ void ProcessBlock(byte[] inputBuffer, uint inputOffset);
                /*0x1ffb0d8*/ void ProcessFinalBlock(byte[] inputBuffer, int inputOffset, int inputCount);
                /*0x1ffbb68*/ void AddLength(ulong length, byte[] buffer, int position);
            }

            class SHA1CryptoServiceProvider : System.Security.Cryptography.SHA1
            {
                /*0x28*/ System.Security.Cryptography.SHA1Internal sha;

                /*0x1ffbc58*/ SHA1CryptoServiceProvider();
                /*0x1ffbcc0*/ void Finalize();
                /*0x1ffbd64*/ void Dispose(bool disposing);
                /*0x1ffbd70*/ void HashCore(byte[] rgb, int ibStart, int cbSize);
                /*0x1ffbd94*/ byte[] HashFinal();
                /*0x1ffbdb4*/ void Initialize();
            }

            class TripleDESTransform : Mono.Security.Cryptography.SymmetricTransform
            {
                /*0x58*/ System.Security.Cryptography.DESTransform E1;
                /*0x60*/ System.Security.Cryptography.DESTransform D2;
                /*0x68*/ System.Security.Cryptography.DESTransform E3;
                /*0x70*/ System.Security.Cryptography.DESTransform D1;
                /*0x78*/ System.Security.Cryptography.DESTransform E2;
                /*0x80*/ System.Security.Cryptography.DESTransform D3;

                static /*0x1ffc108*/ byte[] GetStrongKey();
                /*0x1ffbdcc*/ TripleDESTransform(System.Security.Cryptography.TripleDES algo, bool encryption, byte[] key, byte[] iv);
                /*0x1ffc1b0*/ void ECB(byte[] input, byte[] output);
            }

            class AesCcm : System.IDisposable
            {
                static /*0x1ffc37c*/ System.Security.Cryptography.KeySizes get_NonceByteSizes();
                static /*0x1ffc3bc*/ System.Security.Cryptography.KeySizes get_TagByteSizes();
                /*0x1ffc2ec*/ AesCcm(byte[] key);
                /*0x1ffc334*/ AesCcm(System.ReadOnlySpan<byte> key);
                /*0x1ffc3fc*/ void Decrypt(byte[] nonce, byte[] ciphertext, byte[] tag, byte[] plaintext, byte[] associatedData);
                /*0x1ffc43c*/ void Decrypt(System.ReadOnlySpan<byte> nonce, System.ReadOnlySpan<byte> ciphertext, System.ReadOnlySpan<byte> tag, System.Span<byte> plaintext, System.ReadOnlySpan<byte> associatedData);
                /*0x1ffc47c*/ void Dispose();
                /*0x1ffc480*/ void Encrypt(byte[] nonce, byte[] plaintext, byte[] ciphertext, byte[] tag, byte[] associatedData);
                /*0x1ffc4c0*/ void Encrypt(System.ReadOnlySpan<byte> nonce, System.ReadOnlySpan<byte> plaintext, System.Span<byte> ciphertext, System.Span<byte> tag, System.ReadOnlySpan<byte> associatedData);
            }

            class AesGcm : System.IDisposable
            {
                static /*0x1ffc590*/ System.Security.Cryptography.KeySizes get_NonceByteSizes();
                static /*0x1ffc5d0*/ System.Security.Cryptography.KeySizes get_TagByteSizes();
                /*0x1ffc500*/ AesGcm(byte[] key);
                /*0x1ffc548*/ AesGcm(System.ReadOnlySpan<byte> key);
                /*0x1ffc610*/ void Decrypt(byte[] nonce, byte[] ciphertext, byte[] tag, byte[] plaintext, byte[] associatedData);
                /*0x1ffc650*/ void Decrypt(System.ReadOnlySpan<byte> nonce, System.ReadOnlySpan<byte> ciphertext, System.ReadOnlySpan<byte> tag, System.Span<byte> plaintext, System.ReadOnlySpan<byte> associatedData);
                /*0x1ffc690*/ void Dispose();
                /*0x1ffc694*/ void Encrypt(byte[] nonce, byte[] plaintext, byte[] ciphertext, byte[] tag, byte[] associatedData);
                /*0x1ffc6d4*/ void Encrypt(System.ReadOnlySpan<byte> nonce, System.ReadOnlySpan<byte> plaintext, System.Span<byte> ciphertext, System.Span<byte> tag, System.ReadOnlySpan<byte> associatedData);
            }

            class CryptoConfigForwarder
            {
                static /*0x1ffc714*/ object CreateFromName(string name);
                static /*0x1ffc76c*/ System.Security.Cryptography.HashAlgorithm CreateDefaultHashAlgorithm();
            }

            enum PbeEncryptionAlgorithm
            {
                Unknown = 0,
                Aes128Cbc = 1,
                Aes192Cbc = 2,
                Aes256Cbc = 3,
                TripleDes3KeyPkcs12 = 4,
            }

            class PbeParameters
            {
                /*0x10*/ System.Security.Cryptography.PbeEncryptionAlgorithm <EncryptionAlgorithm>k__BackingField;
                /*0x18*/ System.Security.Cryptography.HashAlgorithmName <HashAlgorithm>k__BackingField;
                /*0x20*/ int <IterationCount>k__BackingField;

                /*0x1ffc7dc*/ PbeParameters(System.Security.Cryptography.PbeEncryptionAlgorithm encryptionAlgorithm, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, int iterationCount);
                /*0x1ffc7c4*/ System.Security.Cryptography.PbeEncryptionAlgorithm get_EncryptionAlgorithm();
                /*0x1ffc7cc*/ System.Security.Cryptography.HashAlgorithmName get_HashAlgorithm();
                /*0x1ffc7d4*/ int get_IterationCount();
            }

            namespace X509Certificates
            {
                enum X509ContentType
                {
                    Unknown = 0,
                    Cert = 1,
                    SerializedCert = 2,
                    Pfx = 3,
                    Pkcs12 = 3,
                    SerializedStore = 4,
                    Pkcs7 = 5,
                    Authenticode = 6,
                }

                enum X509KeyStorageFlags
                {
                    DefaultKeySet = 0,
                    UserKeySet = 1,
                    MachineKeySet = 2,
                    Exportable = 4,
                    UserProtected = 8,
                    PersistKeySet = 16,
                    EphemeralKeySet = 32,
                }

                class X509Certificate : System.IDisposable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable
                {
                    static System.Security.Cryptography.X509Certificates.X509KeyStorageFlags KeyStorageFlagsAll = 63;
                    /*0x10*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl impl;
                    /*0x18*/ byte[] lazyCertHash;
                    /*0x20*/ byte[] lazySerialNumber;
                    /*0x28*/ string lazyIssuer;
                    /*0x30*/ string lazySubject;
                    /*0x38*/ string lazyKeyAlgorithm;
                    /*0x40*/ byte[] lazyKeyAlgorithmParameters;
                    /*0x48*/ byte[] lazyPublicKey;
                    /*0x50*/ System.DateTime lazyNotBefore;
                    /*0x58*/ System.DateTime lazyNotAfter;

                    static /*0x1ffda04*/ System.Security.Cryptography.X509Certificates.X509Certificate CreateFromCertFile(string filename);
                    static /*0x1ffda6c*/ System.Security.Cryptography.X509Certificates.X509Certificate CreateFromSignedFile(string filename);
                    static /*0x1ffecb4*/ string FormatDate(System.DateTime date);
                    static /*0x1ffd064*/ void ValidateKeyStorageFlags(System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    /*0x1ffc9c8*/ X509Certificate();
                    /*0x1ffca3c*/ X509Certificate(byte[] data);
                    /*0x1ffcb84*/ X509Certificate(byte[] rawData, string password);
                    /*0x1ffcdf4*/ X509Certificate(byte[] rawData, System.Security.SecureString password);
                    /*0x1ffcb8c*/ X509Certificate(byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    /*0x1ffcdfc*/ X509Certificate(byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    /*0x1ffd240*/ X509Certificate(nint handle);
                    /*0x1ffd2e0*/ X509Certificate(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    /*0x1ffd398*/ X509Certificate(string fileName);
                    /*0x1ffd604*/ X509Certificate(string fileName, string password);
                    /*0x1ffd60c*/ X509Certificate(string fileName, System.Security.SecureString password);
                    /*0x1ffd3a4*/ X509Certificate(string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    /*0x1ffd614*/ X509Certificate(string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    /*0x1ffd830*/ X509Certificate(System.Security.Cryptography.X509Certificates.X509Certificate cert);
                    /*0x1ffd9c0*/ X509Certificate(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x1ffc8a4*/ void Reset();
                    /*0x1ffdad4*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x1ffdb14*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
                    /*0x1ffdb54*/ nint get_Handle();
                    /*0x1ffdbec*/ string get_Issuer();
                    /*0x1ffdc48*/ string get_Subject();
                    /*0x1ffdc9c*/ void Dispose();
                    /*0x1ffdcac*/ void Dispose(bool disposing);
                    /*0x1ffdcc0*/ bool Equals(object obj);
                    /*0x1ffdd54*/ bool Equals(System.Security.Cryptography.X509Certificates.X509Certificate other);
                    /*0x1ffde90*/ byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType contentType);
                    /*0x1ffdea0*/ byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType contentType, string password);
                    /*0x1ffe110*/ byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType contentType, System.Security.SecureString password);
                    /*0x1ffe320*/ string GetRawCertDataString();
                    /*0x1ffe350*/ byte[] GetCertHash();
                    /*0x1ffe3c4*/ byte[] GetCertHash(System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                    /*0x1ffe404*/ bool TryGetCertHash(System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Span<byte> destination, ref int bytesWritten);
                    /*0x1ffe444*/ string GetCertHashString();
                    /*0x1ffe468*/ string GetCertHashString(System.Security.Cryptography.HashAlgorithmName hashAlgorithm);
                    /*0x1ffe374*/ byte[] GetRawCertHash();
                    /*0x1ffe4a8*/ string GetEffectiveDateString();
                    /*0x1ffe568*/ string GetExpirationDateString();
                    /*0x1ffe628*/ string GetFormat();
                    /*0x1ffe668*/ string GetPublicKeyString();
                    /*0x1ffe688*/ byte[] GetRawCertData();
                    /*0x1ffe6c0*/ int GetHashCode();
                    /*0x1ffe738*/ string GetKeyAlgorithm();
                    /*0x1ffe790*/ byte[] GetKeyAlgorithmParameters();
                    /*0x1ffe7ec*/ string GetKeyAlgorithmParametersString();
                    /*0x1ffe81c*/ byte[] GetPublicKey();
                    /*0x1ffe878*/ byte[] GetSerialNumber();
                    /*0x1ffe8e0*/ string GetSerialNumberString();
                    /*0x1ffde40*/ byte[] GetRawSerialNumber();
                    /*0x1ffe904*/ string GetName();
                    /*0x1ffe930*/ string GetIssuerName();
                    /*0x1ffe95c*/ string ToString();
                    /*0x1ffe970*/ string ToString(bool fVerbose);
                    /*0x1ffedc4*/ void Import(byte[] rawData);
                    /*0x1ffee14*/ void Import(byte[] rawData, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    /*0x1ffee64*/ void Import(byte[] rawData, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    /*0x1ffeeb4*/ void Import(string fileName);
                    /*0x1ffef04*/ void Import(string fileName, string password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    /*0x1ffef54*/ void Import(string fileName, System.Security.SecureString password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    /*0x1ffe588*/ System.DateTime GetNotAfter();
                    /*0x1ffe4c8*/ System.DateTime GetNotBefore();
                    /*0x1ffe0b0*/ void VerifyContentType(System.Security.Cryptography.X509Certificates.X509ContentType contentType);
                    /*0x1ffefa4*/ void ImportHandle(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    /*0x1ffefd4*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl get_Impl();
                    /*0x1ffefdc*/ bool get_IsValid();
                    /*0x1ffdc40*/ void ThrowIfInvalid();
                }

                class X509CertificateImpl : System.IDisposable
                {
                    /*0x1fff3b4*/ X509CertificateImpl();
                    bool get_IsValid();
                    nint get_Handle();
                    nint GetNativeAppleCertificate();
                    /*0x1fff034*/ void ThrowIfContextInvalid();
                    System.Security.Cryptography.X509Certificates.X509CertificateImpl Clone();
                    string get_Issuer();
                    string get_Subject();
                    string get_LegacyIssuer();
                    string get_LegacySubject();
                    byte[] get_RawData();
                    System.DateTime get_NotAfter();
                    System.DateTime get_NotBefore();
                    byte[] get_Thumbprint();
                    /*0x1fff0f8*/ int GetHashCode();
                    bool Equals(System.Security.Cryptography.X509Certificates.X509CertificateImpl other, ref bool result);
                    string get_KeyAlgorithm();
                    byte[] get_KeyAlgorithmParameters();
                    byte[] get_PublicKeyValue();
                    byte[] get_SerialNumber();
                    bool get_HasPrivateKey();
                    System.Security.Cryptography.RSA GetRSAPrivateKey();
                    System.Security.Cryptography.DSA GetDSAPrivateKey();
                    byte[] Export(System.Security.Cryptography.X509Certificates.X509ContentType contentType, Microsoft.Win32.SafeHandles.SafePasswordHandle password);
                    System.Security.Cryptography.X509Certificates.X509CertificateImpl CopyWithPrivateKey(System.Security.Cryptography.RSA privateKey);
                    System.Security.Cryptography.X509Certificates.X509Certificate CreateCertificate();
                    /*0x1fff18c*/ bool Equals(object obj);
                    /*0x1ffc958*/ void Dispose();
                    /*0x1fff30c*/ void Dispose(bool disposing);
                    /*0x1fff310*/ void Finalize();
                }

                class X509Helper
                {
                    static /*0x1fff3bc*/ Mono.ISystemCertificateProvider get_CertificateProvider();
                    static /*0x1ffd910*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl InitFromCertificate(System.Security.Cryptography.X509Certificates.X509Certificate cert);
                    static /*0x1ffd384*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl InitFromCertificate(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    static /*0x1ffdbd8*/ bool IsValid(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    static /*0x1ffeff4*/ void ThrowIfContextInvalid(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl);
                    static /*0x1fff070*/ System.Exception GetInvalidContextException();
                    static /*0x1ffcad8*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(byte[] rawData);
                    static /*0x1ffd178*/ System.Security.Cryptography.X509Certificates.X509CertificateImpl Import(byte[] rawData, Microsoft.Win32.SafeHandles.SafePasswordHandle password, System.Security.Cryptography.X509Certificates.X509KeyStorageFlags keyStorageFlags);
                    static /*0x1fff484*/ byte[] Export(System.Security.Cryptography.X509Certificates.X509CertificateImpl impl, System.Security.Cryptography.X509Certificates.X509ContentType contentType, Microsoft.Win32.SafeHandles.SafePasswordHandle password);
                    static /*0x1fff4c8*/ bool Equals(System.Security.Cryptography.X509Certificates.X509CertificateImpl first, System.Security.Cryptography.X509Certificates.X509CertificateImpl second);
                    static /*0x1fff5f0*/ string ToHexString(byte[] data);
                }
            }
        }

        namespace Principal
        {
            class GenericIdentity : System.Security.Claims.ClaimsIdentity
            {
                /*0x78*/ string m_name;
                /*0x80*/ string m_type;

                /*0x1fff6e0*/ GenericIdentity(string name);
                /*0x1fff894*/ GenericIdentity(string name, string type);
                /*0x1fff950*/ GenericIdentity();
                /*0x1fff96c*/ GenericIdentity(System.Security.Principal.GenericIdentity identity);
                /*0x1fffb8c*/ System.Security.Claims.ClaimsIdentity Clone();
                /*0x1fffbec*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> get_Claims();
                /*0x1fffc68*/ string get_Name();
                /*0x1fffc70*/ string get_AuthenticationType();
                /*0x1fffc78*/ bool get_IsAuthenticated();
                /*0x1fff7bc*/ void AddNameClaim();
            }

            enum TokenAccessLevels
            {
                AssignPrimary = 1,
                Duplicate = 2,
                Impersonate = 4,
                Query = 8,
                QuerySource = 16,
                AdjustPrivileges = 32,
                AdjustGroups = 64,
                AdjustDefault = 128,
                AdjustSessionId = 256,
                Read = 131080,
                Write = 131296,
                AllAccess = 983551,
                MaximumAllowed = 33554432,
            }

            interface IIdentity
            {
                string get_Name();
                string get_AuthenticationType();
                bool get_IsAuthenticated();
            }

            interface IPrincipal
            {
                System.Security.Principal.IIdentity get_Identity();
                bool IsInRole(string role);
            }

            enum PrincipalPolicy
            {
                UnauthenticatedPrincipal = 0,
                NoPrincipal = 1,
                WindowsPrincipal = 2,
            }

            enum TokenImpersonationLevel
            {
                None = 0,
                Anonymous = 1,
                Identification = 2,
                Impersonation = 3,
                Delegation = 4,
            }

            class GenericPrincipal : System.Security.Claims.ClaimsPrincipal
            {
                /*0x30*/ System.Security.Principal.IIdentity m_identity;
                /*0x38*/ string[] m_roles;

                /*0x1fffe70*/ GenericPrincipal(System.Security.Principal.IIdentity identity, string[] roles);
                /*0x2000078*/ string[] get_Roles();
                /*0x2000080*/ System.Security.Principal.IIdentity get_Identity();
                /*0x2000088*/ bool IsInRole(string role);
            }

            class IdentityNotMappedException : System.SystemException
            {
                /*0x90*/ System.Security.Principal.IdentityReferenceCollection _coll;

                /*0x2000138*/ IdentityNotMappedException();
                /*0x2000190*/ IdentityNotMappedException(string message);
                /*0x2000198*/ IdentityNotMappedException(string message, System.Exception inner);
                /*0x20001a0*/ System.Security.Principal.IdentityReferenceCollection get_UnmappedIdentities();
                /*0x2000274*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);
            }

            class IdentityReference
            {
                static /*0x2000280*/ bool op_Equality(System.Security.Principal.IdentityReference left, System.Security.Principal.IdentityReference right);
                static /*0x20002e8*/ bool op_Inequality(System.Security.Principal.IdentityReference left, System.Security.Principal.IdentityReference right);
                /*0x2000278*/ IdentityReference();
                string get_Value();
                bool Equals(object o);
                int GetHashCode();
                bool IsValidTargetType(System.Type targetType);
                string ToString();
                System.Security.Principal.IdentityReference Translate(System.Type targetType);
            }

            class IdentityReferenceCollection : System.Collections.IEnumerable, System.Collections.Generic.ICollection<System.Security.Principal.IdentityReference>, System.Collections.Generic.IEnumerable<System.Security.Principal.IdentityReference>
            {
                /*0x10*/ System.Collections.ArrayList _list;

                /*0x2000208*/ IdentityReferenceCollection();
                /*0x2000350*/ IdentityReferenceCollection(int capacity);
                /*0x20003cc*/ int get_Count();
                /*0x20003f0*/ bool get_IsReadOnly();
                /*0x20003f8*/ System.Security.Principal.IdentityReference get_Item(int index);
                /*0x20004b4*/ void set_Item(int index, System.Security.Principal.IdentityReference value);
                /*0x20004d8*/ void Add(System.Security.Principal.IdentityReference identity);
                /*0x20004fc*/ void Clear();
                /*0x2000520*/ bool Contains(System.Security.Principal.IdentityReference identity);
                /*0x2000854*/ void CopyTo(System.Security.Principal.IdentityReference[] array, int offset);
                /*0x2000894*/ System.Collections.Generic.IEnumerator<System.Security.Principal.IdentityReference> GetEnumerator();
                /*0x20008d4*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x2000914*/ bool Remove(System.Security.Principal.IdentityReference identity);
                /*0x2000c54*/ System.Security.Principal.IdentityReferenceCollection Translate(System.Type targetType);
                /*0x2000c94*/ System.Security.Principal.IdentityReferenceCollection Translate(System.Type targetType, bool forceSuccess);
            }

            class NTAccount : System.Security.Principal.IdentityReference
            {
                /*0x10*/ string _value;

                static /*0x2000f98*/ bool op_Equality(System.Security.Principal.NTAccount left, System.Security.Principal.NTAccount right);
                static /*0x20014c0*/ bool op_Inequality(System.Security.Principal.NTAccount left, System.Security.Principal.NTAccount right);
                /*0x2000cd4*/ NTAccount(string name);
                /*0x2000dbc*/ NTAccount(string domainName, string accountName);
                /*0x2000ef8*/ string get_Value();
                /*0x2000f00*/ bool Equals(object o);
                /*0x2001000*/ int GetHashCode();
                /*0x2001028*/ bool IsValidTargetType(System.Type targetType);
                /*0x200110c*/ string ToString();
                /*0x2001118*/ System.Security.Principal.IdentityReference Translate(System.Type targetType);
            }

            class SecurityIdentifier : System.Security.Principal.IdentityReference, System.IComparable<System.Security.Principal.SecurityIdentifier>
            {
                static /*0x0*/ int MaxBinaryLength;
                static /*0x4*/ int MinBinaryLength;
                /*0x10*/ byte[] buffer;

                static /*0x200322c*/ SecurityIdentifier();
                static /*0x2001e98*/ bool op_Equality(System.Security.Principal.SecurityIdentifier left, System.Security.Principal.SecurityIdentifier right);
                static /*0x20026f8*/ bool op_Inequality(System.Security.Principal.SecurityIdentifier left, System.Security.Principal.SecurityIdentifier right);
                static /*0x2002d84*/ System.Security.Principal.SecurityIdentifier ParseSddlForm(string sddlForm, ref int pos);
                static /*0x2001528*/ byte[] ParseSddlForm(string sddlForm);
                static /*0x200307c*/ bool TryParseAuthority(string s, ref ulong result);
                static /*0x2003154*/ bool TryParseSubAuthority(string s, ref uint result);
                /*0x2001404*/ SecurityIdentifier(string sddlForm);
                /*0x2001988*/ SecurityIdentifier(byte[] binaryForm, int offset);
                /*0x2001bdc*/ SecurityIdentifier(nint binaryForm);
                /*0x2001c0c*/ SecurityIdentifier(System.Security.Principal.WellKnownSidType sidType, System.Security.Principal.SecurityIdentifier domainSid);
                /*0x2001a74*/ void CreateFromBinaryForm(nint binaryForm, int length);
                /*0x2001f00*/ System.Security.Principal.SecurityIdentifier get_AccountDomainSid();
                /*0x2002024*/ int get_BinaryLength();
                /*0x2002040*/ string get_Value();
                /*0x20021fc*/ ulong GetSidAuthority();
                /*0x20022f8*/ byte GetSidSubAuthorityCount();
                /*0x200227c*/ uint GetSidSubAuthority(byte index);
                /*0x2002324*/ int CompareTo(System.Security.Principal.SecurityIdentifier sid);
                /*0x2002494*/ bool Equals(object o);
                /*0x20024f8*/ bool Equals(System.Security.Principal.SecurityIdentifier sid);
                /*0x20025a0*/ void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x2002668*/ int GetHashCode();
                /*0x2002690*/ bool IsAccountSid();
                /*0x2002760*/ bool IsEqualDomainSid(System.Security.Principal.SecurityIdentifier sid);
                /*0x2002800*/ bool IsValidTargetType(System.Type targetType);
                /*0x20028e4*/ bool IsWellKnown(System.Security.Principal.WellKnownSidType type);
                /*0x2002a04*/ string ToString();
                /*0x2002a10*/ System.Security.Principal.IdentityReference Translate(System.Type targetType);
                /*0x2002cfc*/ string GetSddlForm();
            }

            class WellKnownAccount
            {
                static /*0x0*/ System.Security.Principal.WellKnownAccount[] accounts;
                /*0x10*/ System.Security.Principal.WellKnownSidType <WellKnownValue>k__BackingField;
                /*0x14*/ bool <IsAbsolute>k__BackingField;
                /*0x18*/ string <Sid>k__BackingField;
                /*0x20*/ string <Rid>k__BackingField;
                /*0x28*/ string <Name>k__BackingField;
                /*0x30*/ string <SddlForm>k__BackingField;

                static /*0x20032e8*/ WellKnownAccount();
                static /*0x2001dfc*/ System.Security.Principal.WellKnownAccount LookupByType(System.Security.Principal.WellKnownSidType sidType);
                static /*0x2002c3c*/ System.Security.Principal.WellKnownAccount LookupBySid(string s);
                static /*0x2001344*/ System.Security.Principal.WellKnownAccount LookupByName(string s);
                static /*0x2002fbc*/ System.Security.Principal.WellKnownAccount LookupBySddlForm(string s);
                /*0x20032e0*/ WellKnownAccount();
                /*0x200327c*/ System.Security.Principal.WellKnownSidType get_WellKnownValue();
                /*0x2003284*/ void set_WellKnownValue(System.Security.Principal.WellKnownSidType value);
                /*0x200328c*/ bool get_IsAbsolute();
                /*0x2003294*/ void set_IsAbsolute(bool value);
                /*0x20032a0*/ string get_Sid();
                /*0x20032a8*/ void set_Sid(string value);
                /*0x20032b0*/ string get_Rid();
                /*0x20032b8*/ void set_Rid(string value);
                /*0x20032c0*/ string get_Name();
                /*0x20032c8*/ void set_Name(string value);
                /*0x20032d0*/ string get_SddlForm();
                /*0x20032d8*/ void set_SddlForm(string value);
            }

            enum WellKnownSidType
            {
                NullSid = 0,
                WorldSid = 1,
                LocalSid = 2,
                CreatorOwnerSid = 3,
                CreatorGroupSid = 4,
                CreatorOwnerServerSid = 5,
                CreatorGroupServerSid = 6,
                NTAuthoritySid = 7,
                DialupSid = 8,
                NetworkSid = 9,
                BatchSid = 10,
                InteractiveSid = 11,
                ServiceSid = 12,
                AnonymousSid = 13,
                ProxySid = 14,
                EnterpriseControllersSid = 15,
                SelfSid = 16,
                AuthenticatedUserSid = 17,
                RestrictedCodeSid = 18,
                TerminalServerSid = 19,
                RemoteLogonIdSid = 20,
                LogonIdsSid = 21,
                LocalSystemSid = 22,
                LocalServiceSid = 23,
                NetworkServiceSid = 24,
                BuiltinDomainSid = 25,
                BuiltinAdministratorsSid = 26,
                BuiltinUsersSid = 27,
                BuiltinGuestsSid = 28,
                BuiltinPowerUsersSid = 29,
                BuiltinAccountOperatorsSid = 30,
                BuiltinSystemOperatorsSid = 31,
                BuiltinPrintOperatorsSid = 32,
                BuiltinBackupOperatorsSid = 33,
                BuiltinReplicatorSid = 34,
                BuiltinPreWindows2000CompatibleAccessSid = 35,
                BuiltinRemoteDesktopUsersSid = 36,
                BuiltinNetworkConfigurationOperatorsSid = 37,
                AccountAdministratorSid = 38,
                AccountGuestSid = 39,
                AccountKrbtgtSid = 40,
                AccountDomainAdminsSid = 41,
                AccountDomainUsersSid = 42,
                AccountDomainGuestsSid = 43,
                AccountComputersSid = 44,
                AccountControllersSid = 45,
                AccountCertAdminsSid = 46,
                AccountSchemaAdminsSid = 47,
                AccountEnterpriseAdminsSid = 48,
                AccountPolicyAdminsSid = 49,
                AccountRasAndIasServersSid = 50,
                NtlmAuthenticationSid = 51,
                DigestAuthenticationSid = 52,
                SChannelAuthenticationSid = 53,
                ThisOrganizationSid = 54,
                OtherOrganizationSid = 55,
                BuiltinIncomingForestTrustBuildersSid = 56,
                BuiltinPerformanceMonitoringUsersSid = 57,
                BuiltinPerformanceLoggingUsersSid = 58,
                BuiltinAuthorizationAccessSid = 59,
                WinBuiltinTerminalServerLicenseServersSid = 60,
                MaxDefined = 60,
                WinBuiltinDCOMUsersSid = 61,
                WinBuiltinIUsersSid = 62,
                WinIUserSid = 63,
                WinBuiltinCryptoOperatorsSid = 64,
                WinUntrustedLabelSid = 65,
                WinLowLabelSid = 66,
                WinMediumLabelSid = 67,
                WinHighLabelSid = 68,
                WinSystemLabelSid = 69,
                WinWriteRestrictedCodeSid = 70,
                WinCreatorOwnerRightsSid = 71,
                WinCacheablePrincipalsGroupSid = 72,
                WinNonCacheablePrincipalsGroupSid = 73,
                WinEnterpriseReadonlyControllersSid = 74,
                WinAccountReadonlyControllersSid = 75,
                WinBuiltinEventLogReadersGroup = 76,
                WinNewEnterpriseReadonlyControllersSid = 77,
                WinBuiltinCertSvcDComAccessGroup = 78,
                WinMediumPlusLabelSid = 79,
                WinLocalLogonSid = 80,
                WinConsoleLogonSid = 81,
                WinThisOrganizationCertificateSid = 82,
                WinApplicationPackageAuthoritySid = 83,
                WinBuiltinAnyPackageSid = 84,
                WinCapabilityInternetClientSid = 85,
                WinCapabilityInternetClientServerSid = 86,
                WinCapabilityPrivateNetworkClientServerSid = 87,
                WinCapabilityPicturesLibrarySid = 88,
                WinCapabilityVideosLibrarySid = 89,
                WinCapabilityMusicLibrarySid = 90,
                WinCapabilityDocumentsLibrarySid = 91,
                WinCapabilitySharedUserCertificatesSid = 92,
                WinCapabilityEnterpriseAuthenticationSid = 93,
                WinCapabilityRemovableStorageSid = 94,
            }

            enum WindowsAccountType
            {
                Normal = 0,
                Guest = 1,
                System = 2,
                Anonymous = 3,
            }

            enum WindowsBuiltInRole
            {
                Administrator = 544,
                User = 545,
                Guest = 546,
                PowerUser = 547,
                AccountOperator = 548,
                SystemOperator = 549,
                PrintOperator = 550,
                BackupOperator = 551,
                Replicator = 552,
            }

            class WindowsIdentity : System.Security.Claims.ClaimsIdentity, System.Security.Principal.IIdentity, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable, System.IDisposable
            {
                static string DefaultIssuer = "AD AUTHORITY";
                static /*0x0*/ nint invalidWindows;
                /*0x78*/ nint _token;
                /*0x80*/ string _type;
                /*0x88*/ System.Security.Principal.WindowsAccountType _account;
                /*0x8c*/ bool _authenticated;
                /*0x90*/ string _name;
                /*0x98*/ System.Runtime.Serialization.SerializationInfo _info;

                static /*0x20066b4*/ WindowsIdentity();
                static /*0x2005b74*/ System.Security.Principal.WindowsIdentity GetAnonymous();
                static /*0x2005c88*/ System.Security.Principal.WindowsIdentity GetCurrent();
                static /*0x2005d10*/ System.Security.Principal.WindowsIdentity GetCurrent(bool ifImpersonating);
                static /*0x2005d50*/ System.Security.Principal.WindowsIdentity GetCurrent(System.Security.Principal.TokenAccessLevels desiredAccess);
                static /*0x2005e80*/ System.Security.Principal.WindowsImpersonationContext Impersonate(nint userToken);
                static /*0x2005ee0*/ void RunImpersonated(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle safeAccessTokenHandle, System.Action action);
                static T RunImpersonated<T>(Microsoft.Win32.SafeHandles.SafeAccessTokenHandle safeAccessTokenHandle, System.Func<T> func);
                static /*0x20066b0*/ string[] _GetRoles(nint token);
                static /*0x2005d0c*/ nint GetCurrentToken();
                static /*0x2005fc8*/ string GetTokenName(nint token);
                static /*0x20059f0*/ nint GetUserToken(string username);
                /*0x2005698*/ WindowsIdentity(nint userToken);
                /*0x200570c*/ WindowsIdentity(nint userToken, string type);
                /*0x2005718*/ WindowsIdentity(nint userToken, string type, System.Security.Principal.WindowsAccountType acctType);
                /*0x20056a8*/ WindowsIdentity(nint userToken, string type, System.Security.Principal.WindowsAccountType acctType, bool isAuthenticated);
                /*0x2005880*/ WindowsIdentity(string sUserPrincipalName);
                /*0x2005888*/ WindowsIdentity(string sUserPrincipalName, string type);
                /*0x20059f4*/ WindowsIdentity(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2005a30*/ WindowsIdentity(System.Security.Claims.ClaimsIdentity claimsIdentity, nint userToken);
                /*0x200671c*/ WindowsIdentity(System.Security.Principal.WindowsIdentity identity);
                /*0x2005ad4*/ void Dispose();
                /*0x2005b24*/ void Dispose(bool disposing);
                /*0x2005d90*/ System.Security.Principal.WindowsImpersonationContext Impersonate();
                /*0x2005f20*/ string get_AuthenticationType();
                /*0x2005f28*/ bool get_IsAnonymous();
                /*0x2005f38*/ bool get_IsAuthenticated();
                /*0x2005f40*/ bool get_IsGuest();
                /*0x2005f50*/ bool get_IsSystem();
                /*0x2005f60*/ string get_Name();
                /*0x2005fcc*/ nint get_Token();
                /*0x2005fd4*/ System.Security.Principal.IdentityReferenceCollection get_Groups();
                /*0x2006014*/ System.Security.Principal.TokenImpersonationLevel get_ImpersonationLevel();
                /*0x2006054*/ System.Security.Principal.SecurityIdentifier get_Owner();
                /*0x2006094*/ System.Security.Principal.SecurityIdentifier get_User();
                /*0x20060d4*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
                /*0x20063ac*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2006514*/ System.Security.Claims.ClaimsIdentity CloneAsBase();
                /*0x2006668*/ nint GetTokenInternal();
                /*0x2005720*/ void SetToken(nint token);
                /*0x2006670*/ Microsoft.Win32.SafeHandles.SafeAccessTokenHandle get_AccessToken();
                /*0x2006754*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> get_DeviceClaims();
                /*0x200678c*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> get_UserClaims();
            }

            class WindowsImpersonationContext : System.IDisposable
            {
                /*0x10*/ nint _token;
                /*0x18*/ bool undo;

                static /*0x2006924*/ bool CloseToken(nint token);
                static /*0x20067c4*/ nint DuplicateToken(nint token);
                static /*0x20067c8*/ bool SetCurrentToken(nint token);
                static /*0x2006920*/ bool RevertToSelf();
                /*0x2005df4*/ WindowsImpersonationContext(nint token);
                /*0x2006928*/ WindowsImpersonationContext();
                /*0x20067cc*/ void Dispose();
                /*0x20068a0*/ void Dispose(bool disposing);
                /*0x20067dc*/ void Undo();
            }

            class WindowsPrincipal : System.Security.Claims.ClaimsPrincipal
            {
                /*0x30*/ System.Security.Principal.WindowsIdentity _identity;
                /*0x38*/ string[] m_roles;

                static /*0x2006b68*/ bool IsMemberOfGroupId(nint user, nint group);
                static /*0x2006d64*/ bool IsMemberOfGroupName(nint user, nint group);
                /*0x2006960*/ WindowsPrincipal(System.Security.Principal.WindowsIdentity ntIdentity);
                /*0x2006a18*/ System.Security.Principal.IIdentity get_Identity();
                /*0x2006a20*/ bool IsInRole(int rid);
                /*0x2006b6c*/ bool IsInRole(string role);
                /*0x2006d68*/ bool IsInRole(System.Security.Principal.WindowsBuiltInRole role);
                /*0x2006e04*/ bool IsInRole(System.Security.Principal.SecurityIdentifier sid);
                /*0x2006b44*/ nint get_Token();
                /*0x2006e44*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> get_DeviceClaims();
                /*0x2006e7c*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> get_UserClaims();
            }
        }

        namespace Claims
        {
            class ClaimTypes
            {
                static string ClaimTypeNamespace = "http://schemas.microsoft.com/ws/2008/06/identity/claims";
                static string AuthenticationInstant = "http://schemas.microsoft.com/ws/2008/06/identity/claims/authenticationinstant";
                static string AuthenticationMethod = "http://schemas.microsoft.com/ws/2008/06/identity/claims/authenticationmethod";
                static string CookiePath = "http://schemas.microsoft.com/ws/2008/06/identity/claims/cookiepath";
                static string DenyOnlyPrimarySid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarysid";
                static string DenyOnlyPrimaryGroupSid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlyprimarygroupsid";
                static string DenyOnlyWindowsDeviceGroup = "http://schemas.microsoft.com/ws/2008/06/identity/claims/denyonlywindowsdevicegroup";
                static string Dsa = "http://schemas.microsoft.com/ws/2008/06/identity/claims/dsa";
                static string Expiration = "http://schemas.microsoft.com/ws/2008/06/identity/claims/expiration";
                static string Expired = "http://schemas.microsoft.com/ws/2008/06/identity/claims/expired";
                static string GroupSid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/groupsid";
                static string IsPersistent = "http://schemas.microsoft.com/ws/2008/06/identity/claims/ispersistent";
                static string PrimaryGroupSid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/primarygroupsid";
                static string PrimarySid = "http://schemas.microsoft.com/ws/2008/06/identity/claims/primarysid";
                static string Role = "http://schemas.microsoft.com/ws/2008/06/identity/claims/role";
                static string SerialNumber = "http://schemas.microsoft.com/ws/2008/06/identity/claims/serialnumber";
                static string UserData = "http://schemas.microsoft.com/ws/2008/06/identity/claims/userdata";
                static string Version = "http://schemas.microsoft.com/ws/2008/06/identity/claims/version";
                static string WindowsAccountName = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsaccountname";
                static string WindowsDeviceClaim = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsdeviceclaim";
                static string WindowsDeviceGroup = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsdevicegroup";
                static string WindowsUserClaim = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsuserclaim";
                static string WindowsFqbnVersion = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowsfqbnversion";
                static string WindowsSubAuthority = "http://schemas.microsoft.com/ws/2008/06/identity/claims/windowssubauthority";
                static string ClaimType2005Namespace = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims";
                static string Anonymous = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/anonymous";
                static string Authentication = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/authentication";
                static string AuthorizationDecision = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/authorizationdecision";
                static string Country = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/country";
                static string DateOfBirth = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/dateofbirth";
                static string Dns = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/dns";
                static string DenyOnlySid = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/denyonlysid";
                static string Email = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress";
                static string Gender = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/gender";
                static string GivenName = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname";
                static string Hash = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/hash";
                static string HomePhone = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/homephone";
                static string Locality = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/locality";
                static string MobilePhone = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/mobilephone";
                static string Name = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name";
                static string NameIdentifier = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier";
                static string OtherPhone = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/otherphone";
                static string PostalCode = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/postalcode";
                static string Rsa = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/rsa";
                static string Sid = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/sid";
                static string Spn = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/spn";
                static string StateOrProvince = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/stateorprovince";
                static string StreetAddress = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/streetaddress";
                static string Surname = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname";
                static string System = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/system";
                static string Thumbprint = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/thumbprint";
                static string Upn = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/upn";
                static string Uri = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/uri";
                static string Webpage = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/webpage";
                static string X500DistinguishedName = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/x500distinguishedname";
                static string ClaimType2009Namespace = "http://schemas.xmlsoap.org/ws/2009/09/identity/claims";
                static string Actor = "http://schemas.xmlsoap.org/ws/2009/09/identity/claims/actor";
            }

            class Claim
            {
                /*0x10*/ string m_issuer;
                /*0x18*/ string m_originalIssuer;
                /*0x20*/ string m_type;
                /*0x28*/ string m_value;
                /*0x30*/ string m_valueType;
                /*0x38*/ byte[] m_userSerializationData;
                /*0x40*/ System.Collections.Generic.Dictionary<string, string> m_properties;
                /*0x48*/ object m_propertyLock;
                /*0x50*/ System.Security.Claims.ClaimsIdentity m_subject;

                /*0x2006eb4*/ Claim(System.IO.BinaryReader reader);
                /*0x2006ebc*/ Claim(System.IO.BinaryReader reader, System.Security.Claims.ClaimsIdentity subject);
                /*0x20072f4*/ Claim(string type, string value);
                /*0x2007390*/ Claim(string type, string value, string valueType);
                /*0x200741c*/ Claim(string type, string value, string valueType, string issuer);
                /*0x2007444*/ Claim(string type, string value, string valueType, string issuer, string originalIssuer);
                /*0x1fffcd8*/ Claim(string type, string value, string valueType, string issuer, string originalIssuer, System.Security.Claims.ClaimsIdentity subject);
                /*0x2007468*/ Claim(string type, string value, string valueType, string issuer, string originalIssuer, System.Security.Claims.ClaimsIdentity subject, string propertyKey, string propertyValue);
                /*0x20077f8*/ Claim(System.Security.Claims.Claim other);
                /*0x200780c*/ Claim(System.Security.Claims.Claim other, System.Security.Claims.ClaimsIdentity subject);
                /*0x2007b20*/ byte[] get_CustomSerializationData();
                /*0x2007b28*/ string get_Issuer();
                /*0x2007b30*/ void OnDeserializedMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x2007b90*/ string get_OriginalIssuer();
                /*0x20076c0*/ System.Collections.Generic.IDictionary<string, string> get_Properties();
                /*0x2007b98*/ System.Security.Claims.ClaimsIdentity get_Subject();
                /*0x2007ba0*/ void set_Subject(System.Security.Claims.ClaimsIdentity value);
                /*0x2007ba8*/ string get_Type();
                /*0x2007bb0*/ string get_Value();
                /*0x2007bb8*/ string get_ValueType();
                /*0x2007bc0*/ System.Security.Claims.Claim Clone();
                /*0x2007bd0*/ System.Security.Claims.Claim Clone(System.Security.Claims.ClaimsIdentity identity);
                /*0x2006f94*/ void Initialize(System.IO.BinaryReader reader, System.Security.Claims.ClaimsIdentity subject);
                /*0x2007c40*/ void WriteTo(System.IO.BinaryWriter writer);
                /*0x2007c50*/ void WriteTo(System.IO.BinaryWriter writer, byte[] userData);
                /*0x2008454*/ string ToString();

                enum SerializationMask
                {
                    None = 0,
                    NameClaimType = 1,
                    RoleClaimType = 2,
                    StringType = 4,
                    Issuer = 8,
                    OriginalIssuerEqualsIssuer = 16,
                    OriginalIssuer = 32,
                    HasProperties = 64,
                    UserData = 128,
                }
            }

            class ClaimValueTypes
            {
                static string XmlSchemaNamespace = "http://www.w3.org/2001/XMLSchema";
                static string Base64Binary = "http://www.w3.org/2001/XMLSchema#base64Binary";
                static string Base64Octet = "http://www.w3.org/2001/XMLSchema#base64Octet";
                static string Boolean = "http://www.w3.org/2001/XMLSchema#boolean";
                static string Date = "http://www.w3.org/2001/XMLSchema#date";
                static string DateTime = "http://www.w3.org/2001/XMLSchema#dateTime";
                static string Double = "http://www.w3.org/2001/XMLSchema#double";
                static string Fqbn = "http://www.w3.org/2001/XMLSchema#fqbn";
                static string HexBinary = "http://www.w3.org/2001/XMLSchema#hexBinary";
                static string Integer = "http://www.w3.org/2001/XMLSchema#integer";
                static string Integer32 = "http://www.w3.org/2001/XMLSchema#integer32";
                static string Integer64 = "http://www.w3.org/2001/XMLSchema#integer64";
                static string Sid = "http://www.w3.org/2001/XMLSchema#sid";
                static string String = "http://www.w3.org/2001/XMLSchema#string";
                static string Time = "http://www.w3.org/2001/XMLSchema#time";
                static string UInteger32 = "http://www.w3.org/2001/XMLSchema#uinteger32";
                static string UInteger64 = "http://www.w3.org/2001/XMLSchema#uinteger64";
                static string SoapSchemaNamespace = "http://schemas.xmlsoap.org/";
                static string DnsName = "http://schemas.xmlsoap.org/claims/dns";
                static string Email = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress";
                static string Rsa = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/rsa";
                static string UpnName = "http://schemas.xmlsoap.org/claims/UPN";
                static string XmlSignatureConstantsNamespace = "http://www.w3.org/2000/09/xmldsig#";
                static string DsaKeyValue = "http://www.w3.org/2000/09/xmldsig#DSAKeyValue";
                static string KeyInfo = "http://www.w3.org/2000/09/xmldsig#KeyInfo";
                static string RsaKeyValue = "http://www.w3.org/2000/09/xmldsig#RSAKeyValue";
                static string XQueryOperatorsNameSpace = "http://www.w3.org/TR/2002/WD-xquery-operators-20020816";
                static string DaytimeDuration = "http://www.w3.org/TR/2002/WD-xquery-operators-20020816#dayTimeDuration";
                static string YearMonthDuration = "http://www.w3.org/TR/2002/WD-xquery-operators-20020816#yearMonthDuration";
                static string Xacml10Namespace = "urn:oasis:names:tc:xacml:1.0";
                static string Rfc822Name = "urn:oasis:names:tc:xacml:1.0:data-type:rfc822Name";
                static string X500Name = "urn:oasis:names:tc:xacml:1.0:data-type:x500Name";
            }

            class ClaimsIdentity : System.Security.Principal.IIdentity
            {
                static string PreFix = "System.Security.ClaimsIdentity.";
                static string ActorKey = "System.Security.ClaimsIdentity.actor";
                static string AuthenticationTypeKey = "System.Security.ClaimsIdentity.authenticationType";
                static string BootstrapContextKey = "System.Security.ClaimsIdentity.bootstrapContext";
                static string ClaimsKey = "System.Security.ClaimsIdentity.claims";
                static string LabelKey = "System.Security.ClaimsIdentity.label";
                static string NameClaimTypeKey = "System.Security.ClaimsIdentity.nameClaimType";
                static string RoleClaimTypeKey = "System.Security.ClaimsIdentity.roleClaimType";
                static string VersionKey = "System.Security.ClaimsIdentity.version";
                static string DefaultIssuer = "LOCAL AUTHORITY";
                static string DefaultNameClaimType = "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name";
                static string DefaultRoleClaimType = "http://schemas.microsoft.com/ws/2008/06/identity/claims/role";
                /*0x10*/ byte[] m_userSerializationData;
                /*0x18*/ System.Collections.Generic.List<System.Security.Claims.Claim> m_instanceClaims;
                /*0x20*/ System.Collections.ObjectModel.Collection<System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>> m_externalClaims;
                /*0x28*/ string m_nameType;
                /*0x30*/ string m_roleType;
                /*0x38*/ string m_version;
                /*0x40*/ System.Security.Claims.ClaimsIdentity m_actor;
                /*0x48*/ string m_authenticationType;
                /*0x50*/ object m_bootstrapContext;
                /*0x58*/ string m_label;
                /*0x60*/ string m_serializedNameType;
                /*0x68*/ string m_serializedRoleType;
                /*0x70*/ string m_serializedClaims;

                /*0x1fff7a0*/ ClaimsIdentity();
                /*0x20084e8*/ ClaimsIdentity(System.Security.Principal.IIdentity identity);
                /*0x20084cc*/ ClaimsIdentity(System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims);
                /*0x200851c*/ ClaimsIdentity(string authenticationType);
                /*0x2008538*/ ClaimsIdentity(System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims, string authenticationType);
                /*0x2008500*/ ClaimsIdentity(System.Security.Principal.IIdentity identity, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims);
                /*0x2008554*/ ClaimsIdentity(string authenticationType, string nameType, string roleType);
                /*0x2008570*/ ClaimsIdentity(System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims, string authenticationType, string nameType, string roleType);
                /*0x2008514*/ ClaimsIdentity(System.Security.Principal.IIdentity identity, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims, string authenticationType, string nameType, string roleType);
                /*0x200858c*/ ClaimsIdentity(System.Security.Principal.IIdentity identity, System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims, string authenticationType, string nameType, string roleType, bool checkAuthType);
                /*0x2009158*/ ClaimsIdentity(System.IO.BinaryReader reader);
                /*0x1fff99c*/ ClaimsIdentity(System.Security.Claims.ClaimsIdentity other);
                /*0x200950c*/ ClaimsIdentity(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2009e84*/ ClaimsIdentity(System.Runtime.Serialization.SerializationInfo info);
                /*0x200a010*/ string get_AuthenticationType();
                /*0x200a018*/ bool get_IsAuthenticated();
                /*0x200a038*/ System.Security.Claims.ClaimsIdentity get_Actor();
                /*0x200a040*/ void set_Actor(System.Security.Claims.ClaimsIdentity value);
                /*0x200a0d0*/ object get_BootstrapContext();
                /*0x200a0d8*/ void set_BootstrapContext(object value);
                /*0x1fffbf0*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> get_Claims();
                /*0x200a114*/ byte[] get_CustomSerializationData();
                /*0x200a11c*/ System.Collections.ObjectModel.Collection<System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>> get_ExternalClaims();
                /*0x200a124*/ string get_Label();
                /*0x200a12c*/ void set_Label(string value);
                /*0x200a134*/ string get_Name();
                /*0x200a15c*/ string get_NameClaimType();
                /*0x200a164*/ string get_RoleClaimType();
                /*0x2006518*/ System.Security.Claims.ClaimsIdentity Clone();
                /*0x1fffcf8*/ void AddClaim(System.Security.Claims.Claim claim);
                /*0x200a16c*/ void AddClaims(System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims);
                /*0x200a498*/ bool TryRemoveClaim(System.Security.Claims.Claim claim);
                /*0x200a560*/ void RemoveClaim(System.Security.Claims.Claim claim);
                /*0x2008c40*/ void SafeAddClaims(System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> claims);
                /*0x200902c*/ void SafeAddClaim(System.Security.Claims.Claim claim);
                /*0x200a620*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> FindAll(System.Predicate<System.Security.Claims.Claim> match);
                /*0x200aa78*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> FindAll(string type);
                /*0x200aed8*/ bool HasClaim(System.Predicate<System.Security.Claims.Claim> match);
                /*0x200b24c*/ bool HasClaim(string type, string value);
                /*0x200b618*/ System.Security.Claims.Claim FindFirst(System.Predicate<System.Security.Claims.Claim> match);
                /*0x200b990*/ System.Security.Claims.Claim FindFirst(string type);
                /*0x200bd0c*/ void OnSerializingMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x200bfc0*/ void OnDeserializedMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x200c3d4*/ void OnDeserializingMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x200c4b0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x200c09c*/ void DeserializeClaims(string serializedClaims);
                /*0x200bd70*/ string SerializeClaims();
                /*0x2008c08*/ bool IsCircular(System.Security.Claims.ClaimsIdentity subject);
                /*0x20092d8*/ void Initialize(System.IO.BinaryReader reader);
                /*0x200ca64*/ System.Security.Claims.Claim CreateClaim(System.IO.BinaryReader reader);
                /*0x200cb1c*/ void WriteTo(System.IO.BinaryWriter writer);
                /*0x200cb30*/ void WriteTo(System.IO.BinaryWriter writer, byte[] userData);
                /*0x20096a8*/ void Deserialize(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, bool useContext);

                enum SerializationMask
                {
                    None = 0,
                    AuthenticationType = 1,
                    BootstrapConext = 2,
                    NameClaimType = 4,
                    RoleClaimType = 8,
                    HasClaims = 16,
                    HasLabel = 32,
                    Actor = 64,
                    UserData = 128,
                }

                class <get_Claims>d__51 : System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Security.Claims.Claim>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Security.Claims.Claim <>2__current;
                    /*0x20*/ int <>l__initialThreadId;
                    /*0x28*/ System.Security.Claims.ClaimsIdentity <>4__this;
                    /*0x30*/ int <i>5__2;
                    /*0x38*/ System.Collections.Generic.IEnumerator<System.Security.Claims.Claim> <>7__wrap2;

                    /*0x200a0e0*/ <get_Claims>d__51(int <>1__state);
                    /*0x200cfc0*/ void System.IDisposable.Dispose();
                    /*0x200cfdc*/ bool MoveNext();
                    /*0x200d3d4*/ void <>m__Finally1();
                    /*0x200d484*/ System.Security.Claims.Claim System.Collections.Generic.IEnumerator<System.Security.Claims.Claim>.get_Current();
                    /*0x200d48c*/ void System.Collections.IEnumerator.Reset();
                    /*0x200d4cc*/ object System.Collections.IEnumerator.get_Current();
                    /*0x200d4d4*/ System.Collections.Generic.IEnumerator<System.Security.Claims.Claim> System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>.GetEnumerator();
                    /*0x200d578*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                }
            }

            class ClaimsPrincipal : System.Security.Principal.IPrincipal
            {
                static string PreFix = "System.Security.ClaimsPrincipal.";
                static string IdentitiesKey = "System.Security.ClaimsPrincipal.Identities";
                static string VersionKey = "System.Security.ClaimsPrincipal.Version";
                static /*0x0*/ System.Func<System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>, System.Security.Claims.ClaimsIdentity> s_identitySelector;
                static /*0x8*/ System.Func<System.Security.Claims.ClaimsPrincipal> s_principalSelector;
                /*0x10*/ byte[] m_userSerializationData;
                /*0x18*/ string m_version;
                /*0x20*/ string m_serializedClaimsIdentities;
                /*0x28*/ System.Collections.Generic.List<System.Security.Claims.ClaimsIdentity> m_identities;

                static /*0x20116f4*/ ClaimsPrincipal();
                static /*0x200d57c*/ System.Security.Claims.ClaimsIdentity SelectPrimaryIdentity(System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity> identities);
                static /*0x200d8fc*/ System.Security.Claims.ClaimsPrincipal SelectClaimsPrincipal();
                static /*0x200dc68*/ System.Func<System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>, System.Security.Claims.ClaimsIdentity> get_PrimaryIdentitySelector();
                static /*0x200dcc0*/ void set_PrimaryIdentitySelector(System.Func<System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity>, System.Security.Claims.ClaimsIdentity> value);
                static /*0x200dd1c*/ System.Func<System.Security.Claims.ClaimsPrincipal> get_ClaimsPrincipalSelector();
                static /*0x200dd74*/ void set_ClaimsPrincipalSelector(System.Func<System.Security.Claims.ClaimsPrincipal> value);
                static /*0x200fc6c*/ System.Security.Claims.ClaimsPrincipal get_Current();
                /*0x1ffffd8*/ ClaimsPrincipal();
                /*0x200ddd0*/ ClaimsPrincipal(System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity> identities);
                /*0x200deec*/ ClaimsPrincipal(System.Security.Principal.IIdentity identity);
                /*0x200d9a4*/ ClaimsPrincipal(System.Security.Principal.IPrincipal principal);
                /*0x200e118*/ ClaimsPrincipal(System.IO.BinaryReader reader);
                /*0x200e400*/ ClaimsPrincipal(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x200e654*/ byte[] get_CustomSerializationData();
                /*0x200e65c*/ System.Security.Claims.ClaimsPrincipal Clone();
                /*0x200e6bc*/ System.Security.Claims.ClaimsIdentity CreateClaimsIdentity(System.IO.BinaryReader reader);
                /*0x200e76c*/ void OnSerializingMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x200f1e8*/ void OnDeserializedMethod(System.Runtime.Serialization.StreamingContext context);
                /*0x200f944*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x200e500*/ void Deserialize(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x200f248*/ void DeserializeIdentities(string identities);
                /*0x200e7c8*/ string SerializeIdentities();
                /*0x200fa20*/ void AddIdentity(System.Security.Claims.ClaimsIdentity identity);
                /*0x200fb18*/ void AddIdentities(System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity> identities);
                /*0x200fbc0*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> get_Claims();
                /*0x200fd14*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> FindAll(System.Predicate<System.Security.Claims.Claim> match);
                /*0x2010440*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> FindAll(string type);
                /*0x2010b6c*/ System.Security.Claims.Claim FindFirst(System.Predicate<System.Security.Claims.Claim> match);
                /*0x2010ed4*/ System.Security.Claims.Claim FindFirst(string type);
                /*0x2010fe8*/ bool HasClaim(System.Predicate<System.Security.Claims.Claim> match);
                /*0x2011104*/ bool HasClaim(string type, string value);
                /*0x2011250*/ System.Collections.Generic.IEnumerable<System.Security.Claims.ClaimsIdentity> get_Identities();
                /*0x20112a0*/ System.Security.Principal.IIdentity get_Identity();
                /*0x2011350*/ bool IsInRole(string role);
                /*0x200e218*/ void Initialize(System.IO.BinaryReader reader);
                /*0x2011444*/ void WriteTo(System.IO.BinaryWriter writer);
                /*0x2011458*/ void WriteTo(System.IO.BinaryWriter writer, byte[] userData);

                enum SerializationMask
                {
                    None = 0,
                    HasIdentities = 1,
                    UserData = 2,
                }

                class <get_Claims>d__37 : System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Security.Claims.Claim>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Security.Claims.Claim <>2__current;
                    /*0x20*/ int <>l__initialThreadId;
                    /*0x28*/ System.Security.Claims.ClaimsPrincipal <>4__this;
                    /*0x30*/ System.Collections.Generic.IEnumerator<System.Security.Claims.ClaimsIdentity> <>7__wrap1;
                    /*0x38*/ System.Collections.Generic.IEnumerator<System.Security.Claims.Claim> <>7__wrap2;

                    /*0x200fc38*/ <get_Claims>d__37(int <>1__state);
                    /*0x20117c0*/ void System.IDisposable.Dispose();
                    /*0x2011878*/ bool MoveNext();
                    /*0x2011d84*/ void <>m__Finally1();
                    /*0x2011cd4*/ void <>m__Finally2();
                    /*0x2011e34*/ System.Security.Claims.Claim System.Collections.Generic.IEnumerator<System.Security.Claims.Claim>.get_Current();
                    /*0x2011e3c*/ void System.Collections.IEnumerator.Reset();
                    /*0x2011e7c*/ object System.Collections.IEnumerator.get_Current();
                    /*0x2011e84*/ System.Collections.Generic.IEnumerator<System.Security.Claims.Claim> System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>.GetEnumerator();
                    /*0x2011f28*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                }
            }

            class RoleClaimProvider
            {
                /*0x10*/ string m_issuer;
                /*0x18*/ string[] m_roles;
                /*0x20*/ System.Security.Claims.ClaimsIdentity m_subject;

                /*0x2011f2c*/ RoleClaimProvider(string issuer, string[] roles, System.Security.Claims.ClaimsIdentity subject);
                /*0x2011f68*/ System.Collections.Generic.IEnumerable<System.Security.Claims.Claim> get_Claims();

                class <get_Claims>d__5 : System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Security.Claims.Claim>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Security.Claims.Claim <>2__current;
                    /*0x20*/ int <>l__initialThreadId;
                    /*0x28*/ System.Security.Claims.RoleClaimProvider <>4__this;
                    /*0x30*/ int <i>5__2;

                    /*0x2011fe0*/ <get_Claims>d__5(int <>1__state);
                    /*0x2012014*/ void System.IDisposable.Dispose();
                    /*0x2012018*/ bool MoveNext();
                    /*0x201214c*/ System.Security.Claims.Claim System.Collections.Generic.IEnumerator<System.Security.Claims.Claim>.get_Current();
                    /*0x2012154*/ void System.Collections.IEnumerator.Reset();
                    /*0x2012194*/ object System.Collections.IEnumerator.get_Current();
                    /*0x201219c*/ System.Collections.Generic.IEnumerator<System.Security.Claims.Claim> System.Collections.Generic.IEnumerable<System.Security.Claims.Claim>.GetEnumerator();
                    /*0x2012240*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                }
            }
        }

        namespace AccessControl
        {
            class PrivilegeNotHeldException : System.UnauthorizedAccessException, System.Runtime.Serialization.ISerializable
            {
                /*0x90*/ string _privilegeName;

                /*0x2012244*/ PrivilegeNotHeldException();
                /*0x2012290*/ PrivilegeNotHeldException(string privilege);
                /*0x201232c*/ PrivilegeNotHeldException(string privilege, System.Exception inner);
                /*0x20123d0*/ PrivilegeNotHeldException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2012458*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2012534*/ string get_PrivilegeName();
            }

            enum AccessControlActions
            {
                None = 0,
                View = 1,
                Change = 2,
            }

            enum AccessControlModification
            {
                Add = 0,
                Set = 1,
                Reset = 2,
                Remove = 3,
                RemoveAll = 4,
                RemoveSpecific = 5,
            }

            enum AccessControlSections
            {
                None = 0,
                Audit = 1,
                Access = 2,
                Owner = 4,
                Group = 8,
                All = 15,
            }

            enum AccessControlType
            {
                Allow = 0,
                Deny = 1,
            }

            class AccessRule : System.Security.AccessControl.AuthorizationRule
            {
                /*0x28*/ System.Security.AccessControl.AccessControlType type;

                /*0x201253c*/ AccessRule(System.Security.Principal.IdentityReference identity, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x2012768*/ System.Security.AccessControl.AccessControlType get_AccessControlType();
            }

            class AccessRule<T> : System.Security.AccessControl.AccessRule
            {
                AccessRule(string identity, T rights, System.Security.AccessControl.AccessControlType type);
                AccessRule(System.Security.Principal.IdentityReference identity, T rights, System.Security.AccessControl.AccessControlType type);
                AccessRule(string identity, T rights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                AccessRule(System.Security.Principal.IdentityReference identity, T rights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                AccessRule(System.Security.Principal.IdentityReference identity, int rights, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                T get_Rights();
            }

            class AceEnumerator : System.Collections.IEnumerator
            {
                /*0x10*/ System.Security.AccessControl.GenericAcl owner;
                /*0x18*/ int current;

                /*0x2012770*/ AceEnumerator(System.Security.AccessControl.GenericAcl owner);
                /*0x201283c*/ AceEnumerator();
                /*0x20127a0*/ System.Security.AccessControl.GenericAce get_Current();
                /*0x20127d4*/ object System.Collections.IEnumerator.get_Current();
                /*0x20127d8*/ bool MoveNext();
                /*0x2012830*/ void Reset();
            }

            enum AceFlags
            {
                None = 0,
                ObjectInherit = 1,
                ContainerInherit = 2,
                NoPropagateInherit = 4,
                InheritOnly = 8,
                InheritanceFlags = 15,
                Inherited = 16,
                SuccessfulAccess = 64,
                FailedAccess = 128,
                AuditFlags = 192,
            }

            enum AceQualifier
            {
                AccessAllowed = 0,
                AccessDenied = 1,
                SystemAudit = 2,
                SystemAlarm = 3,
            }

            enum AceType
            {
                AccessAllowed = 0,
                AccessDenied = 1,
                SystemAudit = 2,
                SystemAlarm = 3,
                AccessAllowedCompound = 4,
                AccessAllowedObject = 5,
                AccessDeniedObject = 6,
                SystemAuditObject = 7,
                SystemAlarmObject = 8,
                AccessAllowedCallback = 9,
                AccessDeniedCallback = 10,
                AccessAllowedCallbackObject = 11,
                AccessDeniedCallbackObject = 12,
                SystemAuditCallback = 13,
                SystemAlarmCallback = 14,
                SystemAuditCallbackObject = 15,
                SystemAlarmCallbackObject = 16,
                MaxDefinedAceType = 16,
            }

            enum AuditFlags
            {
                None = 0,
                Success = 1,
                Failure = 2,
            }

            class AuditRule : System.Security.AccessControl.AuthorizationRule
            {
                /*0x28*/ System.Security.AccessControl.AuditFlags auditFlags;

                /*0x2012874*/ AuditRule(System.Security.Principal.IdentityReference identity, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags);
                /*0x2012904*/ System.Security.AccessControl.AuditFlags get_AuditFlags();
            }

            class AuditRule<T> : System.Security.AccessControl.AuditRule
            {
                AuditRule(string identity, T rights, System.Security.AccessControl.AuditFlags flags);
                AuditRule(System.Security.Principal.IdentityReference identity, T rights, System.Security.AccessControl.AuditFlags flags);
                AuditRule(string identity, T rights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                AuditRule(System.Security.Principal.IdentityReference identity, T rights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                AuditRule(System.Security.Principal.IdentityReference identity, int rights, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                T get_Rights();
            }

            class AuthorizationRule
            {
                /*0x10*/ System.Security.Principal.IdentityReference identity;
                /*0x18*/ int accessMask;
                /*0x1c*/ bool isInherited;
                /*0x20*/ System.Security.AccessControl.InheritanceFlags inheritanceFlags;
                /*0x24*/ System.Security.AccessControl.PropagationFlags propagationFlags;

                /*0x201290c*/ AuthorizationRule();
                /*0x20125cc*/ AuthorizationRule(System.Security.Principal.IdentityReference identity, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags);
                /*0x2012914*/ System.Security.Principal.IdentityReference get_IdentityReference();
                /*0x201291c*/ System.Security.AccessControl.InheritanceFlags get_InheritanceFlags();
                /*0x2012924*/ bool get_IsInherited();
                /*0x201292c*/ System.Security.AccessControl.PropagationFlags get_PropagationFlags();
                /*0x2012934*/ int get_AccessMask();
            }

            class AuthorizationRuleCollection : System.Collections.ReadOnlyCollectionBase
            {
                /*0x201293c*/ AuthorizationRuleCollection();
                /*0x2012944*/ AuthorizationRuleCollection(System.Security.AccessControl.AuthorizationRule[] rules);
                /*0x201298c*/ void AddRule(System.Security.AccessControl.AuthorizationRule rule);
                /*0x20129bc*/ System.Security.AccessControl.AuthorizationRule get_Item(int index);
                /*0x2012a5c*/ void CopyTo(System.Security.AccessControl.AuthorizationRule[] rules, int index);
            }

            class CommonAce : System.Security.AccessControl.QualifiedAce
            {
                static /*0x2012f60*/ int MaxOpaqueLength(bool isCallback);
                static /*0x2012af8*/ System.Security.AccessControl.AceType ConvertType(System.Security.AccessControl.AceQualifier qualifier, bool isCallback);
                /*0x2012a9c*/ CommonAce(System.Security.AccessControl.AceFlags flags, System.Security.AccessControl.AceQualifier qualifier, int accessMask, System.Security.Principal.SecurityIdentifier sid, bool isCallback, byte[] opaque);
                /*0x2012c08*/ CommonAce(System.Security.AccessControl.AceType type, System.Security.AccessControl.AceFlags flags, int accessMask, System.Security.Principal.SecurityIdentifier sid, byte[] opaque);
                /*0x2012c3c*/ CommonAce(byte[] binaryForm, int offset);
                /*0x2012e3c*/ int get_BinaryLength();
                /*0x2012e70*/ void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x2012f68*/ string GetSddlForm();
            }

            class CommonAcl : System.Security.AccessControl.GenericAcl
            {
                static int default_capacity = 10;
                /*0x10*/ bool is_aefa;
                /*0x11*/ bool is_canonical;
                /*0x12*/ bool is_container;
                /*0x13*/ bool is_ds;
                /*0x18*/ System.Security.AccessControl.RawAcl raw_acl;

                static /*0x2014300*/ void GetObjectAceTypeGuids(System.Security.AccessControl.ObjectAce ace, ref System.Guid type, ref System.Guid inheritedType);
                static /*0x20135c0*/ System.Security.AccessControl.GenericAce CopyAce(System.Security.AccessControl.GenericAce ace);
                /*0x201316c*/ CommonAcl(bool isContainer, bool isDS, System.Security.AccessControl.RawAcl rawAcl);
                /*0x20132f0*/ CommonAcl(bool isContainer, bool isDS, byte revision, int capacity);
                /*0x20133bc*/ CommonAcl(bool isContainer, bool isDS, int capacity);
                /*0x2014da0*/ CommonAcl();
                /*0x20132d8*/ void Init(bool isContainer, bool isDS, System.Security.AccessControl.RawAcl rawAcl);
                /*0x201350c*/ int get_BinaryLength();
                /*0x201352c*/ int get_Count();
                /*0x201354c*/ bool get_IsCanonical();
                /*0x2013554*/ bool get_IsContainer();
                /*0x201355c*/ bool get_IsDS();
                /*0x2013564*/ bool get_IsAefa();
                /*0x201356c*/ void set_IsAefa(bool value);
                /*0x2013578*/ byte get_Revision();
                /*0x201359c*/ System.Security.AccessControl.GenericAce get_Item(int index);
                /*0x2013650*/ void set_Item(int index, System.Security.AccessControl.GenericAce value);
                /*0x2013690*/ void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x20136b4*/ void Purge(System.Security.Principal.SecurityIdentifier sid);
                /*0x20137f0*/ void RemoveInheritedAces();
                /*0x2013790*/ void RequireCanonicity();
                /*0x2013448*/ void CanonicalizeAndClearAefa();
                /*0x2013bd8*/ bool IsAceMeaningless(System.Security.AccessControl.GenericAce ace);
                /*0x20138f4*/ bool TestCanonicity();
                /*0x2013cc4*/ int GetCanonicalExplicitDenyAceCount();
                /*0x2013df8*/ int GetCanonicalExplicitAceCount();
                /*0x2013ad8*/ void MergeExplicitAces();
                /*0x2013e7c*/ System.Security.AccessControl.GenericAce MergeExplicitAcePair(System.Security.AccessControl.GenericAce ace1, System.Security.AccessControl.GenericAce ace2);
                void ApplyCanonicalSortToExplicitAces();
                /*0x20143a8*/ void ApplyCanonicalSortToExplicitAces(int start, int count);
                /*0x201456c*/ string GetSddlForm(System.Security.AccessControl.ControlFlags sdFlags, bool isDacl);
                void RemoveAces<T>(System.Security.AccessControl.CommonAcl.RemoveAcesCallback<T> callback);
                /*0x2014594*/ void AddAce(System.Security.AccessControl.AceQualifier aceQualifier, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags);
                /*0x2014700*/ void AddAce(System.Security.AccessControl.AceQualifier aceQualifier, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x2014734*/ System.Security.AccessControl.QualifiedAce AddAceGetQualifiedAce(System.Security.AccessControl.AceQualifier aceQualifier, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x20145b0*/ System.Security.AccessControl.QualifiedAce AddAceGetQualifiedAce(System.Security.AccessControl.AceQualifier aceQualifier, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags);
                /*0x2014680*/ void AddAce(System.Security.AccessControl.QualifiedAce newAce);
                int GetAceInsertPosition(System.Security.AccessControl.AceQualifier aceQualifier);
                /*0x20148b4*/ System.Security.AccessControl.AceFlags GetAceFlags(System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags);
                /*0x201498c*/ void RemoveAceSpecific(System.Security.AccessControl.AceQualifier aceQualifier, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags);
                /*0x2014aa0*/ void RemoveAceSpecific(System.Security.AccessControl.AceQualifier aceQualifier, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x2014c60*/ void SetAce(System.Security.AccessControl.AceQualifier aceQualifier, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags);
                /*0x2014d6c*/ void SetAce(System.Security.AccessControl.AceQualifier aceQualifier, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags auditFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x2014c7c*/ void SetAce(System.Security.AccessControl.QualifiedAce newAce);

                class RemoveAcesCallback<T> : System.MulticastDelegate
                {
                    RemoveAcesCallback(object object, nint method);
                    bool Invoke(T ace);
                }

                class <>c__DisplayClass30_0
                {
                    /*0x10*/ System.Security.Principal.SecurityIdentifier sid;

                    /*0x2015dd8*/ <>c__DisplayClass30_0();
                    /*0x2015de0*/ bool <Purge>b__0(System.Security.AccessControl.KnownAce ace);
                }

                class <>c
                {
                    static /*0x0*/ System.Security.AccessControl.CommonAcl.<> <>9;
                    static /*0x8*/ System.Security.AccessControl.CommonAcl.RemoveAcesCallback<System.Security.AccessControl.GenericAce> <>9__31_0;

                    static /*0x2015e50*/ <>c();
                    /*0x2015eb4*/ <>c();
                    /*0x2015ebc*/ bool <RemoveInheritedAces>b__31_0(System.Security.AccessControl.GenericAce ace);
                }

                class <>c__DisplayClass53_0
                {
                    /*0x10*/ int accessMask;
                    /*0x14*/ System.Security.AccessControl.AceQualifier aceQualifier;
                    /*0x18*/ System.Security.Principal.SecurityIdentifier sid;
                    /*0x20*/ System.Security.AccessControl.InheritanceFlags inheritanceFlags;
                    /*0x24*/ System.Security.AccessControl.PropagationFlags propagationFlags;
                    /*0x28*/ System.Security.AccessControl.AuditFlags auditFlags;

                    /*0x2015ee4*/ <>c__DisplayClass53_0();
                    /*0x2015eec*/ bool <RemoveAceSpecific>b__0(System.Security.AccessControl.CommonAce ace);
                }

                class <>c__DisplayClass54_0
                {
                    /*0x10*/ int accessMask;
                    /*0x14*/ System.Security.AccessControl.AceQualifier aceQualifier;
                    /*0x18*/ System.Security.Principal.SecurityIdentifier sid;
                    /*0x20*/ System.Security.AccessControl.InheritanceFlags inheritanceFlags;
                    /*0x24*/ System.Security.AccessControl.PropagationFlags propagationFlags;
                    /*0x28*/ System.Security.AccessControl.AuditFlags auditFlags;
                    /*0x2c*/ System.Security.AccessControl.ObjectAceFlags objectFlags;
                    /*0x30*/ System.Guid objectType;

                    /*0x20160dc*/ <>c__DisplayClass54_0();
                    /*0x20160e4*/ bool <RemoveAceSpecific>b__0(System.Security.AccessControl.ObjectAce ace);
                }

                class <>c__DisplayClass57_0
                {
                    /*0x10*/ System.Security.AccessControl.QualifiedAce newAce;

                    /*0x2016284*/ <>c__DisplayClass57_0();
                    /*0x201628c*/ bool <SetAce>b__0(System.Security.AccessControl.QualifiedAce oldAce);
                }
            }

            class CommonObjectSecurity : System.Security.AccessControl.ObjectSecurity
            {
                /*0x2016338*/ CommonObjectSecurity(bool isContainer);
                /*0x2016444*/ CommonObjectSecurity(System.Security.AccessControl.CommonSecurityDescriptor securityDescriptor);
                /*0x201650c*/ System.Security.AccessControl.AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, System.Type targetType);
                /*0x201684c*/ System.Security.AccessControl.AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, System.Type targetType);
                /*0x2016b7c*/ void AddAccessRule(System.Security.AccessControl.AccessRule rule);
                /*0x2016ba8*/ bool RemoveAccessRule(System.Security.AccessControl.AccessRule rule);
                /*0x2016bd8*/ void RemoveAccessRuleAll(System.Security.AccessControl.AccessRule rule);
                /*0x2016c04*/ void RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule rule);
                /*0x2016c30*/ void ResetAccessRule(System.Security.AccessControl.AccessRule rule);
                /*0x2016c5c*/ void SetAccessRule(System.Security.AccessControl.AccessRule rule);
                /*0x2016c88*/ bool ModifyAccess(System.Security.AccessControl.AccessControlModification modification, System.Security.AccessControl.AccessRule rule, ref bool modified);
                /*0x2017290*/ void AddAuditRule(System.Security.AccessControl.AuditRule rule);
                /*0x20172bc*/ bool RemoveAuditRule(System.Security.AccessControl.AuditRule rule);
                /*0x20172ec*/ void RemoveAuditRuleAll(System.Security.AccessControl.AuditRule rule);
                /*0x2017318*/ void RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule rule);
                /*0x2017344*/ void SetAuditRule(System.Security.AccessControl.AuditRule rule);
                /*0x2017370*/ bool ModifyAudit(System.Security.AccessControl.AccessControlModification modification, System.Security.AccessControl.AuditRule rule, ref bool modified);
            }

            class CommonSecurityDescriptor : System.Security.AccessControl.GenericSecurityDescriptor
            {
                /*0x10*/ bool is_container;
                /*0x11*/ bool is_ds;
                /*0x14*/ System.Security.AccessControl.ControlFlags flags;
                /*0x18*/ System.Security.Principal.SecurityIdentifier owner;
                /*0x20*/ System.Security.Principal.SecurityIdentifier group;
                /*0x28*/ System.Security.AccessControl.SystemAcl system_acl;
                /*0x30*/ System.Security.AccessControl.DiscretionaryAcl discretionary_acl;

                /*0x2017864*/ CommonSecurityDescriptor(bool isContainer, bool isDS, System.Security.AccessControl.RawSecurityDescriptor rawSecurityDescriptor);
                /*0x2017a48*/ CommonSecurityDescriptor(bool isContainer, bool isDS, string sddlForm);
                /*0x2017bbc*/ CommonSecurityDescriptor(bool isContainer, bool isDS, byte[] binaryForm, int offset);
                /*0x2017f2c*/ CommonSecurityDescriptor(bool isContainer, bool isDS, System.Security.AccessControl.ControlFlags flags, System.Security.Principal.SecurityIdentifier owner, System.Security.Principal.SecurityIdentifier group, System.Security.AccessControl.SystemAcl systemAcl, System.Security.AccessControl.DiscretionaryAcl discretionaryAcl);
                /*0x20178b0*/ void Init(bool isContainer, bool isDS, System.Security.AccessControl.RawSecurityDescriptor rawSecurityDescriptor);
                /*0x2017fa0*/ void Init(bool isContainer, bool isDS, System.Security.AccessControl.ControlFlags flags, System.Security.Principal.SecurityIdentifier owner, System.Security.Principal.SecurityIdentifier group, System.Security.AccessControl.SystemAcl systemAcl, System.Security.AccessControl.DiscretionaryAcl discretionaryAcl);
                /*0x2018158*/ System.Security.AccessControl.ControlFlags get_ControlFlags();
                /*0x2018178*/ System.Security.AccessControl.DiscretionaryAcl get_DiscretionaryAcl();
                /*0x2018044*/ void set_DiscretionaryAcl(System.Security.AccessControl.DiscretionaryAcl value);
                /*0x2018254*/ System.Security.AccessControl.GenericAcl get_InternalDacl();
                /*0x201825c*/ System.Security.Principal.SecurityIdentifier get_Group();
                /*0x2018264*/ void set_Group(System.Security.Principal.SecurityIdentifier value);
                /*0x201826c*/ bool get_IsContainer();
                /*0x2018274*/ bool get_IsDiscretionaryAclCanonical();
                /*0x2018290*/ bool get_IsDS();
                /*0x2018298*/ bool get_IsSystemAclCanonical();
                /*0x20182b8*/ System.Security.Principal.SecurityIdentifier get_Owner();
                /*0x20182c0*/ void set_Owner(System.Security.Principal.SecurityIdentifier value);
                /*0x20182c8*/ System.Security.AccessControl.SystemAcl get_SystemAcl();
                /*0x20177b8*/ void set_SystemAcl(System.Security.AccessControl.SystemAcl value);
                /*0x20182d0*/ System.Security.AccessControl.GenericAcl get_InternalSacl();
                /*0x20182d8*/ void PurgeAccessControl(System.Security.Principal.SecurityIdentifier sid);
                /*0x20182f4*/ void PurgeAudit(System.Security.Principal.SecurityIdentifier sid);
                /*0x2018308*/ void SetDiscretionaryAclProtection(bool isProtected, bool preserveInheritance);
                /*0x2018350*/ void SetSystemAclProtection(bool isProtected, bool preserveInheritance);
                /*0x2018380*/ void AddDiscretionaryAcl(byte revision, int trusted);
                /*0x201843c*/ void AddSystemAcl(byte revision, int trusted);
                /*0x2018190*/ void CheckAclConsistency(System.Security.AccessControl.CommonAcl acl);
                /*0x20184fc*/ bool get_DaclIsUnmodifiedAefa();
            }

            class CompoundAce : System.Security.AccessControl.KnownAce
            {
                /*0x20*/ System.Security.AccessControl.CompoundAceType compound_ace_type;

                /*0x2018518*/ CompoundAce(System.Security.AccessControl.AceFlags flags, int accessMask, System.Security.AccessControl.CompoundAceType compoundAceType, System.Security.Principal.SecurityIdentifier sid);
                /*0x201856c*/ int get_BinaryLength();
                /*0x20185ac*/ System.Security.AccessControl.CompoundAceType get_CompoundAceType();
                /*0x20185b4*/ void set_CompoundAceType(System.Security.AccessControl.CompoundAceType value);
                /*0x20185bc*/ void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x20185fc*/ string GetSddlForm();
            }

            enum CompoundAceType
            {
                Impersonation = 1,
            }

            enum ControlFlags
            {
                None = 0,
                OwnerDefaulted = 1,
                GroupDefaulted = 2,
                DiscretionaryAclPresent = 4,
                DiscretionaryAclDefaulted = 8,
                SystemAclPresent = 16,
                SystemAclDefaulted = 32,
                DiscretionaryAclUntrusted = 64,
                ServerSecurity = 128,
                DiscretionaryAclAutoInheritRequired = 256,
                SystemAclAutoInheritRequired = 512,
                DiscretionaryAclAutoInherited = 1024,
                SystemAclAutoInherited = 2048,
                DiscretionaryAclProtected = 4096,
                SystemAclProtected = 8192,
                RMControlValid = 16384,
                SelfRelative = 32768,
            }

            class CryptoKeyAccessRule : System.Security.AccessControl.AccessRule
            {
                /*0x201863c*/ CryptoKeyAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.CryptoKeyRights cryptoKeyRights, System.Security.AccessControl.AccessControlType type);
                /*0x2018654*/ CryptoKeyAccessRule(string identity, System.Security.AccessControl.CryptoKeyRights cryptoKeyRights, System.Security.AccessControl.AccessControlType type);
                /*0x20186e4*/ System.Security.AccessControl.CryptoKeyRights get_CryptoKeyRights();
            }

            class CryptoKeyAuditRule : System.Security.AccessControl.AuditRule
            {
                /*0x20186ec*/ CryptoKeyAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.CryptoKeyRights cryptoKeyRights, System.Security.AccessControl.AuditFlags flags);
                /*0x2018704*/ CryptoKeyAuditRule(string identity, System.Security.AccessControl.CryptoKeyRights cryptoKeyRights, System.Security.AccessControl.AuditFlags flags);
                /*0x20187a0*/ System.Security.AccessControl.CryptoKeyRights get_CryptoKeyRights();
            }

            enum CryptoKeyRights
            {
                ReadData = 1,
                WriteData = 2,
                ReadExtendedAttributes = 8,
                WriteExtendedAttributes = 16,
                ReadAttributes = 128,
                WriteAttributes = 256,
                Delete = 65536,
                ReadPermissions = 131072,
                ChangePermissions = 262144,
                TakeOwnership = 524288,
                Synchronize = 1048576,
                FullControl = 2032027,
                GenericAll = 268435456,
                GenericExecute = 536870912,
                GenericWrite = 1073741824,
                GenericRead = -2147483648,
            }

            class CryptoKeySecurity : System.Security.AccessControl.NativeObjectSecurity
            {
                /*0x20187a8*/ CryptoKeySecurity();
                /*0x20187e8*/ CryptoKeySecurity(System.Security.AccessControl.CommonSecurityDescriptor securityDescriptor);
                /*0x20187f0*/ System.Type get_AccessRightType();
                /*0x201885c*/ System.Type get_AccessRuleType();
                /*0x20188c8*/ System.Type get_AuditRuleType();
                /*0x2018934*/ System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x20189b8*/ void AddAccessRule(System.Security.AccessControl.CryptoKeyAccessRule rule);
                /*0x20189e4*/ bool RemoveAccessRule(System.Security.AccessControl.CryptoKeyAccessRule rule);
                /*0x2018a14*/ void RemoveAccessRuleAll(System.Security.AccessControl.CryptoKeyAccessRule rule);
                /*0x2018a40*/ void RemoveAccessRuleSpecific(System.Security.AccessControl.CryptoKeyAccessRule rule);
                /*0x2018a6c*/ void ResetAccessRule(System.Security.AccessControl.CryptoKeyAccessRule rule);
                /*0x2018a98*/ void SetAccessRule(System.Security.AccessControl.CryptoKeyAccessRule rule);
                /*0x2018ac4*/ System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x2018b4c*/ void AddAuditRule(System.Security.AccessControl.CryptoKeyAuditRule rule);
                /*0x2018b78*/ bool RemoveAuditRule(System.Security.AccessControl.CryptoKeyAuditRule rule);
                /*0x2018ba8*/ void RemoveAuditRuleAll(System.Security.AccessControl.CryptoKeyAuditRule rule);
                /*0x2018bd4*/ void RemoveAuditRuleSpecific(System.Security.AccessControl.CryptoKeyAuditRule rule);
                /*0x2018c00*/ void SetAuditRule(System.Security.AccessControl.CryptoKeyAuditRule rule);
            }

            class CustomAce : System.Security.AccessControl.GenericAce
            {
                static /*0x0*/ int MaxOpaqueLength;
                /*0x18*/ byte[] opaque;

                /*0x2018c2c*/ CustomAce(System.Security.AccessControl.AceType type, System.Security.AccessControl.AceFlags flags, byte[] opaque);
                /*0x2018d8c*/ int get_BinaryLength();
                /*0x2018dcc*/ int get_OpaqueLength();
                /*0x2018de8*/ void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x2018e28*/ byte[] GetOpaque();
                /*0x2018ce4*/ void SetOpaque(byte[] opaque);
                /*0x2018ea0*/ string GetSddlForm();
            }

            class DirectoryObjectSecurity : System.Security.AccessControl.ObjectSecurity
            {
                /*0x2018ee0*/ DirectoryObjectSecurity();
                /*0x2018eec*/ DirectoryObjectSecurity(System.Security.AccessControl.CommonSecurityDescriptor securityDescriptor);
                /*0x2018ef0*/ System.Exception GetNotImplementedException();
                /*0x2018f4c*/ System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x2018f70*/ System.Security.AccessControl.AccessRule InternalAccessRuleFactory(System.Security.AccessControl.QualifiedAce ace, System.Type targetType, System.Security.AccessControl.AccessControlType type);
                /*0x2019264*/ System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x2019288*/ System.Security.AccessControl.AuditRule InternalAuditRuleFactory(System.Security.AccessControl.QualifiedAce ace, System.Type targetType);
                /*0x2019444*/ System.Security.AccessControl.AuthorizationRuleCollection GetAccessRules(bool includeExplicit, bool includeInherited, System.Type targetType);
                /*0x2019450*/ System.Security.AccessControl.AuthorizationRuleCollection GetAuditRules(bool includeExplicit, bool includeInherited, System.Type targetType);
                /*0x201945c*/ void AddAccessRule(System.Security.AccessControl.ObjectAccessRule rule);
                /*0x2019488*/ bool RemoveAccessRule(System.Security.AccessControl.ObjectAccessRule rule);
                /*0x20194b8*/ void RemoveAccessRuleAll(System.Security.AccessControl.ObjectAccessRule rule);
                /*0x20194e4*/ void RemoveAccessRuleSpecific(System.Security.AccessControl.ObjectAccessRule rule);
                /*0x2019510*/ void ResetAccessRule(System.Security.AccessControl.ObjectAccessRule rule);
                /*0x201953c*/ void SetAccessRule(System.Security.AccessControl.ObjectAccessRule rule);
                /*0x2019568*/ bool ModifyAccess(System.Security.AccessControl.AccessControlModification modification, System.Security.AccessControl.AccessRule rule, ref bool modified);
                /*0x2019d10*/ void AddAuditRule(System.Security.AccessControl.ObjectAuditRule rule);
                /*0x2019d3c*/ bool RemoveAuditRule(System.Security.AccessControl.ObjectAuditRule rule);
                /*0x2019d6c*/ void RemoveAuditRuleAll(System.Security.AccessControl.ObjectAuditRule rule);
                /*0x2019d98*/ void RemoveAuditRuleSpecific(System.Security.AccessControl.ObjectAuditRule rule);
                /*0x2019dc4*/ void SetAuditRule(System.Security.AccessControl.ObjectAuditRule rule);
                /*0x2019df0*/ bool ModifyAudit(System.Security.AccessControl.AccessControlModification modification, System.Security.AccessControl.AuditRule rule, ref bool modified);
            }

            class DirectorySecurity : System.Security.AccessControl.FileSystemSecurity
            {
                /*0x201a4ac*/ DirectorySecurity();
                /*0x201a4ec*/ DirectorySecurity(string name, System.Security.AccessControl.AccessControlSections includeSections);
            }

            class DiscretionaryAcl : System.Security.AccessControl.CommonAcl
            {
                static /*0x201a524*/ System.Security.AccessControl.AceQualifier GetAceQualifier(System.Security.AccessControl.AccessControlType accessType);
                /*0x2018180*/ DiscretionaryAcl(bool isContainer, bool isDS, int capacity);
                /*0x2018034*/ DiscretionaryAcl(bool isContainer, bool isDS, System.Security.AccessControl.RawAcl rawAcl);
                /*0x201842c*/ DiscretionaryAcl(bool isContainer, bool isDS, byte revision, int capacity);
                /*0x201713c*/ void AddAccess(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags);
                /*0x2019b38*/ void AddAccess(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x201a584*/ void AddAccess(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAccessRule rule);
                /*0x20171ec*/ bool RemoveAccess(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags);
                /*0x2019c48*/ bool RemoveAccess(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x201a630*/ bool RemoveAccess(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAccessRule rule);
                /*0x201722c*/ void RemoveAccessSpecific(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags);
                /*0x2019c88*/ void RemoveAccessSpecific(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x201a678*/ void RemoveAccessSpecific(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAccessRule rule);
                /*0x2017194*/ void SetAccess(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags);
                /*0x2019bc0*/ void SetAccess(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x201a724*/ void SetAccess(System.Security.AccessControl.AccessControlType accessType, System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAccessRule rule);
                /*0x201a7d0*/ void ApplyCanonicalSortToExplicitAces();
                /*0x201a828*/ int GetAceInsertPosition(System.Security.AccessControl.AceQualifier aceQualifier);
                /*0x201a83c*/ bool IsAceMeaningless(System.Security.AccessControl.GenericAce ace);
            }

            class EventWaitHandleAccessRule : System.Security.AccessControl.AccessRule
            {
                /*0x201aa80*/ EventWaitHandleAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.EventWaitHandleRights eventRights, System.Security.AccessControl.AccessControlType type);
                /*0x201aa98*/ EventWaitHandleAccessRule(string identity, System.Security.AccessControl.EventWaitHandleRights eventRights, System.Security.AccessControl.AccessControlType type);
                /*0x201ab28*/ System.Security.AccessControl.EventWaitHandleRights get_EventWaitHandleRights();
            }

            class EventWaitHandleAuditRule : System.Security.AccessControl.AuditRule
            {
                /*0x201ab30*/ EventWaitHandleAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.EventWaitHandleRights eventRights, System.Security.AccessControl.AuditFlags flags);
                /*0x201abb8*/ System.Security.AccessControl.EventWaitHandleRights get_EventWaitHandleRights();
            }

            enum EventWaitHandleRights
            {
                Modify = 2,
                Delete = 65536,
                ReadPermissions = 131072,
                ChangePermissions = 262144,
                TakeOwnership = 524288,
                Synchronize = 1048576,
                FullControl = 2031619,
            }

            class EventWaitHandleSecurity : System.Security.AccessControl.NativeObjectSecurity
            {
                /*0x201abc0*/ EventWaitHandleSecurity();
                /*0x201abe0*/ EventWaitHandleSecurity(System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201ac0c*/ System.Type get_AccessRightType();
                /*0x201ac78*/ System.Type get_AccessRuleType();
                /*0x201ace4*/ System.Type get_AuditRuleType();
                /*0x201ad50*/ System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x201add4*/ void AddAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule rule);
                /*0x201ae00*/ bool RemoveAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule rule);
                /*0x201ae30*/ void RemoveAccessRuleAll(System.Security.AccessControl.EventWaitHandleAccessRule rule);
                /*0x201ae5c*/ void RemoveAccessRuleSpecific(System.Security.AccessControl.EventWaitHandleAccessRule rule);
                /*0x201ae88*/ void ResetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule rule);
                /*0x201aeb4*/ void SetAccessRule(System.Security.AccessControl.EventWaitHandleAccessRule rule);
                /*0x201aee0*/ System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x201af58*/ void AddAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule rule);
                /*0x201af84*/ bool RemoveAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule rule);
                /*0x201afb4*/ void RemoveAuditRuleAll(System.Security.AccessControl.EventWaitHandleAuditRule rule);
                /*0x201afe0*/ void RemoveAuditRuleSpecific(System.Security.AccessControl.EventWaitHandleAuditRule rule);
                /*0x201b00c*/ void SetAuditRule(System.Security.AccessControl.EventWaitHandleAuditRule rule);
                /*0x201b038*/ void Persist(System.Runtime.InteropServices.SafeHandle handle);
            }

            class FileSecurity : System.Security.AccessControl.FileSystemSecurity
            {
                /*0x201b0f4*/ FileSecurity();
                /*0x201b114*/ FileSecurity(string fileName, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201b130*/ FileSecurity(System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections);
            }

            class FileSystemAccessRule : System.Security.AccessControl.AccessRule
            {
                /*0x201b168*/ FileSystemAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.FileSystemRights fileSystemRights, System.Security.AccessControl.AccessControlType type);
                /*0x201b198*/ FileSystemAccessRule(string identity, System.Security.AccessControl.FileSystemRights fileSystemRights, System.Security.AccessControl.AccessControlType type);
                /*0x201b180*/ FileSystemAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.FileSystemRights fileSystemRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x201b234*/ FileSystemAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.FileSystemRights fileSystemRights, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x201b240*/ FileSystemAccessRule(string identity, System.Security.AccessControl.FileSystemRights fileSystemRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x201b2ec*/ System.Security.AccessControl.FileSystemRights get_FileSystemRights();
            }

            class FileSystemAuditRule : System.Security.AccessControl.AuditRule
            {
                /*0x201b2f4*/ FileSystemAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.FileSystemRights fileSystemRights, System.Security.AccessControl.AuditFlags flags);
                /*0x201b324*/ FileSystemAuditRule(string identity, System.Security.AccessControl.FileSystemRights fileSystemRights, System.Security.AccessControl.AuditFlags flags);
                /*0x201b30c*/ FileSystemAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.FileSystemRights fileSystemRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x201b3c0*/ FileSystemAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.FileSystemRights fileSystemRights, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x201b3cc*/ FileSystemAuditRule(string identity, System.Security.AccessControl.FileSystemRights fileSystemRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x201b478*/ System.Security.AccessControl.FileSystemRights get_FileSystemRights();
            }

            enum FileSystemRights
            {
                ListDirectory = 1,
                ReadData = 1,
                CreateFiles = 2,
                WriteData = 2,
                AppendData = 4,
                CreateDirectories = 4,
                ReadExtendedAttributes = 8,
                WriteExtendedAttributes = 16,
                ExecuteFile = 32,
                Traverse = 32,
                DeleteSubdirectoriesAndFiles = 64,
                ReadAttributes = 128,
                WriteAttributes = 256,
                Write = 278,
                Delete = 65536,
                ReadPermissions = 131072,
                Read = 131209,
                ReadAndExecute = 131241,
                Modify = 197055,
                ChangePermissions = 262144,
                TakeOwnership = 524288,
                Synchronize = 1048576,
                FullControl = 2032127,
            }

            class FileSystemSecurity : System.Security.AccessControl.NativeObjectSecurity
            {
                /*0x201a4cc*/ FileSystemSecurity(bool isContainer);
                /*0x201a508*/ FileSystemSecurity(bool isContainer, string name, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201b14c*/ FileSystemSecurity(bool isContainer, System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201b908*/ FileSystemSecurity();
                /*0x201b490*/ System.Type get_AccessRightType();
                /*0x201b4fc*/ System.Type get_AccessRuleType();
                /*0x201b568*/ System.Type get_AuditRuleType();
                /*0x201b5d4*/ System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x201b678*/ void AddAccessRule(System.Security.AccessControl.FileSystemAccessRule rule);
                /*0x201b6a4*/ bool RemoveAccessRule(System.Security.AccessControl.FileSystemAccessRule rule);
                /*0x201b6d4*/ void RemoveAccessRuleAll(System.Security.AccessControl.FileSystemAccessRule rule);
                /*0x201b700*/ void RemoveAccessRuleSpecific(System.Security.AccessControl.FileSystemAccessRule rule);
                /*0x201b72c*/ void ResetAccessRule(System.Security.AccessControl.FileSystemAccessRule rule);
                /*0x201b758*/ void SetAccessRule(System.Security.AccessControl.FileSystemAccessRule rule);
                /*0x201b784*/ System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x201b828*/ void AddAuditRule(System.Security.AccessControl.FileSystemAuditRule rule);
                /*0x201b854*/ bool RemoveAuditRule(System.Security.AccessControl.FileSystemAuditRule rule);
                /*0x201b884*/ void RemoveAuditRuleAll(System.Security.AccessControl.FileSystemAuditRule rule);
                /*0x201b8b0*/ void RemoveAuditRuleSpecific(System.Security.AccessControl.FileSystemAuditRule rule);
                /*0x201b8dc*/ void SetAuditRule(System.Security.AccessControl.FileSystemAuditRule rule);
            }

            class GenericAce
            {
                /*0x10*/ System.Security.AccessControl.AceFlags ace_flags;
                /*0x11*/ System.Security.AccessControl.AceType ace_type;

                static /*0x201bb20*/ System.Security.AccessControl.GenericAce CreateFromBinaryForm(byte[] binaryForm, int offset);
                static /*0x20190ac*/ bool op_Equality(System.Security.AccessControl.GenericAce left, System.Security.AccessControl.GenericAce right);
                static /*0x201a938*/ bool op_Inequality(System.Security.AccessControl.GenericAce left, System.Security.AccessControl.GenericAce right);
                static /*0x201c0e0*/ System.Security.AccessControl.GenericAce CreateFromSddlForm(string sddlForm, ref int pos);
                static /*0x201bcec*/ bool IsObjectType(System.Security.AccessControl.AceType type);
                static /*0x201cc80*/ string GetSddlAceType(System.Security.AccessControl.AceType type);
                static /*0x201c4c0*/ System.Security.AccessControl.AceType ParseSddlAceType(string type);
                static /*0x201cdec*/ string GetSddlAceFlags(System.Security.AccessControl.AceFlags flags);
                static /*0x201c810*/ System.Security.AccessControl.AceFlags ParseSddlAceFlags(string flags);
                static /*0x201caf8*/ int ParseSddlAccessRights(string accessMask);
                static /*0x201cf8c*/ int ParseSddlAliasRights(string accessMask);
                static /*0x201d180*/ ushort ReadUShort(byte[] buffer, int offset);
                static /*0x201d1c0*/ int ReadInt(byte[] buffer, int offset);
                static /*0x201d234*/ void WriteInt(int val, byte[] buffer, int offset);
                static /*0x201d2b4*/ void WriteUShort(ushort val, byte[] buffer, int offset);
                /*0x2018c54*/ GenericAce(System.Security.AccessControl.AceType type, System.Security.AccessControl.AceFlags flags);
                /*0x201b940*/ GenericAce(byte[] binaryForm, int offset);
                /*0x201d2fc*/ GenericAce();
                /*0x201ba84*/ System.Security.AccessControl.AceFlags get_AceFlags();
                /*0x201ba8c*/ void set_AceFlags(System.Security.AccessControl.AceFlags value);
                /*0x201ba94*/ System.Security.AccessControl.AceType get_AceType();
                /*0x20160c0*/ System.Security.AccessControl.AuditFlags get_AuditFlags();
                int get_BinaryLength();
                /*0x20160a4*/ System.Security.AccessControl.InheritanceFlags get_InheritanceFlags();
                /*0x2015ed8*/ bool get_IsInherited();
                /*0x20160b4*/ System.Security.AccessControl.PropagationFlags get_PropagationFlags();
                /*0x201ba9c*/ System.Security.AccessControl.GenericAce Copy();
                /*0x201bf94*/ bool Equals(object o);
                void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x201c014*/ int GetHashCode();
                string GetSddlForm();
            }

            class GenericAcl : System.Collections.ICollection, System.Collections.IEnumerable
            {
                static /*0x0*/ byte AclRevision;
                static /*0x1*/ byte AclRevisionDS;
                static /*0x4*/ int MaxBinaryLength;

                static /*0x201d334*/ GenericAcl();
                /*0x201d388*/ GenericAcl();
                int get_BinaryLength();
                int get_Count();
                /*0x201d390*/ bool get_IsSynchronized();
                System.Security.AccessControl.GenericAce get_Item(int index);
                void set_Item(int index, System.Security.AccessControl.GenericAce value);
                byte get_Revision();
                /*0x201d398*/ object get_SyncRoot();
                /*0x201d39c*/ void CopyTo(System.Security.AccessControl.GenericAce[] array, int index);
                /*0x201d528*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x201d5ac*/ System.Security.AccessControl.AceEnumerator GetEnumerator();
                /*0x201d610*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                string GetSddlForm(System.Security.AccessControl.ControlFlags sdFlags, bool isDacl);
            }

            class GenericSecurityDescriptor
            {
                static /*0x201d830*/ byte get_Revision();
                static /*0x201e0a8*/ bool IsSddlConversionSupported();
                /*0x20178a8*/ GenericSecurityDescriptor();
                /*0x201d614*/ int get_BinaryLength();
                System.Security.AccessControl.ControlFlags get_ControlFlags();
                System.Security.Principal.SecurityIdentifier get_Group();
                void set_Group(System.Security.Principal.SecurityIdentifier value);
                System.Security.Principal.SecurityIdentifier get_Owner();
                void set_Owner(System.Security.Principal.SecurityIdentifier value);
                /*0x201d838*/ System.Security.AccessControl.GenericAcl get_InternalDacl();
                /*0x201d840*/ System.Security.AccessControl.GenericAcl get_InternalSacl();
                /*0x201d848*/ byte get_InternalReservedField();
                /*0x201d850*/ void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x201dd38*/ string GetSddlForm(System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201e0b0*/ bool get_DaclIsUnmodifiedAefa();
                /*0x201d7c8*/ bool get_DaclPresent();
                /*0x201d7fc*/ bool get_SaclPresent();
                /*0x201dc70*/ void WriteUShort(ushort val, byte[] buffer, int offset);
                /*0x201dcb8*/ void WriteInt(int val, byte[] buffer, int offset);
            }

            enum InheritanceFlags
            {
                None = 0,
                ContainerInherit = 1,
                ObjectInherit = 2,
            }

            class KnownAce : System.Security.AccessControl.GenericAce
            {
                /*0x14*/ int access_mask;
                /*0x18*/ System.Security.Principal.SecurityIdentifier identifier;

                static /*0x201e0dc*/ string GetSddlAccessRights(int accessMask);
                static /*0x201e1ac*/ string GetSddlAliasRights(int accessMask);
                /*0x2018568*/ KnownAce(System.Security.AccessControl.AceType type, System.Security.AccessControl.AceFlags flags);
                /*0x201e0b8*/ KnownAce(byte[] binaryForm, int offset);
                /*0x201e540*/ KnownAce();
                /*0x201e0bc*/ int get_AccessMask();
                /*0x201e0c4*/ void set_AccessMask(int value);
                /*0x201e0cc*/ System.Security.Principal.SecurityIdentifier get_SecurityIdentifier();
                /*0x201e0d4*/ void set_SecurityIdentifier(System.Security.Principal.SecurityIdentifier value);
            }

            class MutexAccessRule : System.Security.AccessControl.AccessRule
            {
                /*0x201e578*/ MutexAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.MutexRights eventRights, System.Security.AccessControl.AccessControlType type);
                /*0x201e590*/ MutexAccessRule(string identity, System.Security.AccessControl.MutexRights eventRights, System.Security.AccessControl.AccessControlType type);
                /*0x201e62c*/ System.Security.AccessControl.MutexRights get_MutexRights();
            }

            class MutexAuditRule : System.Security.AccessControl.AuditRule
            {
                /*0x201e634*/ MutexAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.MutexRights eventRights, System.Security.AccessControl.AuditFlags flags);
                /*0x201e64c*/ System.Security.AccessControl.MutexRights get_MutexRights();
            }

            enum MutexRights
            {
                Modify = 1,
                Delete = 65536,
                ReadPermissions = 131072,
                ChangePermissions = 262144,
                TakeOwnership = 524288,
                Synchronize = 1048576,
                FullControl = 2031617,
            }

            class MutexSecurity : System.Security.AccessControl.NativeObjectSecurity
            {
                static /*0x201eda8*/ System.Exception MutexExceptionFromErrorCode(int errorCode, string name, System.Runtime.InteropServices.SafeHandle handle, object context);
                /*0x201e654*/ MutexSecurity();
                /*0x201e674*/ MutexSecurity(string name, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201e850*/ MutexSecurity(System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201e968*/ System.Type get_AccessRightType();
                /*0x201e9d4*/ System.Type get_AccessRuleType();
                /*0x201ea40*/ System.Type get_AuditRuleType();
                /*0x201eaac*/ System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x201eb34*/ void AddAccessRule(System.Security.AccessControl.MutexAccessRule rule);
                /*0x201eb60*/ bool RemoveAccessRule(System.Security.AccessControl.MutexAccessRule rule);
                /*0x201eb90*/ void RemoveAccessRuleAll(System.Security.AccessControl.MutexAccessRule rule);
                /*0x201ebbc*/ void RemoveAccessRuleSpecific(System.Security.AccessControl.MutexAccessRule rule);
                /*0x201ebe8*/ void ResetAccessRule(System.Security.AccessControl.MutexAccessRule rule);
                /*0x201ec14*/ void SetAccessRule(System.Security.AccessControl.MutexAccessRule rule);
                /*0x201ec40*/ System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x201ecc8*/ void AddAuditRule(System.Security.AccessControl.MutexAuditRule rule);
                /*0x201ecf4*/ bool RemoveAuditRule(System.Security.AccessControl.MutexAuditRule rule);
                /*0x201ed24*/ void RemoveAuditRuleAll(System.Security.AccessControl.MutexAuditRule rule);
                /*0x201ed50*/ void RemoveAuditRuleSpecific(System.Security.AccessControl.MutexAuditRule rule);
                /*0x201ed7c*/ void SetAuditRule(System.Security.AccessControl.MutexAuditRule rule);
            }

            class NativeObjectSecurity : System.Security.AccessControl.CommonObjectSecurity
            {
                /*0x28*/ System.Security.AccessControl.NativeObjectSecurity.ExceptionFromErrorCode exception_from_error_code;

                static /*0x201ee20*/ System.Exception DefaultExceptionFromErrorCode(int errorCode, string name, System.Runtime.InteropServices.SafeHandle handle, object context);
                /*0x20187ec*/ NativeObjectSecurity(System.Security.AccessControl.CommonSecurityDescriptor securityDescriptor, System.Security.AccessControl.ResourceType resourceType);
                /*0x20187c8*/ NativeObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType);
                /*0x201efac*/ NativeObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType, System.Security.AccessControl.NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
                /*0x201abfc*/ NativeObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType, System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201b480*/ NativeObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType, string name, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201e8f0*/ NativeObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType, System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections, System.Security.AccessControl.NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
                /*0x201e7d8*/ NativeObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType, string name, System.Security.AccessControl.AccessControlSections includeSections, System.Security.AccessControl.NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
                /*0x201f07c*/ void ClearAccessControlSectionsModified();
                /*0x201f144*/ void Persist(System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201f254*/ void Persist(string name, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201b03c*/ void PersistModifications(System.Runtime.InteropServices.SafeHandle handle);
                /*0x201f14c*/ void Persist(System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections, object exceptionContext);
                /*0x201f3cc*/ void PersistModifications(string name);
                /*0x201f25c*/ void Persist(string name, System.Security.AccessControl.AccessControlSections includeSections, object exceptionContext);
                /*0x201efd8*/ void RaiseExceptionOnFailure(int errorCode, string name, System.Runtime.InteropServices.SafeHandle handle, object context);
                /*0x201f484*/ int InternalGet(System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201f4c4*/ int InternalGet(string name, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201f504*/ int InternalSet(System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x201f544*/ int InternalSet(string name, System.Security.AccessControl.AccessControlSections includeSections);

                class ExceptionFromErrorCode : System.MulticastDelegate
                {
                    /*0x201e714*/ ExceptionFromErrorCode(object object, nint method);
                    /*0x201f584*/ System.Exception Invoke(int errorCode, string name, System.Runtime.InteropServices.SafeHandle handle, object context);
                }
            }

            class ObjectAccessRule : System.Security.AccessControl.AccessRule
            {
                /*0x2c*/ System.Guid object_type;
                /*0x3c*/ System.Guid inherited_object_type;

                /*0x201f598*/ ObjectAccessRule(System.Security.Principal.IdentityReference identity, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Guid objectType, System.Guid inheritedObjectType, System.Security.AccessControl.AccessControlType type);
                /*0x201f5e4*/ System.Guid get_InheritedObjectType();
                /*0x2019a74*/ System.Security.AccessControl.ObjectAceFlags get_ObjectFlags();
                /*0x201f5f4*/ System.Guid get_ObjectType();
            }

            class ObjectAce : System.Security.AccessControl.QualifiedAce
            {
                /*0x28*/ System.Guid object_ace_type;
                /*0x38*/ System.Guid inherited_object_type;
                /*0x48*/ System.Security.AccessControl.ObjectAceFlags object_ace_flags;

                static /*0x201fc04*/ int MaxOpaqueLength(bool isCallback);
                static /*0x201f69c*/ System.Security.AccessControl.AceType ConvertType(System.Security.AccessControl.AceQualifier qualifier, bool isCallback);
                /*0x201f604*/ ObjectAce(System.Security.AccessControl.AceFlags aceFlags, System.Security.AccessControl.AceQualifier qualifier, int accessMask, System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAceFlags flags, System.Guid type, System.Guid inheritedType, bool isCallback, byte[] opaque);
                /*0x201cc10*/ ObjectAce(System.Security.AccessControl.AceType type, System.Security.AccessControl.AceFlags flags, int accessMask, System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAceFlags objFlags, System.Guid objType, System.Guid inheritedType, byte[] opaque);
                /*0x201bd2c*/ ObjectAce(byte[] binaryForm, int offset);
                /*0x201f930*/ int get_BinaryLength();
                /*0x201f99c*/ System.Guid get_InheritedObjectAceType();
                /*0x201f9a8*/ void set_InheritedObjectAceType(System.Guid value);
                /*0x201f7e4*/ bool get_InheritedObjectAceTypePresent();
                /*0x201f9b0*/ System.Security.AccessControl.ObjectAceFlags get_ObjectAceFlags();
                /*0x201f9b8*/ void set_ObjectAceFlags(System.Security.AccessControl.ObjectAceFlags value);
                /*0x201f9c0*/ System.Guid get_ObjectAceType();
                /*0x201f9cc*/ void set_ObjectAceType(System.Guid value);
                /*0x201f7d8*/ bool get_ObjectAceTypePresent();
                /*0x201f9d4*/ void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x201fc0c*/ string GetSddlForm();
                /*0x201fb44*/ void WriteGuid(System.Guid val, byte[] buffer, int offset);
                /*0x201f7f0*/ System.Guid ReadGuid(byte[] buffer, int offset);
            }

            enum ObjectAceFlags
            {
                None = 0,
                ObjectAceTypePresent = 1,
                InheritedObjectAceTypePresent = 2,
            }

            class ObjectAuditRule : System.Security.AccessControl.AuditRule
            {
                /*0x2c*/ System.Guid inherited_object_type;
                /*0x3c*/ System.Guid object_type;

                /*0x201fed0*/ ObjectAuditRule(System.Security.Principal.IdentityReference identity, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Guid objectType, System.Guid inheritedObjectType, System.Security.AccessControl.AuditFlags auditFlags);
                /*0x201ff1c*/ System.Guid get_InheritedObjectType();
                /*0x201a33c*/ System.Security.AccessControl.ObjectAceFlags get_ObjectFlags();
                /*0x201ff2c*/ System.Guid get_ObjectType();
            }

            class ObjectSecurity
            {
                /*0x10*/ System.Security.AccessControl.CommonSecurityDescriptor descriptor;
                /*0x18*/ System.Security.AccessControl.AccessControlSections sections_modified;
                /*0x20*/ System.Threading.ReaderWriterLock rw_lock;

                static /*0x2020900*/ bool IsSddlConversionSupported();
                static /*0x2017020*/ System.Security.Principal.SecurityIdentifier SidFromIR(System.Security.Principal.IdentityReference identity);
                /*0x201ff3c*/ ObjectSecurity();
                /*0x2016448*/ ObjectSecurity(System.Security.AccessControl.CommonSecurityDescriptor securityDescriptor);
                /*0x2016344*/ ObjectSecurity(bool isContainer, bool isDS);
                System.Type get_AccessRightType();
                System.Type get_AccessRuleType();
                System.Type get_AuditRuleType();
                /*0x201ff44*/ bool get_AreAccessRulesCanonical();
                /*0x202002c*/ bool get_AreAccessRulesProtected();
                /*0x20200ec*/ bool get_AreAuditRulesCanonical();
                /*0x20201b8*/ bool get_AreAuditRulesProtected();
                /*0x201f3b4*/ System.Security.AccessControl.AccessControlSections get_AccessControlSectionsModified();
                /*0x201f120*/ void set_AccessControlSectionsModified(System.Security.AccessControl.AccessControlSections value);
                /*0x2020370*/ bool get_AccessRulesModified();
                /*0x2017284*/ void set_AccessRulesModified(bool value);
                /*0x20203fc*/ bool get_AuditRulesModified();
                /*0x2017858*/ void set_AuditRulesModified(bool value);
                /*0x2020418*/ bool get_GroupModified();
                /*0x2020434*/ void set_GroupModified(bool value);
                /*0x2017770*/ bool get_IsContainer();
                /*0x201778c*/ bool get_IsDS();
                /*0x2020440*/ bool get_OwnerModified();
                /*0x202045c*/ void set_OwnerModified(bool value);
                System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x2020468*/ System.Security.Principal.IdentityReference GetGroup(System.Type targetType);
                /*0x20205cc*/ System.Security.Principal.IdentityReference GetOwner(System.Type targetType);
                /*0x2020730*/ byte[] GetSecurityDescriptorBinaryForm();
                /*0x2020840*/ string GetSecurityDescriptorSddlForm(System.Security.AccessControl.AccessControlSections includeSections);
                /*0x2020908*/ bool ModifyAccessRule(System.Security.AccessControl.AccessControlModification modification, System.Security.AccessControl.AccessRule rule, ref bool modified);
                /*0x2020a18*/ bool ModifyAuditRule(System.Security.AccessControl.AccessControlModification modification, System.Security.AccessControl.AuditRule rule, ref bool modified);
                /*0x2020b28*/ void PurgeAccessRules(System.Security.Principal.IdentityReference identity);
                /*0x2020c50*/ void PurgeAuditRules(System.Security.Principal.IdentityReference identity);
                /*0x2020d7c*/ void SetAccessRuleProtection(bool isProtected, bool preserveInheritance);
                /*0x2020e34*/ void SetAuditRuleProtection(bool isProtected, bool preserveInheritance);
                /*0x2020f1c*/ void SetGroup(System.Security.Principal.IdentityReference identity);
                /*0x2020ffc*/ void SetOwner(System.Security.Principal.IdentityReference identity);
                /*0x20210dc*/ void SetSecurityDescriptorBinaryForm(byte[] binaryForm);
                /*0x20210e4*/ void SetSecurityDescriptorBinaryForm(byte[] binaryForm, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x2021338*/ void SetSecurityDescriptorSddlForm(string sddlForm);
                /*0x2021340*/ void SetSecurityDescriptorSddlForm(string sddlForm, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x2021188*/ void CopySddlForm(System.Security.AccessControl.CommonSecurityDescriptor sourceDescriptor, System.Security.AccessControl.AccessControlSections includeSections);
                bool ModifyAccess(System.Security.AccessControl.AccessControlModification modification, System.Security.AccessControl.AccessRule rule, ref bool modified);
                bool ModifyAudit(System.Security.AccessControl.AccessControlModification modification, System.Security.AccessControl.AuditRule rule, ref bool modified);
                /*0x20213e0*/ System.Exception GetNotImplementedException();
                /*0x202143c*/ void Persist(System.Runtime.InteropServices.SafeHandle handle, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x2021460*/ void Persist(string name, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x2021484*/ void Persist(bool enableOwnershipPrivilege, string name, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x2020278*/ void Reading();
                /*0x202000c*/ void ReadLock();
                /*0x20214c4*/ void ReadUnlock();
                /*0x2020300*/ void Writing();
                /*0x2017000*/ void WriteLock();
                /*0x20214e0*/ void WriteUnlock();
                /*0x2016518*/ System.Security.AccessControl.AuthorizationRuleCollection InternalGetAccessRules(bool includeExplicit, bool includeInherited, System.Type targetType);
                /*0x20191f4*/ System.Security.AccessControl.AccessRule InternalAccessRuleFactory(System.Security.AccessControl.QualifiedAce ace, System.Type targetType, System.Security.AccessControl.AccessControlType type);
                /*0x2016858*/ System.Security.AccessControl.AuthorizationRuleCollection InternalGetAuditRules(bool includeExplicit, bool includeInherited, System.Type targetType);
                /*0x20193c4*/ System.Security.AccessControl.AuditRule InternalAuditRuleFactory(System.Security.AccessControl.QualifiedAce ace, System.Type targetType);
                /*0x202038c*/ bool AreAccessControlSectionsModified(System.Security.AccessControl.AccessControlSections mask);
                /*0x20203b8*/ void SetAccessControlSectionsModified(System.Security.AccessControl.AccessControlSections mask, bool modified);
            }

            class ObjectSecurity<T> : System.Security.AccessControl.NativeObjectSecurity
            {
                ObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType);
                ObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType, System.Runtime.InteropServices.SafeHandle safeHandle, System.Security.AccessControl.AccessControlSections includeSections);
                ObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType, string name, System.Security.AccessControl.AccessControlSections includeSections);
                ObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType, System.Runtime.InteropServices.SafeHandle safeHandle, System.Security.AccessControl.AccessControlSections includeSections, System.Security.AccessControl.NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
                ObjectSecurity(bool isContainer, System.Security.AccessControl.ResourceType resourceType, string name, System.Security.AccessControl.AccessControlSections includeSections, System.Security.AccessControl.NativeObjectSecurity.ExceptionFromErrorCode exceptionFromErrorCode, object exceptionContext);
                System.Type get_AccessRightType();
                System.Type get_AccessRuleType();
                System.Type get_AuditRuleType();
                System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                void AddAccessRule(System.Security.AccessControl.AccessRule<T> rule);
                bool RemoveAccessRule(System.Security.AccessControl.AccessRule<T> rule);
                void RemoveAccessRuleAll(System.Security.AccessControl.AccessRule<T> rule);
                void RemoveAccessRuleSpecific(System.Security.AccessControl.AccessRule<T> rule);
                void ResetAccessRule(System.Security.AccessControl.AccessRule<T> rule);
                void SetAccessRule(System.Security.AccessControl.AccessRule<T> rule);
                System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                void AddAuditRule(System.Security.AccessControl.AuditRule<T> rule);
                bool RemoveAuditRule(System.Security.AccessControl.AuditRule<T> rule);
                void RemoveAuditRuleAll(System.Security.AccessControl.AuditRule<T> rule);
                void RemoveAuditRuleSpecific(System.Security.AccessControl.AuditRule<T> rule);
                void SetAuditRule(System.Security.AccessControl.AuditRule<T> rule);
                void Persist(System.Runtime.InteropServices.SafeHandle handle);
                void Persist(string name);
            }

            enum PropagationFlags
            {
                None = 0,
                NoPropagateInherit = 1,
                InheritOnly = 2,
            }

            class QualifiedAce : System.Security.AccessControl.KnownAce
            {
                /*0x20*/ byte[] opaque;

                /*0x201f7ac*/ QualifiedAce(System.Security.AccessControl.AceType type, System.Security.AccessControl.AceFlags flags, byte[] opaque);
                /*0x201f7d4*/ QualifiedAce(byte[] binaryForm, int offset);
                /*0x2021538*/ QualifiedAce();
                /*0x2015fe8*/ System.Security.AccessControl.AceQualifier get_AceQualifier();
                /*0x20214fc*/ bool get_IsCallback();
                /*0x201f984*/ int get_OpaqueLength();
                /*0x201fb90*/ byte[] GetOpaque();
                /*0x201f888*/ void SetOpaque(byte[] opaque);
            }

            class RawAcl : System.Security.AccessControl.GenericAcl
            {
                /*0x10*/ byte revision;
                /*0x18*/ System.Collections.Generic.List<System.Security.AccessControl.GenericAce> list;

                static /*0x202234c*/ System.Security.AccessControl.RawAcl ParseSddlForm(string sddlForm, bool isDacl, ref System.Security.AccessControl.ControlFlags sdFlags, ref int pos);
                static /*0x202258c*/ void ParseFlags(string sddlForm, bool isDacl, ref System.Security.AccessControl.ControlFlags sdFlags, ref int pos);
                /*0x2021570*/ RawAcl(byte revision, int capacity);
                /*0x202162c*/ RawAcl(byte[] binaryForm, int offset);
                /*0x20219c4*/ RawAcl(byte revision, System.Collections.Generic.List<System.Security.AccessControl.GenericAce> aces);
                /*0x2021a38*/ int get_BinaryLength();
                /*0x2021b94*/ int get_Count();
                /*0x2021bdc*/ System.Security.AccessControl.GenericAce get_Item(int index);
                /*0x2021c34*/ void set_Item(int index, System.Security.AccessControl.GenericAce value);
                /*0x2021c9c*/ byte get_Revision();
                /*0x2021ca4*/ void GetBinaryForm(byte[] binaryForm, int offset);
                /*0x2021fbc*/ void InsertAce(int index, System.Security.AccessControl.GenericAce ace);
                /*0x2022094*/ void RemoveAce(int index);
                /*0x20220ec*/ string GetSddlForm(System.Security.AccessControl.ControlFlags sdFlags, bool isDacl);
                /*0x2021f74*/ void WriteUShort(ushort val, byte[] buffer, int offset);
                /*0x2021984*/ ushort ReadUShort(byte[] buffer, int offset);
            }

            class RawSecurityDescriptor : System.Security.AccessControl.GenericSecurityDescriptor
            {
                /*0x10*/ System.Security.AccessControl.ControlFlags control_flags;
                /*0x18*/ System.Security.Principal.SecurityIdentifier owner_sid;
                /*0x20*/ System.Security.Principal.SecurityIdentifier group_sid;
                /*0x28*/ System.Security.AccessControl.RawAcl system_acl;
                /*0x30*/ System.Security.AccessControl.RawAcl discretionary_acl;
                /*0x38*/ byte resourcemgr_control;

                /*0x2017adc*/ RawSecurityDescriptor(string sddlForm);
                /*0x2017c58*/ RawSecurityDescriptor(byte[] binaryForm, int offset);
                /*0x2022ae0*/ RawSecurityDescriptor(System.Security.AccessControl.ControlFlags flags, System.Security.Principal.SecurityIdentifier owner, System.Security.Principal.SecurityIdentifier group, System.Security.AccessControl.RawAcl systemAcl, System.Security.AccessControl.RawAcl discretionaryAcl);
                /*0x2022b30*/ System.Security.AccessControl.ControlFlags get_ControlFlags();
                /*0x2022b38*/ System.Security.AccessControl.RawAcl get_DiscretionaryAcl();
                /*0x2022b40*/ void set_DiscretionaryAcl(System.Security.AccessControl.RawAcl value);
                /*0x2022b48*/ System.Security.Principal.SecurityIdentifier get_Group();
                /*0x2022b50*/ void set_Group(System.Security.Principal.SecurityIdentifier value);
                /*0x2022b58*/ System.Security.Principal.SecurityIdentifier get_Owner();
                /*0x2022b60*/ void set_Owner(System.Security.Principal.SecurityIdentifier value);
                /*0x2022b68*/ byte get_ResourceManagerControl();
                /*0x2022b70*/ void set_ResourceManagerControl(byte value);
                /*0x2022b78*/ System.Security.AccessControl.RawAcl get_SystemAcl();
                /*0x2022b80*/ void set_SystemAcl(System.Security.AccessControl.RawAcl value);
                /*0x2022b88*/ void SetFlags(System.Security.AccessControl.ControlFlags flags);
                /*0x2022b94*/ System.Security.AccessControl.GenericAcl get_InternalDacl();
                /*0x2022b9c*/ System.Security.AccessControl.GenericAcl get_InternalSacl();
                /*0x2022ba4*/ byte get_InternalReservedField();
                /*0x202278c*/ void ParseSddl(string sddlForm);
                /*0x2022a30*/ ushort ReadUShort(byte[] buffer, int offset);
                /*0x2022a70*/ int ReadInt(byte[] buffer, int offset);
            }

            class RegistryAccessRule : System.Security.AccessControl.AccessRule
            {
                /*0x2022bac*/ RegistryAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.AccessControlType type);
                /*0x2022bdc*/ RegistryAccessRule(string identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.AccessControlType type);
                /*0x2022bc4*/ RegistryAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x2022c78*/ RegistryAccessRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x2022c84*/ RegistryAccessRule(string identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x2022d30*/ System.Security.AccessControl.RegistryRights get_RegistryRights();
            }

            class RegistryAuditRule : System.Security.AccessControl.AuditRule
            {
                /*0x2022d38*/ RegistryAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x2022d50*/ RegistryAuditRule(System.Security.Principal.IdentityReference identity, System.Security.AccessControl.RegistryRights registryRights, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x2022d5c*/ RegistryAuditRule(string identity, System.Security.AccessControl.RegistryRights registryRights, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x2022e08*/ System.Security.AccessControl.RegistryRights get_RegistryRights();
            }

            enum RegistryRights
            {
                QueryValues = 1,
                SetValue = 2,
                CreateSubKey = 4,
                EnumerateSubKeys = 8,
                Notify = 16,
                CreateLink = 32,
                Delete = 65536,
                ReadPermissions = 131072,
                WriteKey = 131078,
                ReadKey = 131097,
                ExecuteKey = 131097,
                ChangePermissions = 262144,
                TakeOwnership = 524288,
                FullControl = 983103,
            }

            class RegistrySecurity : System.Security.AccessControl.NativeObjectSecurity
            {
                /*0x2022e10*/ RegistrySecurity();
                /*0x2022e30*/ RegistrySecurity(string name, System.Security.AccessControl.AccessControlSections includeSections);
                /*0x2022e4c*/ System.Type get_AccessRightType();
                /*0x2022eb8*/ System.Type get_AccessRuleType();
                /*0x2022f24*/ System.Type get_AuditRuleType();
                /*0x2022f90*/ System.Security.AccessControl.AccessRule AccessRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AccessControlType type);
                /*0x2023034*/ void AddAccessRule(System.Security.AccessControl.RegistryAccessRule rule);
                /*0x2023060*/ bool RemoveAccessRule(System.Security.AccessControl.RegistryAccessRule rule);
                /*0x2023090*/ void RemoveAccessRuleAll(System.Security.AccessControl.RegistryAccessRule rule);
                /*0x20230bc*/ void RemoveAccessRuleSpecific(System.Security.AccessControl.RegistryAccessRule rule);
                /*0x20230e8*/ void ResetAccessRule(System.Security.AccessControl.RegistryAccessRule rule);
                /*0x2023114*/ void SetAccessRule(System.Security.AccessControl.RegistryAccessRule rule);
                /*0x2023140*/ System.Security.AccessControl.AuditRule AuditRuleFactory(System.Security.Principal.IdentityReference identityReference, int accessMask, bool isInherited, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.AuditFlags flags);
                /*0x20231e4*/ void AddAuditRule(System.Security.AccessControl.RegistryAuditRule rule);
                /*0x2023210*/ bool RemoveAuditRule(System.Security.AccessControl.RegistryAuditRule rule);
                /*0x2023240*/ void RemoveAuditRuleAll(System.Security.AccessControl.RegistryAuditRule rule);
                /*0x202326c*/ void RemoveAuditRuleSpecific(System.Security.AccessControl.RegistryAuditRule rule);
                /*0x2023298*/ void SetAuditRule(System.Security.AccessControl.RegistryAuditRule rule);
            }

            enum ResourceType
            {
                Unknown = 0,
                FileObject = 1,
                Service = 2,
                Printer = 3,
                RegistryKey = 4,
                LMShare = 5,
                KernelObject = 6,
                WindowObject = 7,
                DSObject = 8,
                DSObjectAll = 9,
                ProviderDefined = 10,
                WmiGuidObject = 11,
                RegistryWow6432Key = 12,
            }

            class SddlAccessRight
            {
                static /*0x0*/ System.Security.AccessControl.SddlAccessRight[] rights;
                /*0x10*/ string <Name>k__BackingField;
                /*0x18*/ int <Value>k__BackingField;
                /*0x1c*/ int <ObjectType>k__BackingField;

                static /*0x20232fc*/ SddlAccessRight();
                static /*0x201d0c0*/ System.Security.AccessControl.SddlAccessRight LookupByName(string s);
                static /*0x201e2a8*/ System.Security.AccessControl.SddlAccessRight[] Decompose(int mask);
                /*0x20232f4*/ SddlAccessRight();
                /*0x20232c4*/ string get_Name();
                /*0x20232cc*/ void set_Name(string value);
                /*0x20232d4*/ int get_Value();
                /*0x20232dc*/ void set_Value(int value);
                /*0x20232e4*/ int get_ObjectType();
                /*0x20232ec*/ void set_ObjectType(int value);
            }

            enum SecurityInfos
            {
                Owner = 1,
                Group = 2,
                DiscretionaryAcl = 4,
                SystemAcl = 8,
            }

            class SystemAcl : System.Security.AccessControl.CommonAcl
            {
                static /*0x2024184*/ bool IsValidAuditFlags(System.Security.AccessControl.AuditFlags auditFlags);
                /*0x20177a8*/ SystemAcl(bool isContainer, bool isDS, int capacity);
                /*0x2018024*/ SystemAcl(bool isContainer, bool isDS, System.Security.AccessControl.RawAcl rawAcl);
                /*0x20184ec*/ SystemAcl(bool isContainer, bool isDS, byte revision, int capacity);
                /*0x20177e8*/ void AddAudit(System.Security.AccessControl.AuditFlags auditFlags, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags);
                /*0x201a400*/ void AddAudit(System.Security.AccessControl.AuditFlags auditFlags, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x2023e4c*/ void AddAudit(System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAuditRule rule);
                /*0x2017808*/ bool RemoveAudit(System.Security.AccessControl.AuditFlags auditFlags, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags);
                /*0x201a448*/ bool RemoveAudit(System.Security.AccessControl.AuditFlags auditFlags, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x2023edc*/ bool RemoveAudit(System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAuditRule rule);
                /*0x2017848*/ void RemoveAuditSpecific(System.Security.AccessControl.AuditFlags auditFlags, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags);
                /*0x201a488*/ void RemoveAuditSpecific(System.Security.AccessControl.AuditFlags auditFlags, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x2023f2c*/ void RemoveAuditSpecific(System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAuditRule rule);
                /*0x20177f8*/ void SetAudit(System.Security.AccessControl.AuditFlags auditFlags, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags);
                /*0x201a424*/ void SetAudit(System.Security.AccessControl.AuditFlags auditFlags, System.Security.Principal.SecurityIdentifier sid, int accessMask, System.Security.AccessControl.InheritanceFlags inheritanceFlags, System.Security.AccessControl.PropagationFlags propagationFlags, System.Security.AccessControl.ObjectAceFlags objectFlags, System.Guid objectType, System.Guid inheritedObjectType);
                /*0x2023fbc*/ void SetAudit(System.Security.Principal.SecurityIdentifier sid, System.Security.AccessControl.ObjectAuditRule rule);
                /*0x202404c*/ void ApplyCanonicalSortToExplicitAces();
                /*0x2024074*/ int GetAceInsertPosition(System.Security.AccessControl.AceQualifier aceQualifier);
                /*0x202407c*/ bool IsAceMeaningless(System.Security.AccessControl.GenericAce ace);
            }
        }
    }

    namespace Runtime
    {
        class AssemblyTargetedPatchBandAttribute : System.Attribute
        {
            /*0x10*/ string <TargetedPatchBand>k__BackingField;

            /*0x202419c*/ AssemblyTargetedPatchBandAttribute(string targetedPatchBand);
            /*0x2024194*/ string get_TargetedPatchBand();
        }

        class TargetedPatchingOptOutAttribute : System.Attribute
        {
            /*0x10*/ string <Reason>k__BackingField;

            /*0x20241cc*/ TargetedPatchingOptOutAttribute(string reason);
            /*0x20241c4*/ string get_Reason();
        }

        class AmbiguousImplementationException : System.Exception
        {
            /*0x20241f4*/ AmbiguousImplementationException();
            /*0x2024274*/ AmbiguousImplementationException(string message);
            /*0x20242ec*/ AmbiguousImplementationException(string message, System.Exception innerException);
            /*0x202436c*/ AmbiguousImplementationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class ProfileOptimization
        {
            static /*0x20243ec*/ void InternalSetProfileRoot(string directoryPath);
            static /*0x20243f0*/ void InternalStartProfile(string profile, nint ptrNativeAssemblyLoadContext);
            static /*0x20243f4*/ void SetProfileRoot(string directoryPath);
            static /*0x20243f8*/ void StartProfile(string profile);
        }

        enum GCLargeObjectHeapCompactionMode
        {
            Default = 1,
            CompactOnce = 2,
        }

        enum GCLatencyMode
        {
            Batch = 0,
            Interactive = 1,
            LowLatency = 2,
            SustainedLowLatency = 3,
            NoGCRegion = 4,
        }

        class GCSettings
        {
            static /*0x0*/ System.Runtime.GCLargeObjectHeapCompactionMode <LargeObjectHeapCompactionMode>k__BackingField;

            static /*0x2024424*/ bool get_IsServerGC();
            static /*0x202442c*/ System.Runtime.GCLatencyMode get_LatencyMode();
            static /*0x2024434*/ void set_LatencyMode(System.Runtime.GCLatencyMode value);
            static /*0x2024438*/ System.Runtime.GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
            static /*0x2024480*/ void set_LargeObjectHeapCompactionMode(System.Runtime.GCLargeObjectHeapCompactionMode value);
        }

        class MemoryFailPoint : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
        {
            /*0x20244cc*/ MemoryFailPoint(int sizeInMegabytes);
            /*0x2024514*/ void Finalize();
            /*0x202451c*/ void Dispose();
        }

        class RuntimeImports
        {
            static /*0x202455c*/ void RhZeroMemory(ref byte b, ulong byteLength);
            static /*0x2024564*/ void RhZeroMemory(nint p, nuint byteLength);
            static /*0x2024560*/ void ZeroMemory(void* p, uint byteLength);
            static /*0x20245e8*/ void Memmove(byte* dest, byte* src, uint len);
            static /*0x20245ec*/ void Memmove_wbarrier(byte* dest, byte* src, uint len, nint type_handle);
        }

        namespace Hosting
        {
            class ActivationArguments : System.Security.Policy.EvidenceBase
            {
                /*0x10*/ System.ActivationContext _context;
                /*0x18*/ System.ApplicationIdentity _identity;
                /*0x20*/ string[] _data;

                /*0x20245f0*/ ActivationArguments(System.ActivationContext activationData);
                /*0x2024670*/ ActivationArguments(System.ApplicationIdentity applicationIdentity);
                /*0x20246e8*/ ActivationArguments(System.ActivationContext activationContext, string[] activationData);
                /*0x202476c*/ ActivationArguments(System.ApplicationIdentity applicationIdentity, string[] activationData);
                /*0x20247e8*/ System.ActivationContext get_ActivationContext();
                /*0x20247f0*/ string[] get_ActivationData();
                /*0x20247f8*/ System.ApplicationIdentity get_ApplicationIdentity();
            }

            class ApplicationActivator
            {
                static /*0x20248cc*/ System.Runtime.Remoting.ObjectHandle CreateInstanceHelper(System.AppDomainSetup adSetup);
                /*0x2024800*/ ApplicationActivator();
                /*0x2024808*/ System.Runtime.Remoting.ObjectHandle CreateInstance(System.ActivationContext activationContext);
                /*0x2024818*/ System.Runtime.Remoting.ObjectHandle CreateInstance(System.ActivationContext activationContext, string[] activationCustomData);
            }
        }

        namespace Remoting
        {
            class ChannelInfo : System.Runtime.Remoting.IChannelInfo
            {
                /*0x10*/ object[] channelData;

                /*0x2024bb8*/ ChannelInfo();
                /*0x2024c20*/ ChannelInfo(object remoteChannelData);
                /*0x2024cc8*/ object[] get_ChannelData();
                /*0x2024cd0*/ void set_ChannelData(object[] value);
            }

            class ActivatedClientTypeEntry : System.Runtime.Remoting.TypeEntry
            {
                /*0x20*/ string applicationUrl;
                /*0x28*/ System.Type obj_type;

                /*0x2024cd8*/ ActivatedClientTypeEntry(System.Type type, string appUrl);
                /*0x2024d50*/ ActivatedClientTypeEntry(string typeName, string assemblyName, string appUrl);
                /*0x2024e88*/ string get_ApplicationUrl();
                /*0x2024e90*/ System.Runtime.Remoting.Contexts.IContextAttribute[] get_ContextAttributes();
                /*0x2024e98*/ void set_ContextAttributes(System.Runtime.Remoting.Contexts.IContextAttribute[] value);
                /*0x2024e9c*/ System.Type get_ObjectType();
                /*0x2024ea4*/ string ToString();
            }

            class ActivatedServiceTypeEntry : System.Runtime.Remoting.TypeEntry
            {
                /*0x20*/ System.Type obj_type;

                /*0x2024eb8*/ ActivatedServiceTypeEntry(System.Type type);
                /*0x2024f28*/ ActivatedServiceTypeEntry(string typeName, string assemblyName);
                /*0x2025050*/ System.Runtime.Remoting.Contexts.IContextAttribute[] get_ContextAttributes();
                /*0x2025058*/ void set_ContextAttributes(System.Runtime.Remoting.Contexts.IContextAttribute[] value);
                /*0x202505c*/ System.Type get_ObjectType();
                /*0x2025064*/ string ToString();
            }

            enum CustomErrorsModes
            {
                On = 0,
                Off = 1,
                RemoteOnly = 2,
            }

            class EnvoyInfo : System.Runtime.Remoting.IEnvoyInfo
            {
                /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink envoySinks;

                /*0x2025074*/ EnvoyInfo(System.Runtime.Remoting.Messaging.IMessageSink sinks);
                /*0x202509c*/ System.Runtime.Remoting.Messaging.IMessageSink get_EnvoySinks();
                /*0x20250a4*/ void set_EnvoySinks(System.Runtime.Remoting.Messaging.IMessageSink value);
            }

            interface IChannelInfo
            {
                object[] get_ChannelData();
                void set_ChannelData(object[] value);
            }

            interface IEnvoyInfo
            {
                System.Runtime.Remoting.Messaging.IMessageSink get_EnvoySinks();
                void set_EnvoySinks(System.Runtime.Remoting.Messaging.IMessageSink value);
            }

            interface IObjectHandle
            {
                object Unwrap();
            }

            interface IRemotingTypeInfo
            {
                string get_TypeName();
                void set_TypeName(string value);
                bool CanCastTo(System.Type fromType, object o);
            }

            class Identity
            {
                /*0x10*/ string _objectUri;
                /*0x18*/ System.Runtime.Remoting.Messaging.IMessageSink _channelSink;
                /*0x20*/ System.Runtime.Remoting.Messaging.IMessageSink _envoySink;
                /*0x28*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection _clientDynamicProperties;
                /*0x30*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection _serverDynamicProperties;
                /*0x38*/ System.Runtime.Remoting.ObjRef _objRef;
                /*0x40*/ bool _disposed;

                /*0x20250ac*/ Identity(string objectUri);
                System.Runtime.Remoting.ObjRef CreateObjRef(System.Type requestedType);
                /*0x20250d4*/ bool get_IsFromThisAppDomain();
                /*0x20250e4*/ System.Runtime.Remoting.Messaging.IMessageSink get_ChannelSink();
                /*0x20250ec*/ void set_ChannelSink(System.Runtime.Remoting.Messaging.IMessageSink value);
                /*0x20250f4*/ System.Runtime.Remoting.Messaging.IMessageSink get_EnvoySink();
                /*0x20250fc*/ string get_ObjectUri();
                /*0x2025104*/ void set_ObjectUri(string value);
                /*0x202510c*/ bool get_IsConnected();
                /*0x202511c*/ bool get_Disposed();
                /*0x2025124*/ void set_Disposed(bool value);
                /*0x2025130*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection get_ClientDynamicProperties();
                /*0x202519c*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection get_ServerDynamicProperties();
                /*0x2025208*/ bool get_HasClientDynamicSinks();
                /*0x202521c*/ bool get_HasServerDynamicSinks();
                /*0x2025230*/ void NotifyClientDynamicSinks(bool start, System.Runtime.Remoting.Messaging.IMessage req_msg, bool client_site, bool async);
                /*0x20252a4*/ void NotifyServerDynamicSinks(bool start, System.Runtime.Remoting.Messaging.IMessage req_msg, bool client_site, bool async);
            }

            class ClientIdentity : System.Runtime.Remoting.Identity
            {
                /*0x48*/ System.WeakReference _proxyReference;

                /*0x2025318*/ ClientIdentity(string objectUri, System.Runtime.Remoting.ObjRef objRef);
                /*0x2025420*/ System.MarshalByRefObject get_ClientProxy();
                /*0x20254a8*/ void set_ClientProxy(System.MarshalByRefObject value);
                /*0x2025518*/ System.Runtime.Remoting.ObjRef CreateObjRef(System.Type requestedType);
                /*0x2025520*/ string get_TargetUri();
            }

            class InternalRemotingServices
            {
                static /*0x0*/ System.Collections.Hashtable _soapAttributes;

                static /*0x2025d5c*/ InternalRemotingServices();
                static /*0x2025548*/ void DebugOutChnl(string s);
                static /*0x2025588*/ System.Runtime.Remoting.Metadata.SoapAttribute GetCachedSoapAttribute(object reflectionObject);
                static /*0x2025adc*/ void RemotingAssert(bool condition, string message);
                static /*0x2025b1c*/ void RemotingTrace(object[] messages);
                static /*0x2025b5c*/ void SetServerIdentity(System.Runtime.Remoting.Messaging.MethodCall m, object srvID);
                /*0x2025540*/ InternalRemotingServices();
            }

            class ObjRef : System.Runtime.Serialization.IObjectReference, System.Runtime.Serialization.ISerializable
            {
                static /*0x0*/ int MarshalledObjectRef;
                static /*0x4*/ int WellKnowObjectRef;
                /*0x10*/ System.Runtime.Remoting.IChannelInfo channel_info;
                /*0x18*/ string uri;
                /*0x20*/ System.Runtime.Remoting.IRemotingTypeInfo typeInfo;
                /*0x28*/ System.Runtime.Remoting.IEnvoyInfo envoyInfo;
                /*0x30*/ int flags;
                /*0x38*/ System.Type _serverType;

                static /*0x20272d8*/ ObjRef();
                /*0x2025dd4*/ ObjRef();
                /*0x2025e4c*/ ObjRef(string uri, System.Runtime.Remoting.IChannelInfo cinfo);
                /*0x2026020*/ ObjRef(System.Runtime.Remoting.ObjRef o, bool unmarshalAsProxy);
                /*0x20260c4*/ ObjRef(System.MarshalByRefObject o, System.Type requestedType);
                /*0x202630c*/ ObjRef(System.Type type, string url, object remoteChannelData);
                /*0x202640c*/ ObjRef(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2025e78*/ System.Runtime.Remoting.ObjRef DeserializeInTheCurrentDomain(int domainId, byte[] tInfo);
                /*0x2025fa4*/ byte[] SerializeType();
                /*0x2026940*/ bool IsPossibleToCAD();
                /*0x2026948*/ bool get_IsReferenceToWellKnow();
                /*0x20269b0*/ System.Runtime.Remoting.IChannelInfo get_ChannelInfo();
                /*0x20269b8*/ void set_ChannelInfo(System.Runtime.Remoting.IChannelInfo value);
                /*0x20269c0*/ System.Runtime.Remoting.IEnvoyInfo get_EnvoyInfo();
                /*0x20269c8*/ void set_EnvoyInfo(System.Runtime.Remoting.IEnvoyInfo value);
                /*0x20269d0*/ System.Runtime.Remoting.IRemotingTypeInfo get_TypeInfo();
                /*0x20269d8*/ void set_TypeInfo(System.Runtime.Remoting.IRemotingTypeInfo value);
                /*0x20269e0*/ string get_URI();
                /*0x20269e8*/ void set_URI(string value);
                /*0x20269f0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2026bc8*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
                /*0x2026cc4*/ bool IsFromThisAppDomain();
                /*0x2026f7c*/ bool IsFromThisProcess();
                /*0x2025df0*/ void UpdateChannelInfo();
                /*0x2027190*/ System.Type get_ServerType();
                /*0x20272d4*/ void SetDomainID(int id);
            }

            class ObjectHandle : System.MarshalByRefObject, System.Runtime.Remoting.IObjectHandle
            {
                /*0x18*/ object _wrapped;

                /*0x2027328*/ ObjectHandle(object o);
                /*0x2027350*/ object InitializeLifetimeService();
                /*0x2027358*/ object Unwrap();
            }

            class RemotingConfiguration
            {
                static /*0x0*/ string applicationID;
                static /*0x8*/ string applicationName;
                static /*0x10*/ string processGuid;
                static /*0x18*/ bool defaultConfigRead;
                static /*0x19*/ bool defaultDelayedConfigRead;
                static /*0x1c*/ System.Runtime.Remoting.CustomErrorsModes _errorMode;
                static /*0x20*/ System.Collections.Hashtable wellKnownClientEntries;
                static /*0x28*/ System.Collections.Hashtable activatedClientEntries;
                static /*0x30*/ System.Collections.Hashtable wellKnownServiceEntries;
                static /*0x38*/ System.Collections.Hashtable activatedServiceEntries;
                static /*0x40*/ System.Collections.Hashtable channelTemplates;
                static /*0x48*/ System.Collections.Hashtable clientProviderTemplates;
                static /*0x50*/ System.Collections.Hashtable serverProviderTemplates;

                static /*0x202c360*/ RemotingConfiguration();
                static /*0x2027360*/ string get_ApplicationId();
                static /*0x20273f8*/ string get_ApplicationName();
                static /*0x2027450*/ void set_ApplicationName(string value);
                static /*0x20274ac*/ System.Runtime.Remoting.CustomErrorsModes get_CustomErrorsMode();
                static /*0x2027504*/ void set_CustomErrorsMode(System.Runtime.Remoting.CustomErrorsModes value);
                static /*0x20270e8*/ string get_ProcessId();
                static /*0x2027560*/ void Configure(string filename, bool ensureSecurity);
                static /*0x2027d54*/ void Configure(string filename);
                static /*0x2027740*/ void ReadConfigString(string filename);
                static /*0x2027a38*/ void ReadConfigFile(string filename);
                static /*0x2027e6c*/ void LoadDefaultDelayedChannels();
                static /*0x20281d8*/ System.Runtime.Remoting.ActivatedClientTypeEntry[] GetRegisteredActivatedClientTypes();
                static /*0x20283e8*/ System.Runtime.Remoting.ActivatedServiceTypeEntry[] GetRegisteredActivatedServiceTypes();
                static /*0x20285f8*/ System.Runtime.Remoting.WellKnownClientTypeEntry[] GetRegisteredWellKnownClientTypes();
                static /*0x2028808*/ System.Runtime.Remoting.WellKnownServiceTypeEntry[] GetRegisteredWellKnownServiceTypes();
                static /*0x2028a18*/ bool IsActivationAllowed(System.Type svrType);
                static /*0x2028b5c*/ System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(System.Type svrType);
                static /*0x2028ce8*/ System.Runtime.Remoting.ActivatedClientTypeEntry IsRemotelyActivatedClientType(string typeName, string assemblyName);
                static /*0x2028d70*/ System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(System.Type svrType);
                static /*0x2028efc*/ System.Runtime.Remoting.WellKnownClientTypeEntry IsWellKnownClientType(string typeName, string assemblyName);
                static /*0x2028f84*/ void RegisterActivatedClientType(System.Runtime.Remoting.ActivatedClientTypeEntry entry);
                static /*0x2029210*/ void RegisterActivatedClientType(System.Type type, string appUrl);
                static /*0x2029350*/ void RegisterActivatedServiceType(System.Runtime.Remoting.ActivatedServiceTypeEntry entry);
                static /*0x2029494*/ void RegisterActivatedServiceType(System.Type type);
                static /*0x2029518*/ void RegisterWellKnownClientType(System.Type type, string objectUrl);
                static /*0x202965c*/ void RegisterWellKnownClientType(System.Runtime.Remoting.WellKnownClientTypeEntry entry);
                static /*0x20298e8*/ void RegisterWellKnownServiceType(System.Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);
                static /*0x2029988*/ void RegisterWellKnownServiceType(System.Runtime.Remoting.WellKnownServiceTypeEntry entry);
                static /*0x2029c2c*/ void RegisterChannelTemplate(System.Runtime.Remoting.ChannelData channel);
                static /*0x2029ca8*/ void RegisterClientProviderTemplate(System.Runtime.Remoting.ProviderData prov);
                static /*0x2029d24*/ void RegisterServerProviderTemplate(System.Runtime.Remoting.ProviderData prov);
                static /*0x2029da0*/ void RegisterChannels(System.Collections.ArrayList channels, bool onlyDelayed);
                static /*0x202bb4c*/ void RegisterTypes(System.Collections.ArrayList types);
                static /*0x202c06c*/ bool CustomErrorsEnabled(bool isLocalRequest);
                static /*0x202c100*/ void SetCustomErrorsMode(string mode);
            }

            class ConfigHandler : Mono.Xml.SmallXmlParser.IContentHandler
            {
                /*0x10*/ System.Collections.ArrayList typeEntries;
                /*0x18*/ System.Collections.ArrayList channelInstances;
                /*0x20*/ System.Runtime.Remoting.ChannelData currentChannel;
                /*0x28*/ System.Collections.Stack currentProviderData;
                /*0x30*/ string currentClientUrl;
                /*0x38*/ string appName;
                /*0x40*/ string currentXmlPath;
                /*0x48*/ bool onlyDelayedChannels;

                /*0x2027dac*/ ConfigHandler(bool onlyDelayedChannels);
                /*0x202c4d4*/ void ValidatePath(string element, string[] paths);
                /*0x202c5b8*/ bool CheckPath(string path);
                /*0x202c6a0*/ void OnStartParsing(Mono.Xml.SmallXmlParser parser);
                /*0x202c6a4*/ void OnProcessingInstruction(string name, string text);
                /*0x202c6a8*/ void OnIgnorableWhitespace(string s);
                /*0x202c6ac*/ void OnStartElement(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x202c868*/ void ParseElement(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x202f20c*/ void OnEndElement(string name);
                /*0x202d8b8*/ void ReadCustomProviderData(string name, Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x202dc18*/ void ReadLifetine(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x202f28c*/ System.TimeSpan ParseTime(string s);
                /*0x202e16c*/ void ReadChannel(Mono.Xml.SmallXmlParser.IAttrList attrs, bool isTemplate);
                /*0x202e510*/ System.Runtime.Remoting.ProviderData ReadProvider(string name, Mono.Xml.SmallXmlParser.IAttrList attrs, bool isTemplate);
                /*0x202ebd8*/ void ReadClientActivated(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x202ed1c*/ void ReadServiceActivated(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x202e8f8*/ void ReadClientWellKnown(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x202e9ec*/ void ReadServiceWellKnown(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x202ede4*/ void ReadInteropXml(Mono.Xml.SmallXmlParser.IAttrList attrs, bool isElement);
                /*0x202ef84*/ void ReadPreload(Mono.Xml.SmallXmlParser.IAttrList attrs);
                /*0x202f7e8*/ string GetNotNull(Mono.Xml.SmallXmlParser.IAttrList attrs, string name);
                /*0x202f920*/ string ExtractAssembly(ref string type);
                /*0x202f9e0*/ void OnChars(string ch);
                /*0x202f9e4*/ void OnEndParsing(Mono.Xml.SmallXmlParser parser);
            }

            class ChannelData
            {
                /*0x10*/ string Ref;
                /*0x18*/ string Type;
                /*0x20*/ string Id;
                /*0x28*/ string DelayLoadAsClientChannel;
                /*0x30*/ System.Collections.ArrayList _serverProviders;
                /*0x38*/ System.Collections.ArrayList _clientProviders;
                /*0x40*/ System.Collections.Hashtable _customProperties;

                /*0x202f65c*/ ChannelData();
                /*0x202b370*/ System.Collections.ArrayList get_ServerProviders();
                /*0x202bae0*/ System.Collections.ArrayList get_ClientProviders();
                /*0x202f710*/ System.Collections.Hashtable get_CustomProperties();
                /*0x202aa30*/ void CopyFrom(System.Runtime.Remoting.ChannelData other);
            }

            class ProviderData
            {
                /*0x10*/ string Ref;
                /*0x18*/ string Type;
                /*0x20*/ string Id;
                /*0x28*/ System.Collections.Hashtable CustomProperties;
                /*0x30*/ System.Collections.IList CustomData;

                /*0x202f780*/ ProviderData();
                /*0x202b3dc*/ void CopyFrom(System.Runtime.Remoting.ProviderData other);
            }

            class FormatterData : System.Runtime.Remoting.ProviderData
            {
                /*0x202f77c*/ FormatterData();
            }

            class RemotingException : System.SystemException
            {
                /*0x202fad8*/ RemotingException();
                /*0x2024e80*/ RemotingException(string message);
                /*0x202fae0*/ RemotingException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2027e64*/ RemotingException(string message, System.Exception InnerException);
            }

            class RemotingServices
            {
                static System.Reflection.BindingFlags methodBindings = 52;
                static /*0x0*/ System.Collections.Hashtable uri_hash;
                static /*0x8*/ System.Runtime.Serialization.Formatters.Binary.BinaryFormatter _serializationFormatter;
                static /*0x10*/ System.Runtime.Serialization.Formatters.Binary.BinaryFormatter _deserializationFormatter;
                static /*0x18*/ string app_id;
                static /*0x20*/ object app_id_lock;
                static /*0x28*/ int next_id;
                static /*0x30*/ System.Reflection.MethodInfo FieldSetterMethod;
                static /*0x38*/ System.Reflection.MethodInfo FieldGetterMethod;

                static /*0x202fae8*/ RemotingServices();
                static /*0x202fddc*/ object InternalExecute(System.Reflection.MethodBase method, object obj, object[] parameters, ref object[] out_args);
                static /*0x202fde0*/ System.Reflection.MethodBase GetVirtualMethod(System.Type type, System.Reflection.MethodBase method);
                static /*0x202fde4*/ bool IsTransparentProxy(object proxy);
                static /*0x202fe24*/ System.Runtime.Remoting.Messaging.IMethodReturnMessage InternalExecuteMessage(System.MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);
                static /*0x2030854*/ System.Runtime.Remoting.Messaging.IMethodReturnMessage ExecuteMessage(System.MarshalByRefObject target, System.Runtime.Remoting.Messaging.IMethodCallMessage reqMsg);
                static /*0x20308e4*/ object Connect(System.Type classToProxy, string url);
                static /*0x20309f4*/ object Connect(System.Type classToProxy, string url, object data);
                static /*0x2030a94*/ bool Disconnect(System.MarshalByRefObject obj);
                static /*0x2030d4c*/ System.Type GetServerTypeForUri(string URI);
                static /*0x20262bc*/ string GetObjectUri(System.MarshalByRefObject obj);
                static /*0x2026c6c*/ object Unmarshal(System.Runtime.Remoting.ObjRef objectRef);
                static /*0x2030e44*/ object Unmarshal(System.Runtime.Remoting.ObjRef objectRef, bool fRefine);
                static /*0x2031190*/ System.Runtime.Remoting.ObjRef Marshal(System.MarshalByRefObject Obj);
                static /*0x2031254*/ System.Runtime.Remoting.ObjRef Marshal(System.MarshalByRefObject Obj, string URI);
                static /*0x20311dc*/ System.Runtime.Remoting.ObjRef Marshal(System.MarshalByRefObject Obj, string ObjURI, System.Type RequestedType);
                static /*0x20312a8*/ string NewUri();
                static /*0x203089c*/ System.Runtime.Remoting.Proxies.RealProxy GetRealProxy(object proxy);
                static /*0x20319b0*/ System.Reflection.MethodBase GetMethodBaseFromMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage msg);
                static /*0x2031ca0*/ System.Reflection.MethodBase GetMethodBaseFromName(System.Type type, string methodName, System.Type[] signature);
                static /*0x2031e70*/ System.Reflection.MethodBase FindInterfaceMethod(System.Type type, string methodName, System.Type[] signature);
                static /*0x2031fa0*/ void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                static /*0x2032050*/ System.Runtime.Remoting.ObjRef GetObjRefForProxy(System.MarshalByRefObject obj);
                static /*0x2032094*/ object GetLifetimeService(System.MarshalByRefObject obj);
                static /*0x20320a4*/ System.Runtime.Remoting.Messaging.IMessageSink GetEnvoyChainForProxy(System.MarshalByRefObject obj);
                static /*0x20320ec*/ void LogRemotingStage(int stage);
                static /*0x203212c*/ string GetSessionIdForMethodMessage(System.Runtime.Remoting.Messaging.IMethodMessage msg);
                static /*0x20321cc*/ bool IsMethodOverloaded(System.Runtime.Remoting.Messaging.IMethodMessage msg);
                static /*0x2032360*/ bool IsObjectOutOfAppDomain(object tp);
                static /*0x2032404*/ bool IsObjectOutOfContext(object tp);
                static /*0x20324a8*/ bool IsOneWay(System.Reflection.MethodBase method);
                static /*0x2032544*/ bool IsAsyncMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                static /*0x203263c*/ void SetObjectUriForMarshal(System.MarshalByRefObject obj, string uri);
                static /*0x2032684*/ object CreateClientProxy(System.Runtime.Remoting.ActivatedClientTypeEntry entry, object[] activationAttributes);
                static /*0x2032780*/ object CreateClientProxy(System.Type objectType, string url, object[] activationAttributes);
                static /*0x203299c*/ object CreateClientProxy(System.Runtime.Remoting.WellKnownClientTypeEntry entry);
                static /*0x2032a08*/ object CreateClientProxyForContextBound(System.Type type, object[] activationAttributes);
                static /*0x2026d30*/ System.Runtime.Remoting.Identity GetIdentityForUri(string uri);
                static /*0x2032c04*/ string RemoveAppNameFromUri(string uri);
                static /*0x2030e08*/ System.Runtime.Remoting.Identity GetObjectIdentity(System.MarshalByRefObject obj);
                static /*0x2032cf8*/ System.Runtime.Remoting.ClientIdentity GetOrCreateClientIdentity(System.Runtime.Remoting.ObjRef objRef, System.Type proxyType, ref object clientProxy);
                static /*0x20328b4*/ System.Runtime.Remoting.Messaging.IMessageSink GetClientChannelSinkChain(string url, object channelData, ref string objectUri);
                static /*0x20331c0*/ System.Runtime.Remoting.ClientActivatedIdentity CreateContextBoundObjectIdentity(System.Type objectType);
                static /*0x2031864*/ System.Runtime.Remoting.ClientActivatedIdentity CreateClientActivatedServerIdentity(System.MarshalByRefObject realObject, System.Type objectType, string objectUri);
                static /*0x2029b10*/ System.Runtime.Remoting.ServerIdentity CreateWellKnownServerIdentity(System.Type objectType, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);
                static /*0x2031654*/ void RegisterServerIdentity(System.Runtime.Remoting.ServerIdentity identity);
                static /*0x203109c*/ object GetProxyForRemoteObject(System.Runtime.Remoting.ObjRef objref, System.Type classToProxy);
                static /*0x2030980*/ object GetRemoteObject(System.Runtime.Remoting.ObjRef objRef, System.Type proxyType);
                static /*0x203328c*/ object GetServerObject(string uri);
                static /*0x203339c*/ byte[] SerializeCallData(object obj);
                static /*0x20335a8*/ object DeserializeCallData(byte[] array);
                static /*0x20337f4*/ byte[] SerializeExceptionData(System.Exception ex);
                static /*0x2033968*/ object GetDomainProxy(System.AppDomain domain);
                static /*0x202fd8c*/ void RegisterInternalChannels();
                static /*0x2030b48*/ void DisposeIdentity(System.Runtime.Remoting.Identity ident);
                static /*0x2033c10*/ System.Runtime.Remoting.Identity GetMessageTargetIdentity(System.Runtime.Remoting.Messaging.IMessage msg);
                static /*0x2025c48*/ void SetMessageTargetIdentity(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Identity ident);
                static /*0x2033f48*/ bool UpdateOutArgObject(System.Reflection.ParameterInfo pi, object local, object remote);
                static /*0x2032b8c*/ string GetNormalizedUri(string uri);

                class CACD
                {
                    /*0x10*/ object d;
                    /*0x18*/ object c;

                    /*0x20340dc*/ CACD();
                }
            }

            class RemotingTimeoutException : System.Runtime.Remoting.RemotingException
            {
                /*0x20340e4*/ RemotingTimeoutException();
                /*0x20340ec*/ RemotingTimeoutException(string message);
                /*0x20340f4*/ RemotingTimeoutException(string message, System.Exception InnerException);
                /*0x20340fc*/ RemotingTimeoutException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class ServerException : System.SystemException
            {
                /*0x2034104*/ ServerException();
                /*0x203410c*/ ServerException(string message);
                /*0x2034114*/ ServerException(string message, System.Exception InnerException);
                /*0x203411c*/ ServerException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class ServerIdentity : System.Runtime.Remoting.Identity
            {
                /*0x48*/ System.Type _objectType;
                /*0x50*/ System.MarshalByRefObject _serverObject;
                /*0x58*/ System.Runtime.Remoting.Messaging.IMessageSink _serverSink;
                /*0x60*/ System.Runtime.Remoting.Contexts.Context _context;
                /*0x68*/ System.Runtime.Remoting.Lifetime.Lease _lease;

                /*0x2034124*/ ServerIdentity(string objectUri, System.Runtime.Remoting.Contexts.Context context, System.Type objectType);
                /*0x2034154*/ System.Type get_ObjectType();
                /*0x203415c*/ void StartTrackingLifetime(System.Runtime.Remoting.Lifetime.ILease lease);
                /*0x20344a8*/ void OnLifetimeExpired();
                /*0x2034528*/ System.Runtime.Remoting.ObjRef CreateObjRef(System.Type requestedType);
                /*0x2034ae8*/ void AttachServerObject(System.MarshalByRefObject serverObject, System.Runtime.Remoting.Contexts.Context context);
                /*0x2034de4*/ System.Runtime.Remoting.Lifetime.Lease get_Lease();
                /*0x2034dec*/ System.Runtime.Remoting.Contexts.Context get_Context();
                /*0x2034df4*/ void set_Context(System.Runtime.Remoting.Contexts.Context value);
                System.Runtime.Remoting.Messaging.IMessage SyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                System.Runtime.Remoting.Messaging.IMessageCtrl AsyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                /*0x20344ac*/ void DisposeServerObject();
            }

            class ClientActivatedIdentity : System.Runtime.Remoting.ServerIdentity
            {
                /*0x70*/ System.MarshalByRefObject _targetThis;

                /*0x2035100*/ ClientActivatedIdentity(string objectUri, System.Type objectType);
                /*0x203512c*/ System.MarshalByRefObject GetServerObject();
                /*0x2035134*/ System.MarshalByRefObject GetClientProxy();
                /*0x203513c*/ void SetClientProxy(System.MarshalByRefObject obj);
                /*0x2035144*/ void OnLifetimeExpired();
                /*0x20351a4*/ System.Runtime.Remoting.Messaging.IMessage SyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                /*0x2035438*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
            }

            class SingletonIdentity : System.Runtime.Remoting.ServerIdentity
            {
                /*0x2035528*/ SingletonIdentity(string objectUri, System.Runtime.Remoting.Contexts.Context context, System.Type objectType);
                /*0x2035558*/ System.MarshalByRefObject GetServerObject();
                /*0x2035750*/ System.Runtime.Remoting.Messaging.IMessage SyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                /*0x2035820*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
            }

            class SingleCallIdentity : System.Runtime.Remoting.ServerIdentity
            {
                /*0x2035904*/ SingleCallIdentity(string objectUri, System.Runtime.Remoting.Contexts.Context context, System.Type objectType);
                /*0x2035934*/ System.Runtime.Remoting.Messaging.IMessage SyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                /*0x2035b44*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncObjectProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
            }

            class DisposerReplySink : System.Runtime.Remoting.Messaging.IMessageSink
            {
                /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _next;
                /*0x18*/ System.IDisposable _disposable;

                /*0x2035d04*/ DisposerReplySink(System.Runtime.Remoting.Messaging.IMessageSink next, System.IDisposable disposable);
                /*0x2035d30*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                /*0x2035e4c*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                /*0x2035e8c*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
            }

            class SoapServices
            {
                static /*0x0*/ System.Collections.Hashtable _xmlTypes;
                static /*0x8*/ System.Collections.Hashtable _xmlElements;
                static /*0x10*/ System.Collections.Hashtable _soapActions;
                static /*0x18*/ System.Collections.Hashtable _soapActionsMethods;
                static /*0x20*/ System.Collections.Hashtable _typeInfos;

                static /*0x20383b4*/ SoapServices();
                static /*0x2035e9c*/ string get_XmlNsForClrType();
                static /*0x2035edc*/ string get_XmlNsForClrTypeWithAssembly();
                static /*0x2035f1c*/ string get_XmlNsForClrTypeWithNs();
                static /*0x2035f5c*/ string get_XmlNsForClrTypeWithNsAndAssembly();
                static /*0x2035f9c*/ string CodeXmlNamespaceForClrTypeNamespace(string typeNamespace, string assemblyName);
                static /*0x2036218*/ bool DecodeXmlNamespaceForClrTypeNamespace(string inNamespace, ref string typeNamespace, ref string assemblyName);
                static /*0x20365c0*/ void GetInteropFieldTypeAndNameFromXmlAttribute(System.Type containingType, string xmlAttribute, string xmlNamespace, ref System.Type type, ref string name);
                static /*0x2036810*/ void GetInteropFieldTypeAndNameFromXmlElement(System.Type containingType, string xmlElement, string xmlNamespace, ref System.Type type, ref string name);
                static /*0x20366d0*/ void GetInteropFieldInfo(System.Collections.Hashtable fields, string xmlName, string xmlNamespace, ref System.Type type, ref string name);
                static /*0x2036920*/ string GetNameKey(string name, string namspace);
                static /*0x2036988*/ System.Type GetInteropTypeFromXmlElement(string xmlElement, string xmlNamespace);
                static /*0x2036b60*/ System.Type GetInteropTypeFromXmlType(string xmlType, string xmlTypeNamespace);
                static /*0x2036d38*/ string GetAssemblyName(System.Reflection.MethodBase mb);
                static /*0x2036e74*/ string GetSoapActionFromMethodBase(System.Reflection.MethodBase mb);
                static /*0x2037138*/ bool GetTypeAndMethodNameFromSoapAction(string soapAction, ref string typeName, ref string methodName);
                static /*0x20374dc*/ bool GetXmlElementForInteropType(System.Type type, ref string xmlElement, ref string xmlNamespace);
                static /*0x20375b0*/ string GetXmlNamespaceForMethodCall(System.Reflection.MethodBase mb);
                static /*0x2037648*/ string GetXmlNamespaceForMethodResponse(System.Reflection.MethodBase mb);
                static /*0x20376e0*/ bool GetXmlTypeForInteropType(System.Type type, ref string xmlType, ref string xmlTypeNamespace);
                static /*0x20377a8*/ bool IsClrTypeNamespace(string namespaceString);
                static /*0x2037834*/ bool IsSoapActionValidForMethodBase(string soapAction, System.Reflection.MethodBase mb);
                static /*0x203792c*/ void PreLoad(System.Reflection.Assembly assembly);
                static /*0x20379e8*/ void PreLoad(System.Type type);
                static /*0x2038044*/ void RegisterInteropXmlElement(string xmlElement, string xmlNamespace, System.Type type);
                static /*0x2037eb4*/ void RegisterInteropXmlType(string xmlType, string xmlTypeNamespace, System.Type type);
                static /*0x20381dc*/ void RegisterSoapActionForMethodBase(System.Reflection.MethodBase mb);
                static /*0x2036ec8*/ string InternalGetSoapAction(System.Reflection.MethodBase mb);
                static /*0x2038230*/ void RegisterSoapActionForMethodBase(System.Reflection.MethodBase mb, string soapAction);
                static /*0x2036134*/ string EncodeNs(string ns);
                static /*0x20364dc*/ string DecodeNs(string ns);
                /*0x2035e94*/ SoapServices();

                class TypeInfo
                {
                    /*0x10*/ System.Collections.Hashtable Attributes;
                    /*0x18*/ System.Collections.Hashtable Elements;

                    /*0x20381d4*/ TypeInfo();
                }
            }

            class TypeEntry
            {
                /*0x10*/ string assembly_name;
                /*0x18*/ string type_name;

                /*0x20384bc*/ TypeEntry();
                /*0x20384c4*/ string get_AssemblyName();
                /*0x20384cc*/ void set_AssemblyName(string value);
                /*0x20384d4*/ string get_TypeName();
                /*0x20384dc*/ void set_TypeName(string value);
            }

            class TypeInfo : System.Runtime.Remoting.IRemotingTypeInfo
            {
                /*0x10*/ string serverType;
                /*0x18*/ string[] serverHierarchy;
                /*0x20*/ string[] interfacesImplemented;

                /*0x20346d8*/ TypeInfo(System.Type type);
                /*0x20384e4*/ string get_TypeName();
                /*0x20384ec*/ void set_TypeName(string value);
                /*0x20384f4*/ bool CanCastTo(System.Type fromType, object o);
            }

            class WellKnownClientTypeEntry : System.Runtime.Remoting.TypeEntry
            {
                /*0x20*/ System.Type obj_type;
                /*0x28*/ string obj_url;
                /*0x30*/ string app_url;

                /*0x2038760*/ WellKnownClientTypeEntry(System.Type type, string objectUrl);
                /*0x20387d8*/ WellKnownClientTypeEntry(string typeName, string assemblyName, string objectUrl);
                /*0x203890c*/ string get_ApplicationUrl();
                /*0x2038914*/ void set_ApplicationUrl(string value);
                /*0x203891c*/ System.Type get_ObjectType();
                /*0x2038924*/ string get_ObjectUrl();
                /*0x203892c*/ string ToString();
            }

            enum WellKnownObjectMode
            {
                Singleton = 1,
                SingleCall = 2,
            }

            class WellKnownServiceTypeEntry : System.Runtime.Remoting.TypeEntry
            {
                /*0x20*/ System.Type obj_type;
                /*0x28*/ string obj_uri;
                /*0x30*/ System.Runtime.Remoting.WellKnownObjectMode obj_mode;

                /*0x2038948*/ WellKnownServiceTypeEntry(System.Type type, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);
                /*0x20389d0*/ WellKnownServiceTypeEntry(string typeName, string assemblyName, string objectUri, System.Runtime.Remoting.WellKnownObjectMode mode);
                /*0x2038b10*/ System.Runtime.Remoting.Contexts.IContextAttribute[] get_ContextAttributes();
                /*0x2038b18*/ void set_ContextAttributes(System.Runtime.Remoting.Contexts.IContextAttribute[] value);
                /*0x2038b1c*/ System.Runtime.Remoting.WellKnownObjectMode get_Mode();
                /*0x2038b24*/ System.Type get_ObjectType();
                /*0x2038b2c*/ string get_ObjectUri();
                /*0x2038b34*/ string ToString();
            }

            namespace Services
            {
                class EnterpriseServicesHelper
                {
                    static /*0x2038cb4*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage CreateConstructionReturnMessage(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorMsg, System.MarshalByRefObject retObj);
                    static /*0x2038d2c*/ void SwitchWrappers(System.Runtime.Remoting.Proxies.RealProxy oldcp, System.Runtime.Remoting.Proxies.RealProxy newcp);
                    static /*0x2038d6c*/ object WrapIUnknownWithComObject(nint punk);
                    /*0x2038cac*/ EnterpriseServicesHelper();
                }

                interface ITrackingHandler
                {
                    void DisconnectedObject(object obj);
                    void MarshaledObject(object obj, System.Runtime.Remoting.ObjRef or);
                    void UnmarshaledObject(object obj, System.Runtime.Remoting.ObjRef or);
                }

                class TrackingServices
                {
                    static /*0x0*/ System.Collections.ArrayList _handlers;

                    static /*0x2039aac*/ TrackingServices();
                    static /*0x2038db4*/ void RegisterTrackingHandler(System.Runtime.Remoting.Services.ITrackingHandler handler);
                    static /*0x2038ff4*/ void UnregisterTrackingHandler(System.Runtime.Remoting.Services.ITrackingHandler handler);
                    static /*0x2039234*/ System.Runtime.Remoting.Services.ITrackingHandler[] get_RegisteredHandlers();
                    static /*0x203948c*/ void NotifyMarshaledObject(object obj, System.Runtime.Remoting.ObjRef or);
                    static /*0x203979c*/ void NotifyUnmarshaledObject(object obj, System.Runtime.Remoting.ObjRef or);
                    static /*0x2034dfc*/ void NotifyDisconnectedObject(object obj);
                    /*0x2038dac*/ TrackingServices();
                }
            }

            namespace Proxies
            {
                class ProxyAttribute : System.Attribute, System.Runtime.Remoting.Contexts.IContextAttribute
                {
                    /*0x2039b24*/ ProxyAttribute();
                    /*0x2039b2c*/ System.MarshalByRefObject CreateInstance(System.Type serverType);
                    /*0x2039c78*/ System.Runtime.Remoting.Proxies.RealProxy CreateProxy(System.Runtime.Remoting.ObjRef objRef, System.Type serverType, object serverObject, System.Runtime.Remoting.Contexts.Context serverContext);
                    /*0x2039ce8*/ void GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    /*0x2039cec*/ bool IsContextOK(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                class TransparentProxy
                {
                    /*0x10*/ System.Runtime.Remoting.Proxies.RealProxy _rp;
                    /*0x18*/ Mono.RuntimeRemoteClassHandle _class;
                    /*0x20*/ bool _custom_type_info;

                    /*0x203acf4*/ TransparentProxy();
                    /*0x2039cf4*/ System.RuntimeType GetProxyType();
                    /*0x2039dc4*/ bool get_IsContextBoundObject();
                    /*0x2039de0*/ System.Runtime.Remoting.Contexts.Context get_TargetContext();
                    /*0x2039dfc*/ bool InCurrentContext();
                    /*0x2039e3c*/ object LoadRemoteFieldNew(nint classPtr, nint fieldPtr);
                    /*0x203aa14*/ void StoreRemoteField(nint classPtr, nint fieldPtr, object arg);
                }

                class RealProxy
                {
                    /*0x10*/ System.Type class_to_proxy;
                    /*0x18*/ System.Runtime.Remoting.Contexts.Context _targetContext;
                    /*0x20*/ System.MarshalByRefObject _server;
                    /*0x28*/ int _targetDomainId;
                    /*0x30*/ string _targetUri;
                    /*0x38*/ System.Runtime.Remoting.Identity _objectIdentity;
                    /*0x40*/ object _objTP;
                    /*0x48*/ object _stubData;

                    static /*0x203af08*/ System.Type InternalGetProxyType(object transparentProxy);
                    static /*0x203b1f8*/ object GetStubData(System.Runtime.Remoting.Proxies.RealProxy rp);
                    static /*0x203b210*/ void SetStubData(System.Runtime.Remoting.Proxies.RealProxy rp, object stubData);
                    static /*0x203a11c*/ object PrivateInvoke(System.Runtime.Remoting.Proxies.RealProxy rp, System.Runtime.Remoting.Messaging.IMessage msg, ref System.Exception exc, ref object[] out_args);
                    static /*0x203b5a8*/ object[] ProcessResponse(System.Runtime.Remoting.Messaging.IMethodReturnMessage mrm, System.Runtime.Remoting.Messaging.MonoMethodMessage call);
                    /*0x203acfc*/ RealProxy();
                    /*0x203ad0c*/ RealProxy(System.Type classToProxy);
                    /*0x203ae9c*/ RealProxy(System.Type classToProxy, System.Runtime.Remoting.ClientIdentity identity);
                    /*0x203ad6c*/ RealProxy(System.Type classToProxy, nint stub, object stubData);
                    /*0x203af0c*/ System.Type GetProxiedType();
                    /*0x203afb8*/ System.Runtime.Remoting.ObjRef CreateObjRef(System.Type requestedType);
                    /*0x203b090*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x203b128*/ System.Runtime.Remoting.Identity get_ObjectIdentity();
                    /*0x203b130*/ void set_ObjectIdentity(System.Runtime.Remoting.Identity value);
                    /*0x203b138*/ nint GetCOMIUnknown(bool fIsMarshalled);
                    /*0x203b178*/ void SetCOMIUnknown(nint i);
                    /*0x203b1b8*/ nint SupportsInterface(ref System.Guid iid);
                    System.Runtime.Remoting.Messaging.IMessage Invoke(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x203bcd0*/ object InternalGetTransparentProxy(string className);
                    /*0x203bcd4*/ object GetTransparentProxy();
                    /*0x203be38*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage InitializeServerObject(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorMsg);
                    /*0x203be78*/ void AttachServer(System.MarshalByRefObject s);
                    /*0x203be80*/ System.MarshalByRefObject DetachServer();
                    /*0x203be90*/ System.MarshalByRefObject GetUnwrappedServer();
                    /*0x203be98*/ void SetTargetDomain(int domainId);
                    /*0x203bea0*/ object GetAppDomainTarget();
                }

                class RemotingProxy : System.Runtime.Remoting.Proxies.RealProxy, System.Runtime.Remoting.IRemotingTypeInfo
                {
                    static /*0x0*/ System.Reflection.MethodInfo _cache_GetTypeMethod;
                    static /*0x8*/ System.Reflection.MethodInfo _cache_GetHashCodeMethod;
                    /*0x50*/ System.Runtime.Remoting.Messaging.IMessageSink _sink;
                    /*0x58*/ bool _hasEnvoySink;
                    /*0x60*/ System.Runtime.Remoting.Messaging.ConstructionCall _ctorCall;

                    static /*0x203db70*/ RemotingProxy();
                    /*0x203bfcc*/ RemotingProxy(System.Type type, System.Runtime.Remoting.ClientIdentity identity);
                    /*0x2039c30*/ RemotingProxy(System.Type type, string activationUrl, object[] activationAttributes);
                    /*0x203c9d0*/ System.Runtime.Remoting.Messaging.IMessage Invoke(System.Runtime.Remoting.Messaging.IMessage request);
                    /*0x203d268*/ void AttachIdentity(System.Runtime.Remoting.Identity identity);
                    /*0x203b228*/ System.Runtime.Remoting.Messaging.IMessage ActivateRemoteObject(System.Runtime.Remoting.Messaging.IMethodMessage request);
                    /*0x203d6c0*/ string get_TypeName();
                    /*0x203d7f8*/ void set_TypeName(string value);
                    /*0x203d838*/ bool CanCastTo(System.Type fromType, object o);
                    /*0x203da54*/ void Finalize();
                }
            }

            namespace Lifetime
            {
                class ClientSponsor : System.MarshalByRefObject, System.Runtime.Remoting.Lifetime.ISponsor
                {
                    /*0x18*/ System.TimeSpan renewal_time;
                    /*0x20*/ System.Collections.Hashtable registered_objects;

                    /*0x203dc64*/ ClientSponsor();
                    /*0x203dcfc*/ ClientSponsor(System.TimeSpan renewalTime);
                    /*0x203dd78*/ System.TimeSpan get_RenewalTime();
                    /*0x203dd80*/ void set_RenewalTime(System.TimeSpan value);
                    /*0x203dd88*/ void Close();
                    /*0x203e18c*/ void Finalize();
                    /*0x203e220*/ object InitializeLifetimeService();
                    /*0x203e228*/ bool Register(System.MarshalByRefObject obj);
                    /*0x203e344*/ System.TimeSpan Renewal(System.Runtime.Remoting.Lifetime.ILease lease);
                    /*0x203e34c*/ void Unregister(System.MarshalByRefObject obj);
                }

                interface ILease
                {
                    System.TimeSpan get_CurrentLeaseTime();
                    System.Runtime.Remoting.Lifetime.LeaseState get_CurrentState();
                    System.TimeSpan get_InitialLeaseTime();
                    void set_InitialLeaseTime(System.TimeSpan value);
                    System.TimeSpan get_RenewOnCallTime();
                    void set_RenewOnCallTime(System.TimeSpan value);
                    System.TimeSpan get_SponsorshipTimeout();
                    void set_SponsorshipTimeout(System.TimeSpan value);
                    void Register(System.Runtime.Remoting.Lifetime.ISponsor obj);
                    void Register(System.Runtime.Remoting.Lifetime.ISponsor obj, System.TimeSpan renewalTime);
                    System.TimeSpan Renew(System.TimeSpan renewalTime);
                    void Unregister(System.Runtime.Remoting.Lifetime.ISponsor obj);
                }

                interface ISponsor
                {
                    System.TimeSpan Renewal(System.Runtime.Remoting.Lifetime.ILease lease);
                }

                class Lease : System.MarshalByRefObject, System.Runtime.Remoting.Lifetime.ILease
                {
                    /*0x18*/ System.DateTime _leaseExpireTime;
                    /*0x20*/ System.Runtime.Remoting.Lifetime.LeaseState _currentState;
                    /*0x28*/ System.TimeSpan _initialLeaseTime;
                    /*0x30*/ System.TimeSpan _renewOnCallTime;
                    /*0x38*/ System.TimeSpan _sponsorshipTimeout;
                    /*0x40*/ System.Collections.ArrayList _sponsors;
                    /*0x48*/ System.Collections.Queue _renewingSponsors;
                    /*0x50*/ System.Runtime.Remoting.Lifetime.Lease.RenewalDelegate _renewalDelegate;

                    /*0x20342e8*/ Lease();
                    /*0x203e478*/ System.TimeSpan get_CurrentLeaseTime();
                    /*0x203e4e0*/ System.Runtime.Remoting.Lifetime.LeaseState get_CurrentState();
                    /*0x203e4e8*/ void Activate();
                    /*0x203e4f4*/ System.TimeSpan get_InitialLeaseTime();
                    /*0x203e4fc*/ void set_InitialLeaseTime(System.TimeSpan value);
                    /*0x203e664*/ System.TimeSpan get_RenewOnCallTime();
                    /*0x203e66c*/ void set_RenewOnCallTime(System.TimeSpan value);
                    /*0x203e740*/ System.TimeSpan get_SponsorshipTimeout();
                    /*0x203e748*/ void set_SponsorshipTimeout(System.TimeSpan value);
                    /*0x203e81c*/ void Register(System.Runtime.Remoting.Lifetime.ISponsor obj);
                    /*0x203e88c*/ void Register(System.Runtime.Remoting.Lifetime.ISponsor obj, System.TimeSpan renewalTime);
                    /*0x203ea18*/ System.TimeSpan Renew(System.TimeSpan renewalTime);
                    /*0x203eaa4*/ void Unregister(System.Runtime.Remoting.Lifetime.ISponsor obj);
                    /*0x203ebe8*/ void UpdateState();
                    /*0x203ed88*/ void CheckNextSponsor();
                    /*0x203f118*/ void ProcessSponsorResponse(object state, bool timedOut);

                    class RenewalDelegate : System.MulticastDelegate
                    {
                        /*0x203efcc*/ RenewalDelegate(object object, nint method);
                        /*0x203f324*/ System.TimeSpan Invoke(System.Runtime.Remoting.Lifetime.ILease lease);
                        /*0x203f0f8*/ System.IAsyncResult BeginInvoke(System.Runtime.Remoting.Lifetime.ILease lease, System.AsyncCallback callback, object object);
                        /*0x203f2fc*/ System.TimeSpan EndInvoke(System.IAsyncResult result);
                    }
                }

                class LeaseManager
                {
                    /*0x10*/ System.Collections.ArrayList _objects;
                    /*0x18*/ System.Threading.Timer _timer;

                    /*0x203fa3c*/ LeaseManager();
                    /*0x203f338*/ void SetPollTime(System.TimeSpan timeSpan);
                    /*0x203f430*/ void TrackLifetime(System.Runtime.Remoting.ServerIdentity identity);
                    /*0x203f6c4*/ void StopTrackingLifetime(System.Runtime.Remoting.ServerIdentity identity);
                    /*0x203f564*/ void StartManager();
                    /*0x203f7bc*/ void StopManager();
                    /*0x203f7d8*/ void ManageLeases(object state);
                }

                class LeaseSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _nextSink;

                    /*0x203faa4*/ LeaseSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                    /*0x203facc*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x203fe0c*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x203fb7c*/ void RenewLease(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x203fed0*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                }

                enum LeaseState
                {
                    Null = 0,
                    Initial = 1,
                    Active = 2,
                    Renewing = 3,
                    Expired = 4,
                }

                class LifetimeServices
                {
                    static /*0x0*/ System.TimeSpan _leaseManagerPollTime;
                    static /*0x8*/ System.TimeSpan _leaseTime;
                    static /*0x10*/ System.TimeSpan _renewOnCallTime;
                    static /*0x18*/ System.TimeSpan _sponsorshipTimeout;
                    static /*0x20*/ System.Runtime.Remoting.Lifetime.LeaseManager _leaseManager;

                    static /*0x203fed8*/ LifetimeServices();
                    static /*0x203ffe4*/ System.TimeSpan get_LeaseManagerPollTime();
                    static /*0x204003c*/ void set_LeaseManagerPollTime(System.TimeSpan value);
                    static /*0x20400b0*/ System.TimeSpan get_LeaseTime();
                    static /*0x2040108*/ void set_LeaseTime(System.TimeSpan value);
                    static /*0x2040164*/ System.TimeSpan get_RenewOnCallTime();
                    static /*0x20401bc*/ void set_RenewOnCallTime(System.TimeSpan value);
                    static /*0x2040218*/ System.TimeSpan get_SponsorshipTimeout();
                    static /*0x2040270*/ void set_SponsorshipTimeout(System.TimeSpan value);
                    static /*0x2034440*/ void TrackLifetime(System.Runtime.Remoting.ServerIdentity identity);
                    static /*0x20402cc*/ void StopTrackingLifetime(System.Runtime.Remoting.ServerIdentity identity);
                    /*0x203ffdc*/ LifetimeServices();
                }
            }

            namespace Contexts
            {
                class Context
                {
                    static /*0x0*/ object[] local_slots;
                    static /*0x8*/ System.Runtime.Remoting.Messaging.IMessageSink default_server_context_sink;
                    static /*0x10*/ int global_count;
                    static /*0x18*/ System.LocalDataStoreMgr _localDataStoreMgr;
                    static /*0x20*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection global_dynamic_properties;
                    /*0x10*/ int domain_id;
                    /*0x14*/ int context_id;
                    /*0x18*/ nuint static_data;
                    /*0x20*/ nuint data;
                    /*0x28*/ System.Runtime.Remoting.Messaging.IMessageSink server_context_sink_chain;
                    /*0x30*/ System.Runtime.Remoting.Messaging.IMessageSink client_context_sink_chain;
                    /*0x38*/ System.Collections.Generic.List<System.Runtime.Remoting.Contexts.IContextProperty> context_properties;
                    /*0x40*/ System.LocalDataStoreHolder _localDataStore;
                    /*0x48*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection context_dynamic_properties;
                    /*0x50*/ System.Runtime.Remoting.Contexts.ContextCallbackObject callback_object;

                    static /*0x2042b48*/ Context();
                    static /*0x2040334*/ void RegisterContext(System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x2040338*/ void ReleaseContext(System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x2035748*/ System.Runtime.Remoting.Contexts.Context get_DefaultContext();
                    static /*0x204062c*/ bool RegisterDynamicProperty(System.Runtime.Remoting.Contexts.IDynamicProperty prop, System.ContextBoundObject obj, System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x2040b74*/ bool UnregisterDynamicProperty(string name, System.ContextBoundObject obj, System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x20406a4*/ System.Runtime.Remoting.Contexts.DynamicPropertyCollection GetDynamicPropertyCollection(System.ContextBoundObject obj, System.Runtime.Remoting.Contexts.Context ctx);
                    static /*0x2040dcc*/ void NotifyGlobalDynamicSinks(bool start, System.Runtime.Remoting.Messaging.IMessage req_msg, bool client_site, bool async);
                    static /*0x2041528*/ bool get_HasGlobalDynamicSinks();
                    static /*0x2041df0*/ System.Runtime.Remoting.Contexts.Context SwitchToContext(System.Runtime.Remoting.Contexts.Context newContext);
                    static /*0x2041df8*/ System.Runtime.Remoting.Contexts.Context CreateNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    static /*0x2042930*/ System.LocalDataStoreSlot AllocateDataSlot();
                    static /*0x2042994*/ System.LocalDataStoreSlot AllocateNamedDataSlot(string name);
                    static /*0x2042a00*/ void FreeNamedDataSlot(string name);
                    static /*0x2042a6c*/ System.LocalDataStoreSlot GetNamedDataSlot(string name);
                    static /*0x2042ad8*/ object GetData(System.LocalDataStoreSlot slot);
                    static /*0x2042b08*/ void SetData(System.LocalDataStoreSlot slot, object data);
                    /*0x204033c*/ Context();
                    /*0x20403c0*/ void Finalize();
                    /*0x2040490*/ int get_ContextID();
                    /*0x2040498*/ System.Runtime.Remoting.Contexts.IContextProperty[] get_ContextProperties();
                    /*0x204050c*/ bool get_IsDefaultContext();
                    /*0x204051c*/ bool get_NeedsContextSink();
                    /*0x20415cc*/ void NotifyDynamicSinks(bool start, System.Runtime.Remoting.Messaging.IMessage req_msg, bool client_site, bool async);
                    /*0x2041650*/ bool get_HasDynamicSinks();
                    /*0x203cfa8*/ bool get_HasExitSinks();
                    /*0x2041690*/ System.Runtime.Remoting.Contexts.IContextProperty GetProperty(string name);
                    /*0x2041878*/ void SetProperty(System.Runtime.Remoting.Contexts.IContextProperty prop);
                    /*0x2041a24*/ void Freeze();
                    /*0x2041bd0*/ string ToString();
                    /*0x2041c2c*/ System.Runtime.Remoting.Messaging.IMessageSink GetServerContextSinkChain();
                    /*0x203d060*/ System.Runtime.Remoting.Messaging.IMessageSink GetClientContextSinkChain();
                    /*0x2035280*/ System.Runtime.Remoting.Messaging.IMessageSink CreateServerObjectSinkChain(System.MarshalByRefObject obj, bool forceInternalExecute);
                    /*0x2034be0*/ System.Runtime.Remoting.Messaging.IMessageSink CreateEnvoySink(System.MarshalByRefObject serverObject);
                    /*0x204263c*/ void DoCallBack(System.Runtime.Remoting.Contexts.CrossContextDelegate deleg);
                    /*0x20427bc*/ System.LocalDataStore get_MyLocalStore();
                }

                class DynamicPropertyCollection
                {
                    /*0x10*/ System.Collections.ArrayList _properties;

                    /*0x2040d64*/ DynamicPropertyCollection();
                    /*0x20405fc*/ bool get_HasProperties();
                    /*0x2040888*/ bool RegisterDynamicProperty(System.Runtime.Remoting.Contexts.IDynamicProperty prop);
                    /*0x2040bec*/ bool UnregisterDynamicProperty(string name);
                    /*0x2040ecc*/ void NotifyMessage(bool start, System.Runtime.Remoting.Messaging.IMessage msg, bool client_site, bool async);
                    /*0x2042bc0*/ int FindProperty(string name);

                    class DynamicPropertyReg
                    {
                        /*0x10*/ System.Runtime.Remoting.Contexts.IDynamicProperty Property;
                        /*0x18*/ System.Runtime.Remoting.Contexts.IDynamicMessageSink Sink;

                        /*0x2042d24*/ DynamicPropertyReg();
                    }
                }

                class ContextCallbackObject : System.ContextBoundObject
                {
                    /*0x20427b0*/ ContextCallbackObject();
                    /*0x20427b8*/ void DoCallBack(System.Runtime.Remoting.Contexts.CrossContextDelegate deleg);
                }

                class ContextAttribute : System.Attribute, System.Runtime.Remoting.Contexts.IContextAttribute, System.Runtime.Remoting.Contexts.IContextProperty
                {
                    /*0x10*/ string AttributeName;

                    /*0x2042d2c*/ ContextAttribute(string name);
                    /*0x2042d54*/ string get_Name();
                    /*0x2042d5c*/ bool Equals(object o);
                    /*0x2042df0*/ void Freeze(System.Runtime.Remoting.Contexts.Context newContext);
                    /*0x2042df4*/ int GetHashCode();
                    /*0x2042e0c*/ void GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorMsg);
                    /*0x2042f78*/ bool IsContextOK(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Activation.IConstructionCallMessage ctorMsg);
                    /*0x20430d4*/ bool IsNewContextOK(System.Runtime.Remoting.Contexts.Context newCtx);
                }

                class ContextProperty
                {
                    /*0x10*/ string name;
                    /*0x18*/ object prop;

                    /*0x20430dc*/ ContextProperty(string name, object prop);
                    /*0x2043118*/ ContextProperty();
                    /*0x2043108*/ string get_Name();
                    /*0x2043110*/ object get_Property();
                }

                class CrossContextChannel : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x20439c0*/ CrossContextChannel();
                    /*0x2043150*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x204352c*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x20439b8*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();

                    class ContextRestoreSink : System.Runtime.Remoting.Messaging.IMessageSink
                    {
                        /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _next;
                        /*0x18*/ System.Runtime.Remoting.Contexts.Context _context;
                        /*0x20*/ System.Runtime.Remoting.Messaging.IMessage _call;

                        /*0x204397c*/ ContextRestoreSink(System.Runtime.Remoting.Messaging.IMessageSink next, System.Runtime.Remoting.Contexts.Context context, System.Runtime.Remoting.Messaging.IMessage call);
                        /*0x20439c8*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                        /*0x2043c84*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                        /*0x2043cc4*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                    }
                }

                class CrossContextDelegate : System.MulticastDelegate
                {
                    /*0x2043ccc*/ CrossContextDelegate(object object, nint method);
                    /*0x2043d88*/ void Invoke();
                    /*0x2043d9c*/ System.IAsyncResult BeginInvoke(System.AsyncCallback callback, object object);
                    /*0x2043dbc*/ void EndInvoke(System.IAsyncResult result);
                }

                interface IContextAttribute
                {
                    void GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    bool IsContextOK(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                interface IContextProperty
                {
                    string get_Name();
                    void Freeze(System.Runtime.Remoting.Contexts.Context newContext);
                    bool IsNewContextOK(System.Runtime.Remoting.Contexts.Context newCtx);
                }

                interface IContextPropertyActivator
                {
                    void CollectFromClientContext(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    void CollectFromServerContext(System.Runtime.Remoting.Activation.IConstructionReturnMessage msg);
                    bool DeliverClientContextToServerContext(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    bool DeliverServerContextToClientContext(System.Runtime.Remoting.Activation.IConstructionReturnMessage msg);
                    bool IsOKToActivate(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                interface IContributeClientContextSink
                {
                    System.Runtime.Remoting.Messaging.IMessageSink GetClientContextSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                }

                interface IContributeDynamicSink
                {
                    System.Runtime.Remoting.Contexts.IDynamicMessageSink GetDynamicSink();
                }

                interface IContributeEnvoySink
                {
                    System.Runtime.Remoting.Messaging.IMessageSink GetEnvoySink(System.MarshalByRefObject obj, System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                }

                interface IContributeObjectSink
                {
                    System.Runtime.Remoting.Messaging.IMessageSink GetObjectSink(System.MarshalByRefObject obj, System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                }

                interface IContributeServerContextSink
                {
                    System.Runtime.Remoting.Messaging.IMessageSink GetServerContextSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                }

                interface IDynamicMessageSink
                {
                    void ProcessMessageFinish(System.Runtime.Remoting.Messaging.IMessage replyMsg, bool bCliSide, bool bAsync);
                    void ProcessMessageStart(System.Runtime.Remoting.Messaging.IMessage reqMsg, bool bCliSide, bool bAsync);
                }

                interface IDynamicProperty
                {
                    string get_Name();
                }

                class SynchronizationAttribute : System.Runtime.Remoting.Contexts.ContextAttribute, System.Runtime.Remoting.Contexts.IContributeClientContextSink, System.Runtime.Remoting.Contexts.IContributeServerContextSink
                {
                    static int NOT_SUPPORTED = 1;
                    static int SUPPORTED = 2;
                    static int REQUIRED = 4;
                    static int REQUIRES_NEW = 8;
                    /*0x18*/ bool _bReEntrant;
                    /*0x1c*/ int _flavor;
                    /*0x20*/ int _lockCount;
                    /*0x28*/ System.Threading.Mutex _mutex;
                    /*0x30*/ System.Threading.Thread _ownerThread;

                    static /*0x20445fc*/ void ExitContext();
                    static /*0x20446c8*/ void EnterContext();
                    /*0x2043dc8*/ SynchronizationAttribute();
                    /*0x2043ee4*/ SynchronizationAttribute(bool reEntrant);
                    /*0x2043ef0*/ SynchronizationAttribute(int flag);
                    /*0x2043dd4*/ SynchronizationAttribute(int flag, bool reEntrant);
                    /*0x2043ef8*/ bool get_IsReEntrant();
                    /*0x2043f00*/ bool get_Locked();
                    /*0x2043f10*/ void set_Locked(bool value);
                    /*0x20440b0*/ void AcquireLock();
                    /*0x2044198*/ void ReleaseLock();
                    /*0x20442a0*/ void GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorMsg);
                    /*0x20443d8*/ System.Runtime.Remoting.Messaging.IMessageSink GetClientContextSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                    /*0x2044474*/ System.Runtime.Remoting.Messaging.IMessageSink GetServerContextSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                    /*0x2044510*/ bool IsContextOK(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                class SynchronizedClientContextSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _next;
                    /*0x18*/ System.Runtime.Remoting.Contexts.SynchronizationAttribute _att;

                    /*0x2044448*/ SynchronizedClientContextSink(System.Runtime.Remoting.Messaging.IMessageSink next, System.Runtime.Remoting.Contexts.SynchronizationAttribute att);
                    /*0x2044794*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                    /*0x204479c*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x2044904*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                }

                class SynchronizedServerContextSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _next;
                    /*0x18*/ System.Runtime.Remoting.Contexts.SynchronizationAttribute _att;

                    /*0x20444e4*/ SynchronizedServerContextSink(System.Runtime.Remoting.Messaging.IMessageSink next, System.Runtime.Remoting.Contexts.SynchronizationAttribute att);
                    /*0x2044a98*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                    /*0x2044aa0*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x2044ba4*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                }

                class SynchronizedContextReplySink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _next;
                    /*0x18*/ bool _newLock;
                    /*0x20*/ System.Runtime.Remoting.Contexts.SynchronizationAttribute _att;

                    /*0x20448c4*/ SynchronizedContextReplySink(System.Runtime.Remoting.Messaging.IMessageSink next, System.Runtime.Remoting.Contexts.SynchronizationAttribute att, bool newLock);
                    /*0x2044ce0*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                    /*0x2044ce8*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x2044d28*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                }
            }

            namespace Channels
            {
                class AggregateDictionary : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable
                {
                    /*0x10*/ System.Collections.IDictionary[] dictionaries;
                    /*0x18*/ System.Collections.ArrayList _values;
                    /*0x20*/ System.Collections.ArrayList _keys;

                    /*0x2044e84*/ AggregateDictionary(System.Collections.IDictionary[] dics);
                    /*0x2044eac*/ bool get_IsFixedSize();
                    /*0x2044eb4*/ bool get_IsReadOnly();
                    /*0x2044ebc*/ object get_Item(object key);
                    /*0x204501c*/ void set_Item(object key, object value);
                    /*0x204505c*/ System.Collections.ICollection get_Keys();
                    /*0x20451a8*/ System.Collections.ICollection get_Values();
                    /*0x20452f4*/ void Add(object key, object value);
                    /*0x2045334*/ void Clear();
                    /*0x2045374*/ bool Contains(object ob);
                    /*0x2045474*/ System.Collections.IDictionaryEnumerator GetEnumerator();
                    /*0x2045510*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    /*0x2045580*/ void Remove(object ob);
                    /*0x20455c0*/ void CopyTo(System.Array array, int index);
                    /*0x204585c*/ int get_Count();
                    /*0x2045958*/ bool get_IsSynchronized();
                    /*0x2045960*/ object get_SyncRoot();
                }

                class AggregateEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
                {
                    /*0x10*/ System.Collections.IDictionary[] dictionaries;
                    /*0x18*/ int pos;
                    /*0x20*/ System.Collections.IDictionaryEnumerator currente;

                    /*0x20454e4*/ AggregateEnumerator(System.Collections.IDictionary[] dics);
                    /*0x2045a2c*/ System.Collections.DictionaryEntry get_Entry();
                    /*0x2045ad0*/ object get_Key();
                    /*0x2045b70*/ object get_Value();
                    /*0x2045c14*/ object get_Current();
                    /*0x2045cb8*/ bool MoveNext();
                    /*0x2045964*/ void Reset();
                }

                class BaseChannelObjectWithProperties : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable
                {
                    /*0x10*/ System.Collections.Hashtable table;

                    /*0x2045e38*/ BaseChannelObjectWithProperties();
                    /*0x2045ea4*/ int get_Count();
                    /*0x2045ec8*/ bool get_IsFixedSize();
                    /*0x2045ed0*/ bool get_IsReadOnly();
                    /*0x2045ed8*/ bool get_IsSynchronized();
                    /*0x2045ee0*/ object get_Item(object key);
                    /*0x2045f20*/ void set_Item(object key, object value);
                    /*0x2045f60*/ System.Collections.ICollection get_Keys();
                    /*0x2045f84*/ System.Collections.IDictionary get_Properties();
                    /*0x2045f88*/ object get_SyncRoot();
                    /*0x2045f8c*/ System.Collections.ICollection get_Values();
                    /*0x2045fb0*/ void Add(object key, object value);
                    /*0x2045ff0*/ void Clear();
                    /*0x2046030*/ bool Contains(object key);
                    /*0x2046054*/ void CopyTo(System.Array array, int index);
                    /*0x2046094*/ System.Collections.IDictionaryEnumerator GetEnumerator();
                    /*0x20460b8*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    /*0x20460dc*/ void Remove(object key);
                }

                class BaseChannelSinkWithProperties : System.Runtime.Remoting.Channels.BaseChannelObjectWithProperties
                {
                    /*0x204611c*/ BaseChannelSinkWithProperties();
                }

                class BaseChannelWithProperties : System.Runtime.Remoting.Channels.BaseChannelObjectWithProperties
                {
                    /*0x18*/ System.Runtime.Remoting.Channels.IChannelSinkBase SinksWithProperties;

                    /*0x2046120*/ BaseChannelWithProperties();
                    /*0x2046124*/ System.Collections.IDictionary get_Properties();
                }

                class ChannelDataStore : System.Runtime.Remoting.Channels.IChannelDataStore
                {
                    /*0x10*/ string[] _channelURIs;
                    /*0x18*/ System.Collections.DictionaryEntry[] _extraData;

                    /*0x20462e8*/ ChannelDataStore(string[] channelURIs);
                    /*0x2046310*/ string[] get_ChannelUris();
                    /*0x2046318*/ void set_ChannelUris(string[] value);
                    /*0x2046320*/ object get_Item(object key);
                    /*0x20463a8*/ void set_Item(object key, object value);
                }

                class ChannelServices
                {
                    static /*0x0*/ System.Collections.ArrayList registeredChannels;
                    static /*0x8*/ System.Collections.ArrayList delayedClientChannels;
                    static /*0x10*/ System.Runtime.Remoting.Contexts.CrossContextChannel _crossContextSink;
                    static /*0x18*/ string CrossContextUrl;
                    static /*0x20*/ System.Collections.IList oldStartModeTypes;

                    static /*0x204abc8*/ ChannelServices();
                    static /*0x20464cc*/ System.Runtime.Remoting.Contexts.CrossContextChannel get_CrossContextChannel();
                    static /*0x2046524*/ System.Runtime.Remoting.Messaging.IMessageSink CreateClientChannelSinkChain(string url, object remoteChannelData, ref string objectUri);
                    static /*0x2046da0*/ System.Runtime.Remoting.Messaging.IMessageSink CreateClientChannelSinkChain(System.Runtime.Remoting.Channels.IChannelSender sender, string url, object[] channelDataArray, ref string objectUri);
                    static /*0x2047000*/ System.Runtime.Remoting.Channels.IChannel[] get_RegisteredChannels();
                    static /*0x2047338*/ System.Runtime.Remoting.Channels.IServerChannelSink CreateServerChannelSinkChain(System.Runtime.Remoting.Channels.IServerChannelSinkProvider provider, System.Runtime.Remoting.Channels.IChannelReceiver channel);
                    static /*0x204753c*/ System.Runtime.Remoting.Channels.ServerProcessing DispatchMessage(System.Runtime.Remoting.Channels.IServerChannelSinkStack sinkStack, System.Runtime.Remoting.Messaging.IMessage msg, ref System.Runtime.Remoting.Messaging.IMessage replyMsg);
                    static /*0x2047784*/ System.Runtime.Remoting.Channels.IChannel GetChannel(string name);
                    static /*0x2047c50*/ System.Collections.IDictionary GetChannelSinkProperties(object obj);
                    static /*0x2048054*/ string[] GetUrlsForObject(System.MarshalByRefObject obj);
                    static /*0x2046fa8*/ void RegisterChannel(System.Runtime.Remoting.Channels.IChannel chnl);
                    static /*0x20485b4*/ void RegisterChannel(System.Runtime.Remoting.Channels.IChannel chnl, bool ensureSecurity);
                    static /*0x2048e34*/ void RegisterChannelConfig(System.Runtime.Remoting.ChannelData channel);
                    static /*0x2049a24*/ object CreateProvider(System.Runtime.Remoting.ProviderData prov);
                    static /*0x20476dc*/ System.Runtime.Remoting.Messaging.IMessage SyncDispatchMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    static /*0x204a1c0*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncDispatchMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    static /*0x2049d40*/ System.Runtime.Remoting.Messaging.ReturnMessage CheckIncomingMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    static /*0x2049fec*/ System.Runtime.Remoting.Messaging.IMessage CheckReturnMessage(System.Runtime.Remoting.Messaging.IMessage callMsg, System.Runtime.Remoting.Messaging.IMessage retMsg);
                    static /*0x204a370*/ bool IsLocalCall(System.Runtime.Remoting.Messaging.IMessage callMsg);
                    static /*0x204a3a4*/ void UnregisterChannel(System.Runtime.Remoting.Channels.IChannel chnl);
                    static /*0x204a6c8*/ object[] GetCurrentChannelInfo();
                    /*0x20464c4*/ ChannelServices();
                }

                class ExceptionFilterSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _next;
                    /*0x18*/ System.Runtime.Remoting.Messaging.IMessage _call;

                    /*0x204a378*/ ExceptionFilterSink(System.Runtime.Remoting.Messaging.IMessage call, System.Runtime.Remoting.Messaging.IMessageSink next);
                    /*0x204ad7c*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x204ae60*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x204aea0*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                }

                class ChanelSinkStackEntry
                {
                    /*0x10*/ System.Runtime.Remoting.Channels.IChannelSinkBase Sink;
                    /*0x18*/ object State;
                    /*0x20*/ System.Runtime.Remoting.Channels.ChanelSinkStackEntry Next;

                    /*0x204aea8*/ ChanelSinkStackEntry(System.Runtime.Remoting.Channels.IChannelSinkBase sink, object state, System.Runtime.Remoting.Channels.ChanelSinkStackEntry next);
                }

                class ClientChannelSinkStack : System.Runtime.Remoting.Channels.IClientChannelSinkStack, System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _replySink;
                    /*0x18*/ System.Runtime.Remoting.Channels.ChanelSinkStackEntry _sinkStack;

                    /*0x204aee4*/ ClientChannelSinkStack();
                    /*0x204aeec*/ ClientChannelSinkStack(System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x204af14*/ void AsyncProcessResponse(System.Runtime.Remoting.Channels.ITransportHeaders headers, System.IO.Stream stream);
                    /*0x204b084*/ void DispatchException(System.Exception e);
                    /*0x204b0fc*/ void DispatchReplyMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x204b1ac*/ object Pop(System.Runtime.Remoting.Channels.IClientChannelSink sink);
                    /*0x204b228*/ void Push(System.Runtime.Remoting.Channels.IClientChannelSink sink, object state);
                }

                class CrossAppDomainData
                {
                    /*0x10*/ object _ContextID;
                    /*0x18*/ int _DomainID;
                    /*0x20*/ string _processGuid;

                    /*0x204b2a4*/ CrossAppDomainData(int domainId);
                    /*0x204b34c*/ int get_DomainID();
                    /*0x204b354*/ string get_ProcessID();
                }

                class CrossAppDomainChannel : System.Runtime.Remoting.Channels.IChannel, System.Runtime.Remoting.Channels.IChannelSender, System.Runtime.Remoting.Channels.IChannelReceiver
                {
                    static string _strName = "MONOCAD";
                    static /*0x0*/ object s_lock;

                    static /*0x204b9e0*/ CrossAppDomainChannel();
                    static /*0x204b35c*/ void RegisterCrossAppDomainChannel();
                    /*0x204b4a0*/ CrossAppDomainChannel();
                    /*0x204b4a8*/ string get_ChannelName();
                    /*0x204b4e8*/ int get_ChannelPriority();
                    /*0x204b4f0*/ string Parse(string url, ref string objectURI);
                    /*0x204b4fc*/ object get_ChannelData();
                    /*0x204b568*/ string[] GetUrlsForUri(string objectURI);
                    /*0x204b5b8*/ void StartListening(object data);
                    /*0x204b5bc*/ void StopListening(object data);
                    /*0x204b5c0*/ System.Runtime.Remoting.Messaging.IMessageSink CreateMessageSink(string url, object data, ref string uri);
                }

                class CrossAppDomainSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    static /*0x0*/ System.Collections.Hashtable s_sinks;
                    static /*0x8*/ System.Reflection.MethodInfo processMessageMethod;
                    /*0x10*/ int _domainID;

                    static /*0x204c344*/ CrossAppDomainSink();
                    static /*0x204b740*/ System.Runtime.Remoting.Channels.CrossAppDomainSink GetSink(int domainID);
                    static /*0x204ba88*/ System.Runtime.Remoting.Channels.CrossAppDomainSink.ProcessMessageRes ProcessMessageInDomain(byte[] arrRequest, System.Runtime.Remoting.Messaging.CADMethodCallMessage cadMsg);
                    /*0x204ba58*/ CrossAppDomainSink(int domainID);
                    /*0x204ba80*/ int get_TargetDomainId();
                    /*0x204bcb8*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msgRequest);
                    /*0x204c138*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage reqMsg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x204c230*/ void SendAsyncMessage(object data);
                    /*0x204c33c*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                    /*0x204c440*/ void <AsyncProcessMessage>b__10_0(object data);

                    struct ProcessMessageRes
                    {
                        /*0x10*/ byte[] arrResponse;
                        /*0x18*/ System.Runtime.Remoting.Messaging.CADMethodReturnMessage cadMrm;
                    }
                }

                class CADSerializer
                {
                    static /*0x204c0f8*/ System.Runtime.Remoting.Messaging.IMessage DeserializeMessage(System.IO.MemoryStream mem, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    static /*0x204bbc8*/ System.IO.MemoryStream SerializeMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    static /*0x204c4c0*/ object DeserializeObjectSafe(byte[] mem);
                    static /*0x204c5e8*/ System.IO.MemoryStream SerializeObject(object obj);
                    static /*0x204c560*/ object DeserializeObject(System.IO.MemoryStream mem);
                    /*0x204c6d8*/ CADSerializer();
                }

                class AsyncRequest
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink ReplySink;
                    /*0x18*/ System.Runtime.Remoting.Messaging.IMessage MsgRequest;

                    /*0x204c204*/ AsyncRequest(System.Runtime.Remoting.Messaging.IMessage msgRequest, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                }

                interface IChannel
                {
                    string get_ChannelName();
                    int get_ChannelPriority();
                    string Parse(string url, ref string objectURI);
                }

                interface IChannelDataStore
                {
                    string[] get_ChannelUris();
                    object get_Item(object key);
                    void set_Item(object key, object value);
                }

                interface IChannelReceiver : System.Runtime.Remoting.Channels.IChannel
                {
                    object get_ChannelData();
                    string[] GetUrlsForUri(string objectURI);
                    void StartListening(object data);
                    void StopListening(object data);
                }

                interface IChannelReceiverHook
                {
                    string get_ChannelScheme();
                    System.Runtime.Remoting.Channels.IServerChannelSink get_ChannelSinkChain();
                    bool get_WantsToListen();
                    void AddHookChannelUri(string channelUri);
                }

                interface IChannelSender : System.Runtime.Remoting.Channels.IChannel
                {
                    System.Runtime.Remoting.Messaging.IMessageSink CreateMessageSink(string url, object remoteChannelData, ref string objectURI);
                }

                interface IChannelSinkBase
                {
                    System.Collections.IDictionary get_Properties();
                }

                interface IClientChannelSink : System.Runtime.Remoting.Channels.IChannelSinkBase
                {
                    System.Runtime.Remoting.Channels.IClientChannelSink get_NextChannelSink();
                    void AsyncProcessRequest(System.Runtime.Remoting.Channels.IClientChannelSinkStack sinkStack, System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers, System.IO.Stream stream);
                    void AsyncProcessResponse(System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack sinkStack, object state, System.Runtime.Remoting.Channels.ITransportHeaders headers, System.IO.Stream stream);
                    System.IO.Stream GetRequestStream(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers);
                    void ProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders requestHeaders, System.IO.Stream requestStream, ref System.Runtime.Remoting.Channels.ITransportHeaders responseHeaders, ref System.IO.Stream responseStream);
                }

                interface IClientChannelSinkProvider
                {
                    System.Runtime.Remoting.Channels.IClientChannelSinkProvider get_Next();
                    void set_Next(System.Runtime.Remoting.Channels.IClientChannelSinkProvider value);
                    System.Runtime.Remoting.Channels.IClientChannelSink CreateSink(System.Runtime.Remoting.Channels.IChannelSender channel, string url, object remoteChannelData);
                }

                interface IClientChannelSinkStack : System.Runtime.Remoting.Channels.IClientResponseChannelSinkStack
                {
                    object Pop(System.Runtime.Remoting.Channels.IClientChannelSink sink);
                    void Push(System.Runtime.Remoting.Channels.IClientChannelSink sink, object state);
                }

                interface IClientFormatterSink : System.Runtime.Remoting.Messaging.IMessageSink, System.Runtime.Remoting.Channels.IClientChannelSink, System.Runtime.Remoting.Channels.IChannelSinkBase
                {
                }

                interface IClientFormatterSinkProvider : System.Runtime.Remoting.Channels.IClientChannelSinkProvider
                {
                }

                interface IClientResponseChannelSinkStack
                {
                    void AsyncProcessResponse(System.Runtime.Remoting.Channels.ITransportHeaders headers, System.IO.Stream stream);
                    void DispatchException(System.Exception e);
                    void DispatchReplyMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                }

                interface ISecurableChannel
                {
                    bool get_IsSecured();
                    void set_IsSecured(bool value);
                }

                interface IServerChannelSink : System.Runtime.Remoting.Channels.IChannelSinkBase
                {
                    System.Runtime.Remoting.Channels.IServerChannelSink get_NextChannelSink();
                    void AsyncProcessResponse(System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack sinkStack, object state, System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers, System.IO.Stream stream);
                    System.IO.Stream GetResponseStream(System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack sinkStack, object state, System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers);
                    System.Runtime.Remoting.Channels.ServerProcessing ProcessMessage(System.Runtime.Remoting.Channels.IServerChannelSinkStack sinkStack, System.Runtime.Remoting.Messaging.IMessage requestMsg, System.Runtime.Remoting.Channels.ITransportHeaders requestHeaders, System.IO.Stream requestStream, ref System.Runtime.Remoting.Messaging.IMessage responseMsg, ref System.Runtime.Remoting.Channels.ITransportHeaders responseHeaders, ref System.IO.Stream responseStream);
                }

                interface IServerChannelSinkProvider
                {
                    System.Runtime.Remoting.Channels.IServerChannelSinkProvider get_Next();
                    void set_Next(System.Runtime.Remoting.Channels.IServerChannelSinkProvider value);
                    System.Runtime.Remoting.Channels.IServerChannelSink CreateSink(System.Runtime.Remoting.Channels.IChannelReceiver channel);
                    void GetChannelData(System.Runtime.Remoting.Channels.IChannelDataStore channelData);
                }

                interface IServerChannelSinkStack : System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack
                {
                    object Pop(System.Runtime.Remoting.Channels.IServerChannelSink sink);
                    void Push(System.Runtime.Remoting.Channels.IServerChannelSink sink, object state);
                    void ServerCallback(System.IAsyncResult ar);
                    void Store(System.Runtime.Remoting.Channels.IServerChannelSink sink, object state);
                    void StoreAndDispatch(System.Runtime.Remoting.Channels.IServerChannelSink sink, object state);
                }

                interface IServerFormatterSinkProvider : System.Runtime.Remoting.Channels.IServerChannelSinkProvider
                {
                }

                interface IServerResponseChannelSinkStack
                {
                    void AsyncProcessResponse(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers, System.IO.Stream stream);
                    System.IO.Stream GetResponseStream(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers);
                }

                interface ITransportHeaders
                {
                    object get_Item(object key);
                    void set_Item(object key, object value);
                    System.Collections.IEnumerator GetEnumerator();
                }

                class ServerChannelSinkStack : System.Runtime.Remoting.Channels.IServerChannelSinkStack, System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack
                {
                    /*0x10*/ System.Runtime.Remoting.Channels.ChanelSinkStackEntry _sinkStack;

                    /*0x204c6e0*/ ServerChannelSinkStack();
                    /*0x204c6e8*/ System.IO.Stream GetResponseStream(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers);
                    /*0x204c850*/ object Pop(System.Runtime.Remoting.Channels.IServerChannelSink sink);
                    /*0x204c8cc*/ void Push(System.Runtime.Remoting.Channels.IServerChannelSink sink, object state);
                    /*0x204c948*/ void ServerCallback(System.IAsyncResult ar);
                    /*0x204c988*/ void Store(System.Runtime.Remoting.Channels.IServerChannelSink sink, object state);
                    /*0x204c9c8*/ void StoreAndDispatch(System.Runtime.Remoting.Channels.IServerChannelSink sink, object state);
                    /*0x204ca08*/ void AsyncProcessResponse(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers, System.IO.Stream stream);
                }

                class ServerDispatchSink : System.Runtime.Remoting.Channels.IServerChannelSink, System.Runtime.Remoting.Channels.IChannelSinkBase
                {
                    /*0x204cb88*/ ServerDispatchSink();
                    /*0x204cb90*/ System.Runtime.Remoting.Channels.IServerChannelSink get_NextChannelSink();
                    /*0x204cb98*/ System.Collections.IDictionary get_Properties();
                    /*0x204cba0*/ void AsyncProcessResponse(System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack sinkStack, object state, System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers, System.IO.Stream stream);
                    /*0x204cbe0*/ System.IO.Stream GetResponseStream(System.Runtime.Remoting.Channels.IServerResponseChannelSinkStack sinkStack, object state, System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Channels.ITransportHeaders headers);
                    /*0x204cbe8*/ System.Runtime.Remoting.Channels.ServerProcessing ProcessMessage(System.Runtime.Remoting.Channels.IServerChannelSinkStack sinkStack, System.Runtime.Remoting.Messaging.IMessage requestMsg, System.Runtime.Remoting.Channels.ITransportHeaders requestHeaders, System.IO.Stream requestStream, ref System.Runtime.Remoting.Messaging.IMessage responseMsg, ref System.Runtime.Remoting.Channels.ITransportHeaders responseHeaders, ref System.IO.Stream responseStream);
                }

                class ServerDispatchSinkProvider : System.Runtime.Remoting.Channels.IServerFormatterSinkProvider, System.Runtime.Remoting.Channels.IServerChannelSinkProvider
                {
                    /*0x2047534*/ ServerDispatchSinkProvider();
                    /*0x204cc64*/ ServerDispatchSinkProvider(System.Collections.IDictionary properties, System.Collections.ICollection providerData);
                    /*0x204cc6c*/ System.Runtime.Remoting.Channels.IServerChannelSinkProvider get_Next();
                    /*0x204cc74*/ void set_Next(System.Runtime.Remoting.Channels.IServerChannelSinkProvider value);
                    /*0x204ccb4*/ System.Runtime.Remoting.Channels.IServerChannelSink CreateSink(System.Runtime.Remoting.Channels.IChannelReceiver channel);
                    /*0x204cd10*/ void GetChannelData(System.Runtime.Remoting.Channels.IChannelDataStore channelData);
                }

                enum ServerProcessing
                {
                    Complete = 0,
                    OneWay = 1,
                    Async = 2,
                }

                class SinkProviderData
                {
                    /*0x10*/ string sinkName;
                    /*0x18*/ System.Collections.ArrayList children;
                    /*0x20*/ System.Collections.Hashtable properties;

                    /*0x204cd14*/ SinkProviderData(string name);
                    /*0x204cdc0*/ System.Collections.IList get_Children();
                    /*0x204cdc8*/ string get_Name();
                    /*0x204cdd0*/ System.Collections.IDictionary get_Properties();
                }

                class TransportHeaders : System.Runtime.Remoting.Channels.ITransportHeaders
                {
                    /*0x10*/ System.Collections.Hashtable hash_table;

                    /*0x204cdd8*/ TransportHeaders();
                    /*0x204ce70*/ object get_Item(object key);
                    /*0x204ce94*/ void set_Item(object key, object value);
                    /*0x204ceb8*/ System.Collections.IEnumerator GetEnumerator();
                }
            }

            namespace Activation
            {
                class ActivationServices
                {
                    static /*0x0*/ System.Runtime.Remoting.Activation.IActivator _constructionActivator;

                    static /*0x204cedc*/ System.Runtime.Remoting.Activation.IActivator get_ConstructionActivator();
                    static /*0x203d498*/ System.Runtime.Remoting.Messaging.IMessage Activate(System.Runtime.Remoting.Proxies.RemotingProxy proxy, System.Runtime.Remoting.Messaging.ConstructionCall ctorCall);
                    static /*0x204cf78*/ System.Runtime.Remoting.Messaging.IMessage RemoteActivate(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorCall);
                    static /*0x204d150*/ object CreateProxyFromAttributes(System.Type type, object[] activationAttributes);
                    static /*0x203c010*/ System.Runtime.Remoting.Messaging.ConstructionCall CreateConstructionCall(System.Type type, string activationUrl, object[] activationAttributes);
                    static /*0x204d3dc*/ System.Runtime.Remoting.Messaging.IMessage CreateInstanceFromMessage(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorCall);
                    static /*0x204d7e4*/ object CreateProxyForType(System.Type type);
                    static /*0x204d924*/ void PushActivationAttributes(System.Type serverType, object[] attributes);
                    static /*0x204d928*/ void PopActivationAttributes(System.Type serverType);
                    static /*0x204d7e0*/ object AllocateUninitializedClassInstance(System.Type type);
                    static /*0x204d92c*/ void EnableProxyActivation(System.Type type, bool enable);
                    /*0x204d934*/ ActivationServices();
                }

                enum ActivatorLevel
                {
                    Construction = 4,
                    Context = 8,
                    AppDomain = 12,
                    Process = 16,
                    Machine = 20,
                }

                class AppDomainLevelActivator : System.Runtime.Remoting.Activation.IActivator
                {
                    /*0x10*/ string _activationUrl;
                    /*0x18*/ System.Runtime.Remoting.Activation.IActivator _next;

                    /*0x204d388*/ AppDomainLevelActivator(string activationUrl, System.Runtime.Remoting.Activation.IActivator next);
                    /*0x204d93c*/ System.Runtime.Remoting.Activation.ActivatorLevel get_Level();
                    /*0x204d944*/ System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                    /*0x204d94c*/ void set_NextActivator(System.Runtime.Remoting.Activation.IActivator value);
                    /*0x204d954*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorCall);
                }

                class ConstructionLevelActivator : System.Runtime.Remoting.Activation.IActivator
                {
                    /*0x204cf70*/ ConstructionLevelActivator();
                    /*0x204de38*/ System.Runtime.Remoting.Activation.ActivatorLevel get_Level();
                    /*0x204de40*/ System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                    /*0x204de48*/ void set_NextActivator(System.Runtime.Remoting.Activation.IActivator value);
                    /*0x204de4c*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                class ContextLevelActivator : System.Runtime.Remoting.Activation.IActivator
                {
                    /*0x10*/ System.Runtime.Remoting.Activation.IActivator m_NextActivator;

                    /*0x204d3b4*/ ContextLevelActivator(System.Runtime.Remoting.Activation.IActivator next);
                    /*0x204df3c*/ System.Runtime.Remoting.Activation.ActivatorLevel get_Level();
                    /*0x204df44*/ System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                    /*0x204df4c*/ void set_NextActivator(System.Runtime.Remoting.Activation.IActivator value);
                    /*0x204df54*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorCall);
                }

                interface IActivator
                {
                    System.Runtime.Remoting.Activation.ActivatorLevel get_Level();
                    System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                    void set_NextActivator(System.Runtime.Remoting.Activation.IActivator value);
                    System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }

                interface IConstructionCallMessage : System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage
                {
                    System.Type get_ActivationType();
                    string get_ActivationTypeName();
                    System.Runtime.Remoting.Activation.IActivator get_Activator();
                    void set_Activator(System.Runtime.Remoting.Activation.IActivator value);
                    object[] get_CallSiteActivationAttributes();
                    System.Collections.IList get_ContextProperties();
                }

                interface IConstructionReturnMessage : System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                }

                class RemoteActivationAttribute : System.Attribute, System.Runtime.Remoting.Contexts.IContextAttribute
                {
                    /*0x10*/ System.Collections.IList _contextProperties;

                    /*0x204e288*/ RemoteActivationAttribute();
                    /*0x204e290*/ RemoteActivationAttribute(System.Collections.IList contextProperties);
                    /*0x204e2b8*/ bool IsContextOK(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Activation.IConstructionCallMessage ctor);
                    /*0x204e2c0*/ void GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage ctor);
                }

                class RemoteActivator : System.MarshalByRefObject, System.Runtime.Remoting.Activation.IActivator
                {
                    /*0x204ee44*/ RemoteActivator();
                    /*0x204e6a8*/ System.Runtime.Remoting.Activation.IConstructionReturnMessage Activate(System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                    /*0x204eb28*/ object InitializeLifetimeService();
                    /*0x204ed84*/ System.Runtime.Remoting.Activation.ActivatorLevel get_Level();
                    /*0x204edc4*/ System.Runtime.Remoting.Activation.IActivator get_NextActivator();
                    /*0x204ee04*/ void set_NextActivator(System.Runtime.Remoting.Activation.IActivator value);
                }

                class UrlAttribute : System.Runtime.Remoting.Contexts.ContextAttribute
                {
                    /*0x18*/ string url;

                    /*0x204ee4c*/ UrlAttribute(string callsiteURL);
                    /*0x204ee74*/ string get_UrlValue();
                    /*0x204ee7c*/ bool Equals(object o);
                    /*0x204eef0*/ int GetHashCode();
                    /*0x204ef10*/ void GetPropertiesForNewContext(System.Runtime.Remoting.Activation.IConstructionCallMessage ctorMsg);
                    /*0x204ef14*/ bool IsContextOK(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Activation.IConstructionCallMessage msg);
                }
            }

            namespace Metadata
            {
                class RemotingCachedData
                {
                    /*0x204ef1c*/ RemotingCachedData();
                }

                class RemotingFieldCachedData
                {
                    /*0x204ef24*/ RemotingFieldCachedData(System.Reflection.RuntimeFieldInfo ri);
                    /*0x204ef2c*/ RemotingFieldCachedData(System.Runtime.Serialization.SerializationFieldInfo ri);
                }

                class SoapAttribute : System.Attribute
                {
                    /*0x10*/ bool _nested;
                    /*0x11*/ bool _useAttribute;
                    /*0x18*/ string ProtXmlNamespace;
                    /*0x20*/ object ReflectInfo;

                    /*0x204ef34*/ SoapAttribute();
                    /*0x204ef3c*/ bool get_Embedded();
                    /*0x204ef44*/ void set_Embedded(bool value);
                    /*0x204ef50*/ bool get_UseAttribute();
                    /*0x204ef58*/ void set_UseAttribute(bool value);
                    /*0x204ef64*/ string get_XmlNamespace();
                    /*0x204ef6c*/ void set_XmlNamespace(string value);
                    /*0x204ef74*/ void SetReflectionObject(object reflectionObject);
                }

                class SoapFieldAttribute : System.Runtime.Remoting.Metadata.SoapAttribute
                {
                    /*0x28*/ int _order;
                    /*0x30*/ string _elementName;
                    /*0x38*/ bool _isElement;

                    /*0x204ef7c*/ SoapFieldAttribute();
                    /*0x204ef84*/ int get_Order();
                    /*0x204ef8c*/ void set_Order(int value);
                    /*0x204ef94*/ string get_XmlElementName();
                    /*0x204ef9c*/ void set_XmlElementName(string value);
                    /*0x204efb0*/ bool IsInteropXmlElement();
                    /*0x204efb8*/ void SetReflectionObject(object reflectionObject);
                }

                class SoapMethodAttribute : System.Runtime.Remoting.Metadata.SoapAttribute
                {
                    /*0x28*/ string _responseElement;
                    /*0x30*/ string _responseNamespace;
                    /*0x38*/ string _returnElement;
                    /*0x40*/ string _soapAction;
                    /*0x48*/ bool _useAttribute;
                    /*0x50*/ string _namespace;

                    /*0x204f05c*/ SoapMethodAttribute();
                    /*0x204f064*/ string get_ResponseXmlElementName();
                    /*0x204f06c*/ void set_ResponseXmlElementName(string value);
                    /*0x204f074*/ string get_ResponseXmlNamespace();
                    /*0x204f07c*/ void set_ResponseXmlNamespace(string value);
                    /*0x204f084*/ string get_ReturnXmlElementName();
                    /*0x204f08c*/ void set_ReturnXmlElementName(string value);
                    /*0x204f094*/ string get_SoapAction();
                    /*0x204f09c*/ void set_SoapAction(string value);
                    /*0x204f0a4*/ bool get_UseAttribute();
                    /*0x204f0ac*/ void set_UseAttribute(bool value);
                    /*0x204f0b8*/ string get_XmlNamespace();
                    /*0x204f0c0*/ void set_XmlNamespace(string value);
                    /*0x204f0c8*/ void SetReflectionObject(object reflectionObject);
                }

                enum SoapOption
                {
                    None = 0,
                    AlwaysIncludeTypes = 1,
                    XsdString = 2,
                    EmbedAll = 4,
                    Option1 = 8,
                    Option2 = 16,
                }

                class SoapParameterAttribute : System.Runtime.Remoting.Metadata.SoapAttribute
                {
                    /*0x204f27c*/ SoapParameterAttribute();
                }

                class SoapTypeAttribute : System.Runtime.Remoting.Metadata.SoapAttribute
                {
                    /*0x28*/ System.Runtime.Remoting.Metadata.SoapOption _soapOption;
                    /*0x2c*/ bool _useAttribute;
                    /*0x30*/ string _xmlElementName;
                    /*0x38*/ System.Runtime.Remoting.Metadata.XmlFieldOrderOption _xmlFieldOrder;
                    /*0x40*/ string _xmlNamespace;
                    /*0x48*/ string _xmlTypeName;
                    /*0x50*/ string _xmlTypeNamespace;
                    /*0x58*/ bool _isType;
                    /*0x59*/ bool _isElement;

                    /*0x204f284*/ SoapTypeAttribute();
                    /*0x204f28c*/ System.Runtime.Remoting.Metadata.SoapOption get_SoapOptions();
                    /*0x204f294*/ void set_SoapOptions(System.Runtime.Remoting.Metadata.SoapOption value);
                    /*0x204f29c*/ bool get_UseAttribute();
                    /*0x204f2a4*/ void set_UseAttribute(bool value);
                    /*0x204f2b0*/ string get_XmlElementName();
                    /*0x204f2b8*/ void set_XmlElementName(string value);
                    /*0x204f2cc*/ System.Runtime.Remoting.Metadata.XmlFieldOrderOption get_XmlFieldOrder();
                    /*0x204f2d4*/ void set_XmlFieldOrder(System.Runtime.Remoting.Metadata.XmlFieldOrderOption value);
                    /*0x204f2dc*/ string get_XmlNamespace();
                    /*0x204f2e4*/ void set_XmlNamespace(string value);
                    /*0x204f2f8*/ string get_XmlTypeName();
                    /*0x204f300*/ void set_XmlTypeName(string value);
                    /*0x204f314*/ string get_XmlTypeNamespace();
                    /*0x204f31c*/ void set_XmlTypeNamespace(string value);
                    /*0x204f330*/ bool get_IsInteropXmlElement();
                    /*0x204f338*/ bool get_IsInteropXmlType();
                    /*0x204f340*/ void SetReflectionObject(object reflectionObject);
                }

                enum XmlFieldOrderOption
                {
                    All = 0,
                    Sequence = 1,
                    Choice = 2,
                }

                namespace W3cXsd2001
                {
                    interface ISoapXsd
                    {
                        string GetXsdType();
                    }

                    class SoapAnyUri : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x204f584*/ string get_XsdType();
                        static /*0x204f604*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapAnyUri Parse(string value);
                        /*0x204f544*/ SoapAnyUri();
                        /*0x204f54c*/ SoapAnyUri(string value);
                        /*0x204f574*/ string get_Value();
                        /*0x204f57c*/ void set_Value(string value);
                        /*0x204f5c4*/ string GetXsdType();
                        /*0x204f668*/ string ToString();
                    }

                    class SoapBase64Binary : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ byte[] _value;

                        static /*0x204f6b0*/ string get_XsdType();
                        static /*0x204f730*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapBase64Binary Parse(string value);
                        /*0x204f670*/ SoapBase64Binary();
                        /*0x204f678*/ SoapBase64Binary(byte[] value);
                        /*0x204f6a0*/ byte[] get_Value();
                        /*0x204f6a8*/ void set_Value(byte[] value);
                        /*0x204f6f0*/ string GetXsdType();
                        /*0x204f7cc*/ string ToString();
                    }

                    class SoapDate : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        static /*0x0*/ string[] _datetimeFormats;
                        /*0x10*/ int _sign;
                        /*0x18*/ System.DateTime _value;

                        static /*0x204fb00*/ SoapDate();
                        static /*0x204f8a8*/ string get_XsdType();
                        static /*0x204f960*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDate Parse(string value);
                        /*0x204f828*/ SoapDate();
                        /*0x204f830*/ SoapDate(System.DateTime value);
                        /*0x204f858*/ SoapDate(System.DateTime value, int sign);
                        /*0x204f888*/ int get_Sign();
                        /*0x204f890*/ void set_Sign(int value);
                        /*0x204f898*/ System.DateTime get_Value();
                        /*0x204f8a0*/ void set_Value(System.DateTime value);
                        /*0x204f8e8*/ string GetXsdType();
                        /*0x204fa58*/ string ToString();
                    }

                    class SoapDateTime
                    {
                        static /*0x0*/ string[] _datetimeFormats;

                        static /*0x204fe60*/ SoapDateTime();
                        static /*0x204fd08*/ string get_XsdType();
                        static /*0x204fd48*/ System.DateTime Parse(string value);
                        static /*0x204fde0*/ string ToString(System.DateTime value);
                        /*0x204fd00*/ SoapDateTime();
                    }

                    class SoapDay : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        static /*0x0*/ string[] _datetimeFormats;
                        /*0x10*/ System.DateTime _value;

                        static /*0x2050724*/ SoapDay();
                        static /*0x2050524*/ string get_XsdType();
                        static /*0x20505dc*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapDay Parse(string value);
                        /*0x20504e4*/ SoapDay();
                        /*0x20504ec*/ SoapDay(System.DateTime value);
                        /*0x2050514*/ System.DateTime get_Value();
                        /*0x205051c*/ void set_Value(System.DateTime value);
                        /*0x2050564*/ string GetXsdType();
                        /*0x20506a4*/ string ToString();
                    }

                    class SoapDuration
                    {
                        static /*0x205082c*/ string get_XsdType();
                        static /*0x205086c*/ System.TimeSpan Parse(string value);
                        static /*0x2050dc8*/ string ToString(System.TimeSpan timeSpan);
                        /*0x2050824*/ SoapDuration();
                    }

                    class SoapEntities : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x20510f0*/ string get_XsdType();
                        static /*0x2051170*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntities Parse(string value);
                        /*0x20510ac*/ SoapEntities();
                        /*0x20510b4*/ SoapEntities(string value);
                        /*0x20510e0*/ string get_Value();
                        /*0x20510e8*/ void set_Value(string value);
                        /*0x2051130*/ string GetXsdType();
                        /*0x20511d4*/ string ToString();
                    }

                    class SoapEntity : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x205121c*/ string get_XsdType();
                        static /*0x205129c*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapEntity Parse(string value);
                        /*0x20511dc*/ SoapEntity();
                        /*0x20511e4*/ SoapEntity(string value);
                        /*0x205120c*/ string get_Value();
                        /*0x2051214*/ void set_Value(string value);
                        /*0x205125c*/ string GetXsdType();
                        /*0x2051300*/ string ToString();
                    }

                    class SoapHelper
                    {
                        static /*0x2051308*/ System.Exception GetException(System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd type, string msg);
                        static /*0x20510dc*/ string Normalize(string s);
                        /*0x2051434*/ SoapHelper();
                    }

                    class SoapHexBinary : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ byte[] _value;
                        /*0x18*/ System.Text.StringBuilder sb;

                        static /*0x2051530*/ string get_XsdType();
                        static /*0x20515b0*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapHexBinary Parse(string value);
                        static /*0x2051620*/ byte[] FromBinHexString(string value);
                        static /*0x2051894*/ byte FromHex(char hexDigit, string value);
                        static /*0x2051794*/ System.Exception CreateInvalidValueException(string value);
                        /*0x205143c*/ SoapHexBinary();
                        /*0x20514a4*/ SoapHexBinary(byte[] value);
                        /*0x2051520*/ byte[] get_Value();
                        /*0x2051528*/ void set_Value(byte[] value);
                        /*0x2051570*/ string GetXsdType();
                        /*0x20519ac*/ string ToString();
                    }

                    class SoapId : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x2051ad8*/ string get_XsdType();
                        static /*0x2051b58*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapId Parse(string value);
                        /*0x2051a98*/ SoapId();
                        /*0x2051aa0*/ SoapId(string value);
                        /*0x2051ac8*/ string get_Value();
                        /*0x2051ad0*/ void set_Value(string value);
                        /*0x2051b18*/ string GetXsdType();
                        /*0x2051bbc*/ string ToString();
                    }

                    class SoapIdref : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x2051c04*/ string get_XsdType();
                        static /*0x2051c84*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdref Parse(string value);
                        /*0x2051bc4*/ SoapIdref();
                        /*0x2051bcc*/ SoapIdref(string value);
                        /*0x2051bf4*/ string get_Value();
                        /*0x2051bfc*/ void set_Value(string value);
                        /*0x2051c44*/ string GetXsdType();
                        /*0x2051ce8*/ string ToString();
                    }

                    class SoapIdrefs : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x2051d30*/ string get_XsdType();
                        static /*0x2051db0*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapIdrefs Parse(string value);
                        /*0x2051cf0*/ SoapIdrefs();
                        /*0x2051cf8*/ SoapIdrefs(string value);
                        /*0x2051d20*/ string get_Value();
                        /*0x2051d28*/ void set_Value(string value);
                        /*0x2051d70*/ string GetXsdType();
                        /*0x2051e14*/ string ToString();
                    }

                    class SoapInteger : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ decimal _value;

                        static /*0x2051e64*/ string get_XsdType();
                        static /*0x2051ee4*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapInteger Parse(string value);
                        /*0x2051e1c*/ SoapInteger();
                        /*0x2051e24*/ SoapInteger(decimal value);
                        /*0x2051e50*/ decimal get_Value();
                        /*0x2051e5c*/ void set_Value(decimal value);
                        /*0x2051ea4*/ string GetXsdType();
                        /*0x2051f80*/ string ToString();
                    }

                    class SoapLanguage : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x2051fcc*/ string get_XsdType();
                        static /*0x205204c*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapLanguage Parse(string value);
                        /*0x2051f8c*/ SoapLanguage();
                        /*0x2051f94*/ SoapLanguage(string value);
                        /*0x2051fbc*/ string get_Value();
                        /*0x2051fc4*/ void set_Value(string value);
                        /*0x205200c*/ string GetXsdType();
                        /*0x20520b0*/ string ToString();
                    }

                    class SoapMonth : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        static /*0x0*/ string[] _datetimeFormats;
                        /*0x10*/ System.DateTime _value;

                        static /*0x20522f8*/ SoapMonth();
                        static /*0x20520f8*/ string get_XsdType();
                        static /*0x20521b0*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonth Parse(string value);
                        /*0x20520b8*/ SoapMonth();
                        /*0x20520c0*/ SoapMonth(System.DateTime value);
                        /*0x20520e8*/ System.DateTime get_Value();
                        /*0x20520f0*/ void set_Value(System.DateTime value);
                        /*0x2052138*/ string GetXsdType();
                        /*0x2052278*/ string ToString();
                    }

                    class SoapMonthDay : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        static /*0x0*/ string[] _datetimeFormats;
                        /*0x10*/ System.DateTime _value;

                        static /*0x2052638*/ SoapMonthDay();
                        static /*0x2052438*/ string get_XsdType();
                        static /*0x20524f0*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapMonthDay Parse(string value);
                        /*0x20523f8*/ SoapMonthDay();
                        /*0x2052400*/ SoapMonthDay(System.DateTime value);
                        /*0x2052428*/ System.DateTime get_Value();
                        /*0x2052430*/ void set_Value(System.DateTime value);
                        /*0x2052478*/ string GetXsdType();
                        /*0x20525b8*/ string ToString();
                    }

                    class SoapName : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x2052778*/ string get_XsdType();
                        static /*0x20527f8*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapName Parse(string value);
                        /*0x2052738*/ SoapName();
                        /*0x2052740*/ SoapName(string value);
                        /*0x2052768*/ string get_Value();
                        /*0x2052770*/ void set_Value(string value);
                        /*0x20527b8*/ string GetXsdType();
                        /*0x205285c*/ string ToString();
                    }

                    class SoapNcName : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x20528a4*/ string get_XsdType();
                        static /*0x2052924*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNcName Parse(string value);
                        /*0x2052864*/ SoapNcName();
                        /*0x205286c*/ SoapNcName(string value);
                        /*0x2052894*/ string get_Value();
                        /*0x205289c*/ void set_Value(string value);
                        /*0x20528e4*/ string GetXsdType();
                        /*0x2052988*/ string ToString();
                    }

                    class SoapNegativeInteger : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ decimal _value;

                        static /*0x2052ac4*/ string get_XsdType();
                        static /*0x2052b44*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNegativeInteger Parse(string value);
                        /*0x2052990*/ SoapNegativeInteger();
                        /*0x2052998*/ SoapNegativeInteger(decimal value);
                        /*0x2052ab0*/ decimal get_Value();
                        /*0x2052abc*/ void set_Value(decimal value);
                        /*0x2052b04*/ string GetXsdType();
                        /*0x2052be0*/ string ToString();
                    }

                    class SoapNmtoken : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x2052c2c*/ string get_XsdType();
                        static /*0x2052cac*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtoken Parse(string value);
                        /*0x2052bec*/ SoapNmtoken();
                        /*0x2052bf4*/ SoapNmtoken(string value);
                        /*0x2052c1c*/ string get_Value();
                        /*0x2052c24*/ void set_Value(string value);
                        /*0x2052c6c*/ string GetXsdType();
                        /*0x2052d10*/ string ToString();
                    }

                    class SoapNmtokens : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x2052d58*/ string get_XsdType();
                        static /*0x2052dd8*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNmtokens Parse(string value);
                        /*0x2052d18*/ SoapNmtokens();
                        /*0x2052d20*/ SoapNmtokens(string value);
                        /*0x2052d48*/ string get_Value();
                        /*0x2052d50*/ void set_Value(string value);
                        /*0x2052d98*/ string GetXsdType();
                        /*0x2052e3c*/ string ToString();
                    }

                    class SoapNonNegativeInteger : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ decimal _value;

                        static /*0x2052f78*/ string get_XsdType();
                        static /*0x2052ff8*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonNegativeInteger Parse(string value);
                        /*0x2052e44*/ SoapNonNegativeInteger();
                        /*0x2052e4c*/ SoapNonNegativeInteger(decimal value);
                        /*0x2052f64*/ decimal get_Value();
                        /*0x2052f70*/ void set_Value(decimal value);
                        /*0x2052fb8*/ string GetXsdType();
                        /*0x2053094*/ string ToString();
                    }

                    class SoapNonPositiveInteger : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ decimal _value;

                        static /*0x20531d4*/ string get_XsdType();
                        static /*0x2053254*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNonPositiveInteger Parse(string value);
                        /*0x20530a0*/ SoapNonPositiveInteger();
                        /*0x20530a8*/ SoapNonPositiveInteger(decimal value);
                        /*0x20531c0*/ decimal get_Value();
                        /*0x20531cc*/ void set_Value(decimal value);
                        /*0x2053214*/ string GetXsdType();
                        /*0x20532f0*/ string ToString();
                    }

                    class SoapNormalizedString : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x205333c*/ string get_XsdType();
                        static /*0x20533bc*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNormalizedString Parse(string value);
                        /*0x20532fc*/ SoapNormalizedString();
                        /*0x2053304*/ SoapNormalizedString(string value);
                        /*0x205332c*/ string get_Value();
                        /*0x2053334*/ void set_Value(string value);
                        /*0x205337c*/ string GetXsdType();
                        /*0x2053420*/ string ToString();
                    }

                    class SoapNotation : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x2053468*/ string get_XsdType();
                        static /*0x20534e8*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapNotation Parse(string value);
                        /*0x2053428*/ SoapNotation();
                        /*0x2053430*/ SoapNotation(string value);
                        /*0x2053458*/ string get_Value();
                        /*0x2053460*/ void set_Value(string value);
                        /*0x20534a8*/ string GetXsdType();
                        /*0x205354c*/ string ToString();
                    }

                    class SoapPositiveInteger : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ decimal _value;

                        static /*0x2053688*/ string get_XsdType();
                        static /*0x2053708*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapPositiveInteger Parse(string value);
                        /*0x2053554*/ SoapPositiveInteger();
                        /*0x205355c*/ SoapPositiveInteger(decimal value);
                        /*0x2053674*/ decimal get_Value();
                        /*0x2053680*/ void set_Value(decimal value);
                        /*0x20536c8*/ string GetXsdType();
                        /*0x20537a4*/ string ToString();
                    }

                    class SoapQName : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _name;
                        /*0x18*/ string _key;
                        /*0x20*/ string _namespace;

                        static /*0x2053878*/ string get_XsdType();
                        static /*0x20538f8*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapQName Parse(string value);
                        /*0x20537b0*/ SoapQName();
                        /*0x20537b8*/ SoapQName(string value);
                        /*0x20537e0*/ SoapQName(string key, string name);
                        /*0x205380c*/ SoapQName(string key, string name, string namespaceValue);
                        /*0x2053848*/ string get_Key();
                        /*0x2053850*/ void set_Key(string value);
                        /*0x2053858*/ string get_Name();
                        /*0x2053860*/ void set_Name(string value);
                        /*0x2053868*/ string get_Namespace();
                        /*0x2053870*/ void set_Namespace(string value);
                        /*0x20538b8*/ string GetXsdType();
                        /*0x20539a8*/ string ToString();
                    }

                    class SoapTime : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        static /*0x0*/ string[] _datetimeFormats;
                        /*0x10*/ System.DateTime _value;

                        static /*0x2053c70*/ SoapTime();
                        static /*0x2053a70*/ string get_XsdType();
                        static /*0x2053b28*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapTime Parse(string value);
                        /*0x2053a30*/ SoapTime();
                        /*0x2053a38*/ SoapTime(System.DateTime value);
                        /*0x2053a60*/ System.DateTime get_Value();
                        /*0x2053a68*/ void set_Value(System.DateTime value);
                        /*0x2053ab0*/ string GetXsdType();
                        /*0x2053bf0*/ string ToString();
                    }

                    class SoapToken : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        /*0x10*/ string _value;

                        static /*0x2054334*/ string get_XsdType();
                        static /*0x20543b4*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapToken Parse(string value);
                        /*0x20542f4*/ SoapToken();
                        /*0x20542fc*/ SoapToken(string value);
                        /*0x2054324*/ string get_Value();
                        /*0x205432c*/ void set_Value(string value);
                        /*0x2054374*/ string GetXsdType();
                        /*0x2054418*/ string ToString();
                    }

                    class SoapYear : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        static /*0x0*/ string[] _datetimeFormats;
                        /*0x10*/ int _sign;
                        /*0x18*/ System.DateTime _value;

                        static /*0x20546f8*/ SoapYear();
                        static /*0x20544a0*/ string get_XsdType();
                        static /*0x2054558*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYear Parse(string value);
                        /*0x2054420*/ SoapYear();
                        /*0x2054428*/ SoapYear(System.DateTime value);
                        /*0x2054450*/ SoapYear(System.DateTime value, int sign);
                        /*0x2054480*/ int get_Sign();
                        /*0x2054488*/ void set_Sign(int value);
                        /*0x2054490*/ System.DateTime get_Value();
                        /*0x2054498*/ void set_Value(System.DateTime value);
                        /*0x20544e0*/ string GetXsdType();
                        /*0x2054650*/ string ToString();
                    }

                    class SoapYearMonth : System.Runtime.Remoting.Metadata.W3cXsd2001.ISoapXsd
                    {
                        static /*0x0*/ string[] _datetimeFormats;
                        /*0x10*/ int _sign;
                        /*0x18*/ System.DateTime _value;

                        static /*0x2054bd0*/ SoapYearMonth();
                        static /*0x2054978*/ string get_XsdType();
                        static /*0x2054a30*/ System.Runtime.Remoting.Metadata.W3cXsd2001.SoapYearMonth Parse(string value);
                        /*0x20548f8*/ SoapYearMonth();
                        /*0x2054900*/ SoapYearMonth(System.DateTime value);
                        /*0x2054928*/ SoapYearMonth(System.DateTime value, int sign);
                        /*0x2054958*/ int get_Sign();
                        /*0x2054960*/ void set_Sign(int value);
                        /*0x2054968*/ System.DateTime get_Value();
                        /*0x2054970*/ void set_Value(System.DateTime value);
                        /*0x20549b8*/ string GetXsdType();
                        /*0x2054b28*/ string ToString();
                    }
                }
            }

            namespace Messaging
            {
                class CallContext
                {
                    static /*0x2054dd8*/ object SetCurrentCallContext(System.Runtime.Remoting.Messaging.LogicalCallContext ctx);
                    static /*0x2054de0*/ System.Runtime.Remoting.Messaging.LogicalCallContext SetLogicalCallContext(System.Runtime.Remoting.Messaging.LogicalCallContext callCtx);
                    static /*0x2054e24*/ void FreeNamedDataSlot(string name);
                    static /*0x2054edc*/ object LogicalGetData(string name);
                    static /*0x2054f34*/ object IllogicalGetData(string name);
                    static /*0x2054f94*/ System.Security.Principal.IPrincipal get_Principal();
                    static /*0x2054fe4*/ void set_Principal(System.Security.Principal.IPrincipal value);
                    static /*0x2055048*/ object get_HostContext();
                    static /*0x20550c8*/ void set_HostContext(object value);
                    static /*0x2055180*/ object GetData(string name);
                    static /*0x20551a4*/ void SetData(string name, object data);
                    static /*0x2055260*/ void LogicalSetData(string name, object data);
                    static /*0x205539c*/ System.Runtime.Remoting.Messaging.Header[] GetHeaders();
                    static /*0x2055404*/ void SetHeaders(System.Runtime.Remoting.Messaging.Header[] headers);
                    /*0x2054dd0*/ CallContext();
                }

                interface ILogicalThreadAffinative
                {
                }

                class IllogicalCallContext
                {
                    /*0x10*/ System.Collections.Hashtable m_Datastore;
                    /*0x18*/ object m_HostContext;

                    /*0x2055770*/ IllogicalCallContext();
                    /*0x2055448*/ System.Collections.Hashtable get_Datastore();
                    /*0x20554b4*/ object get_HostContext();
                    /*0x20554bc*/ void set_HostContext(object value);
                    /*0x20554c4*/ bool get_HasUserData();
                    /*0x2054eb0*/ void FreeNamedDataSlot(string name);
                    /*0x20554f0*/ object GetData(string name);
                    /*0x20552c8*/ void SetData(string name, object data);
                    /*0x205551c*/ System.Runtime.Remoting.Messaging.IllogicalCallContext CreateCopy();

                    struct Reader
                    {
                        /*0x10*/ System.Runtime.Remoting.Messaging.IllogicalCallContext m_ctx;

                        /*0x2055778*/ Reader(System.Runtime.Remoting.Messaging.IllogicalCallContext ctx);
                        /*0x2055780*/ bool get_IsNull();
                        /*0x2054f84*/ object GetData(string name);
                        /*0x20550b0*/ object get_HostContext();
                    }
                }

                class LogicalCallContext : System.Runtime.Serialization.ISerializable, System.ICloneable
                {
                    static string s_CorrelationMgrSlotName = "System.Diagnostics.Trace.CorrelationManagerSlot";
                    static /*0x0*/ System.Type s_callContextType;
                    /*0x10*/ System.Collections.Hashtable m_Datastore;
                    /*0x18*/ System.Runtime.Remoting.Messaging.CallContextRemotingData m_RemotingData;
                    /*0x20*/ System.Runtime.Remoting.Messaging.CallContextSecurityData m_SecurityData;
                    /*0x28*/ object m_HostContext;
                    /*0x30*/ bool m_IsCorrelationMgr;
                    /*0x38*/ System.Runtime.Remoting.Messaging.Header[] _sendHeaders;
                    /*0x40*/ System.Runtime.Remoting.Messaging.Header[] _recvHeaders;

                    static /*0x2056e2c*/ LogicalCallContext();
                    static /*0x20567d4*/ string GetPropertyKeyForHeader(System.Runtime.Remoting.Messaging.Header header);
                    /*0x2055790*/ LogicalCallContext();
                    /*0x2055798*/ LogicalCallContext(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x2055b00*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x2055e80*/ object Clone();
                    /*0x203b378*/ void Merge(System.Runtime.Remoting.Messaging.LogicalCallContext lc);
                    /*0x203b30c*/ bool get_HasInfo();
                    /*0x2055e54*/ bool get_HasUserData();
                    /*0x2056480*/ System.Runtime.Remoting.Messaging.CallContextRemotingData get_RemotingData();
                    /*0x20564ec*/ System.Runtime.Remoting.Messaging.CallContextSecurityData get_SecurityData();
                    /*0x2056558*/ object get_HostContext();
                    /*0x2056560*/ void set_HostContext(object value);
                    /*0x2055a94*/ System.Collections.Hashtable get_Datastore();
                    /*0x2056568*/ System.Security.Principal.IPrincipal get_Principal();
                    /*0x2055028*/ void set_Principal(System.Security.Principal.IPrincipal value);
                    /*0x2054e84*/ void FreeNamedDataSlot(string name);
                    /*0x2056580*/ object GetData(string name);
                    /*0x2055304*/ void SetData(string name, object data);
                    /*0x20565ac*/ System.Runtime.Remoting.Messaging.Header[] InternalGetOutgoingHeaders();
                    /*0x2055440*/ void InternalSetHeaders(System.Runtime.Remoting.Messaging.Header[] headers);
                    /*0x20553e8*/ System.Runtime.Remoting.Messaging.Header[] InternalGetHeaders();
                    /*0x20565bc*/ System.Security.Principal.IPrincipal RemovePrincipalIfNotSerializable();
                    /*0x2056628*/ void PropagateOutgoingHeadersToMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x205683c*/ void PropagateIncomingHeadersToCallContext(System.Runtime.Remoting.Messaging.IMessage msg);

                    struct Reader
                    {
                        /*0x10*/ System.Runtime.Remoting.Messaging.LogicalCallContext m_ctx;

                        /*0x2057ebc*/ Reader(System.Runtime.Remoting.Messaging.LogicalCallContext ctx);
                        /*0x2057ec4*/ bool get_IsNull();
                        /*0x2057ed4*/ bool get_HasInfo();
                        /*0x2057ee8*/ System.Runtime.Remoting.Messaging.LogicalCallContext Clone();
                        /*0x2057f54*/ System.Security.Principal.IPrincipal get_Principal();
                        /*0x2057f68*/ object GetData(string name);
                        /*0x2057f7c*/ object get_HostContext();
                    }
                }

                class CallContextSecurityData : System.ICloneable
                {
                    /*0x10*/ System.Security.Principal.IPrincipal _principal;

                    /*0x205801c*/ CallContextSecurityData();
                    /*0x2057f94*/ System.Security.Principal.IPrincipal get_Principal();
                    /*0x2057f9c*/ void set_Principal(System.Security.Principal.IPrincipal value);
                    /*0x2057fa4*/ bool get_HasInfo();
                    /*0x2057fb4*/ object Clone();
                }

                class CallContextRemotingData : System.ICloneable
                {
                    /*0x10*/ string _logicalCallID;

                    /*0x20580ac*/ CallContextRemotingData();
                    /*0x2058024*/ string get_LogicalCallID();
                    /*0x205802c*/ void set_LogicalCallID(string value);
                    /*0x2058034*/ bool get_HasInfo();
                    /*0x2058044*/ object Clone();
                }

                enum ArgInfoType
                {
                    In = 0,
                    Out = 1,
                }

                class ArgInfo
                {
                    /*0x10*/ int[] _paramMap;
                    /*0x18*/ int _inoutArgCount;
                    /*0x20*/ System.Reflection.MethodBase _method;

                    /*0x20580b4*/ ArgInfo(System.Reflection.MethodBase method, System.Runtime.Remoting.Messaging.ArgInfoType type);
                    /*0x2058270*/ int GetInOutArgIndex(int inoutArgNum);
                    /*0x20582a0*/ string GetInOutArgName(int index);
                    /*0x2058320*/ int GetInOutArgCount();
                    /*0x2058328*/ object[] GetInOutArgs(object[] args);
                }

                class AsyncResult : System.IAsyncResult, System.Runtime.Remoting.Messaging.IMessageSink, System.Threading.IThreadPoolWorkItem
                {
                    /*0x10*/ object async_state;
                    /*0x18*/ System.Threading.WaitHandle handle;
                    /*0x20*/ object async_delegate;
                    /*0x28*/ nint data;
                    /*0x30*/ object object_data;
                    /*0x38*/ bool sync_completed;
                    /*0x39*/ bool completed;
                    /*0x3a*/ bool endinvoke_called;
                    /*0x40*/ object async_callback;
                    /*0x48*/ System.Threading.ExecutionContext current;
                    /*0x50*/ System.Threading.ExecutionContext original;
                    /*0x58*/ long add_time;
                    /*0x60*/ System.Runtime.Remoting.Messaging.MonoMethodMessage call_message;
                    /*0x68*/ System.Runtime.Remoting.Messaging.IMessageCtrl message_ctrl;
                    /*0x70*/ System.Runtime.Remoting.Messaging.IMessage reply_message;
                    /*0x78*/ System.Threading.WaitCallback orig_cb;

                    /*0x2058428*/ AsyncResult();
                    /*0x2058430*/ object get_AsyncState();
                    /*0x2058438*/ System.Threading.WaitHandle get_AsyncWaitHandle();
                    /*0x205855c*/ bool get_CompletedSynchronously();
                    /*0x2058564*/ bool get_IsCompleted();
                    /*0x205856c*/ bool get_EndInvokeCalled();
                    /*0x2058574*/ void set_EndInvokeCalled(bool value);
                    /*0x2058580*/ object get_AsyncDelegate();
                    /*0x2058588*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                    /*0x2058590*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x20585d0*/ System.Runtime.Remoting.Messaging.IMessage GetReplyMessage();
                    /*0x20585d8*/ void SetMessageCtrl(System.Runtime.Remoting.Messaging.IMessageCtrl mc);
                    /*0x20585e0*/ void SetCompletedSynchronously(bool completed);
                    /*0x20585ec*/ System.Runtime.Remoting.Messaging.IMessage EndInvoke();
                    /*0x20586fc*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x205888c*/ System.Runtime.Remoting.Messaging.MonoMethodMessage get_CallMessage();
                    /*0x2058894*/ void set_CallMessage(System.Runtime.Remoting.Messaging.MonoMethodMessage value);
                    /*0x205889c*/ void System.Threading.IThreadPoolWorkItem.ExecuteWorkItem();
                    /*0x20588a4*/ void System.Threading.IThreadPoolWorkItem.MarkAborted(System.Threading.ThreadAbortException tae);
                    /*0x20588a0*/ object Invoke();
                }

                class CADArgHolder
                {
                    /*0x10*/ int index;

                    /*0x20588a8*/ CADArgHolder(int i);
                }

                class CADObjRef
                {
                    /*0x10*/ System.Runtime.Remoting.ObjRef objref;
                    /*0x18*/ int SourceDomain;
                    /*0x20*/ byte[] TypeInfo;

                    /*0x20588d0*/ CADObjRef(System.Runtime.Remoting.ObjRef o, int sourceDomain);
                    /*0x2058918*/ string get_TypeName();
                    /*0x20589cc*/ string get_URI();
                }

                class CADMethodRef
                {
                    /*0x10*/ bool ctor;
                    /*0x18*/ string typeName;
                    /*0x20*/ string methodName;
                    /*0x28*/ string[] param_names;
                    /*0x30*/ string[] generic_arg_names;

                    /*0x2059064*/ CADMethodRef(System.Runtime.Remoting.Messaging.IMethodMessage msg);
                    /*0x20589ec*/ System.Type[] GetTypes(string[] typeArray);
                    /*0x2058b38*/ System.Reflection.MethodBase Resolve();
                }

                class CADMessageBase
                {
                    /*0x10*/ object[] _args;
                    /*0x18*/ byte[] _serializedArgs;
                    /*0x20*/ int _propertyCount;
                    /*0x28*/ System.Runtime.Remoting.Messaging.CADArgHolder _callContext;
                    /*0x30*/ byte[] serializedMethod;

                    static /*0x205945c*/ System.Type[] GetSignature(System.Reflection.MethodBase methodBase, bool load);
                    static /*0x2059610*/ int MarshalProperties(System.Collections.IDictionary dict, ref System.Collections.ArrayList args);
                    static /*0x2059ef8*/ void UnmarshalProperties(System.Collections.IDictionary dict, int count, System.Collections.ArrayList args);
                    static /*0x205a034*/ bool IsPossibleToIgnoreMarshal(object obj);
                    /*0x2059340*/ CADMessageBase(System.Runtime.Remoting.Messaging.IMethodMessage msg);
                    /*0x20593d8*/ System.Reflection.MethodBase GetMethod();
                    /*0x205a1e4*/ object MarshalArgument(object arg, ref System.Collections.ArrayList args);
                    /*0x205a3a8*/ object UnmarshalArgument(object arg, System.Collections.ArrayList args);
                    /*0x205aad4*/ object[] MarshalArguments(object[] arguments, ref System.Collections.ArrayList args);
                    /*0x205abd4*/ object[] UnmarshalArguments(object[] arguments, System.Collections.ArrayList args);
                    /*0x205acd4*/ void SaveLogicalCallContext(System.Runtime.Remoting.Messaging.IMethodMessage msg, ref System.Collections.ArrayList serializeList);
                    /*0x205af14*/ System.Runtime.Remoting.Messaging.LogicalCallContext GetLogicalCallContext(System.Collections.ArrayList args);
                }

                class CADMethodCallMessage : System.Runtime.Remoting.Messaging.CADMessageBase
                {
                    /*0x38*/ string _uri;

                    static /*0x205afa4*/ System.Runtime.Remoting.Messaging.CADMethodCallMessage Create(System.Runtime.Remoting.Messaging.IMessage callMsg);
                    /*0x205b034*/ CADMethodCallMessage(System.Runtime.Remoting.Messaging.IMethodCallMessage callMsg);
                    /*0x205af9c*/ string get_Uri();
                    /*0x205b228*/ System.Collections.ArrayList GetArguments();
                    /*0x205b36c*/ object[] GetArgs(System.Collections.ArrayList args);
                    /*0x205b37c*/ int get_PropertiesCount();
                }

                class CADMethodReturnMessage : System.Runtime.Remoting.Messaging.CADMessageBase
                {
                    /*0x38*/ object _returnValue;
                    /*0x40*/ System.Runtime.Remoting.Messaging.CADArgHolder _exception;
                    /*0x48*/ System.Type[] _sig;

                    static /*0x205b384*/ System.Runtime.Remoting.Messaging.CADMethodReturnMessage Create(System.Runtime.Remoting.Messaging.IMessage callMsg);
                    /*0x205b414*/ CADMethodReturnMessage(System.Runtime.Remoting.Messaging.IMethodReturnMessage retMsg);
                    /*0x205b794*/ System.Collections.ArrayList GetArguments();
                    /*0x205b8d8*/ object[] GetArgs(System.Collections.ArrayList args);
                    /*0x205b8e8*/ object GetReturnValue(System.Collections.ArrayList args);
                    /*0x205b8f8*/ System.Exception GetException(System.Collections.ArrayList args);
                    /*0x205b99c*/ int get_PropertiesCount();
                }

                class ClientContextTerminatorSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Contexts.Context _context;

                    /*0x205b9a4*/ ClientContextTerminatorSink(System.Runtime.Remoting.Contexts.Context ctx);
                    /*0x205b9cc*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x205bbb8*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x205be2c*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                }

                class ClientContextReplySink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _replySink;
                    /*0x18*/ System.Runtime.Remoting.Contexts.Context _context;

                    /*0x205be00*/ ClientContextReplySink(System.Runtime.Remoting.Contexts.Context ctx, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x205be34*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x205bf40*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x205bf80*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                }

                class ConstructionCall : System.Runtime.Remoting.Messaging.MethodCall, System.Runtime.Remoting.Activation.IConstructionCallMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage
                {
                    /*0x70*/ System.Runtime.Remoting.Activation.IActivator _activator;
                    /*0x78*/ object[] _activationAttributes;
                    /*0x80*/ System.Collections.IList _contextProperties;
                    /*0x88*/ System.Type _activationType;
                    /*0x90*/ string _activationTypeName;
                    /*0x98*/ bool _isContextOk;
                    /*0xa0*/ System.Runtime.Remoting.Proxies.RemotingProxy _sourceProxy;

                    /*0x205bf88*/ ConstructionCall(System.Runtime.Remoting.Messaging.IMessage m);
                    /*0x205c48c*/ ConstructionCall(System.Type type);
                    /*0x205c4e4*/ ConstructionCall(System.Runtime.Remoting.Messaging.Header[] headers);
                    /*0x205c598*/ ConstructionCall(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x205c648*/ void InitDictionary();
                    /*0x205c778*/ bool get_IsContextOk();
                    /*0x205c780*/ void set_IsContextOk(bool value);
                    /*0x205c78c*/ System.Type get_ActivationType();
                    /*0x205c854*/ string get_ActivationTypeName();
                    /*0x205c85c*/ System.Runtime.Remoting.Activation.IActivator get_Activator();
                    /*0x205c864*/ void set_Activator(System.Runtime.Remoting.Activation.IActivator value);
                    /*0x205c86c*/ object[] get_CallSiteActivationAttributes();
                    /*0x205c874*/ void SetActivationAttributes(object[] attributes);
                    /*0x205c87c*/ System.Collections.IList get_ContextProperties();
                    /*0x205c8e8*/ void InitMethodProperty(string key, object value);
                    /*0x205cfb4*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x205d5dc*/ System.Collections.IDictionary get_Properties();
                    /*0x205d63c*/ System.Runtime.Remoting.Proxies.RemotingProxy get_SourceProxy();
                    /*0x205d644*/ void set_SourceProxy(System.Runtime.Remoting.Proxies.RemotingProxy value);
                }

                class ConstructionCallDictionary : System.Runtime.Remoting.Messaging.MessageDictionary
                {
                    static /*0x0*/ string[] InternalKeys;

                    static /*0x205e4b8*/ ConstructionCallDictionary();
                    /*0x205c6cc*/ ConstructionCallDictionary(System.Runtime.Remoting.Activation.IConstructionCallMessage message);
                    /*0x205d674*/ object GetMethodProperty(string key);
                    /*0x205df6c*/ void SetMethodProperty(string key, object value);
                }

                class ConstructionResponse : System.Runtime.Remoting.Messaging.MethodResponse, System.Runtime.Remoting.Activation.IConstructionReturnMessage, System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                    /*0x205e7f8*/ ConstructionResponse(System.Runtime.Remoting.Messaging.Header[] h, System.Runtime.Remoting.Messaging.IMethodCallMessage mcm);
                    /*0x205eb40*/ ConstructionResponse(object resultObject, System.Runtime.Remoting.Messaging.LogicalCallContext callCtx, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    /*0x205ec20*/ ConstructionResponse(System.Exception e, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    /*0x205ed38*/ ConstructionResponse(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x205edc8*/ System.Collections.IDictionary get_Properties();
                }

                class EnvoyTerminatorSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    static /*0x0*/ System.Runtime.Remoting.Messaging.EnvoyTerminatorSink Instance;

                    static /*0x205efec*/ EnvoyTerminatorSink();
                    /*0x205efe4*/ EnvoyTerminatorSink();
                    /*0x205ee60*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x205ef18*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x205efdc*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                }

                class ErrorMessage : System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                    /*0x10*/ string _uri;

                    /*0x205f050*/ ErrorMessage();
                    /*0x205f0a0*/ int get_ArgCount();
                    /*0x205f0a8*/ object[] get_Args();
                    /*0x205f0b0*/ bool get_HasVarArgs();
                    /*0x205f0b8*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x205f0c0*/ string get_MethodName();
                    /*0x205f100*/ object get_MethodSignature();
                    /*0x205f108*/ System.Collections.IDictionary get_Properties();
                    /*0x205f110*/ string get_TypeName();
                    /*0x205f150*/ string get_Uri();
                    /*0x205f158*/ void set_Uri(string value);
                    /*0x205f160*/ object GetArg(int arg_num);
                    /*0x205f168*/ string GetArgName(int arg_num);
                    /*0x205f1a8*/ int get_InArgCount();
                    /*0x205f1b0*/ string GetInArgName(int index);
                    /*0x205f1b8*/ object GetInArg(int argNum);
                    /*0x205f1c0*/ object[] get_InArgs();
                    /*0x205f1c8*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                }

                class Header
                {
                    /*0x10*/ string HeaderNamespace;
                    /*0x18*/ bool MustUnderstand;
                    /*0x20*/ string Name;
                    /*0x28*/ object Value;

                    /*0x205f1d0*/ Header(string _Name, object _Value);
                    /*0x205f208*/ Header(string _Name, object _Value, bool _MustUnderstand);
                    /*0x205f248*/ Header(string _Name, object _Value, bool _MustUnderstand, string _HeaderNamespace);
                }

                class HeaderHandler : System.MulticastDelegate
                {
                    /*0x205f28c*/ HeaderHandler(object object, nint method);
                    /*0x205f3b8*/ object Invoke(System.Runtime.Remoting.Messaging.Header[] headers);
                    /*0x205f3cc*/ System.IAsyncResult BeginInvoke(System.Runtime.Remoting.Messaging.Header[] headers, System.AsyncCallback callback, object object);
                    /*0x205f3ec*/ object EndInvoke(System.IAsyncResult result);
                }

                interface IInternalMessage
                {
                    System.Runtime.Remoting.Identity get_TargetIdentity();
                    void set_TargetIdentity(System.Runtime.Remoting.Identity value);
                    string get_Uri();
                    void set_Uri(string value);
                    bool HasProperties();
                }

                interface IMessage
                {
                    System.Collections.IDictionary get_Properties();
                }

                interface IMessageCtrl
                {
                    void Cancel(int msToCancel);
                }

                interface IMessageSink
                {
                    System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                }

                interface IMethodCallMessage : System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                    int get_InArgCount();
                    object[] get_InArgs();
                    object GetInArg(int argNum);
                    string GetInArgName(int index);
                }

                interface IMethodMessage : System.Runtime.Remoting.Messaging.IMessage
                {
                    int get_ArgCount();
                    object[] get_Args();
                    bool get_HasVarArgs();
                    System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    System.Reflection.MethodBase get_MethodBase();
                    string get_MethodName();
                    object get_MethodSignature();
                    string get_TypeName();
                    string get_Uri();
                    object GetArg(int argNum);
                    string GetArgName(int index);
                }

                interface IMethodReturnMessage : System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                    System.Exception get_Exception();
                    int get_OutArgCount();
                    object[] get_OutArgs();
                    object get_ReturnValue();
                    object GetOutArg(int argNum);
                    string GetOutArgName(int index);
                }

                interface IRemotingFormatter : System.Runtime.Serialization.IFormatter
                {
                    object Deserialize(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler);
                    void Serialize(System.IO.Stream serializationStream, object graph, System.Runtime.Remoting.Messaging.Header[] headers);
                }

                interface ISerializationRootObject
                {
                    void RootSetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                }

                class InternalMessageWrapper
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessage WrappedMessage;

                    /*0x205f3f8*/ InternalMessageWrapper(System.Runtime.Remoting.Messaging.IMessage msg);
                }

                class MessageSurrogateFilter : System.MulticastDelegate
                {
                    /*0x205f420*/ MessageSurrogateFilter(object object, nint method);
                    /*0x205f4f8*/ bool Invoke(string key, object value);
                    /*0x205f50c*/ System.IAsyncResult BeginInvoke(string key, object value, System.AsyncCallback callback, object object);
                    /*0x205f534*/ bool EndInvoke(System.IAsyncResult result);
                }

                class MethodCall : System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Serialization.ISerializable, System.Runtime.Remoting.Messaging.IInternalMessage, System.Runtime.Remoting.Messaging.ISerializationRootObject
                {
                    /*0x10*/ string _uri;
                    /*0x18*/ string _typeName;
                    /*0x20*/ string _methodName;
                    /*0x28*/ object[] _args;
                    /*0x30*/ System.Type[] _methodSignature;
                    /*0x38*/ System.Reflection.MethodBase _methodBase;
                    /*0x40*/ System.Runtime.Remoting.Messaging.LogicalCallContext _callContext;
                    /*0x48*/ System.Runtime.Remoting.Messaging.ArgInfo _inArgInfo;
                    /*0x50*/ System.Runtime.Remoting.Identity _targetIdentity;
                    /*0x58*/ System.Type[] _genericArguments;
                    /*0x60*/ System.Collections.IDictionary ExternalProperties;
                    /*0x68*/ System.Collections.IDictionary InternalProperties;

                    static /*0x2060958*/ string GetTypeNameFromAssemblyQualifiedName(string aqname);
                    /*0x205c4e8*/ MethodCall(System.Runtime.Remoting.Messaging.Header[] h1);
                    /*0x205c59c*/ MethodCall(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x205fc64*/ MethodCall(System.Runtime.Remoting.Messaging.CADMethodCallMessage msg);
                    /*0x205bfb0*/ MethodCall(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x20600d4*/ MethodCall(string uri, string typeName, string methodName, object[] args);
                    /*0x205c4dc*/ MethodCall();
                    /*0x205fd78*/ void CopyFrom(System.Runtime.Remoting.Messaging.IMethodMessage call);
                    /*0x205cb98*/ void InitMethodProperty(string key, object value);
                    /*0x205d14c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x206012c*/ int get_ArgCount();
                    /*0x2060148*/ object[] get_Args();
                    /*0x2060150*/ bool get_HasVarArgs();
                    /*0x20601ac*/ int get_InArgCount();
                    /*0x2060220*/ object[] get_InArgs();
                    /*0x2060298*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x206017c*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x2060304*/ string get_MethodName();
                    /*0x206033c*/ object get_MethodSignature();
                    /*0x205d60c*/ System.Collections.IDictionary get_Properties();
                    /*0x206046c*/ void InitDictionary();
                    /*0x205c440*/ string get_TypeName();
                    /*0x206056c*/ string get_Uri();
                    /*0x2060574*/ void set_Uri(string value);
                    /*0x206057c*/ string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
                    /*0x2060584*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
                    /*0x206058c*/ object GetArg(int argNum);
                    /*0x20605bc*/ string GetArgName(int index);
                    /*0x2060614*/ object GetInArg(int argNum);
                    /*0x20606bc*/ string GetInArgName(int index);
                    /*0x2060748*/ object HeaderHandler(System.Runtime.Remoting.Messaging.Header[] h);
                    /*0x2060788*/ void Init();
                    /*0x205f55c*/ void ResolveMethod();
                    /*0x206078c*/ System.Type CastTo(string clientType, System.Type serverType);
                    /*0x2060a00*/ void RootSetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext ctx);
                    /*0x2060a40*/ System.Runtime.Remoting.Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
                    /*0x2060a48*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(System.Runtime.Remoting.Identity value);
                    /*0x2060a50*/ bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
                    /*0x206091c*/ System.Type[] get_GenericArguments();
                }

                class MCMDictionary : System.Runtime.Remoting.Messaging.MessageDictionary
                {
                    static /*0x0*/ string[] InternalKeys;

                    static /*0x2060a70*/ MCMDictionary();
                    /*0x20604f0*/ MCMDictionary(System.Runtime.Remoting.Messaging.IMethodMessage message);
                }

                class MethodCallMessageWrapper : System.Runtime.Remoting.Messaging.InternalMessageWrapper, System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                    /*0x18*/ object[] _args;
                    /*0x20*/ System.Runtime.Remoting.Messaging.ArgInfo _inArgInfo;
                    /*0x28*/ System.Runtime.Remoting.Messaging.MethodCallMessageWrapper.DictionaryWrapper _properties;

                    /*0x2060c70*/ MethodCallMessageWrapper(System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    /*0x2060e34*/ int get_ArgCount();
                    /*0x2060f38*/ object[] get_Args();
                    /*0x2060f40*/ void set_Args(object[] value);
                    /*0x2060f48*/ bool get_HasVarArgs();
                    /*0x2061050*/ int get_InArgCount();
                    /*0x206106c*/ object[] get_InArgs();
                    /*0x206108c*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x2061194*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x206129c*/ string get_MethodName();
                    /*0x20613a4*/ object get_MethodSignature();
                    /*0x20614ac*/ System.Collections.IDictionary get_Properties();
                    /*0x206163c*/ string get_TypeName();
                    /*0x2061744*/ string get_Uri();
                    /*0x206184c*/ void set_Uri(string value);
                    /*0x20619c4*/ object GetArg(int argNum);
                    /*0x20619f4*/ string GetArgName(int index);
                    /*0x2061b04*/ object GetInArg(int argNum);
                    /*0x2061b44*/ string GetInArgName(int index);

                    class DictionaryWrapper : System.Runtime.Remoting.Messaging.MCMDictionary
                    {
                        static /*0x0*/ string[] _keys;
                        /*0x30*/ System.Collections.IDictionary _wrappedDictionary;

                        static /*0x2061dac*/ DictionaryWrapper();
                        /*0x2061598*/ DictionaryWrapper(System.Runtime.Remoting.Messaging.IMethodMessage message, System.Collections.IDictionary wrappedDictionary);
                        /*0x2061b64*/ System.Collections.IDictionary AllocInternalProperties();
                        /*0x2061b6c*/ void SetMethodProperty(string key, object value);
                        /*0x2061ce0*/ object GetMethodProperty(string key);
                    }
                }

                class MessageDictionary : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable
                {
                    /*0x10*/ System.Collections.IDictionary _internalProperties;
                    /*0x18*/ System.Runtime.Remoting.Messaging.IMethodMessage _message;
                    /*0x20*/ string[] _methodKeys;
                    /*0x28*/ bool _ownProperties;

                    /*0x205d64c*/ MessageDictionary(System.Runtime.Remoting.Messaging.IMethodMessage message);
                    /*0x2061f70*/ MessageDictionary(string[] keys);
                    /*0x2059d74*/ bool HasUserData();
                    /*0x2059e70*/ System.Collections.IDictionary get_InternalDictionary();
                    /*0x2061e6c*/ string[] get_MethodKeys();
                    /*0x2061e74*/ void set_MethodKeys(string[] value);
                    /*0x2061e7c*/ System.Collections.IDictionary AllocInternalProperties();
                    /*0x205c748*/ System.Collections.IDictionary GetInternalProperties();
                    /*0x2061ee4*/ bool IsOverridenKey(string key);
                    /*0x2061f98*/ bool get_IsFixedSize();
                    /*0x2061fa0*/ bool get_IsReadOnly();
                    /*0x2061fa8*/ object get_Item(object key);
                    /*0x20620f4*/ void set_Item(object key, object value);
                    /*0x205da20*/ object GetMethodProperty(string key);
                    /*0x205e1d8*/ void SetMethodProperty(string key, object value);
                    /*0x2062260*/ System.Collections.ICollection get_Keys();
                    /*0x2062694*/ System.Collections.ICollection get_Values();
                    /*0x20620f8*/ void Add(object key, object value);
                    /*0x2062ab4*/ void Clear();
                    /*0x2062b60*/ bool Contains(object key);
                    /*0x2062ca8*/ void Remove(object key);
                    /*0x2062e30*/ int get_Count();
                    /*0x2062ef8*/ bool get_IsSynchronized();
                    /*0x2062f00*/ object get_SyncRoot();
                    /*0x2062f04*/ void CopyTo(System.Array array, int index);
                    /*0x2062fc4*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    /*0x2063108*/ System.Collections.IDictionaryEnumerator GetEnumerator();

                    class DictionaryEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
                    {
                        /*0x10*/ System.Runtime.Remoting.Messaging.MessageDictionary _methodDictionary;
                        /*0x18*/ System.Collections.IDictionaryEnumerator _hashtableEnum;
                        /*0x20*/ int _posMethod;

                        /*0x2063024*/ DictionaryEnumerator(System.Runtime.Remoting.Messaging.MessageDictionary methodDictionary);
                        /*0x2063168*/ object get_Current();
                        /*0x2063338*/ bool MoveNext();
                        /*0x20634fc*/ void Reset();
                        /*0x20631cc*/ System.Collections.DictionaryEntry get_Entry();
                        /*0x20635a8*/ object get_Key();
                        /*0x20635ac*/ object get_Value();
                    }
                }

                class MethodResponse : System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Serialization.ISerializable, System.Runtime.Remoting.Messaging.IInternalMessage, System.Runtime.Remoting.Messaging.ISerializationRootObject
                {
                    /*0x10*/ string _methodName;
                    /*0x18*/ string _uri;
                    /*0x20*/ string _typeName;
                    /*0x28*/ System.Reflection.MethodBase _methodBase;
                    /*0x30*/ object _returnValue;
                    /*0x38*/ System.Exception _exception;
                    /*0x40*/ System.Type[] _methodSignature;
                    /*0x48*/ System.Runtime.Remoting.Messaging.ArgInfo _inArgInfo;
                    /*0x50*/ object[] _args;
                    /*0x58*/ object[] _outArgs;
                    /*0x60*/ System.Runtime.Remoting.Messaging.IMethodCallMessage _callMsg;
                    /*0x68*/ System.Runtime.Remoting.Messaging.LogicalCallContext _callContext;
                    /*0x70*/ System.Runtime.Remoting.Identity _targetIdentity;
                    /*0x78*/ System.Collections.IDictionary ExternalProperties;
                    /*0x80*/ System.Collections.IDictionary InternalProperties;

                    /*0x205e7fc*/ MethodResponse(System.Runtime.Remoting.Messaging.Header[] h1, System.Runtime.Remoting.Messaging.IMethodCallMessage mcm);
                    /*0x205ec24*/ MethodResponse(System.Exception e, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    /*0x205eb4c*/ MethodResponse(object returnValue, object[] outArgs, System.Runtime.Remoting.Messaging.LogicalCallContext callCtx, System.Runtime.Remoting.Messaging.IMethodCallMessage msg);
                    /*0x2063a68*/ MethodResponse(System.Runtime.Remoting.Messaging.IMethodCallMessage msg, System.Runtime.Remoting.Messaging.CADMethodReturnMessage retmsg);
                    /*0x205ed3c*/ MethodResponse(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x20635c0*/ void InitMethodProperty(string key, object value);
                    /*0x2063cac*/ int get_ArgCount();
                    /*0x2063cc4*/ object[] get_Args();
                    /*0x2063ccc*/ System.Exception get_Exception();
                    /*0x2063cd4*/ bool get_HasVarArgs();
                    /*0x2063e0c*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x2063d00*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x2063e78*/ string get_MethodName();
                    /*0x2063fe8*/ object get_MethodSignature();
                    /*0x20640fc*/ int get_OutArgCount();
                    /*0x2064194*/ object[] get_OutArgs();
                    /*0x205edcc*/ System.Collections.IDictionary get_Properties();
                    /*0x2064334*/ object get_ReturnValue();
                    /*0x2063f30*/ string get_TypeName();
                    /*0x206433c*/ string get_Uri();
                    /*0x20643f4*/ void set_Uri(string value);
                    /*0x20643fc*/ string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
                    /*0x2064400*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
                    /*0x2064408*/ object GetArg(int argNum);
                    /*0x206443c*/ string GetArgName(int index);
                    /*0x2064494*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x2064944*/ object GetOutArg(int argNum);
                    /*0x2064a14*/ string GetOutArgName(int index);
                    /*0x2064b08*/ object HeaderHandler(System.Runtime.Remoting.Messaging.Header[] h);
                    /*0x2064b48*/ void RootSetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext ctx);
                    /*0x2064b88*/ System.Runtime.Remoting.Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
                    /*0x2064b90*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(System.Runtime.Remoting.Identity value);
                    /*0x2064b98*/ bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
                }

                class MethodReturnDictionary : System.Runtime.Remoting.Messaging.MessageDictionary
                {
                    static /*0x0*/ string[] InternalReturnKeys;
                    static /*0x8*/ string[] InternalExceptionKeys;

                    static /*0x2064bb8*/ MethodReturnDictionary();
                    /*0x2064238*/ MethodReturnDictionary(System.Runtime.Remoting.Messaging.IMethodReturnMessage message);
                }

                class MethodReturnMessageWrapper : System.Runtime.Remoting.Messaging.InternalMessageWrapper, System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage
                {
                    /*0x18*/ object[] _args;
                    /*0x20*/ System.Runtime.Remoting.Messaging.ArgInfo _outArgInfo;
                    /*0x28*/ System.Runtime.Remoting.Messaging.MethodReturnMessageWrapper.DictionaryWrapper _properties;
                    /*0x30*/ System.Exception _exception;
                    /*0x38*/ object _return;

                    /*0x2064e48*/ MethodReturnMessageWrapper(System.Runtime.Remoting.Messaging.IMethodReturnMessage msg);
                    /*0x2065164*/ int get_ArgCount();
                    /*0x2065180*/ object[] get_Args();
                    /*0x2065188*/ void set_Args(object[] value);
                    /*0x2065190*/ System.Exception get_Exception();
                    /*0x2065198*/ void set_Exception(System.Exception value);
                    /*0x20651a0*/ bool get_HasVarArgs();
                    /*0x20652a8*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x20653b0*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x20654b8*/ string get_MethodName();
                    /*0x20655c0*/ object get_MethodSignature();
                    /*0x20656c8*/ int get_OutArgCount();
                    /*0x20656e0*/ object[] get_OutArgs();
                    /*0x20656fc*/ System.Collections.IDictionary get_Properties();
                    /*0x206588c*/ object get_ReturnValue();
                    /*0x2065894*/ void set_ReturnValue(object value);
                    /*0x206589c*/ string get_TypeName();
                    /*0x20659a4*/ string get_Uri();
                    /*0x2065aac*/ void set_Uri(string value);
                    /*0x2065b88*/ object GetArg(int argNum);
                    /*0x2065bb8*/ string GetArgName(int index);
                    /*0x2065cc8*/ object GetOutArg(int argNum);
                    /*0x2065d08*/ string GetOutArgName(int index);

                    class DictionaryWrapper : System.Runtime.Remoting.Messaging.MethodReturnDictionary
                    {
                        static /*0x0*/ string[] _keys;
                        /*0x30*/ System.Collections.IDictionary _wrappedDictionary;

                        static /*0x2066044*/ DictionaryWrapper();
                        /*0x20657e8*/ DictionaryWrapper(System.Runtime.Remoting.Messaging.IMethodReturnMessage message, System.Collections.IDictionary wrappedDictionary);
                        /*0x2065d28*/ System.Collections.IDictionary AllocInternalProperties();
                        /*0x2065d30*/ void SetMethodProperty(string key, object value);
                        /*0x2065f14*/ object GetMethodProperty(string key);
                    }
                }

                class MonoMethodMessage : System.Runtime.Remoting.Messaging.IMethodCallMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IInternalMessage
                {
                    /*0x10*/ System.Reflection.RuntimeMethodInfo method;
                    /*0x18*/ object[] args;
                    /*0x20*/ string[] names;
                    /*0x28*/ byte[] arg_types;
                    /*0x30*/ System.Runtime.Remoting.Messaging.LogicalCallContext ctx;
                    /*0x38*/ object rval;
                    /*0x40*/ System.Exception exc;
                    /*0x48*/ System.Runtime.Remoting.Messaging.AsyncResult asyncResult;
                    /*0x50*/ System.Runtime.Remoting.Messaging.CallType call_type;
                    /*0x58*/ string uri;
                    /*0x60*/ System.Runtime.Remoting.Messaging.MCMDictionary properties;
                    /*0x68*/ System.Runtime.Remoting.Identity identity;
                    /*0x70*/ System.Type[] methodSignature;

                    static /*0x20665e0*/ System.Reflection.MethodInfo GetMethodInfo(System.Type type, string methodName);
                    /*0x20663e0*/ MonoMethodMessage(System.Reflection.MethodBase method, object[] out_args);
                    /*0x20664a8*/ MonoMethodMessage(System.Reflection.MethodInfo minfo, object[] in_args, object[] out_args);
                    /*0x2066694*/ MonoMethodMessage(System.Type type, string methodName, object[] in_args);
                    /*0x2066144*/ void InitMessage(System.Reflection.RuntimeMethodInfo method, object[] out_args);
                    /*0x20666cc*/ System.Collections.IDictionary get_Properties();
                    /*0x2066738*/ int get_ArgCount();
                    /*0x20667ec*/ object[] get_Args();
                    /*0x20667f4*/ bool get_HasVarArgs();
                    /*0x20667fc*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x2066804*/ void set_LogicalCallContext(System.Runtime.Remoting.Messaging.LogicalCallContext value);
                    /*0x206680c*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x2066814*/ string get_MethodName();
                    /*0x2066898*/ object get_MethodSignature();
                    /*0x20669b8*/ string get_TypeName();
                    /*0x2066a50*/ string get_Uri();
                    /*0x2066a58*/ void set_Uri(string value);
                    /*0x2066a60*/ object GetArg(int arg_num);
                    /*0x2066a94*/ string GetArgName(int arg_num);
                    /*0x2066b14*/ int get_InArgCount();
                    /*0x2066b98*/ object[] get_InArgs();
                    /*0x2066cb0*/ object GetInArg(int arg_num);
                    /*0x2066d38*/ string GetInArgName(int arg_num);
                    /*0x2066dc0*/ System.Exception get_Exception();
                    /*0x2066dc8*/ int get_OutArgCount();
                    /*0x2066e34*/ object[] get_OutArgs();
                    /*0x2066f5c*/ object get_ReturnValue();
                    /*0x2066f64*/ object GetOutArg(int arg_num);
                    /*0x2066fec*/ string GetOutArgName(int arg_num);
                    /*0x2067074*/ System.Runtime.Remoting.Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
                    /*0x206707c*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(System.Runtime.Remoting.Identity value);
                    /*0x2067084*/ bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
                    /*0x2067094*/ bool get_IsAsync();
                    /*0x20670a4*/ System.Runtime.Remoting.Messaging.AsyncResult get_AsyncResult();
                    /*0x2066770*/ System.Runtime.Remoting.Messaging.CallType get_CallType();
                    /*0x20670ac*/ bool NeedsOutProcessing(ref int outCount);
                }

                enum CallType
                {
                    Sync = 0,
                    BeginInvoke = 1,
                    EndInvoke = 2,
                    OneWay = 3,
                }

                class OneWayAttribute : System.Attribute
                {
                    /*0x206713c*/ OneWayAttribute();
                }

                class RemotingSurrogate : System.Runtime.Serialization.ISerializationSurrogate
                {
                    /*0x206729c*/ RemotingSurrogate();
                    /*0x2067144*/ void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc);
                    /*0x206725c*/ object SetObjectData(object obj, System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc, System.Runtime.Serialization.ISurrogateSelector selector);
                }

                class ObjRefSurrogate : System.Runtime.Serialization.ISerializationSurrogate
                {
                    /*0x2067400*/ ObjRefSurrogate();
                    /*0x20672a4*/ void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc);
                    /*0x20673b0*/ object SetObjectData(object obj, System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc, System.Runtime.Serialization.ISurrogateSelector selector);
                }

                class RemotingSurrogateSelector : System.Runtime.Serialization.ISurrogateSelector
                {
                    static /*0x0*/ System.Type s_cachedTypeObjRef;
                    static /*0x8*/ System.Runtime.Remoting.Messaging.ObjRefSurrogate _objRefSurrogate;
                    static /*0x10*/ System.Runtime.Remoting.Messaging.RemotingSurrogate _objRemotingSurrogate;
                    /*0x10*/ object _rootObj;
                    /*0x18*/ System.Runtime.Remoting.Messaging.MessageSurrogateFilter _filter;
                    /*0x20*/ System.Runtime.Serialization.ISurrogateSelector _next;

                    static /*0x206770c*/ RemotingSurrogateSelector();
                    /*0x2067408*/ RemotingSurrogateSelector();
                    /*0x2067410*/ System.Runtime.Remoting.Messaging.MessageSurrogateFilter get_Filter();
                    /*0x2067418*/ void set_Filter(System.Runtime.Remoting.Messaging.MessageSurrogateFilter value);
                    /*0x2067420*/ void ChainSelector(System.Runtime.Serialization.ISurrogateSelector selector);
                    /*0x20674d4*/ System.Runtime.Serialization.ISurrogateSelector GetNextSelector();
                    /*0x20674dc*/ object GetRootObject();
                    /*0x20674e4*/ System.Runtime.Serialization.ISerializationSurrogate GetSurrogate(System.Type type, System.Runtime.Serialization.StreamingContext context, ref System.Runtime.Serialization.ISurrogateSelector ssout);
                    /*0x206767c*/ void SetRootObject(object obj);
                    /*0x20676cc*/ void UseSoapFormat();
                }

                class ReturnMessage : System.Runtime.Remoting.Messaging.IMethodReturnMessage, System.Runtime.Remoting.Messaging.IMethodMessage, System.Runtime.Remoting.Messaging.IMessage, System.Runtime.Remoting.Messaging.IInternalMessage
                {
                    /*0x10*/ object[] _outArgs;
                    /*0x18*/ object[] _args;
                    /*0x20*/ System.Runtime.Remoting.Messaging.LogicalCallContext _callCtx;
                    /*0x28*/ object _returnValue;
                    /*0x30*/ string _uri;
                    /*0x38*/ System.Exception _exception;
                    /*0x40*/ System.Reflection.MethodBase _methodBase;
                    /*0x48*/ string _methodName;
                    /*0x50*/ System.Type[] _methodSignature;
                    /*0x58*/ string _typeName;
                    /*0x60*/ System.Runtime.Remoting.Messaging.MethodReturnDictionary _properties;
                    /*0x68*/ System.Runtime.Remoting.Identity _targetIdentity;
                    /*0x70*/ System.Runtime.Remoting.Messaging.ArgInfo _inArgInfo;

                    /*0x2067810*/ ReturnMessage(object ret, object[] outArgs, int outArgsCount, System.Runtime.Remoting.Messaging.LogicalCallContext callCtx, System.Runtime.Remoting.Messaging.IMethodCallMessage mcm);
                    /*0x2067978*/ ReturnMessage(System.Exception e, System.Runtime.Remoting.Messaging.IMethodCallMessage mcm);
                    /*0x2067ac0*/ int get_ArgCount();
                    /*0x2067adc*/ object[] get_Args();
                    /*0x2067ae4*/ bool get_HasVarArgs();
                    /*0x2067b30*/ System.Runtime.Remoting.Messaging.LogicalCallContext get_LogicalCallContext();
                    /*0x2067b9c*/ System.Reflection.MethodBase get_MethodBase();
                    /*0x2067ba4*/ string get_MethodName();
                    /*0x2067bf8*/ object get_MethodSignature();
                    /*0x2067d28*/ System.Collections.IDictionary get_Properties();
                    /*0x2067d94*/ string get_TypeName();
                    /*0x2067dfc*/ string get_Uri();
                    /*0x2067e04*/ void set_Uri(string value);
                    /*0x2067e0c*/ string System.Runtime.Remoting.Messaging.IInternalMessage.get_Uri();
                    /*0x2067e14*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_Uri(string value);
                    /*0x2067e1c*/ object GetArg(int argNum);
                    /*0x2067e4c*/ string GetArgName(int index);
                    /*0x2067ea4*/ System.Exception get_Exception();
                    /*0x2067eac*/ int get_OutArgCount();
                    /*0x2067f38*/ object[] get_OutArgs();
                    /*0x2067fd0*/ object get_ReturnValue();
                    /*0x2067fd8*/ object GetOutArg(int argNum);
                    /*0x2068080*/ string GetOutArgName(int index);
                    /*0x206810c*/ System.Runtime.Remoting.Identity System.Runtime.Remoting.Messaging.IInternalMessage.get_TargetIdentity();
                    /*0x2068114*/ void System.Runtime.Remoting.Messaging.IInternalMessage.set_TargetIdentity(System.Runtime.Remoting.Identity value);
                    /*0x206811c*/ bool System.Runtime.Remoting.Messaging.IInternalMessage.HasProperties();
                    /*0x206812c*/ bool HasProperties();
                }

                class ServerContextTerminatorSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x2068360*/ ServerContextTerminatorSink();
                    /*0x206813c*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x2068270*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x2068358*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                }

                class ServerObjectTerminatorSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _nextSink;

                    /*0x2068368*/ ServerObjectTerminatorSink(System.Runtime.Remoting.Messaging.IMessageSink nextSink);
                    /*0x2068390*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x2068504*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x20686fc*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                }

                class ServerObjectReplySink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.Runtime.Remoting.Messaging.IMessageSink _replySink;
                    /*0x18*/ System.Runtime.Remoting.ServerIdentity _identity;

                    /*0x20686d0*/ ServerObjectReplySink(System.Runtime.Remoting.ServerIdentity identity, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x2068704*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x20687cc*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x206880c*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                }

                class StackBuilderSink : System.Runtime.Remoting.Messaging.IMessageSink
                {
                    /*0x10*/ System.MarshalByRefObject _target;
                    /*0x18*/ System.Runtime.Remoting.Proxies.RealProxy _rp;

                    /*0x2068814*/ StackBuilderSink(System.MarshalByRefObject obj, bool forceInternalExecute);
                    /*0x20688b8*/ System.Runtime.Remoting.Messaging.IMessage SyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x2068ddc*/ System.Runtime.Remoting.Messaging.IMessageCtrl AsyncProcessMessage(System.Runtime.Remoting.Messaging.IMessage msg, System.Runtime.Remoting.Messaging.IMessageSink replySink);
                    /*0x2068efc*/ void ExecuteAsyncMessage(object ob);
                    /*0x20690fc*/ System.Runtime.Remoting.Messaging.IMessageSink get_NextSink();
                    /*0x2068984*/ void CheckParameters(System.Runtime.Remoting.Messaging.IMessage msg);
                    /*0x2069104*/ void <AsyncProcessMessage>b__4_0(object data);
                }
            }
        }

        namespace Versioning
        {
            class NonVersionableAttribute : System.Attribute
            {
                /*0x2069184*/ NonVersionableAttribute();
            }

            class TargetFrameworkAttribute : System.Attribute
            {
                /*0x10*/ string _frameworkName;
                /*0x18*/ string _frameworkDisplayName;

                /*0x206918c*/ TargetFrameworkAttribute(string frameworkName);
                /*0x2069204*/ string get_FrameworkName();
                /*0x206920c*/ string get_FrameworkDisplayName();
                /*0x2069214*/ void set_FrameworkDisplayName(string value);
            }

            class MultitargetingHelpers
            {
                static /*0x206921c*/ string GetAssemblyQualifiedName(System.Type type, System.Func<System.Type, string> converter);
                static /*0x20693e0*/ bool IsCriticalException(System.Exception ex);
                static /*0x206935c*/ bool IsSecurityOrCriticalException(System.Exception ex);
            }

            class ComponentGuaranteesAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.Versioning.ComponentGuaranteesOptions <Guarantees>k__BackingField;

                /*0x2069518*/ ComponentGuaranteesAttribute(System.Runtime.Versioning.ComponentGuaranteesOptions guarantees);
                /*0x2069510*/ System.Runtime.Versioning.ComponentGuaranteesOptions get_Guarantees();
            }

            enum ComponentGuaranteesOptions
            {
                None = 0,
                Exchange = 1,
                Stable = 2,
                SideBySide = 4,
            }

            class ResourceConsumptionAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.Versioning.ResourceScope _consumptionScope;
                /*0x14*/ System.Runtime.Versioning.ResourceScope _resourceScope;

                /*0x2069540*/ ResourceConsumptionAttribute(System.Runtime.Versioning.ResourceScope resourceScope);
                /*0x2069568*/ ResourceConsumptionAttribute(System.Runtime.Versioning.ResourceScope resourceScope, System.Runtime.Versioning.ResourceScope consumptionScope);
                /*0x2069594*/ System.Runtime.Versioning.ResourceScope get_ResourceScope();
                /*0x206959c*/ System.Runtime.Versioning.ResourceScope get_ConsumptionScope();
            }

            class ResourceExposureAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.Versioning.ResourceScope _resourceExposureLevel;

                /*0x20695a4*/ ResourceExposureAttribute(System.Runtime.Versioning.ResourceScope exposureLevel);
                /*0x20695cc*/ System.Runtime.Versioning.ResourceScope get_ResourceExposureLevel();
            }

            enum ResourceScope
            {
                None = 0,
                Machine = 1,
                Process = 2,
                AppDomain = 4,
                Library = 8,
                Private = 16,
                Assembly = 32,
            }

            enum SxSRequirements
            {
                None = 0,
                AppDomainID = 1,
                ProcessID = 2,
                CLRInstanceID = 4,
                AssemblyName = 8,
                TypeName = 16,
            }

            class VersioningHelper
            {
                static System.Runtime.Versioning.ResourceScope ResTypeMask = 15;
                static System.Runtime.Versioning.ResourceScope VisibilityMask = 48;

                static /*0x20695d4*/ int GetRuntimeId();
                static /*0x20695d8*/ string MakeVersionSafeName(string name, System.Runtime.Versioning.ResourceScope from, System.Runtime.Versioning.ResourceScope to);
                static /*0x20695e0*/ string MakeVersionSafeName(string name, System.Runtime.Versioning.ResourceScope from, System.Runtime.Versioning.ResourceScope to, System.Type type);
                static /*0x2069c8c*/ string GetCLRInstanceString();
                static /*0x206999c*/ System.Runtime.Versioning.SxSRequirements GetRequirements(System.Runtime.Versioning.ResourceScope consumeAsScope, System.Runtime.Versioning.ResourceScope calleeScope);
            }

            enum TargetFrameworkId
            {
                NotYetChecked = 0,
                Unrecognized = 1,
                Unspecified = 2,
                NetFramework = 3,
                Portable = 4,
                NetCore = 5,
                Silverlight = 6,
                Phone = 7,
            }

            class BinaryCompatibility
            {
                static /*0x0*/ bool TargetsAtLeast_Desktop_V4_5;
                static /*0x1*/ bool TargetsAtLeast_Desktop_V4_5_1;

                static /*0x2069d04*/ BinaryCompatibility();
                static /*0x2069cfc*/ bool get_TargetsAtLeast_Desktop_V4_5_2();
            }

            class CompatibilitySwitch
            {
                static /*0x2069d50*/ bool IsEnabled(string compatibilitySwitchName);
                static /*0x2069d58*/ string GetValue(string compatibilitySwitchName);
                static /*0x2069d60*/ string GetValueInternal(string compatibilitySwitchName);
            }
        }

        namespace Serialization
        {
            interface IDeserializationCallback
            {
                void OnDeserialization(object sender);
            }

            interface IFormatterConverter
            {
                object Convert(object value, System.Type type);
                object Convert(object value, System.TypeCode typeCode);
                bool ToBoolean(object value);
                char ToChar(object value);
                sbyte ToSByte(object value);
                byte ToByte(object value);
                short ToInt16(object value);
                ushort ToUInt16(object value);
                int ToInt32(object value);
                uint ToUInt32(object value);
                long ToInt64(object value);
                ulong ToUInt64(object value);
                float ToSingle(object value);
                double ToDouble(object value);
                decimal ToDecimal(object value);
                System.DateTime ToDateTime(object value);
                string ToString(object value);
            }

            interface IObjectReference
            {
                object GetRealObject(System.Runtime.Serialization.StreamingContext context);
            }

            interface ISerializable
            {
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class SerializationException : System.SystemException
            {
                static /*0x0*/ string s_nullMessage;

                static /*0x2069e2c*/ SerializationException();
                /*0x2069d68*/ SerializationException();
                /*0x2069ddc*/ SerializationException(string message);
                /*0x2069e00*/ SerializationException(string message, System.Exception innerException);
                /*0x2069e24*/ SerializationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            struct SerializationEntry
            {
                /*0x10*/ string _name;
                /*0x18*/ object _value;
                /*0x20*/ System.Type _type;

                /*0x2069e8c*/ SerializationEntry(string entryName, object entryValue, System.Type entryType);
                /*0x2069e98*/ object get_Value();
                /*0x2069ea0*/ string get_Name();
                /*0x2069ea8*/ System.Type get_ObjectType();
            }

            class SerializationInfoEnumerator : System.Collections.IEnumerator
            {
                /*0x10*/ string[] _members;
                /*0x18*/ object[] _data;
                /*0x20*/ System.Type[] _types;
                /*0x28*/ int _numItems;
                /*0x2c*/ int _currItem;
                /*0x30*/ bool _current;

                /*0x2069eb0*/ SerializationInfoEnumerator(string[] members, object[] info, System.Type[] types, int numItems);
                /*0x206a118*/ SerializationInfoEnumerator();
                /*0x205fc38*/ bool MoveNext();
                /*0x2069f00*/ object System.Collections.IEnumerator.get_Current();
                /*0x205fb70*/ System.Runtime.Serialization.SerializationEntry get_Current();
                /*0x2069f70*/ void Reset();
                /*0x2069f80*/ string get_Name();
                /*0x206a008*/ object get_Value();
                /*0x206a090*/ System.Type get_ObjectType();
            }

            class DeserializationEventHandler : System.MulticastDelegate
            {
                /*0x206a150*/ DeserializationEventHandler(object object, nint method);
                /*0x206a27c*/ void Invoke(object sender);
                /*0x206a290*/ System.IAsyncResult BeginInvoke(object sender, System.AsyncCallback callback, object object);
                /*0x206a2b0*/ void EndInvoke(System.IAsyncResult result);
            }

            class SerializationEventHandler : System.MulticastDelegate
            {
                /*0x206a2bc*/ SerializationEventHandler(object object, nint method);
                /*0x206a380*/ void Invoke(System.Runtime.Serialization.StreamingContext context);
                /*0x206a394*/ System.IAsyncResult BeginInvoke(System.Runtime.Serialization.StreamingContext context, System.AsyncCallback callback, object object);
                /*0x206a418*/ void EndInvoke(System.IAsyncResult result);
            }

            class Formatter : System.Runtime.Serialization.IFormatter
            {
                /*0x10*/ System.Runtime.Serialization.ObjectIDGenerator m_idGenerator;
                /*0x18*/ System.Collections.Queue m_objectQueue;

                /*0x206a424*/ Formatter();
                object Deserialize(System.IO.Stream serializationStream);
                /*0x206a594*/ object GetNext(ref long objID);
                /*0x206a66c*/ long Schedule(object obj);
                void Serialize(System.IO.Stream serializationStream, object graph);
                void WriteArray(object obj, string name, System.Type memberType);
                void WriteBoolean(bool val, string name);
                void WriteByte(byte val, string name);
                void WriteChar(char val, string name);
                void WriteDateTime(System.DateTime val, string name);
                void WriteDecimal(decimal val, string name);
                void WriteDouble(double val, string name);
                void WriteInt16(short val, string name);
                void WriteInt32(int val, string name);
                void WriteInt64(long val, string name);
                void WriteObjectRef(object obj, string name, System.Type memberType);
                /*0x206a6e8*/ void WriteMember(string memberName, object data);
                void WriteSByte(sbyte val, string name);
                void WriteSingle(float val, string name);
                void WriteTimeSpan(System.TimeSpan val, string name);
                void WriteUInt16(ushort val, string name);
                void WriteUInt32(uint val, string name);
                void WriteUInt64(ulong val, string name);
                void WriteValueType(object obj, string name, System.Type memberType);
                System.Runtime.Serialization.ISurrogateSelector get_SurrogateSelector();
                void set_SurrogateSelector(System.Runtime.Serialization.ISurrogateSelector value);
                System.Runtime.Serialization.SerializationBinder get_Binder();
                void set_Binder(System.Runtime.Serialization.SerializationBinder value);
                System.Runtime.Serialization.StreamingContext get_Context();
                void set_Context(System.Runtime.Serialization.StreamingContext value);
            }

            class FormatterConverter : System.Runtime.Serialization.IFormatterConverter
            {
                static /*0x206b1c0*/ void ThrowValueNullException();
                /*0x206bb98*/ FormatterConverter();
                /*0x206b120*/ object Convert(object value, System.Type type);
                /*0x206b210*/ object Convert(object value, System.TypeCode typeCode);
                /*0x206b2b0*/ bool ToBoolean(object value);
                /*0x206b348*/ char ToChar(object value);
                /*0x206b3e0*/ sbyte ToSByte(object value);
                /*0x206b478*/ byte ToByte(object value);
                /*0x206b510*/ short ToInt16(object value);
                /*0x206b5a8*/ ushort ToUInt16(object value);
                /*0x206b640*/ int ToInt32(object value);
                /*0x206b6d8*/ uint ToUInt32(object value);
                /*0x206b770*/ long ToInt64(object value);
                /*0x206b808*/ ulong ToUInt64(object value);
                /*0x206b8a0*/ float ToSingle(object value);
                /*0x206b938*/ double ToDouble(object value);
                /*0x206b9d0*/ decimal ToDecimal(object value);
                /*0x206ba68*/ System.DateTime ToDateTime(object value);
                /*0x206bb00*/ string ToString(object value);
            }

            interface ISerializationSurrogate
            {
                void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                object SetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ISurrogateSelector selector);
            }

            interface ISurrogateSelector
            {
                void ChainSelector(System.Runtime.Serialization.ISurrogateSelector selector);
                System.Runtime.Serialization.ISerializationSurrogate GetSurrogate(System.Type type, System.Runtime.Serialization.StreamingContext context, ref System.Runtime.Serialization.ISurrogateSelector selector);
                System.Runtime.Serialization.ISurrogateSelector GetNextSelector();
            }

            class MemberHolder
            {
                /*0x10*/ System.Reflection.MemberInfo[] _members;
                /*0x18*/ System.Type _memberType;
                /*0x20*/ System.Runtime.Serialization.StreamingContext _context;

                /*0x206bba0*/ MemberHolder(System.Type type, System.Runtime.Serialization.StreamingContext ctx);
                /*0x206bbdc*/ int GetHashCode();
                /*0x206bbfc*/ bool Equals(object obj);
            }

            class SerializationBinder
            {
                /*0x206bc94*/ SerializationBinder();
                /*0x206bc88*/ void BindToName(System.Type serializedType, ref string assemblyName, ref string typeName);
                System.Type BindToType(string assemblyName, string typeName);
            }

            class SerializationEvents
            {
                /*0x10*/ System.Collections.Generic.List<System.Reflection.MethodInfo> _onSerializingMethods;
                /*0x18*/ System.Collections.Generic.List<System.Reflection.MethodInfo> _onSerializedMethods;
                /*0x20*/ System.Collections.Generic.List<System.Reflection.MethodInfo> _onDeserializingMethods;
                /*0x28*/ System.Collections.Generic.List<System.Reflection.MethodInfo> _onDeserializedMethods;

                static /*0x206c08c*/ void InvokeOnDelegate(object obj, System.Runtime.Serialization.StreamingContext context, System.Collections.Generic.List<System.Reflection.MethodInfo> methods);
                static /*0x206c198*/ System.Runtime.Serialization.SerializationEventHandler AddOnDelegate(object obj, System.Runtime.Serialization.SerializationEventHandler handler, System.Collections.Generic.List<System.Reflection.MethodInfo> methods);
                /*0x206bc9c*/ SerializationEvents(System.Type t);
                /*0x206bdd0*/ System.Collections.Generic.List<System.Reflection.MethodInfo> GetMethodsWithAttribute(System.Type attribute, System.Type t);
                /*0x206c018*/ bool get_HasOnSerializingEvents();
                /*0x206c038*/ void InvokeOnSerializing(object obj, System.Runtime.Serialization.StreamingContext context);
                /*0x206c0dc*/ void InvokeOnDeserializing(object obj, System.Runtime.Serialization.StreamingContext context);
                /*0x206c130*/ void InvokeOnDeserialized(object obj, System.Runtime.Serialization.StreamingContext context);
                /*0x206c184*/ System.Runtime.Serialization.SerializationEventHandler AddOnSerialized(object obj, System.Runtime.Serialization.SerializationEventHandler handler);
                /*0x206c3d4*/ System.Runtime.Serialization.SerializationEventHandler AddOnDeserialized(object obj, System.Runtime.Serialization.SerializationEventHandler handler);
            }

            class SerializationEventsCache
            {
                static /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary<System.Type, System.Runtime.Serialization.SerializationEvents> s_cache;

                static /*0x206c51c*/ SerializationEventsCache();
                static /*0x206c3e8*/ System.Runtime.Serialization.SerializationEvents GetSerializationEventsForType(System.Type t);

                class <>c
                {
                    static /*0x0*/ System.Runtime.Serialization.SerializationEventsCache.<> <>9;
                    static /*0x8*/ System.Func<System.Type, System.Runtime.Serialization.SerializationEvents> <>9__1_0;

                    static /*0x206c5a8*/ <>c();
                    /*0x206c60c*/ <>c();
                    /*0x206c614*/ System.Runtime.Serialization.SerializationEvents <GetSerializationEventsForType>b__1_0(System.Type type);
                }
            }

            class SerializationObjectManager
            {
                /*0x10*/ System.Collections.Generic.Dictionary<object, object> _objectSeenTable;
                /*0x18*/ System.Runtime.Serialization.StreamingContext _context;
                /*0x28*/ System.Runtime.Serialization.SerializationEventHandler _onSerializedHandler;

                /*0x206c674*/ SerializationObjectManager(System.Runtime.Serialization.StreamingContext context);
                /*0x206c708*/ void RegisterObject(object obj);
                /*0x206c8a8*/ void RaiseOnSerializedEvent();
                /*0x206c818*/ void AddOnSerialized(object obj);
            }

            class ValueTypeFixupInfo
            {
                /*0x10*/ long _containerID;
                /*0x18*/ System.Reflection.FieldInfo _parentField;
                /*0x20*/ int[] _parentIndex;

                /*0x206c8c8*/ ValueTypeFixupInfo(long containerID, System.Reflection.FieldInfo member, int[] parentIndex);
                /*0x206ca18*/ long get_ContainerID();
                /*0x206ca20*/ System.Reflection.FieldInfo get_ParentField();
                /*0x206ca28*/ int[] get_ParentIndex();
            }

            class FormatterServices
            {
                static /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary<System.Runtime.Serialization.MemberHolder, System.Reflection.MemberInfo[]> m_MemberInfoTable;
                static /*0x8*/ bool unsafeTypeForwardersIsEnabled;
                static /*0x9*/ bool unsafeTypeForwardersIsEnabledInitialized;
                static /*0x10*/ System.Type[] advancedTypes;
                static /*0x18*/ System.Reflection.Binder s_binder;

                static /*0x206ca30*/ FormatterServices();
                static /*0x206cbac*/ System.Reflection.MemberInfo[] GetSerializableMembers(System.RuntimeType type);
                static /*0x206cd44*/ bool CheckSerializable(System.RuntimeType type);
                static /*0x206cd64*/ System.Reflection.MemberInfo[] InternalGetSerializableMembers(System.RuntimeType type);
                static /*0x206d470*/ bool GetParentTypes(System.RuntimeType parentType, ref System.RuntimeType[] parentTypes, ref int parentTypeCount);
                static /*0x206d880*/ System.Reflection.MemberInfo[] GetSerializableMembers(System.Type type);
                static /*0x206d8f8*/ System.Reflection.MemberInfo[] GetSerializableMembers(System.Type type, System.Runtime.Serialization.StreamingContext context);
                static /*0x206db98*/ void CheckTypeSecurity(System.Type t, System.Runtime.Serialization.Formatters.TypeFilterLevel securityLevel);
                static /*0x206ddb0*/ object GetUninitializedObject(System.Type type);
                static /*0x206df84*/ object GetSafeUninitializedObject(System.Type type);
                static /*0x206df7c*/ object nativeGetUninitializedObject(System.RuntimeType type);
                static /*0x206e280*/ object nativeGetSafeUninitializedObject(System.RuntimeType type);
                static /*0x206e288*/ bool GetEnableUnsafeTypeForwarders();
                static /*0x206e290*/ bool UnsafeTypeForwardersIsEnabled();
                static /*0x206e338*/ void SerializationSetValue(System.Reflection.MemberInfo fi, object target, object value);
                static /*0x206e520*/ object PopulateObjectMembers(object obj, System.Reflection.MemberInfo[] members, object[] data);
                static /*0x206e838*/ object[] GetObjectData(object obj, System.Reflection.MemberInfo[] members);
                static /*0x206ebac*/ System.Runtime.Serialization.ISerializationSurrogate GetSurrogateForCyclicalReference(System.Runtime.Serialization.ISerializationSurrogate innerSurrogate);
                static /*0x206ecd4*/ System.Type GetTypeFromAssembly(System.Reflection.Assembly assem, string name);
                static /*0x206ed70*/ System.Reflection.Assembly LoadAssemblyFromString(string assemblyName);
                static /*0x206ed78*/ System.Reflection.Assembly LoadAssemblyFromStringNoThrow(string assemblyName);
                static /*0x206ee4c*/ string GetClrAssemblyName(System.Type type, ref bool hasTypeForwardedFrom);
                static /*0x206efbc*/ string GetClrTypeFullName(System.Type type);
                static /*0x206f03c*/ string GetClrTypeFullNameForArray(System.Type type);
                static /*0x206f260*/ string GetClrTypeFullNameForNonArrayTypes(System.Type type);

                class <>c__DisplayClass9_0
                {
                    /*0x10*/ System.Type type;

                    /*0x206db90*/ <>c__DisplayClass9_0();
                    /*0x206f4d4*/ System.Reflection.MemberInfo[] <GetSerializableMembers>b__0(System.Runtime.Serialization.MemberHolder _);
                }
            }

            class SurrogateForCyclicalReference : System.Runtime.Serialization.ISerializationSurrogate
            {
                /*0x10*/ System.Runtime.Serialization.ISerializationSurrogate innerSurrogate;

                /*0x206ec5c*/ SurrogateForCyclicalReference(System.Runtime.Serialization.ISerializationSurrogate innerSurrogate);
                /*0x206f580*/ void GetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x206f650*/ object SetObjectData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ISurrogateSelector selector);
            }

            interface IFormatter
            {
                object Deserialize(System.IO.Stream serializationStream);
                void Serialize(System.IO.Stream serializationStream, object graph);
                System.Runtime.Serialization.ISurrogateSelector get_SurrogateSelector();
                void set_SurrogateSelector(System.Runtime.Serialization.ISurrogateSelector value);
                System.Runtime.Serialization.SerializationBinder get_Binder();
                void set_Binder(System.Runtime.Serialization.SerializationBinder value);
                System.Runtime.Serialization.StreamingContext get_Context();
                void set_Context(System.Runtime.Serialization.StreamingContext value);
            }

            class ObjectIDGenerator
            {
                static int numbins = 4;
                static /*0x0*/ int[] sizes;
                /*0x10*/ int m_currentCount;
                /*0x14*/ int m_currentSize;
                /*0x18*/ long[] m_ids;
                /*0x20*/ object[] m_objs;

                static /*0x206fcfc*/ ObjectIDGenerator();
                /*0x206a4bc*/ ObjectIDGenerator();
                /*0x206f72c*/ int FindElement(object obj, ref bool found);
                /*0x206f7f0*/ long GetId(object obj, ref bool firstTime);
                /*0x206fc28*/ long HasId(object obj, ref bool firstTime);
                /*0x206f974*/ void Rehash();
            }

            class ObjectManager
            {
                static int DefaultInitialSize = 16;
                static int MaxArraySize = 4096;
                static int ArrayMask = 4095;
                static int MaxReferenceDepth = 100;
                /*0x10*/ System.Runtime.Serialization.DeserializationEventHandler m_onDeserializationHandler;
                /*0x18*/ System.Runtime.Serialization.SerializationEventHandler m_onDeserializedHandler;
                /*0x20*/ System.Runtime.Serialization.ObjectHolder[] m_objects;
                /*0x28*/ object m_topObject;
                /*0x30*/ System.Runtime.Serialization.ObjectHolderList m_specialFixupObjects;
                /*0x38*/ long m_fixupCount;
                /*0x40*/ System.Runtime.Serialization.ISurrogateSelector m_selector;
                /*0x48*/ System.Runtime.Serialization.StreamingContext m_context;

                static /*0x206fea0*/ ObjectManager();
                static /*0x207292c*/ System.Reflection.RuntimeConstructorInfo GetConstructor(System.RuntimeType t);
                /*0x206fd90*/ ObjectManager(System.Runtime.Serialization.ISurrogateSelector selector, System.Runtime.Serialization.StreamingContext context);
                /*0x206fd9c*/ ObjectManager(System.Runtime.Serialization.ISurrogateSelector selector, System.Runtime.Serialization.StreamingContext context, bool checkSecurity, bool isCrossAppDomain);
                /*0x206fe1c*/ bool CanCallGetType(object obj);
                /*0x206fe24*/ void set_TopObject(object value);
                /*0x206fe2c*/ object get_TopObject();
                /*0x206fe34*/ System.Runtime.Serialization.ObjectHolderList get_SpecialFixupObjects();
                /*0x206fea4*/ System.Runtime.Serialization.ObjectHolder FindObjectHolder(long objectID);
                /*0x206fefc*/ System.Runtime.Serialization.ObjectHolder FindOrCreateObjectHolder(long objectID);
                /*0x206ffd4*/ void AddObjectHolder(System.Runtime.Serialization.ObjectHolder holder);
                /*0x2070100*/ bool GetCompletionInfo(System.Runtime.Serialization.FixupHolder fixup, ref System.Runtime.Serialization.ObjectHolder holder, ref object member, bool bThrowIfMissing);
                /*0x2070408*/ void FixupSpecialObject(System.Runtime.Serialization.ObjectHolder holder);
                /*0x2071204*/ bool ResolveObjectReference(System.Runtime.Serialization.ObjectHolder holder);
                /*0x2070bbc*/ bool DoValueTypeFixup(System.Reflection.FieldInfo memberToFix, System.Runtime.Serialization.ObjectHolder holder, object value);
                /*0x20714a8*/ void DumpValueTypeFixup(object obj, System.Reflection.FieldInfo[] intermediateFields, System.Reflection.FieldInfo memberToFix, object value);
                /*0x207166c*/ void CompleteObject(System.Runtime.Serialization.ObjectHolder holder, bool bObjectFullyComplete);
                /*0x207111c*/ void DoNewlyRegisteredObjectFixups(System.Runtime.Serialization.ObjectHolder holder);
                /*0x2071d18*/ object GetObject(long objectID);
                /*0x2071dcc*/ void RegisterObject(object obj, long objectID);
                /*0x2071de8*/ void RegisterObject(object obj, long objectID, System.Runtime.Serialization.SerializationInfo info);
                /*0x2071de0*/ void RegisterObject(object obj, long objectID, System.Runtime.Serialization.SerializationInfo info, long idOfContainingObj, System.Reflection.MemberInfo member);
                /*0x20723c0*/ void RegisterString(string obj, long objectID, System.Runtime.Serialization.SerializationInfo info, long idOfContainingObj, System.Reflection.MemberInfo member);
                /*0x2071df8*/ void RegisterObject(object obj, long objectID, System.Runtime.Serialization.SerializationInfo info, long idOfContainingObj, System.Reflection.MemberInfo member, int[] arrayIndex);
                /*0x20708a4*/ void CompleteISerializableObject(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2072a64*/ void DoFixups();
                /*0x2072d90*/ void RegisterFixup(System.Runtime.Serialization.FixupHolder fixup, long objectToBeFixed, long objectRequired);
                /*0x2072fa4*/ void RecordFixup(long objectToBeFixed, System.Reflection.MemberInfo member, long objectRequired);
                /*0x2073244*/ void RecordDelayedFixup(long objectToBeFixed, string memberName, long objectRequired);
                /*0x20733ac*/ void RecordArrayElementFixup(long arrayToBeFixed, int index, long objectRequired);
                /*0x2073444*/ void RecordArrayElementFixup(long arrayToBeFixed, int[] indices, long objectRequired);
                /*0x20735ac*/ void RaiseDeserializationEvent();
                /*0x20735f8*/ void AddOnDeserialization(System.Runtime.Serialization.DeserializationEventHandler handler);
                /*0x2073678*/ void RemoveOnDeserialization(System.Runtime.Serialization.DeserializationEventHandler handler);
                /*0x20736f8*/ void AddOnDeserialized(object obj);
                /*0x2073788*/ void RaiseOnDeserializedEvent(object obj);
                /*0x207380c*/ void RaiseOnDeserializingEvent(object obj);
            }

            class ObjectHolder
            {
                static int INCOMPLETE_OBJECT_REFERENCE = 1;
                static int HAS_ISERIALIZABLE = 2;
                static int HAS_SURROGATE = 4;
                static int REQUIRES_VALUETYPE_FIXUP = 8;
                static int REQUIRES_DELAYED_FIXUP = 7;
                static int SER_INFO_FIXED = 16384;
                static int VALUETYPE_FIXUP_PERFORMED = 32768;
                /*0x10*/ object m_object;
                /*0x18*/ long m_id;
                /*0x20*/ int m_missingElementsRemaining;
                /*0x24*/ int m_missingDecendents;
                /*0x28*/ System.Runtime.Serialization.SerializationInfo m_serInfo;
                /*0x30*/ System.Runtime.Serialization.ISerializationSurrogate m_surrogate;
                /*0x38*/ System.Runtime.Serialization.FixupHolderList m_missingElements;
                /*0x40*/ System.Runtime.Serialization.LongList m_dependentObjects;
                /*0x48*/ System.Runtime.Serialization.ObjectHolder m_next;
                /*0x50*/ int m_flags;
                /*0x54*/ bool m_markForFixupWhenAvailable;
                /*0x58*/ System.Runtime.Serialization.ValueTypeFixupInfo m_valueFixup;
                /*0x60*/ System.Runtime.Serialization.TypeLoadExceptionHolder m_typeLoad;
                /*0x68*/ bool m_reachable;

                /*0x206ffa0*/ ObjectHolder(long objID);
                /*0x20725a4*/ ObjectHolder(object obj, long objID, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.ISerializationSurrogate surrogate, long idOfContainingObj, System.Reflection.FieldInfo field, int[] arrayIndex);
                /*0x20724c0*/ ObjectHolder(string obj, long objID, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.ISerializationSurrogate surrogate, long idOfContainingObj, System.Reflection.FieldInfo field, int[] arrayIndex);
                /*0x2073890*/ void IncrementDescendentFixups(int amount);
                /*0x2071ca8*/ void DecrementFixupsRemaining(System.Runtime.Serialization.ObjectManager manager);
                /*0x2071ccc*/ void RemoveDependency(long id);
                /*0x2072e70*/ void AddFixup(System.Runtime.Serialization.FixupHolder fixup, System.Runtime.Serialization.ObjectManager manager);
                /*0x20738a0*/ void UpdateDescendentDependencyChain(int amount, System.Runtime.Serialization.ObjectManager manager);
                /*0x2072f2c*/ void AddDependency(long dependentObject);
                /*0x2072790*/ void UpdateData(object obj, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.ISerializationSurrogate surrogate, long idOfContainer, System.Reflection.FieldInfo field, int[] arrayIndex, System.Runtime.Serialization.ObjectManager manager);
                /*0x2071d0c*/ void MarkForCompletionWhenAvailable();
                /*0x20707ec*/ void SetFlags();
                /*0x20703fc*/ bool get_IsIncompleteObjectReference();
                /*0x207148c*/ void set_IsIncompleteObjectReference(bool value);
                /*0x2072780*/ bool get_RequiresDelayedFixup();
                /*0x2070b78*/ bool get_RequiresValueTypeFixup();
                /*0x2070b84*/ bool get_ValueTypeFixupPerformed();
                /*0x2071cf8*/ void set_ValueTypeFixupPerformed(bool value);
                /*0x2071c9c*/ bool get_HasISerializable();
                /*0x2070640*/ bool get_HasSurrogate();
                /*0x207064c*/ bool get_CanSurrogatedObjectValueChange();
                /*0x20703dc*/ bool get_CanObjectValueChange();
                /*0x2073918*/ int get_DirectlyDependentObjects();
                /*0x2072920*/ int get_TotalDependentObjects();
                /*0x2073920*/ bool get_Reachable();
                /*0x2073928*/ void set_Reachable(bool value);
                /*0x2071ce8*/ bool get_TypeLoadExceptionReachable();
                /*0x2073934*/ System.Runtime.Serialization.TypeLoadExceptionHolder get_TypeLoadException();
                /*0x207393c*/ void set_TypeLoadException(System.Runtime.Serialization.TypeLoadExceptionHolder value);
                /*0x2073944*/ object get_ObjectValue();
                /*0x20706f4*/ void SetObjectValue(object obj, System.Runtime.Serialization.ObjectManager manager);
                /*0x207394c*/ System.Runtime.Serialization.SerializationInfo get_SerializationInfo();
                /*0x2073954*/ void set_SerializationInfo(System.Runtime.Serialization.SerializationInfo value);
                /*0x207395c*/ System.Runtime.Serialization.ISerializationSurrogate get_Surrogate();
                /*0x2073964*/ System.Runtime.Serialization.LongList get_DependentObjects();
                /*0x207396c*/ void set_DependentObjects(System.Runtime.Serialization.LongList value);
                /*0x2072d74*/ bool get_RequiresSerInfoFixup();
                /*0x2070b5c*/ void set_RequiresSerInfoFixup(bool value);
                /*0x2073974*/ System.Runtime.Serialization.ValueTypeFixupInfo get_ValueFixup();
                /*0x20703b8*/ bool get_CompletelyFixed();
                /*0x2073900*/ long get_ContainerID();
            }

            class FixupHolder
            {
                static int ArrayFixup = 1;
                static int MemberFixup = 2;
                static int DelayedFixup = 4;
                /*0x10*/ long m_id;
                /*0x18*/ object m_fixupInfo;
                /*0x20*/ int m_fixupType;

                /*0x207497c*/ FixupHolder(long id, object fixupInfo, int fixupType);
            }

            class FixupHolderList
            {
                static int InitialSize = 2;
                /*0x10*/ System.Runtime.Serialization.FixupHolder[] m_values;
                /*0x18*/ int m_count;

                /*0x20749b8*/ FixupHolderList();
                /*0x20749c0*/ FixupHolderList(int startingSize);
                /*0x2074a2c*/ void Add(long id, object fixupInfo);
                /*0x2074b30*/ void Add(System.Runtime.Serialization.FixupHolder fixup);
                /*0x2074aa8*/ void EnlargeArray();
            }

            class LongList
            {
                static int InitialSize = 2;
                /*0x10*/ long[] m_values;
                /*0x18*/ int m_count;
                /*0x1c*/ int m_totalItems;
                /*0x20*/ int m_currentItem;

                /*0x2074bd8*/ LongList();
                /*0x2074be0*/ LongList(int startingSize);
                /*0x2074c4c*/ void Add(long value);
                /*0x2074d54*/ int get_Count();
                /*0x2074d5c*/ void StartEnumeration();
                /*0x2074d68*/ bool MoveNext();
                /*0x2074dd0*/ long get_Current();
                /*0x2074e04*/ bool RemoveElement(long value);
                /*0x2074ccc*/ void EnlargeArray();
            }

            class ObjectHolderList
            {
                static int DefaultInitialSize = 8;
                /*0x10*/ System.Runtime.Serialization.ObjectHolder[] m_values;
                /*0x18*/ int m_count;

                /*0x2074e94*/ ObjectHolderList();
                /*0x2074e9c*/ ObjectHolderList(int startingSize);
                /*0x2074f08*/ void Add(System.Runtime.Serialization.ObjectHolder value);
                /*0x2075038*/ System.Runtime.Serialization.ObjectHolderListEnumerator GetFixupEnumerator();
                /*0x2074fb0*/ void EnlargeArray();
                /*0x20750e4*/ int get_Version();
                /*0x20750ec*/ int get_Count();
            }

            class ObjectHolderListEnumerator
            {
                /*0x10*/ bool m_isFixupEnumerator;
                /*0x18*/ System.Runtime.Serialization.ObjectHolderList m_list;
                /*0x20*/ int m_startingVersion;
                /*0x24*/ int m_currPos;

                /*0x207509c*/ ObjectHolderListEnumerator(System.Runtime.Serialization.ObjectHolderList list, bool isFixupEnumerator);
                /*0x20750f4*/ bool MoveNext();
                /*0x2075198*/ System.Runtime.Serialization.ObjectHolder get_Current();
            }

            class TypeLoadExceptionHolder
            {
                /*0x10*/ string m_typeName;

                /*0x20751d4*/ TypeLoadExceptionHolder(string typeName);
                /*0x20751fc*/ string get_TypeName();
            }

            class SafeSerializationEventArgs : System.EventArgs
            {
                /*0x10*/ System.Runtime.Serialization.StreamingContext m_streamingContext;
                /*0x20*/ System.Collections.Generic.List<object> m_serializedStates;

                /*0x2075204*/ SafeSerializationEventArgs(System.Runtime.Serialization.StreamingContext streamingContext);
                /*0x2075510*/ SafeSerializationEventArgs();
                /*0x20752bc*/ void AddSerializedState(System.Runtime.Serialization.ISafeSerializationData serializedState);
                /*0x20754fc*/ System.Collections.Generic.IList<object> get_SerializedStates();
                /*0x2075504*/ System.Runtime.Serialization.StreamingContext get_StreamingContext();
            }

            interface ISafeSerializationData
            {
                void CompleteDeserialization(object deserialized);
            }

            class SafeSerializationManager : System.Runtime.Serialization.IObjectReference, System.Runtime.Serialization.ISerializable
            {
                static string RealTypeSerializationName = "CLR_SafeSerializationManager_RealType";
                /*0x10*/ System.Collections.Generic.IList<object> m_serializedStates;
                /*0x18*/ System.Runtime.Serialization.SerializationInfo m_savedSerializationInfo;
                /*0x20*/ object m_realObject;
                /*0x28*/ System.RuntimeType m_realType;
                /*0x30*/ System.EventHandler<System.Runtime.Serialization.SafeSerializationEventArgs> SerializeObjectState;

                /*0x20756a8*/ SafeSerializationManager();
                /*0x20756b0*/ SafeSerializationManager(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2075548*/ void add_SerializeObjectState(System.EventHandler<System.Runtime.Serialization.SafeSerializationEventArgs> value);
                /*0x20755f8*/ void remove_SerializeObjectState(System.EventHandler<System.Runtime.Serialization.SafeSerializationEventArgs> value);
                /*0x2075bb0*/ bool get_IsActive();
                /*0x2075bc0*/ void CompleteSerialization(object serializedObject, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2075efc*/ void CompleteDeserialization(object deserializedObject);
                /*0x207629c*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x207634c*/ object System.Runtime.Serialization.IObjectReference.GetRealObject(System.Runtime.Serialization.StreamingContext context);
                /*0x2076638*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext context);
            }

            class OptionalFieldAttribute : System.Attribute
            {
                /*0x10*/ int versionAdded;

                /*0x20766dc*/ OptionalFieldAttribute();
                /*0x20766ec*/ int get_VersionAdded();
                /*0x20766f4*/ void set_VersionAdded(int value);
            }

            class OnSerializingAttribute : System.Attribute
            {
                /*0x207676c*/ OnSerializingAttribute();
            }

            class OnSerializedAttribute : System.Attribute
            {
                /*0x2076774*/ OnSerializedAttribute();
            }

            class OnDeserializingAttribute : System.Attribute
            {
                /*0x207677c*/ OnDeserializingAttribute();
            }

            class OnDeserializedAttribute : System.Attribute
            {
                /*0x2076784*/ OnDeserializedAttribute();
            }

            class SerializationFieldInfo : System.Reflection.FieldInfo
            {
                static string FakeNameSeparatorString = "+";
                /*0x10*/ System.Reflection.RuntimeFieldInfo m_field;
                /*0x18*/ string m_serializationName;

                /*0x20767d4*/ SerializationFieldInfo(System.Reflection.RuntimeFieldInfo field, string namePrefix);
                /*0x207678c*/ System.Reflection.Module get_Module();
                /*0x20767b0*/ int get_MetadataToken();
                /*0x2076868*/ string get_Name();
                /*0x2076870*/ System.Type get_DeclaringType();
                /*0x2076894*/ System.Type get_ReflectedType();
                /*0x20768b8*/ object[] GetCustomAttributes(bool inherit);
                /*0x20768e0*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x2076908*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x2076930*/ System.Type get_FieldType();
                /*0x2076954*/ object GetValue(object obj);
                /*0x2076978*/ object InternalGetValue(object obj);
                /*0x20769f8*/ void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
                /*0x2076a1c*/ void InternalSetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
                /*0x2076acc*/ System.Reflection.RuntimeFieldInfo get_FieldInfo();
                /*0x2076ad4*/ System.RuntimeFieldHandle get_FieldHandle();
                /*0x2076af8*/ System.Reflection.FieldAttributes get_Attributes();
            }

            class SerializationInfo
            {
                static int defaultSize = 4;
                static string s_mscorlibAssemblySimpleName = "mscorlib";
                static string s_mscorlibFileName = "mscorlib.dll";
                /*0x10*/ string[] m_members;
                /*0x18*/ object[] m_data;
                /*0x20*/ System.Type[] m_types;
                /*0x28*/ System.Collections.Generic.Dictionary<string, int> m_nameToIndex;
                /*0x30*/ int m_currMember;
                /*0x38*/ System.Runtime.Serialization.IFormatterConverter m_converter;
                /*0x40*/ string m_fullTypeName;
                /*0x48*/ string m_assemName;
                /*0x50*/ System.Type objectType;
                /*0x58*/ bool isFullTypeNameSetExplicit;
                /*0x59*/ bool isAssemblyNameSetExplicit;
                /*0x5a*/ bool requireSameTokenInPartialTrust;

                static /*0x2076e10*/ bool Compare(byte[] a, byte[] b);
                static /*0x2076e0c*/ void DemandForUnsafeAssemblyNameAssignments(string originalAssemblyName, string newAssemblyName);
                static /*0x2076e98*/ bool IsAssemblyNameAssignmentSafe(string originalAssemblyName, string newAssemblyName);
                /*0x2076b1c*/ SerializationInfo(System.Type type, System.Runtime.Serialization.IFormatterConverter converter);
                /*0x2076b24*/ SerializationInfo(System.Type type, System.Runtime.Serialization.IFormatterConverter converter, bool requireSameTokenInPartialTrust);
                /*0x2076d08*/ string get_FullTypeName();
                /*0x2076d10*/ void set_FullTypeName(string value);
                /*0x2076d78*/ string get_AssemblyName();
                /*0x2076d80*/ void set_AssemblyName(string value);
                /*0x2075db8*/ void SetType(System.Type type);
                /*0x2076fcc*/ int get_MemberCount();
                /*0x2076fd4*/ System.Type get_ObjectType();
                /*0x2076fdc*/ bool get_IsFullTypeNameSetExplicit();
                /*0x2076fe4*/ bool get_IsAssemblyNameSetExplicit();
                /*0x2076fec*/ System.Runtime.Serialization.SerializationInfoEnumerator GetEnumerator();
                /*0x2077070*/ void ExpandArrays();
                /*0x2075d34*/ void AddValue(string name, object value, System.Type type);
                /*0x207735c*/ void AddValue(string name, object value);
                /*0x2077414*/ void AddValue(string name, bool value);
                /*0x20774e8*/ void AddValue(string name, char value);
                /*0x20775bc*/ void AddValue(string name, sbyte value);
                /*0x2077690*/ void AddValue(string name, byte value);
                /*0x2077764*/ void AddValue(string name, short value);
                /*0x2077838*/ void AddValue(string name, ushort value);
                /*0x207790c*/ void AddValue(string name, int value);
                /*0x20779e0*/ void AddValue(string name, uint value);
                /*0x2077ab4*/ void AddValue(string name, long value);
                /*0x2077b88*/ void AddValue(string name, ulong value);
                /*0x2077c5c*/ void AddValue(string name, float value);
                /*0x2077d38*/ void AddValue(string name, double value);
                /*0x2077e14*/ void AddValue(string name, decimal value);
                /*0x2077f14*/ void AddValue(string name, System.DateTime value);
                /*0x207717c*/ void AddValueInternal(string name, object value, System.Type type);
                /*0x2077fe8*/ void UpdateValue(string name, object value, System.Type type);
                /*0x20780cc*/ int FindElement(string name);
                /*0x2078194*/ object GetElement(string name, ref System.Type foundType);
                /*0x207829c*/ object GetElementNoThrow(string name, ref System.Type foundType);
                /*0x207599c*/ object GetValue(string name, System.Type type);
                /*0x2075894*/ object GetValueNoThrow(string name, System.Type type);
                /*0x2078318*/ bool GetBoolean(string name);
                /*0x2078498*/ char GetChar(string name);
                /*0x207860c*/ sbyte GetSByte(string name);
                /*0x2078780*/ byte GetByte(string name);
                /*0x20788f4*/ short GetInt16(string name);
                /*0x2078a68*/ ushort GetUInt16(string name);
                /*0x2078bdc*/ int GetInt32(string name);
                /*0x2078d50*/ uint GetUInt32(string name);
                /*0x2078ec4*/ long GetInt64(string name);
                /*0x2079038*/ ulong GetUInt64(string name);
                /*0x20791ac*/ float GetSingle(string name);
                /*0x2079320*/ double GetDouble(string name);
                /*0x2079494*/ decimal GetDecimal(string name);
                /*0x2079610*/ System.DateTime GetDateTime(string name);
                /*0x2079784*/ string GetString(string name);
                /*0x20798f0*/ string[] get_MemberNames();
                /*0x20798f8*/ object[] get_MemberValues();
            }

            struct StreamingContext
            {
                /*0x10*/ object m_additionalContext;
                /*0x18*/ System.Runtime.Serialization.StreamingContextStates m_state;

                /*0x2079900*/ StreamingContext(System.Runtime.Serialization.StreamingContextStates state);
                /*0x207990c*/ StreamingContext(System.Runtime.Serialization.StreamingContextStates state, object additional);
                /*0x2079918*/ object get_Context();
                /*0x2079920*/ bool Equals(object obj);
                /*0x20799d0*/ int GetHashCode();
                /*0x20799d8*/ System.Runtime.Serialization.StreamingContextStates get_State();
            }

            enum StreamingContextStates
            {
                CrossProcess = 1,
                CrossMachine = 2,
                File = 4,
                Persistence = 8,
                Remoting = 16,
                Other = 32,
                Clone = 64,
                CrossAppDomain = 128,
                All = 255,
            }

            class SurrogateSelector : System.Runtime.Serialization.ISurrogateSelector
            {
                /*0x10*/ System.Runtime.Serialization.SurrogateHashtable m_surrogates;
                /*0x18*/ System.Runtime.Serialization.ISurrogateSelector m_nextSelector;

                static /*0x2079be0*/ bool HasCycle(System.Runtime.Serialization.ISurrogateSelector selector);
                /*0x20799e0*/ SurrogateSelector();
                /*0x2079a58*/ void AddSurrogate(System.Type type, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ISerializationSurrogate surrogate);
                /*0x2079d70*/ void ChainSelector(System.Runtime.Serialization.ISurrogateSelector selector);
                /*0x207a1dc*/ System.Runtime.Serialization.ISurrogateSelector GetNextSelector();
                /*0x207a1e4*/ System.Runtime.Serialization.ISerializationSurrogate GetSurrogate(System.Type type, System.Runtime.Serialization.StreamingContext context, ref System.Runtime.Serialization.ISurrogateSelector selector);
                /*0x207a3e4*/ void RemoveSurrogate(System.Type type, System.Runtime.Serialization.StreamingContext context);
            }

            class SurrogateKey
            {
                /*0x10*/ System.Type m_type;
                /*0x18*/ System.Runtime.Serialization.StreamingContext m_context;

                /*0x2079ba4*/ SurrogateKey(System.Type type, System.Runtime.Serialization.StreamingContext context);
                /*0x207a500*/ int GetHashCode();
            }

            class SurrogateHashtable : System.Collections.Hashtable
            {
                /*0x2079a50*/ SurrogateHashtable(int size);
                /*0x207a520*/ bool KeyEquals(object key, object item);
            }

            namespace Formatters
            {
                enum FormatterTypeStyle
                {
                    TypesWhenNeeded = 0,
                    TypesAlways = 1,
                    XsdString = 2,
                }

                enum FormatterAssemblyStyle
                {
                    Simple = 0,
                    Full = 1,
                }

                enum TypeFilterLevel
                {
                    Low = 2,
                    Full = 3,
                }

                interface IFieldInfo
                {
                    string[] get_FieldNames();
                    void set_FieldNames(string[] value);
                    System.Type[] get_FieldTypes();
                    void set_FieldTypes(System.Type[] value);
                }

                interface ISoapMessage
                {
                    string[] get_ParamNames();
                    void set_ParamNames(string[] value);
                    object[] get_ParamValues();
                    void set_ParamValues(object[] value);
                    System.Type[] get_ParamTypes();
                    void set_ParamTypes(System.Type[] value);
                    string get_MethodName();
                    void set_MethodName(string value);
                    string get_XmlNameSpace();
                    void set_XmlNameSpace(string value);
                    System.Runtime.Remoting.Messaging.Header[] get_Headers();
                    void set_Headers(System.Runtime.Remoting.Messaging.Header[] value);
                }

                class InternalRM
                {
                    static /*0x207a648*/ void InfoSoap(object[] messages);
                    static /*0x207a64c*/ bool SoapCheckEnabled();
                    /*0x207a690*/ InternalRM();
                }

                class InternalST
                {
                    static /*0x207a6a0*/ void InfoSoap(object[] messages);
                    static /*0x207a6a4*/ bool SoapCheckEnabled();
                    static /*0x207a6e8*/ void Soap(object[] messages);
                    static /*0x207a7cc*/ void SoapAssert(bool condition, string message);
                    static /*0x207a7d0*/ void SerializationSetValue(System.Reflection.FieldInfo fi, object target, object value);
                    static /*0x207a8f0*/ System.Reflection.Assembly LoadAssemblyFromString(string assemblyString);
                    /*0x207a698*/ InternalST();
                }

                class SerTrace
                {
                    static /*0x207a948*/ void InfoLog(object[] messages);
                    static /*0x207a94c*/ void Log(object[] messages);
                }

                class SoapFault : System.Runtime.Serialization.ISerializable
                {
                    /*0x10*/ string faultCode;
                    /*0x18*/ string faultString;
                    /*0x20*/ string faultActor;
                    /*0x28*/ object detail;

                    /*0x207aa30*/ SoapFault();
                    /*0x207aa38*/ SoapFault(string faultCode, string faultString, string faultActor, System.Runtime.Serialization.Formatters.ServerFault serverFault);
                    /*0x207aa78*/ SoapFault(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x207ad40*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                    /*0x207ae84*/ string get_FaultCode();
                    /*0x207ae8c*/ void set_FaultCode(string value);
                    /*0x207ae94*/ string get_FaultString();
                    /*0x207ae9c*/ void set_FaultString(string value);
                    /*0x207aea4*/ string get_FaultActor();
                    /*0x207aeac*/ void set_FaultActor(string value);
                    /*0x207aeb4*/ object get_Detail();
                    /*0x207aebc*/ void set_Detail(object value);
                }

                class ServerFault
                {
                    /*0x10*/ string exceptionType;
                    /*0x18*/ string message;
                    /*0x20*/ string stackTrace;
                    /*0x28*/ System.Exception exception;

                    /*0x207aec4*/ ServerFault(System.Exception exception);
                    /*0x207aeec*/ ServerFault(string exceptionType, string message, string stackTrace);
                    /*0x207af28*/ string get_ExceptionType();
                    /*0x207af30*/ void set_ExceptionType(string value);
                    /*0x207af38*/ string get_ExceptionMessage();
                    /*0x207af40*/ void set_ExceptionMessage(string value);
                    /*0x207af48*/ string get_StackTrace();
                    /*0x207af50*/ void set_StackTrace(string value);
                    /*0x207af58*/ System.Exception get_Exception();
                }

                class SoapMessage : System.Runtime.Serialization.Formatters.ISoapMessage
                {
                    /*0x10*/ string[] paramNames;
                    /*0x18*/ object[] paramValues;
                    /*0x20*/ System.Type[] paramTypes;
                    /*0x28*/ string methodName;
                    /*0x30*/ string xmlNameSpace;
                    /*0x38*/ System.Runtime.Remoting.Messaging.Header[] headers;

                    /*0x207afc0*/ SoapMessage();
                    /*0x207af60*/ string[] get_ParamNames();
                    /*0x207af68*/ void set_ParamNames(string[] value);
                    /*0x207af70*/ object[] get_ParamValues();
                    /*0x207af78*/ void set_ParamValues(object[] value);
                    /*0x207af80*/ System.Type[] get_ParamTypes();
                    /*0x207af88*/ void set_ParamTypes(System.Type[] value);
                    /*0x207af90*/ string get_MethodName();
                    /*0x207af98*/ void set_MethodName(string value);
                    /*0x207afa0*/ string get_XmlNameSpace();
                    /*0x207afa8*/ void set_XmlNameSpace(string value);
                    /*0x207afb0*/ System.Runtime.Remoting.Messaging.Header[] get_Headers();
                    /*0x207afb8*/ void set_Headers(System.Runtime.Remoting.Messaging.Header[] value);
                }

                namespace Binary
                {
                    enum BinaryHeaderEnum
                    {
                        SerializedStreamHeader = 0,
                        Object = 1,
                        ObjectWithMap = 2,
                        ObjectWithMapAssemId = 3,
                        ObjectWithMapTyped = 4,
                        ObjectWithMapTypedAssemId = 5,
                        ObjectString = 6,
                        Array = 7,
                        MemberPrimitiveTyped = 8,
                        MemberReference = 9,
                        ObjectNull = 10,
                        MessageEnd = 11,
                        Assembly = 12,
                        ObjectNullMultiple256 = 13,
                        ObjectNullMultiple = 14,
                        ArraySinglePrimitive = 15,
                        ArraySingleObject = 16,
                        ArraySingleString = 17,
                        CrossAppDomainMap = 18,
                        CrossAppDomainString = 19,
                        CrossAppDomainAssembly = 20,
                        MethodCall = 21,
                        MethodReturn = 22,
                    }

                    enum BinaryTypeEnum
                    {
                        Primitive = 0,
                        String = 1,
                        Object = 2,
                        ObjectUrt = 3,
                        ObjectUser = 4,
                        ObjectArray = 5,
                        StringArray = 6,
                        PrimitiveArray = 7,
                    }

                    enum BinaryArrayTypeEnum
                    {
                        Single = 0,
                        Jagged = 1,
                        Rectangular = 2,
                        SingleOffset = 3,
                        JaggedOffset = 4,
                        RectangularOffset = 5,
                    }

                    enum InternalSerializerTypeE
                    {
                        Soap = 1,
                        Binary = 2,
                    }

                    enum InternalParseTypeE
                    {
                        Empty = 0,
                        SerializedStreamHeader = 1,
                        Object = 2,
                        Member = 3,
                        ObjectEnd = 4,
                        MemberEnd = 5,
                        Headers = 6,
                        HeadersEnd = 7,
                        SerializedStreamHeaderEnd = 8,
                        Envelope = 9,
                        EnvelopeEnd = 10,
                        Body = 11,
                        BodyEnd = 12,
                    }

                    enum InternalObjectTypeE
                    {
                        Empty = 0,
                        Object = 1,
                        Array = 2,
                    }

                    enum InternalObjectPositionE
                    {
                        Empty = 0,
                        Top = 1,
                        Child = 2,
                        Headers = 3,
                    }

                    enum InternalArrayTypeE
                    {
                        Empty = 0,
                        Single = 1,
                        Jagged = 2,
                        Rectangular = 3,
                        Base64 = 4,
                    }

                    enum InternalMemberTypeE
                    {
                        Empty = 0,
                        Header = 1,
                        Field = 2,
                        Item = 3,
                    }

                    enum InternalMemberValueE
                    {
                        Empty = 0,
                        InlineValue = 1,
                        Nested = 2,
                        Reference = 3,
                        Null = 4,
                    }

                    enum InternalPrimitiveTypeE
                    {
                        Invalid = 0,
                        Boolean = 1,
                        Byte = 2,
                        Char = 3,
                        Currency = 4,
                        Decimal = 5,
                        Double = 6,
                        Int16 = 7,
                        Int32 = 8,
                        Int64 = 9,
                        SByte = 10,
                        Single = 11,
                        TimeSpan = 12,
                        DateTime = 13,
                        UInt16 = 14,
                        UInt32 = 15,
                        UInt64 = 16,
                        Null = 17,
                        String = 18,
                    }

                    enum ValueFixupEnum
                    {
                        Empty = 0,
                        Array = 1,
                        Header = 2,
                        Member = 3,
                    }

                    enum InternalNameSpaceE
                    {
                        None = 0,
                        Soap = 1,
                        XdrPrimitive = 2,
                        XdrString = 3,
                        UrtSystem = 4,
                        UrtUser = 5,
                        UserNameSpace = 6,
                        MemberName = 7,
                        Interop = 8,
                        CallElement = 9,
                    }

                    class BinaryConverter
                    {
                        static /*0x207afc8*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum GetBinaryTypeInfo(System.Type type, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, string typeName, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, ref object typeInformation, ref int assemId);
                        static /*0x207b5a0*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum GetParserBinaryTypeInfo(System.Type type, ref object typeInformation);
                        static /*0x207b894*/ void WriteTypeInfo(System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum, object typeInformation, int assemId, System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        static /*0x207bb30*/ object ReadTypeInfo(System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum, System.Runtime.Serialization.Formatters.Binary.__BinaryParser input, ref int assemId);
                        static /*0x207bcdc*/ void TypeFromInfo(System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum, object typeInformation, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo, ref System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE primitiveTypeEnum, ref string typeString, ref System.Type type, ref bool isVariant);
                    }

                    class IOUtil
                    {
                        static /*0x207c3d0*/ bool FlagTest(System.Runtime.Serialization.Formatters.Binary.MessageEnum flag, System.Runtime.Serialization.Formatters.Binary.MessageEnum target);
                        static /*0x207c3dc*/ void WriteStringWithCode(string value, System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        static /*0x207c458*/ void WriteWithCode(System.Type type, object value, System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        static /*0x207cbfc*/ object ReadWithCode(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        static /*0x207cc58*/ object[] ReadArgs(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                    }

                    class BinaryUtil
                    {
                        static /*0x207cd40*/ void NVTraceI(string name, string value);
                        static /*0x207cd84*/ void NVTraceI(string name, object value);
                    }

                    interface IStreamable
                    {
                        void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                    }

                    class BinaryAssemblyInfo
                    {
                        /*0x10*/ string assemblyString;
                        /*0x18*/ System.Reflection.Assembly assembly;

                        /*0x207cdc8*/ BinaryAssemblyInfo(string assemblyString);
                        /*0x207cdf0*/ BinaryAssemblyInfo(string assemblyString, System.Reflection.Assembly assembly);
                        /*0x207ce1c*/ System.Reflection.Assembly GetAssembly();
                    }

                    class SerializationHeaderRecord : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int binaryFormatterMajorVersion;
                        /*0x14*/ int binaryFormatterMinorVersion;
                        /*0x18*/ System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum;
                        /*0x1c*/ int topId;
                        /*0x20*/ int headerId;
                        /*0x24*/ int majorVersion;
                        /*0x28*/ int minorVersion;

                        static /*0x207d05c*/ int GetInt32(byte[] buffer, int index);
                        /*0x207cf40*/ SerializationHeaderRecord();
                        /*0x207cf50*/ SerializationHeaderRecord(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum, int topId, int headerId, int majorVersion, int minorVersion);
                        /*0x207cfa8*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207d0d0*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207d238*/ void Dump();
                        /*0x207d23c*/ void DumpInternal();
                    }

                    class BinaryAssembly : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int assemId;
                        /*0x18*/ string assemblyString;

                        /*0x207d280*/ BinaryAssembly();
                        /*0x207d288*/ void Set(int assemId, string assemblyString);
                        /*0x207d294*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207d308*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207d34c*/ void Dump();
                        /*0x207d350*/ void DumpInternal();
                    }

                    class BinaryCrossAppDomainAssembly : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int assemId;
                        /*0x14*/ int assemblyIndex;

                        /*0x207d394*/ BinaryCrossAppDomainAssembly();
                        /*0x207d39c*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207d410*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207d454*/ void Dump();
                        /*0x207d458*/ void DumpInternal();
                    }

                    class BinaryObject : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int objectId;
                        /*0x14*/ int mapId;

                        /*0x207d49c*/ BinaryObject();
                        /*0x207d4a4*/ void Set(int objectId, int mapId);
                        /*0x207d4ac*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207d520*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207d564*/ void Dump();
                        /*0x207d568*/ void DumpInternal();
                    }

                    class BinaryMethodCall
                    {
                        /*0x10*/ string methodName;
                        /*0x18*/ string typeName;
                        /*0x20*/ object[] args;
                        /*0x28*/ object callContext;
                        /*0x30*/ System.Type[] argTypes;
                        /*0x38*/ bool bArgsPrimitive;
                        /*0x3c*/ System.Runtime.Serialization.Formatters.Binary.MessageEnum messageEnum;
                        /*0x40*/ object[] callA;

                        /*0x207dc80*/ BinaryMethodCall();
                        /*0x207d5ac*/ object[] WriteArray(string uri, string methodName, string typeName, System.Type[] instArgs, object[] args, object methodSignature, object callContext, object[] properties);
                        /*0x207d9d4*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207db20*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207dbf8*/ void Dump();
                        /*0x207dbfc*/ void DumpInternal();
                    }

                    class BinaryMethodReturn : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        static /*0x0*/ object instanceOfVoid;
                        /*0x10*/ object returnValue;
                        /*0x18*/ object[] args;
                        /*0x20*/ object callContext;
                        /*0x28*/ System.Type[] argTypes;
                        /*0x30*/ bool bArgsPrimitive;
                        /*0x34*/ System.Runtime.Serialization.Formatters.Binary.MessageEnum messageEnum;
                        /*0x38*/ object[] callA;
                        /*0x40*/ System.Type returnType;

                        static /*0x207dc90*/ BinaryMethodReturn();
                        /*0x207dd3c*/ BinaryMethodReturn();
                        /*0x207dd4c*/ object[] WriteArray(object returnValue, object[] args, System.Exception exception, object callContext, object[] properties);
                        /*0x207e23c*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207e388*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207e43c*/ void Dump();
                        /*0x207e440*/ void DumpInternal();
                    }

                    class BinaryObjectString : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int objectId;
                        /*0x18*/ string value;

                        /*0x207e4c4*/ BinaryObjectString();
                        /*0x207e4cc*/ void Set(int objectId, string value);
                        /*0x207e4d8*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207e54c*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207e590*/ void Dump();
                        /*0x207e594*/ void DumpInternal();
                    }

                    class BinaryCrossAppDomainString : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int objectId;
                        /*0x14*/ int value;

                        /*0x207e5d8*/ BinaryCrossAppDomainString();
                        /*0x207e5e0*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207e654*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207e698*/ void Dump();
                        /*0x207e69c*/ void DumpInternal();
                    }

                    class BinaryCrossAppDomainMap : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int crossAppDomainArrayIndex;

                        /*0x207e6e0*/ BinaryCrossAppDomainMap();
                        /*0x207e6e8*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207e740*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207e768*/ void Dump();
                        /*0x207e76c*/ void DumpInternal();
                    }

                    class MemberPrimitiveTyped : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE primitiveTypeEnum;
                        /*0x18*/ object value;

                        /*0x207e7b0*/ MemberPrimitiveTyped();
                        /*0x207e7b8*/ void Set(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE primitiveTypeEnum, object value);
                        /*0x207e7c4*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207e82c*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207e874*/ void Dump();
                        /*0x207e878*/ void DumpInternal();
                    }

                    class BinaryObjectWithMap : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum;
                        /*0x14*/ int objectId;
                        /*0x18*/ string name;
                        /*0x20*/ int numMembers;
                        /*0x28*/ string[] memberNames;
                        /*0x30*/ int assemId;

                        /*0x207e8bc*/ BinaryObjectWithMap();
                        /*0x207e8c4*/ BinaryObjectWithMap(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x207e8ec*/ void Set(int objectId, string name, int numMembers, string[] memberNames, int assemId);
                        /*0x207e910*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207ea28*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207eb64*/ void Dump();
                        /*0x207eb68*/ void DumpInternal();
                    }

                    class BinaryObjectWithMapTyped : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum;
                        /*0x14*/ int objectId;
                        /*0x18*/ string name;
                        /*0x20*/ int numMembers;
                        /*0x28*/ string[] memberNames;
                        /*0x30*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA;
                        /*0x38*/ object[] typeInformationA;
                        /*0x40*/ int[] memberAssemIds;
                        /*0x48*/ int assemId;

                        /*0x207ebac*/ BinaryObjectWithMapTyped();
                        /*0x207ebb4*/ BinaryObjectWithMapTyped(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x207ebdc*/ void Set(int objectId, string name, int numMembers, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA, object[] typeInformationA, int[] memberAssemIds, int assemId);
                        /*0x207ec08*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207ede8*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                    }

                    class BinaryArray : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int objectId;
                        /*0x14*/ int rank;
                        /*0x18*/ int[] lengthA;
                        /*0x20*/ int[] lowerBoundA;
                        /*0x28*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum;
                        /*0x30*/ object typeInformation;
                        /*0x38*/ int assemId;
                        /*0x3c*/ System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.BinaryArrayTypeEnum binaryArrayTypeEnum;

                        /*0x207f08c*/ BinaryArray();
                        /*0x207f094*/ BinaryArray(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x207f0bc*/ void Set(int objectId, int rank, int[] lengthA, int[] lowerBoundA, System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum, object typeInformation, System.Runtime.Serialization.Formatters.Binary.BinaryArrayTypeEnum binaryArrayTypeEnum, int assemId);
                        /*0x207f110*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207f400*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                    }

                    class MemberPrimitiveUnTyped : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE typeInformation;
                        /*0x18*/ object value;

                        /*0x207f700*/ MemberPrimitiveUnTyped();
                        /*0x207f708*/ void Set(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE typeInformation, object value);
                        /*0x207f714*/ void Set(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE typeInformation);
                        /*0x207f71c*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207f740*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207f770*/ void Dump();
                        /*0x207f774*/ void DumpInternal();
                    }

                    class MemberReference : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int idRef;

                        /*0x207f7fc*/ MemberReference();
                        /*0x207f804*/ void Set(int idRef);
                        /*0x207f80c*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207f864*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207f88c*/ void Dump();
                        /*0x207f890*/ void DumpInternal();
                    }

                    class ObjectNull : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x10*/ int nullCount;

                        /*0x207f8d4*/ ObjectNull();
                        /*0x207f8dc*/ void SetNullCount(int nullCount);
                        /*0x207f8e4*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207f99c*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207f9a8*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input, System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x207fa08*/ void Dump();
                        /*0x207fa0c*/ void DumpInternal();
                    }

                    class MessageEnd : System.Runtime.Serialization.Formatters.Binary.IStreamable
                    {
                        /*0x207fa50*/ MessageEnd();
                        /*0x207fa58*/ void Write(System.Runtime.Serialization.Formatters.Binary.__BinaryWriter sout);
                        /*0x207fa84*/ void Read(System.Runtime.Serialization.Formatters.Binary.__BinaryParser input);
                        /*0x207fa88*/ void Dump();
                        /*0x207fa8c*/ void Dump(System.IO.Stream sout);
                        /*0x207fa90*/ void DumpInternal(System.IO.Stream sout);
                    }

                    class ObjectMap
                    {
                        /*0x10*/ string objectName;
                        /*0x18*/ System.Type objectType;
                        /*0x20*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA;
                        /*0x28*/ object[] typeInformationA;
                        /*0x30*/ System.Type[] memberTypes;
                        /*0x38*/ string[] memberNames;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo objectInfo;
                        /*0x48*/ bool isInitObjectInfo;
                        /*0x50*/ System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader;
                        /*0x58*/ int objectId;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo;

                        static /*0x2080604*/ System.Runtime.Serialization.Formatters.Binary.ObjectMap Create(string name, System.Type objectType, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, int objectId, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo);
                        static /*0x20806a4*/ System.Runtime.Serialization.Formatters.Binary.ObjectMap Create(string name, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA, object[] typeInformationA, int[] memberAssemIds, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, int objectId, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo, System.Runtime.Serialization.Formatters.Binary.SizedArray assemIdToAssemblyTable);
                        /*0x207fb14*/ ObjectMap(string objectName, System.Type objectType, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, int objectId, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo);
                        /*0x20801cc*/ ObjectMap(string objectName, string[] memberNames, System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA, object[] typeInformationA, int[] memberAssemIds, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader, int objectId, System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo, System.Runtime.Serialization.Formatters.Binary.SizedArray assemIdToAssemblyTable);
                        /*0x20804ec*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo CreateObjectInfo(ref System.Runtime.Serialization.SerializationInfo si, ref object[] memberData);
                    }

                    class ObjectProgress
                    {
                        static /*0x0*/ int opRecordIdCount;
                        /*0x10*/ int opRecordId;
                        /*0x14*/ bool isInitial;
                        /*0x18*/ int count;
                        /*0x1c*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum expectedType;
                        /*0x20*/ object expectedTypeInformation;
                        /*0x28*/ string name;
                        /*0x30*/ System.Runtime.Serialization.Formatters.Binary.InternalObjectTypeE objectTypeEnum;
                        /*0x34*/ System.Runtime.Serialization.Formatters.Binary.InternalMemberTypeE memberTypeEnum;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.InternalMemberValueE memberValueEnum;
                        /*0x40*/ System.Type dtType;
                        /*0x48*/ int numItems;
                        /*0x4c*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum binaryTypeEnum;
                        /*0x50*/ object typeInformation;
                        /*0x58*/ int nullCount;
                        /*0x5c*/ int memberLength;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum[] binaryTypeEnumA;
                        /*0x68*/ object[] typeInformationA;
                        /*0x70*/ string[] memberNames;
                        /*0x78*/ System.Type[] memberTypes;
                        /*0x80*/ System.Runtime.Serialization.Formatters.Binary.ParseRecord pr;

                        static /*0x2080a7c*/ ObjectProgress();
                        /*0x2080768*/ ObjectProgress();
                        /*0x20807d8*/ void Counter();
                        /*0x2080908*/ void Init();
                        /*0x2080958*/ void ArrayCountIncrement(int value);
                        /*0x2080968*/ bool GetNext(ref System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum outBinaryTypeEnum, ref object outTypeInformation);
                    }

                    class Converter
                    {
                        static /*0x0*/ int primitiveTypeEnumLength;
                        static /*0x8*/ System.Type[] typeA;
                        static /*0x10*/ System.Type[] arrayTypeA;
                        static /*0x18*/ string[] valueA;
                        static /*0x20*/ System.TypeCode[] typeCodeA;
                        static /*0x28*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE[] codeA;
                        static /*0x30*/ System.Type typeofISerializable;
                        static /*0x38*/ System.Type typeofString;
                        static /*0x40*/ System.Type typeofConverter;
                        static /*0x48*/ System.Type typeofBoolean;
                        static /*0x50*/ System.Type typeofByte;
                        static /*0x58*/ System.Type typeofChar;
                        static /*0x60*/ System.Type typeofDecimal;
                        static /*0x68*/ System.Type typeofDouble;
                        static /*0x70*/ System.Type typeofInt16;
                        static /*0x78*/ System.Type typeofInt32;
                        static /*0x80*/ System.Type typeofInt64;
                        static /*0x88*/ System.Type typeofSByte;
                        static /*0x90*/ System.Type typeofSingle;
                        static /*0x98*/ System.Type typeofTimeSpan;
                        static /*0xa0*/ System.Type typeofDateTime;
                        static /*0xa8*/ System.Type typeofUInt16;
                        static /*0xb0*/ System.Type typeofUInt32;
                        static /*0xb8*/ System.Type typeofUInt64;
                        static /*0xc0*/ System.Type typeofObject;
                        static /*0xc8*/ System.Type typeofSystemVoid;
                        static /*0xd0*/ System.Reflection.Assembly urtAssembly;
                        static /*0xd8*/ string urtAssemblyString;
                        static /*0xe0*/ System.Type typeofTypeArray;
                        static /*0xe8*/ System.Type typeofObjectArray;
                        static /*0xf0*/ System.Type typeofStringArray;
                        static /*0xf8*/ System.Type typeofBooleanArray;
                        static /*0x100*/ System.Type typeofByteArray;
                        static /*0x108*/ System.Type typeofCharArray;
                        static /*0x110*/ System.Type typeofDecimalArray;
                        static /*0x118*/ System.Type typeofDoubleArray;
                        static /*0x120*/ System.Type typeofInt16Array;
                        static /*0x128*/ System.Type typeofInt32Array;
                        static /*0x130*/ System.Type typeofInt64Array;
                        static /*0x138*/ System.Type typeofSByteArray;
                        static /*0x140*/ System.Type typeofSingleArray;
                        static /*0x148*/ System.Type typeofTimeSpanArray;
                        static /*0x150*/ System.Type typeofDateTimeArray;
                        static /*0x158*/ System.Type typeofUInt16Array;
                        static /*0x160*/ System.Type typeofUInt32Array;
                        static /*0x168*/ System.Type typeofUInt64Array;
                        static /*0x170*/ System.Type typeofMarshalByRefObject;

                        static /*0x2081fa0*/ Converter();
                        static /*0x207b770*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE ToCode(System.Type type);
                        static /*0x2080b88*/ bool IsWriteAsByteArray(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x2080bac*/ int TypeLength(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x2080bd0*/ System.Runtime.Serialization.Formatters.Binary.InternalNameSpaceE GetNameSpaceEnum(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, System.Type type, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, ref string typeName);
                        static /*0x207c168*/ System.Type ToArrayType(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x208117c*/ void InitTypeA();
                        static /*0x2080dc4*/ void InitArrayTypeA();
                        static /*0x207c0b0*/ System.Type ToType(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x2081534*/ System.Array CreatePrimitiveArray(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, int length);
                        static /*0x207b2c0*/ bool IsPrimitiveArray(System.Type type, ref object typeInformation);
                        static /*0x2081654*/ void InitValueA();
                        static /*0x207bff8*/ string ToComType(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x2081ac0*/ void InitTypeCodeA();
                        static /*0x2081c54*/ System.TypeCode ToTypeCode(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        static /*0x2081d0c*/ void InitCodeA();
                        static /*0x2080ad0*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE ToPrimitiveTypeEnum(System.TypeCode typeCode);
                        static /*0x2081eb4*/ object FromString(string value, System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        /*0x2080ac8*/ Converter();
                    }

                    class BinaryFormatter : System.Runtime.Remoting.Messaging.IRemotingFormatter, System.Runtime.Serialization.IFormatter
                    {
                        static /*0x0*/ System.Collections.Generic.Dictionary<System.Type, System.Runtime.Serialization.Formatters.Binary.TypeInformation> typeNameCache;
                        /*0x10*/ System.Runtime.Serialization.ISurrogateSelector m_surrogates;
                        /*0x18*/ System.Runtime.Serialization.StreamingContext m_context;
                        /*0x28*/ System.Runtime.Serialization.SerializationBinder m_binder;
                        /*0x30*/ System.Runtime.Serialization.Formatters.FormatterTypeStyle m_typeFormat;
                        /*0x34*/ System.Runtime.Serialization.Formatters.FormatterAssemblyStyle m_assemblyFormat;
                        /*0x38*/ System.Runtime.Serialization.Formatters.TypeFilterLevel m_securityLevel;
                        /*0x40*/ object[] m_crossAppDomainArray;

                        static /*0x2083974*/ BinaryFormatter();
                        static /*0x20836dc*/ System.Runtime.Serialization.Formatters.Binary.TypeInformation GetTypeInformation(System.Type type);
                        /*0x2082794*/ BinaryFormatter();
                        /*0x20827c8*/ BinaryFormatter(System.Runtime.Serialization.ISurrogateSelector selector, System.Runtime.Serialization.StreamingContext context);
                        /*0x2082730*/ System.Runtime.Serialization.Formatters.FormatterTypeStyle get_TypeFormat();
                        /*0x2082738*/ void set_TypeFormat(System.Runtime.Serialization.Formatters.FormatterTypeStyle value);
                        /*0x2082740*/ System.Runtime.Serialization.Formatters.FormatterAssemblyStyle get_AssemblyFormat();
                        /*0x2082748*/ void set_AssemblyFormat(System.Runtime.Serialization.Formatters.FormatterAssemblyStyle value);
                        /*0x2082750*/ System.Runtime.Serialization.Formatters.TypeFilterLevel get_FilterLevel();
                        /*0x2082758*/ void set_FilterLevel(System.Runtime.Serialization.Formatters.TypeFilterLevel value);
                        /*0x2082760*/ System.Runtime.Serialization.ISurrogateSelector get_SurrogateSelector();
                        /*0x2082768*/ void set_SurrogateSelector(System.Runtime.Serialization.ISurrogateSelector value);
                        /*0x2082770*/ System.Runtime.Serialization.SerializationBinder get_Binder();
                        /*0x2082778*/ void set_Binder(System.Runtime.Serialization.SerializationBinder value);
                        /*0x2082780*/ System.Runtime.Serialization.StreamingContext get_Context();
                        /*0x208278c*/ void set_Context(System.Runtime.Serialization.StreamingContext value);
                        /*0x2082814*/ object Deserialize(System.IO.Stream serializationStream);
                        /*0x2082828*/ object Deserialize(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler, bool fCheck);
                        /*0x2082820*/ object Deserialize(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler);
                        /*0x2082e98*/ object DeserializeMethodResponse(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler, System.Runtime.Remoting.Messaging.IMethodCallMessage methodCallMessage);
                        /*0x2082eb8*/ object UnsafeDeserialize(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler);
                        /*0x2082ec0*/ object UnsafeDeserializeMethodResponse(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler, System.Runtime.Remoting.Messaging.IMethodCallMessage methodCallMessage);
                        /*0x2082ea8*/ object Deserialize(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler, bool fCheck, System.Runtime.Remoting.Messaging.IMethodCallMessage methodCallMessage);
                        /*0x2082ed0*/ object Deserialize(System.IO.Stream serializationStream, System.Runtime.Remoting.Messaging.HeaderHandler handler, bool fCheck, bool isCrossAppDomain, System.Runtime.Remoting.Messaging.IMethodCallMessage methodCallMessage);
                        /*0x2083418*/ void Serialize(System.IO.Stream serializationStream, object graph);
                        /*0x2083424*/ void Serialize(System.IO.Stream serializationStream, object graph, System.Runtime.Remoting.Messaging.Header[] headers);
                        /*0x208342c*/ void Serialize(System.IO.Stream serializationStream, object graph, System.Runtime.Remoting.Messaging.Header[] headers, bool fCheck);
                    }

                    class __BinaryWriter
                    {
                        /*0x10*/ System.IO.Stream sout;
                        /*0x18*/ System.Runtime.Serialization.Formatters.FormatterTypeStyle formatterTypeStyle;
                        /*0x20*/ System.Collections.Hashtable objectMapTable;
                        /*0x28*/ System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter;
                        /*0x30*/ System.IO.BinaryWriter dataWriter;
                        /*0x38*/ int m_nestedObjectCount;
                        /*0x3c*/ int nullCount;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.BinaryMethodCall binaryMethodCall;
                        /*0x48*/ System.Runtime.Serialization.Formatters.Binary.BinaryMethodReturn binaryMethodReturn;
                        /*0x50*/ System.Runtime.Serialization.Formatters.Binary.BinaryObject binaryObject;
                        /*0x58*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap binaryObjectWithMap;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped binaryObjectWithMapTyped;
                        /*0x68*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectString binaryObjectString;
                        /*0x70*/ System.Runtime.Serialization.Formatters.Binary.BinaryArray binaryArray;
                        /*0x78*/ byte[] byteBuffer;
                        /*0x80*/ int chunkSize;
                        /*0x88*/ System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveUnTyped memberPrimitiveUnTyped;
                        /*0x90*/ System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveTyped memberPrimitiveTyped;
                        /*0x98*/ System.Runtime.Serialization.Formatters.Binary.ObjectNull objectNull;
                        /*0xa0*/ System.Runtime.Serialization.Formatters.Binary.MemberReference memberReference;
                        /*0xa8*/ System.Runtime.Serialization.Formatters.Binary.BinaryAssembly binaryAssembly;

                        /*0x2083624*/ __BinaryWriter(System.IO.Stream sout, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, System.Runtime.Serialization.Formatters.FormatterTypeStyle formatterTypeStyle);
                        /*0x2083a00*/ void WriteBegin();
                        /*0x2083a04*/ void WriteEnd();
                        /*0x2083a24*/ void WriteBoolean(bool value);
                        /*0x207bac4*/ void WriteByte(byte value);
                        /*0x2083a4c*/ void WriteBytes(byte[] value);
                        /*0x2083a70*/ void WriteBytes(byte[] byteA, int offset, int size);
                        /*0x2083a94*/ void WriteChar(char value);
                        /*0x2083ab8*/ void WriteChars(char[] value);
                        /*0x2083adc*/ void WriteDecimal(decimal value);
                        /*0x2083b9c*/ void WriteSingle(float value);
                        /*0x2083bc0*/ void WriteDouble(double value);
                        /*0x2083be4*/ void WriteInt16(short value);
                        /*0x207bb0c*/ void WriteInt32(int value);
                        /*0x2083c08*/ void WriteInt64(long value);
                        /*0x2083c2c*/ void WriteSByte(sbyte value);
                        /*0x207bae8*/ void WriteString(string value);
                        /*0x2083c50*/ void WriteTimeSpan(System.TimeSpan value);
                        /*0x2083c74*/ void WriteDateTime(System.DateTime value);
                        /*0x2083c98*/ void WriteUInt16(ushort value);
                        /*0x2083cbc*/ void WriteUInt32(uint value);
                        /*0x2083ce0*/ void WriteUInt64(ulong value);
                        /*0x2083d04*/ void WriteObjectEnd(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo);
                        /*0x2083d08*/ void WriteSerializationHeaderEnd();
                        /*0x2083d64*/ void WriteSerializationHeader(int topId, int headerId, int minorVersion, int majorVersion);
                        /*0x2083dfc*/ void WriteMethodCall();
                        /*0x2083e7c*/ object[] WriteCallArray(string uri, string methodName, string typeName, System.Type[] instArgs, object[] args, object methodSignature, object callContext, object[] properties);
                        /*0x2083f40*/ void WriteMethodReturn();
                        /*0x2083fc0*/ object[] WriteReturnArray(object returnValue, object[] args, System.Exception exception, object callContext, object[] properties);
                        /*0x208406c*/ void WriteObject(System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, int numMembers, string[] memberNames, System.Type[] memberTypes, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo[] memberObjectInfos);
                        /*0x2084720*/ void WriteObjectString(int objectId, string value);
                        /*0x20847b0*/ void WriteSingleArray(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, int length, int lowerBound, System.Array array);
                        /*0x2084ab0*/ void WriteArrayAsBytes(System.Array array, int typeLength);
                        /*0x2084ce0*/ void WriteJaggedArray(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, int length, int lowerBound);
                        /*0x2084e70*/ void WriteRectangleArray(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, int rank, int[] lengthA, int[] lowerBoundA);
                        /*0x2084fc8*/ void WriteObjectByteArray(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, int length, int lowerBound, byte[] byteA);
                        /*0x2085028*/ void WriteMember(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object value);
                        /*0x2085130*/ void WriteNullMember(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo);
                        /*0x20851d0*/ void WriteMemberObjectRef(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, int idRef);
                        /*0x2085264*/ void WriteMemberNested(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo);
                        /*0x2085280*/ void WriteMemberString(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, string value);
                        /*0x20852c8*/ void WriteItem(System.Runtime.Serialization.Formatters.Binary.NameInfo itemNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object value);
                        /*0x2085308*/ void WriteNullItem(System.Runtime.Serialization.Formatters.Binary.NameInfo itemNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo);
                        /*0x2085318*/ void WriteDelayedNullItem();
                        /*0x2085328*/ void WriteItemEnd();
                        /*0x2084514*/ void InternalWriteItemNull();
                        /*0x208532c*/ void WriteItemObjectRef(System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo, int idRef);
                        /*0x208535c*/ void WriteAssembly(System.Type type, string assemblyString, int assemId, bool isNew);
                        /*0x207c58c*/ void WriteValue(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, object value);
                    }

                    class ObjectMapInfo
                    {
                        /*0x10*/ int objectId;
                        /*0x14*/ int numMembers;
                        /*0x18*/ string[] memberNames;
                        /*0x20*/ System.Type[] memberTypes;

                        /*0x20846e0*/ ObjectMapInfo(int objectId, int numMembers, string[] memberNames, System.Type[] memberTypes);
                        /*0x20845a4*/ bool isCompatible(int numMembers, string[] memberNames, System.Type[] memberTypes);
                    }

                    class WriteObjectInfo
                    {
                        /*0x10*/ int objectInfoId;
                        /*0x18*/ object obj;
                        /*0x20*/ System.Type objectType;
                        /*0x28*/ bool isSi;
                        /*0x29*/ bool isNamed;
                        /*0x2a*/ bool isTyped;
                        /*0x2b*/ bool isArray;
                        /*0x30*/ System.Runtime.Serialization.SerializationInfo si;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoCache cache;
                        /*0x40*/ object[] memberData;
                        /*0x48*/ System.Runtime.Serialization.ISerializationSurrogate serializationSurrogate;
                        /*0x50*/ System.Runtime.Serialization.StreamingContext context;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit;
                        /*0x68*/ long objectId;
                        /*0x70*/ long assemId;
                        /*0x78*/ string binderTypeName;
                        /*0x80*/ string binderAssemblyString;

                        static /*0x2085484*/ System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo Serialize(object obj, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, System.Runtime.Serialization.SerializationBinder binder);
                        static /*0x208634c*/ System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo Serialize(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.SerializationBinder binder);
                        static /*0x2085ed4*/ void CheckTypeForwardedFrom(System.Runtime.Serialization.Formatters.Binary.SerObjectInfoCache cache, System.Type objectType, string binderAssemblyString);
                        static /*0x2085514*/ System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo GetObjectInfo(System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit);
                        static /*0x2085444*/ void PutObjectInfo(System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo);
                        /*0x2085430*/ WriteObjectInfo();
                        /*0x2085438*/ void ObjectEnd();
                        /*0x2085464*/ void InternalInit();
                        /*0x20855ec*/ void InitSerialize(object obj, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.Formatters.Binary.ObjectWriter objectWriter, System.Runtime.Serialization.SerializationBinder binder);
                        /*0x2086314*/ void DumpMemberInfo();
                        /*0x20863d4*/ void InitSerialize(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, System.Runtime.Serialization.SerializationBinder binder);
                        /*0x2085be4*/ void InitSiWrite();
                        /*0x2085ad8*/ void InitNoMembers();
                        /*0x2086034*/ void InitMemberInfo();
                        /*0x207b578*/ string GetTypeFullName();
                        /*0x207b550*/ string GetAssemblyString();
                        /*0x2085bbc*/ void InvokeSerializationBinder(System.Runtime.Serialization.SerializationBinder binder);
                        /*0x2086774*/ System.Type GetMemberType(System.Reflection.MemberInfo objMember);
                        /*0x20868e4*/ void GetMemberInfo(ref string[] outMemberNames, ref System.Type[] outMemberTypes, ref object[] outMemberData);
                    }

                    class ReadObjectInfo
                    {
                        static /*0x0*/ int readObjectInfoCounter;
                        /*0x10*/ int objectInfoId;
                        /*0x18*/ System.Type objectType;
                        /*0x20*/ System.Runtime.Serialization.ObjectManager objectManager;
                        /*0x28*/ int count;
                        /*0x2c*/ bool isSi;
                        /*0x2d*/ bool isNamed;
                        /*0x2e*/ bool isTyped;
                        /*0x2f*/ bool bSimpleAssembly;
                        /*0x30*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoCache cache;
                        /*0x38*/ string[] wireMemberNames;
                        /*0x40*/ System.Type[] wireMemberTypes;
                        /*0x48*/ int lastPosition;
                        /*0x50*/ System.Runtime.Serialization.ISurrogateSelector surrogateSelector;
                        /*0x58*/ System.Runtime.Serialization.ISerializationSurrogate serializationSurrogate;
                        /*0x60*/ System.Runtime.Serialization.StreamingContext context;
                        /*0x70*/ System.Collections.Generic.List<System.Type> memberTypesList;
                        /*0x78*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit;
                        /*0x80*/ System.Runtime.Serialization.IFormatterConverter formatterConverter;

                        static /*0x2086998*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo Create(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ObjectManager objectManager, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, bool bSimpleAssembly);
                        static /*0x2086c4c*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo Create(System.Type objectType, string[] memberNames, System.Type[] memberTypes, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ObjectManager objectManager, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, bool bSimpleAssembly);
                        static /*0x2086a20*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo GetObjectInfo(System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit);
                        /*0x208698c*/ ReadObjectInfo();
                        /*0x2086994*/ void ObjectEnd();
                        /*0x20805fc*/ void PrepareForReuse();
                        /*0x2086a90*/ void Init(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ObjectManager objectManager, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, bool bSimpleAssembly);
                        /*0x2086ce8*/ void Init(System.Type objectType, string[] memberNames, System.Type[] memberTypes, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.ObjectManager objectManager, System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit, System.Runtime.Serialization.IFormatterConverter converter, bool bSimpleAssembly);
                        /*0x2086aac*/ void InitReadConstructor(System.Type objectType, System.Runtime.Serialization.ISurrogateSelector surrogateSelector, System.Runtime.Serialization.StreamingContext context);
                        /*0x2086d9c*/ void InitSiRead();
                        /*0x2086d38*/ void InitNoMembers();
                        /*0x2086e1c*/ void InitMemberInfo();
                        /*0x20871a0*/ System.Reflection.MemberInfo GetMemberInfo(string name);
                        /*0x2087490*/ System.Type GetType(string name);
                        /*0x2087640*/ void AddValue(string name, object value, ref System.Runtime.Serialization.SerializationInfo si, ref object[] memberData);
                        /*0x208052c*/ void InitDataStore(ref System.Runtime.Serialization.SerializationInfo si, ref object[] memberData);
                        /*0x20876d4*/ void RecordFixup(long objectId, string name, long idRef);
                        /*0x2087778*/ void PopulateObjectMembers(object obj, object[] memberData);
                        /*0x2087814*/ void DumpPopulate(System.Reflection.MemberInfo[] memberInfos, object[] memberData);
                        /*0x208783c*/ void DumpPopulateSi();
                        /*0x208735c*/ int Position(string name);
                        /*0x207fcf4*/ System.Type[] GetMemberTypes(string[] inMemberNames, System.Type objectType);
                        /*0x2087030*/ System.Type GetMemberType(System.Reflection.MemberInfo objMember);
                    }

                    class SerObjectInfoInit
                    {
                        /*0x10*/ System.Collections.Hashtable seenBeforeTable;
                        /*0x18*/ int objectInfoIdCount;
                        /*0x20*/ System.Runtime.Serialization.Formatters.Binary.SerStack oiPool;

                        /*0x2087840*/ SerObjectInfoInit();
                    }

                    class SerObjectInfoCache
                    {
                        /*0x10*/ string fullTypeName;
                        /*0x18*/ string assemblyString;
                        /*0x20*/ bool hasTypeForwardedFrom;
                        /*0x28*/ System.Reflection.MemberInfo[] memberInfos;
                        /*0x30*/ string[] memberNames;
                        /*0x38*/ System.Type[] memberTypes;

                        /*0x2086738*/ SerObjectInfoCache(string typeName, string assemblyName, bool hasTypeForwardedFrom);
                        /*0x20866b0*/ SerObjectInfoCache(System.Type type);
                    }

                    class TypeInformation
                    {
                        /*0x10*/ string fullTypeName;
                        /*0x18*/ string assemblyString;
                        /*0x20*/ bool hasTypeForwardedFrom;

                        /*0x2083938*/ TypeInformation(string fullTypeName, string assemblyString, bool hasTypeForwardedFrom);
                        /*0x20878f8*/ string get_FullTypeName();
                        /*0x2087900*/ string get_AssemblyString();
                        /*0x2087908*/ bool get_HasTypeForwardedFrom();
                    }

                    class ObjectReader
                    {
                        static int THRESHOLD_FOR_VALUETYPE_IDS = 2147483647;
                        /*0x10*/ System.IO.Stream m_stream;
                        /*0x18*/ System.Runtime.Serialization.ISurrogateSelector m_surrogates;
                        /*0x20*/ System.Runtime.Serialization.StreamingContext m_context;
                        /*0x30*/ System.Runtime.Serialization.ObjectManager m_objectManager;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.InternalFE formatterEnums;
                        /*0x40*/ System.Runtime.Serialization.SerializationBinder m_binder;
                        /*0x48*/ long topId;
                        /*0x50*/ bool bSimpleAssembly;
                        /*0x58*/ object handlerObject;
                        /*0x60*/ object m_topObject;
                        /*0x68*/ System.Runtime.Remoting.Messaging.Header[] headers;
                        /*0x70*/ System.Runtime.Remoting.Messaging.HeaderHandler handler;
                        /*0x78*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit;
                        /*0x80*/ System.Runtime.Serialization.IFormatterConverter m_formatterConverter;
                        /*0x88*/ System.Runtime.Serialization.Formatters.Binary.SerStack stack;
                        /*0x90*/ System.Runtime.Serialization.Formatters.Binary.SerStack valueFixupStack;
                        /*0x98*/ object[] crossAppDomainArray;
                        /*0xa0*/ bool bFullDeserialization;
                        /*0xa1*/ bool bOldFormatDetected;
                        /*0xa8*/ System.Runtime.Serialization.Formatters.Binary.IntSizedArray valTypeObjectIdTable;
                        /*0xb0*/ System.Runtime.Serialization.Formatters.Binary.NameCache typeCache;
                        /*0xb8*/ string previousAssemblyString;
                        /*0xc0*/ string previousName;
                        /*0xc8*/ System.Type previousType;

                        static /*0x208a210*/ System.Reflection.Assembly ResolveSimpleAssemblyName(System.Reflection.AssemblyName assemblyName);
                        static /*0x208a270*/ void GetSimplyNamedTypeFromAssembly(System.Reflection.Assembly assm, string typeName, ref System.Type type);
                        static /*0x208a4c4*/ void CheckTypeForwardedTo(System.Reflection.Assembly sourceAssembly, System.Reflection.Assembly destAssembly, System.Type resolvedType);
                        /*0x2082a70*/ ObjectReader(System.IO.Stream stream, System.Runtime.Serialization.ISurrogateSelector selector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.InternalFE formatterEnums, System.Runtime.Serialization.SerializationBinder binder);
                        /*0x2087910*/ System.Runtime.Serialization.Formatters.Binary.SerStack get_ValueFixupStack();
                        /*0x2087994*/ object get_TopObject();
                        /*0x208799c*/ void set_TopObject(object value);
                        /*0x208311c*/ object Deserialize(System.Runtime.Remoting.Messaging.HeaderHandler handler, System.Runtime.Serialization.Formatters.Binary.__BinaryParser serParser, bool fCheck, bool isCrossAppDomain, System.Runtime.Remoting.Messaging.IMethodCallMessage methodCallMessage);
                        /*0x2082b84*/ object Deserialize(System.Runtime.Remoting.Messaging.HeaderHandler handler, System.Runtime.Serialization.Formatters.Binary.__BinaryParser serParser, bool fCheck);
                        /*0x20879b0*/ bool HasSurrogate(System.Type t);
                        /*0x2087a88*/ void CheckSerializable(System.Type t);
                        /*0x2087bc4*/ void InitFullDeserialization();
                        /*0x2087cd8*/ object CrossAppDomainArray(int index);
                        /*0x207fcc4*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo CreateReadObjectInfo(System.Type objectType);
                        /*0x20804ac*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo CreateReadObjectInfo(System.Type objectType, string[] memberNames, System.Type[] memberTypes);
                        /*0x2087d08*/ void Parse(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x208895c*/ void ParseError(System.Runtime.Serialization.Formatters.Binary.ParseRecord processing, System.Runtime.Serialization.Formatters.Binary.ParseRecord onStack);
                        /*0x2087e54*/ void ParseSerializedStreamHeader(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x2087e70*/ void ParseSerializedStreamHeaderEnd(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x2087e8c*/ void ParseObject(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x20881a8*/ void ParseObjectEnd(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x2088c34*/ void ParseArray(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x20892e0*/ void NextRectangleMap(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x20893a4*/ void ParseArrayMember(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x2089b88*/ void ParseArrayMemberEnd(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x20883d4*/ void ParseMember(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x208889c*/ void ParseMemberEnd(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x2089b48*/ void ParseString(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr, System.Runtime.Serialization.Formatters.Binary.ParseRecord parentPr);
                        /*0x20892d8*/ void RegisterObject(object obj, System.Runtime.Serialization.Formatters.Binary.ParseRecord pr, System.Runtime.Serialization.Formatters.Binary.ParseRecord objectPr);
                        /*0x2089bb0*/ void RegisterObject(object obj, System.Runtime.Serialization.Formatters.Binary.ParseRecord pr, System.Runtime.Serialization.Formatters.Binary.ParseRecord objectPr, bool bIsString);
                        /*0x2089cd0*/ long GetId(long objectId);
                        /*0x2089db8*/ void IndexTraceMessage(string message, int[] index);
                        /*0x2089ec0*/ System.Type Bind(string assemblyString, string typeString);
                        /*0x2089f18*/ System.Type FastBindToType(string assemblyName, string typeName);
                        /*0x207c220*/ System.Type GetType(System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo assemblyInfo, string name);

                        class TypeNAssembly
                        {
                            /*0x10*/ System.Type type;
                            /*0x18*/ string assemblyName;

                            /*0x208b604*/ TypeNAssembly();
                        }

                        class TopLevelAssemblyTypeResolver
                        {
                            /*0x10*/ System.Reflection.Assembly m_topLevelAssembly;

                            /*0x208b60c*/ TopLevelAssemblyTypeResolver(System.Reflection.Assembly topLevelAssembly);
                            /*0x208b634*/ System.Type ResolveType(System.Reflection.Assembly assembly, string simpleTypeName, bool ignoreCase);
                        }
                    }

                    class ObjectWriter
                    {
                        /*0x10*/ System.Collections.Queue m_objectQueue;
                        /*0x18*/ System.Runtime.Serialization.ObjectIDGenerator m_idGenerator;
                        /*0x20*/ int m_currentId;
                        /*0x28*/ System.Runtime.Serialization.ISurrogateSelector m_surrogates;
                        /*0x30*/ System.Runtime.Serialization.StreamingContext m_context;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.__BinaryWriter serWriter;
                        /*0x48*/ System.Runtime.Serialization.SerializationObjectManager m_objectManager;
                        /*0x50*/ long topId;
                        /*0x58*/ string topName;
                        /*0x60*/ System.Runtime.Remoting.Messaging.Header[] headers;
                        /*0x68*/ System.Runtime.Serialization.Formatters.Binary.InternalFE formatterEnums;
                        /*0x70*/ System.Runtime.Serialization.SerializationBinder m_binder;
                        /*0x78*/ System.Runtime.Serialization.Formatters.Binary.SerObjectInfoInit serObjectInfoInit;
                        /*0x80*/ System.Runtime.Serialization.IFormatterConverter m_formatterConverter;
                        /*0x88*/ object[] crossAppDomainArray;
                        /*0x90*/ System.Collections.ArrayList internalCrossAppDomainArray;
                        /*0x98*/ object previousObj;
                        /*0xa0*/ long previousId;
                        /*0xa8*/ System.Type previousType;
                        /*0xb0*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE previousCode;
                        /*0xb8*/ System.Collections.Hashtable assemblyToIdTable;
                        /*0xc0*/ System.Runtime.Serialization.Formatters.Binary.SerStack niPool;

                        /*0x208b69c*/ ObjectWriter(System.Runtime.Serialization.ISurrogateSelector selector, System.Runtime.Serialization.StreamingContext context, System.Runtime.Serialization.Formatters.Binary.InternalFE formatterEnums, System.Runtime.Serialization.SerializationBinder binder);
                        /*0x208b808*/ void Serialize(object graph, System.Runtime.Remoting.Messaging.Header[] inHeaders, System.Runtime.Serialization.Formatters.Binary.__BinaryWriter serWriter, bool fCheck);
                        /*0x208c438*/ System.Runtime.Serialization.SerializationObjectManager get_ObjectManager();
                        /*0x208bf2c*/ void Write(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo);
                        /*0x208cc30*/ void Write(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, string[] memberNames, System.Type[] memberTypes, object[] memberData, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo[] memberObjectInfos);
                        /*0x208cea4*/ void WriteMemberSetup(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, string memberName, System.Type memberType, object memberData, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo memberObjectInfo);
                        /*0x208cfbc*/ void WriteMembers(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberTypeNameInfo, object memberData, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo memberObjectInfo);
                        /*0x208c440*/ void WriteArray(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo memberObjectInfo);
                        /*0x208d5c0*/ void WriteArrayMember(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemTypeNameInfo, object data);
                        /*0x208d838*/ void WriteRectangle(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, int rank, int[] maxA, System.Array array, System.Runtime.Serialization.Formatters.Binary.NameInfo arrayElemNameTypeInfo, int[] lowerBoundA);
                        /*0x208dacc*/ void IndexTraceMessage(string message, int[] index);
                        /*0x208c2c0*/ object GetNext(ref long objID);
                        /*0x208bc14*/ long InternalGetId(object obj, bool assignUniqueIdToValueType, System.Type type, ref bool isNew);
                        /*0x208dac0*/ long Schedule(object obj, bool assignUniqueIdToValueType, System.Type type);
                        /*0x208d424*/ long Schedule(object obj, bool assignUniqueIdToValueType, System.Type type, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo);
                        /*0x208d4cc*/ bool WriteKnownValueClass(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object data);
                        /*0x208d4b0*/ void WriteObjectRef(System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo, long objectId);
                        /*0x208dbd4*/ void WriteString(System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object stringObject);
                        /*0x208d2e4*/ bool CheckForNull(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo memberNameInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo typeNameInfo, object data);
                        /*0x208bbf0*/ void WriteSerializedStreamHeader(long topId, long headerId);
                        /*0x208dcd4*/ System.Runtime.Serialization.Formatters.Binary.NameInfo TypeToNameInfo(System.Type type, System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo);
                        /*0x208cf80*/ System.Runtime.Serialization.Formatters.Binary.NameInfo TypeToNameInfo(System.Type type);
                        /*0x208bee8*/ System.Runtime.Serialization.Formatters.Binary.NameInfo TypeToNameInfo(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo);
                        /*0x208d3d4*/ System.Runtime.Serialization.Formatters.Binary.NameInfo TypeToNameInfo(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo, System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo);
                        /*0x208d39c*/ void TypeToNameInfo(System.Type type, System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo);
                        /*0x208ce84*/ System.Runtime.Serialization.Formatters.Binary.NameInfo MemberToNameInfo(string name);
                        /*0x208cbb0*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE ToCode(System.Type type);
                        /*0x208bcd8*/ long GetAssemblyId(System.Runtime.Serialization.Formatters.Binary.WriteObjectInfo objectInfo);
                        /*0x208cb98*/ System.Type GetType(object obj);
                        /*0x208dd68*/ System.Runtime.Serialization.Formatters.Binary.NameInfo GetNameInfo();
                        /*0x208cb8c*/ bool CheckTypeFormat(System.Runtime.Serialization.Formatters.FormatterTypeStyle test, System.Runtime.Serialization.Formatters.FormatterTypeStyle want);
                        /*0x208c2a8*/ void PutNameInfo(System.Runtime.Serialization.Formatters.Binary.NameInfo nameInfo);
                    }

                    class __BinaryParser
                    {
                        static int chunkSize = 4096;
                        static /*0x0*/ System.Text.Encoding encoding;
                        static /*0x8*/ System.Runtime.Serialization.Formatters.Binary.MessageEnd messageEnd;
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader;
                        /*0x18*/ System.IO.Stream input;
                        /*0x20*/ long topId;
                        /*0x28*/ long headerId;
                        /*0x30*/ System.Runtime.Serialization.Formatters.Binary.SizedArray objectMapIdTable;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.SizedArray assemIdToAssemblyTable;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.SerStack stack;
                        /*0x48*/ System.Runtime.Serialization.Formatters.Binary.BinaryTypeEnum expectedType;
                        /*0x50*/ object expectedTypeInformation;
                        /*0x58*/ System.Runtime.Serialization.Formatters.Binary.ParseRecord PRS;
                        /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo systemAssemblyInfo;
                        /*0x68*/ System.IO.BinaryReader dataReader;
                        /*0x70*/ System.Runtime.Serialization.Formatters.Binary.SerStack opPool;
                        /*0x78*/ System.Runtime.Serialization.Formatters.Binary.BinaryObject binaryObject;
                        /*0x80*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap bowm;
                        /*0x88*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped bowmt;
                        /*0x90*/ System.Runtime.Serialization.Formatters.Binary.BinaryObjectString objectString;
                        /*0x98*/ System.Runtime.Serialization.Formatters.Binary.BinaryCrossAppDomainString crossAppDomainString;
                        /*0xa0*/ System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveTyped memberPrimitiveTyped;
                        /*0xa8*/ byte[] byteBuffer;
                        /*0xb0*/ System.Runtime.Serialization.Formatters.Binary.MemberPrimitiveUnTyped memberPrimitiveUnTyped;
                        /*0xb8*/ System.Runtime.Serialization.Formatters.Binary.MemberReference memberReference;
                        /*0xc0*/ System.Runtime.Serialization.Formatters.Binary.ObjectNull objectNull;

                        static /*0x20920ac*/ __BinaryParser();
                        /*0x208df54*/ __BinaryParser(System.IO.Stream stream, System.Runtime.Serialization.Formatters.Binary.ObjectReader objectReader);
                        /*0x208e060*/ System.Runtime.Serialization.Formatters.Binary.BinaryAssemblyInfo get_SystemAssemblyInfo();
                        /*0x208e10c*/ System.Runtime.Serialization.Formatters.Binary.SizedArray get_ObjectMapIdTable();
                        /*0x208e1e0*/ System.Runtime.Serialization.Formatters.Binary.SizedArray get_AssemIdToAssemblyTable();
                        /*0x208e2c4*/ System.Runtime.Serialization.Formatters.Binary.ParseRecord get_prs();
                        /*0x208e338*/ void Run();
                        /*0x208e918*/ void ReadBegin();
                        /*0x20906ec*/ void ReadEnd();
                        /*0x2090ac4*/ bool ReadBoolean();
                        /*0x2090ae4*/ byte ReadByte();
                        /*0x2090b04*/ byte[] ReadBytes(int length);
                        /*0x2090b28*/ void ReadBytes(byte[] byteA, int offset, int size);
                        /*0x2090ba4*/ char ReadChar();
                        /*0x2090bc8*/ char[] ReadChars(int length);
                        /*0x2090bec*/ decimal ReadDecimal();
                        /*0x2090ca0*/ float ReadSingle();
                        /*0x2090cc4*/ double ReadDouble();
                        /*0x2090ce8*/ short ReadInt16();
                        /*0x2090d0c*/ int ReadInt32();
                        /*0x2090d30*/ long ReadInt64();
                        /*0x2090d54*/ sbyte ReadSByte();
                        /*0x2090d74*/ string ReadString();
                        /*0x2090d98*/ System.TimeSpan ReadTimeSpan();
                        /*0x2090dbc*/ System.DateTime ReadDateTime();
                        /*0x2090e38*/ ushort ReadUInt16();
                        /*0x2090e5c*/ uint ReadUInt32();
                        /*0x2090e80*/ ulong ReadUInt64();
                        /*0x208e91c*/ void ReadSerializationHeaderRecord();
                        /*0x208e9e4*/ void ReadAssembly(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x208ec5c*/ void ReadObject();
                        /*0x208efbc*/ void ReadCrossAppDomainMap();
                        /*0x208f18c*/ void ReadObjectWithMap(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x2091104*/ void ReadObjectWithMap(System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMap record);
                        /*0x208f22c*/ void ReadObjectWithMapTyped(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x209151c*/ void ReadObjectWithMapTyped(System.Runtime.Serialization.Formatters.Binary.BinaryObjectWithMapTyped record);
                        /*0x208f2bc*/ void ReadObjectString(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x208fdf8*/ void ReadMemberPrimitiveTyped();
                        /*0x208f850*/ void ReadArray(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x2091950*/ void ReadArrayAsBytes(System.Runtime.Serialization.Formatters.Binary.ParseRecord pr);
                        /*0x20906f0*/ void ReadMemberPrimitiveUnTyped();
                        /*0x2090184*/ void ReadMemberReference();
                        /*0x2090378*/ void ReadObjectNull(System.Runtime.Serialization.Formatters.Binary.BinaryHeaderEnum binaryHeaderEnum);
                        /*0x2090574*/ void ReadMessageEnd();
                        /*0x2091c88*/ object ReadValue(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code);
                        /*0x2091018*/ System.Runtime.Serialization.Formatters.Binary.ObjectProgress GetOp();
                        /*0x2090a3c*/ void PutOp(System.Runtime.Serialization.Formatters.Binary.ObjectProgress op);
                    }

                    class ParseRecord
                    {
                        static /*0x0*/ int parseRecordIdCount;
                        /*0x10*/ int PRparseRecordId;
                        /*0x14*/ System.Runtime.Serialization.Formatters.Binary.InternalParseTypeE PRparseTypeEnum;
                        /*0x18*/ System.Runtime.Serialization.Formatters.Binary.InternalObjectTypeE PRobjectTypeEnum;
                        /*0x1c*/ System.Runtime.Serialization.Formatters.Binary.InternalArrayTypeE PRarrayTypeEnum;
                        /*0x20*/ System.Runtime.Serialization.Formatters.Binary.InternalMemberTypeE PRmemberTypeEnum;
                        /*0x24*/ System.Runtime.Serialization.Formatters.Binary.InternalMemberValueE PRmemberValueEnum;
                        /*0x28*/ System.Runtime.Serialization.Formatters.Binary.InternalObjectPositionE PRobjectPositionEnum;
                        /*0x30*/ string PRname;
                        /*0x38*/ string PRvalue;
                        /*0x40*/ object PRvarValue;
                        /*0x48*/ string PRkeyDt;
                        /*0x50*/ System.Type PRdtType;
                        /*0x58*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE PRdtTypeCode;
                        /*0x5c*/ bool PRisVariant;
                        /*0x5d*/ bool PRisEnum;
                        /*0x60*/ long PRobjectId;
                        /*0x68*/ long PRidRef;
                        /*0x70*/ string PRarrayElementTypeString;
                        /*0x78*/ System.Type PRarrayElementType;
                        /*0x80*/ bool PRisArrayVariant;
                        /*0x84*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE PRarrayElementTypeCode;
                        /*0x88*/ int PRrank;
                        /*0x90*/ int[] PRlengthA;
                        /*0x98*/ int[] PRpositionA;
                        /*0xa0*/ int[] PRlowerBoundA;
                        /*0xa8*/ int[] PRupperBoundA;
                        /*0xb0*/ int[] PRindexMap;
                        /*0xb8*/ int PRmemberIndex;
                        /*0xbc*/ int PRlinearlength;
                        /*0xc0*/ int[] PRrectangularMap;
                        /*0xc8*/ bool PRisLowerBound;
                        /*0xd0*/ long PRtopId;
                        /*0xd8*/ long PRheaderId;
                        /*0xe0*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo PRobjectInfo;
                        /*0xe8*/ bool PRisValueTypeFixup;
                        /*0xf0*/ object PRnewObj;
                        /*0xf8*/ object[] PRobjectA;
                        /*0x100*/ System.Runtime.Serialization.Formatters.Binary.PrimitiveArray PRprimitiveArray;
                        /*0x108*/ bool PRisRegistered;
                        /*0x110*/ object[] PRmemberData;
                        /*0x118*/ System.Runtime.Serialization.SerializationInfo PRsi;
                        /*0x120*/ int PRnullCount;

                        static /*0x209212c*/ ParseRecord();
                        /*0x208e330*/ ParseRecord();
                        /*0x20909e0*/ void Init();
                    }

                    class SerStack
                    {
                        /*0x10*/ object[] objects;
                        /*0x18*/ string stackId;
                        /*0x20*/ int top;
                        /*0x24*/ int next;

                        /*0x2092178*/ SerStack();
                        /*0x208b794*/ SerStack(string stackId);
                        /*0x208dea8*/ void Push(object obj);
                        /*0x208de50*/ object Pop();
                        /*0x2092200*/ void IncreaseCapacity();
                        /*0x20909a0*/ object Peek();
                        /*0x20910c0*/ object PeekPeek();
                        /*0x2092288*/ int Count();
                        /*0x208de40*/ bool IsEmpty();
                        /*0x2092294*/ void Dump();
                    }

                    class SizedArray : System.ICloneable
                    {
                        /*0x10*/ object[] objects;
                        /*0x18*/ object[] negObjects;

                        /*0x208e174*/ SizedArray();
                        /*0x208e24c*/ SizedArray(int length);
                        /*0x2092298*/ SizedArray(System.Runtime.Serialization.Formatters.Binary.SizedArray sizedArray);
                        /*0x209234c*/ object Clone();
                        /*0x2090fa4*/ object get_Item(int index);
                        /*0x2090ea4*/ void set_Item(int index, object value);
                        /*0x20923ac*/ void IncreaseCapacity(int index);
                    }

                    class IntSizedArray : System.ICloneable
                    {
                        /*0x10*/ int[] objects;
                        /*0x18*/ int[] negObjects;

                        /*0x20925cc*/ IntSizedArray();
                        /*0x2092634*/ IntSizedArray(System.Runtime.Serialization.Formatters.Binary.IntSizedArray sizedArray);
                        /*0x2092710*/ object Clone();
                        /*0x2092770*/ int get_Item(int index);
                        /*0x20927e8*/ void set_Item(int index, int value);
                        /*0x209289c*/ void IncreaseCapacity(int index);
                    }

                    class NameCache
                    {
                        static /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary<string, object> ht;
                        /*0x10*/ string name;

                        static /*0x2092bfc*/ NameCache();
                        /*0x2092bf4*/ NameCache();
                        /*0x2092abc*/ object GetCachedValue(string name);
                        /*0x2092b64*/ void SetCachedValue(object value);
                    }

                    class ValueFixup
                    {
                        static /*0x0*/ System.Reflection.MemberInfo valueInfo;
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.ValueFixupEnum valueFixupEnum;
                        /*0x18*/ System.Array arrayObj;
                        /*0x20*/ int[] indexMap;
                        /*0x28*/ object header;
                        /*0x30*/ object memberObject;
                        /*0x38*/ System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo objectInfo;
                        /*0x40*/ string memberName;

                        /*0x2092c88*/ ValueFixup(System.Array arrayObj, int[] indexMap);
                        /*0x2092cbc*/ ValueFixup(object memberObject, string memberName, System.Runtime.Serialization.Formatters.Binary.ReadObjectInfo objectInfo);
                        /*0x2092d00*/ void Fixup(System.Runtime.Serialization.Formatters.Binary.ParseRecord record, System.Runtime.Serialization.Formatters.Binary.ParseRecord parent);
                    }

                    class InternalFE
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.FormatterTypeStyle FEtypeFormat;
                        /*0x14*/ System.Runtime.Serialization.Formatters.FormatterAssemblyStyle FEassemblyFormat;
                        /*0x18*/ System.Runtime.Serialization.Formatters.TypeFilterLevel FEsecurityLevel;
                        /*0x1c*/ System.Runtime.Serialization.Formatters.Binary.InternalSerializerTypeE FEserializerTypeEnum;

                        /*0x2093014*/ InternalFE();
                    }

                    class NameInfo
                    {
                        /*0x10*/ string NIFullName;
                        /*0x18*/ long NIobjectId;
                        /*0x20*/ long NIassemId;
                        /*0x28*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE NIprimitiveTypeEnum;
                        /*0x30*/ System.Type NItype;
                        /*0x38*/ bool NIisSealed;
                        /*0x39*/ bool NIisArray;
                        /*0x3a*/ bool NIisArrayItem;
                        /*0x3b*/ bool NItransmitTypeOnObject;
                        /*0x3c*/ bool NItransmitTypeOnMember;
                        /*0x3d*/ bool NIisParentTypeOnObject;
                        /*0x40*/ System.Runtime.Serialization.Formatters.Binary.InternalArrayTypeE NIarrayEnum;
                        /*0x44*/ bool NIsealedStatusChecked;

                        /*0x208dea0*/ NameInfo();
                        /*0x208de20*/ void Init();
                        /*0x208da74*/ bool get_IsSealed();
                        /*0x209301c*/ string get_NIname();
                        /*0x2093054*/ void set_NIname(string value);
                    }

                    class PrimitiveArray
                    {
                        /*0x10*/ System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code;
                        /*0x18*/ bool[] booleanA;
                        /*0x20*/ char[] charA;
                        /*0x28*/ double[] doubleA;
                        /*0x30*/ short[] int16A;
                        /*0x38*/ int[] int32A;
                        /*0x40*/ long[] int64A;
                        /*0x48*/ sbyte[] sbyteA;
                        /*0x50*/ float[] singleA;
                        /*0x58*/ ushort[] uint16A;
                        /*0x60*/ uint[] uint32A;
                        /*0x68*/ ulong[] uint64A;

                        /*0x209305c*/ PrimitiveArray(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, System.Array array);
                        /*0x2093090*/ void Init(System.Runtime.Serialization.Formatters.Binary.InternalPrimitiveTypeE code, System.Array array);
                        /*0x20933b0*/ void SetValue(string value, int index);
                    }

                    enum MessageEnum
                    {
                        NoArgs = 1,
                        ArgsInline = 2,
                        ArgsIsArray = 4,
                        ArgsInArray = 8,
                        NoContext = 16,
                        ContextInline = 32,
                        ContextInArray = 64,
                        MethodSignatureInArray = 128,
                        PropertyInArray = 256,
                        NoReturnValue = 512,
                        ReturnValueVoid = 1024,
                        ReturnValueInline = 2048,
                        ReturnValueInArray = 4096,
                        ExceptionInArray = 8192,
                        GenericMethod = 32768,
                    }

                    enum SoapAttributeType
                    {
                        None = 0,
                        SchemaType = 1,
                        Embedded = 2,
                        XmlElement = 4,
                        XmlAttribute = 8,
                    }
                }
            }
        }

        namespace InteropServices
        {
            enum CharSet
            {
                None = 1,
                Ansi = 2,
                Unicode = 3,
                Auto = 4,
            }

            class ExternalException : System.SystemException
            {
                /*0x209376c*/ ExternalException();
                /*0x20937c8*/ ExternalException(string message);
                /*0x20937ec*/ ExternalException(string message, System.Exception inner);
                /*0x2093810*/ ExternalException(string message, int errorCode);
                /*0x2093838*/ ExternalException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2093840*/ int get_ErrorCode();
                /*0x2093848*/ string ToString();
            }

            struct HandleRef
            {
                /*0x10*/ object _wrapper;
                /*0x18*/ nint _handle;

                static /*0x2093a50*/ nint op_Explicit(System.Runtime.InteropServices.HandleRef value);
                static /*0x2093a58*/ nint ToIntPtr(System.Runtime.InteropServices.HandleRef value);
                /*0x2093a38*/ HandleRef(object wrapper, nint handle);
                /*0x2093a40*/ object get_Wrapper();
                /*0x2093a48*/ nint get_Handle();
            }

            enum LayoutKind
            {
                Sequential = 0,
                Explicit = 2,
                Auto = 3,
            }

            class MarshalDirectiveException : System.SystemException
            {
                /*0x2093a60*/ MarshalDirectiveException();
                /*0x2093abc*/ MarshalDirectiveException(string message);
                /*0x2093ae0*/ MarshalDirectiveException(string message, System.Exception inner);
                /*0x2093b04*/ MarshalDirectiveException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class MemoryMarshal
            {
                static System.Span<byte> AsBytes<T>(System.Span<T> span);
                static System.ReadOnlySpan<byte> AsBytes<T>(System.ReadOnlySpan<T> span);
                static System.Memory<T> AsMemory<T>(System.ReadOnlyMemory<T> memory);
                static ref T GetReference<T>(System.Span<T> span);
                static ref T GetReference<T>(System.ReadOnlySpan<T> span);
                static ref T GetNonNullPinnableReference<T>(System.Span<T> span);
                static ref T GetNonNullPinnableReference<T>(System.ReadOnlySpan<T> span);
                static System.Span<TTo> Cast<TFrom, TTo>(System.Span<TFrom> span);
                static System.ReadOnlySpan<TTo> Cast<TFrom, TTo>(System.ReadOnlySpan<TFrom> span);
                static System.Span<T> CreateSpan<T>(ref T reference, int length);
                static System.ReadOnlySpan<T> CreateReadOnlySpan<T>(ref T reference, int length);
                static bool TryGetArray<T>(System.ReadOnlyMemory<T> memory, ref System.ArraySegment<T> segment);
                static bool TryGetMemoryManager<T, TManager>(System.ReadOnlyMemory<T> memory, ref TManager manager);
                static bool TryGetMemoryManager<T, TManager>(System.ReadOnlyMemory<T> memory, ref TManager manager, ref int start, ref int length);
                static System.Collections.Generic.IEnumerable<T> ToEnumerable<T>(System.ReadOnlyMemory<T> memory);
                static /*0x2093b0c*/ bool TryGetString(System.ReadOnlyMemory<char> memory, ref string text, ref int start, ref int length);
                static T Read<T>(System.ReadOnlySpan<byte> source);
                static bool TryRead<T>(System.ReadOnlySpan<byte> source, ref T value);
                static void Write<T>(System.Span<byte> destination, ref T value);
                static bool TryWrite<T>(System.Span<byte> destination, ref T value);
                static System.Memory<T> CreateFromPinnedArray<T>(T[] array, int start, int length);

                class <ToEnumerable>d__14<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ int <>1__state;
                    /*0x0*/ T <>2__current;
                    /*0x0*/ int <>l__initialThreadId;
                    /*0x0*/ System.ReadOnlyMemory<T> memory;
                    /*0x0*/ System.ReadOnlyMemory<T> <>3__memory;
                    /*0x0*/ int <i>5__2;

                    <ToEnumerable>d__14(int <>1__state);
                    void System.IDisposable.Dispose();
                    bool MoveNext();
                    T System.Collections.Generic.IEnumerator<T>.get_Current();
                    void System.Collections.IEnumerator.Reset();
                    object System.Collections.IEnumerator.get_Current();
                    System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                }
            }

            class SequenceMarshal
            {
                static bool TryGetReadOnlySequenceSegment<T>(System.Buffers.ReadOnlySequence<T> sequence, ref System.Buffers.ReadOnlySequenceSegment<T> startSegment, ref int startIndex, ref System.Buffers.ReadOnlySequenceSegment<T> endSegment, ref int endIndex);
                static bool TryGetArray<T>(System.Buffers.ReadOnlySequence<T> sequence, ref System.ArraySegment<T> segment);
                static bool TryGetReadOnlyMemory<T>(System.Buffers.ReadOnlySequence<T> sequence, ref System.ReadOnlyMemory<T> memory);
                static /*0x2093bb4*/ bool TryGetString(System.Buffers.ReadOnlySequence<char> sequence, ref string text, ref int start, ref int length);
                static bool TryRead<T>(ref System.Buffers.SequenceReader<byte> reader, ref T value);
            }

            enum Architecture
            {
                X86 = 0,
                X64 = 1,
                Arm = 2,
                Arm64 = 3,
            }

            struct OSPlatform : System.IEquatable<System.Runtime.InteropServices.OSPlatform>
            {
                static /*0x0*/ System.Runtime.InteropServices.OSPlatform <Linux>k__BackingField;
                static /*0x8*/ System.Runtime.InteropServices.OSPlatform <OSX>k__BackingField;
                static /*0x10*/ System.Runtime.InteropServices.OSPlatform <Windows>k__BackingField;
                /*0x10*/ string _osPlatform;

                static /*0x2093f98*/ OSPlatform();
                static /*0x2093c24*/ System.Runtime.InteropServices.OSPlatform get_Linux();
                static /*0x2093c7c*/ System.Runtime.InteropServices.OSPlatform get_OSX();
                static /*0x2093cd4*/ System.Runtime.InteropServices.OSPlatform get_Windows();
                static /*0x2093de8*/ System.Runtime.InteropServices.OSPlatform Create(string osPlatform);
                static /*0x2093f14*/ bool op_Equality(System.Runtime.InteropServices.OSPlatform left, System.Runtime.InteropServices.OSPlatform right);
                static /*0x2093f20*/ bool op_Inequality(System.Runtime.InteropServices.OSPlatform left, System.Runtime.InteropServices.OSPlatform right);
                /*0x2093d2c*/ OSPlatform(string osPlatform);
                /*0x2093e08*/ bool Equals(System.Runtime.InteropServices.OSPlatform other);
                /*0x2093e18*/ bool Equals(string other);
                /*0x2093e28*/ bool Equals(object obj);
                /*0x2093ea8*/ int GetHashCode();
                /*0x2093ec0*/ string ToString();
            }

            enum RegistrationConnectionType
            {
                SingleUse = 0,
                MultipleUse = 1,
                MultiSeparate = 2,
                Suspended = 4,
                Surrogate = 8,
            }

            enum GCHandleType
            {
                Weak = 0,
                WeakTrackResurrection = 1,
                Normal = 2,
                Pinned = 3,
            }

            class SafeBuffer : Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid
            {
                static /*0x0*/ nuint Uninitialized;
                /*0x20*/ nuint _numBytes;

                static /*0x2094920*/ SafeBuffer();
                static /*0x20948d0*/ void NotEnoughRoom();
                static /*0x20944d4*/ System.InvalidOperationException NotInitialized();
                static uint AlignedSizeOf<T>();
                static uint SizeOf<T>();
                /*0x2094080*/ SafeBuffer(bool ownsHandle);
                /*0x20940fc*/ void Initialize(ulong numBytes);
                /*0x209426c*/ void Initialize(uint numElements, uint sizeOfEachElement);
                void Initialize<T>(uint numElements);
                /*0x20943cc*/ void AcquirePointer(ref byte* pointer);
                /*0x2094618*/ void ReleasePointer();
                T Read<T>(ulong byteOffset);
                void ReadArray<T>(ulong byteOffset, T[] array, int index, int count);
                void Write<T>(ulong byteOffset, T value);
                void WriteArray<T>(ulong byteOffset, T[] array, int index, int count);
                /*0x20946fc*/ ulong get_ByteLength();
                /*0x20947ec*/ void SpaceCheck(byte* ptr, ulong sizeInBytes);
            }

            class COMException : System.Runtime.InteropServices.ExternalException
            {
                /*0x20949d0*/ COMException(int hr);
                /*0x20949f4*/ COMException();
                /*0x20949f8*/ COMException(string message);
                /*0x2094a1c*/ COMException(string message, System.Exception inner);
                /*0x2094a40*/ COMException(string message, int errorCode);
                /*0x2094a68*/ COMException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2094a70*/ string ToString();
            }

            class BStrWrapper
            {
                /*0x10*/ string m_WrappedObject;

                /*0x2094c60*/ BStrWrapper(string value);
                /*0x2094c88*/ BStrWrapper(object value);
                /*0x2094d08*/ string get_WrappedObject();
            }

            enum ComMemberType
            {
                Method = 0,
                PropGet = 1,
                PropSet = 2,
            }

            class CurrencyWrapper
            {
                /*0x10*/ decimal m_WrappedObject;

                /*0x2094d10*/ CurrencyWrapper(decimal obj);
                /*0x2094d3c*/ CurrencyWrapper(object obj);
                /*0x2094e10*/ decimal get_WrappedObject();
            }

            enum CustomQueryInterfaceMode
            {
                Ignore = 0,
                Allow = 1,
            }

            class ErrorWrapper
            {
                /*0x10*/ int m_ErrorCode;

                /*0x2094e1c*/ ErrorWrapper(int errorCode);
                /*0x2094e44*/ ErrorWrapper(object errorCode);
                /*0x2094f18*/ ErrorWrapper(System.Exception e);
                /*0x2094fa4*/ int get_ErrorCode();
            }

            interface ICustomAdapter
            {
                object GetUnderlyingObject();
            }

            interface ICustomFactory
            {
                System.MarshalByRefObject CreateInstance(System.Type serverType);
            }

            interface ICustomMarshaler
            {
                object MarshalNativeToManaged(nint pNativeData);
                nint MarshalManagedToNative(object ManagedObj);
                void CleanUpNativeData(nint pNativeData);
                void CleanUpManagedData(object ManagedObj);
                int GetNativeDataSize();
            }

            class InvalidComObjectException : System.SystemException
            {
                /*0x2094fac*/ InvalidComObjectException();
                /*0x2095008*/ InvalidComObjectException(string message);
                /*0x209502c*/ InvalidComObjectException(string message, System.Exception inner);
                /*0x2095050*/ InvalidComObjectException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class InvalidOleVariantTypeException : System.SystemException
            {
                /*0x2095058*/ InvalidOleVariantTypeException();
                /*0x20950b4*/ InvalidOleVariantTypeException(string message);
                /*0x20950d8*/ InvalidOleVariantTypeException(string message, System.Exception inner);
                /*0x20950fc*/ InvalidOleVariantTypeException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class SEHException : System.Runtime.InteropServices.ExternalException
            {
                /*0x2095104*/ SEHException();
                /*0x2095124*/ SEHException(string message);
                /*0x2095148*/ SEHException(string message, System.Exception inner);
                /*0x209516c*/ SEHException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x2095174*/ bool CanResume();
            }

            class SafeArrayRankMismatchException : System.SystemException
            {
                /*0x209517c*/ SafeArrayRankMismatchException();
                /*0x20951d8*/ SafeArrayRankMismatchException(string message);
                /*0x20951fc*/ SafeArrayRankMismatchException(string message, System.Exception inner);
                /*0x2095220*/ SafeArrayRankMismatchException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class SafeArrayTypeMismatchException : System.SystemException
            {
                /*0x2095228*/ SafeArrayTypeMismatchException();
                /*0x2095284*/ SafeArrayTypeMismatchException(string message);
                /*0x20952a8*/ SafeArrayTypeMismatchException(string message, System.Exception inner);
                /*0x20952cc*/ SafeArrayTypeMismatchException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class UnknownWrapper
            {
                /*0x10*/ object m_WrappedObject;

                /*0x20952d4*/ UnknownWrapper(object obj);
                /*0x20952fc*/ object get_WrappedObject();
            }

            class VariantWrapper
            {
                /*0x10*/ object m_WrappedObject;

                /*0x2095304*/ VariantWrapper(object obj);
                /*0x209532c*/ object get_WrappedObject();
            }

            struct ArrayWithOffset
            {
                /*0x10*/ object m_array;
                /*0x18*/ int m_offset;
                /*0x1c*/ int m_count;

                static /*0x2095514*/ bool op_Equality(System.Runtime.InteropServices.ArrayWithOffset a, System.Runtime.InteropServices.ArrayWithOffset b);
                static /*0x209553c*/ bool op_Inequality(System.Runtime.InteropServices.ArrayWithOffset a, System.Runtime.InteropServices.ArrayWithOffset b);
                /*0x2095334*/ ArrayWithOffset(object array, int offset);
                /*0x209542c*/ object GetArray();
                /*0x2095434*/ int GetOffset();
                /*0x209543c*/ int GetHashCode();
                /*0x2095448*/ bool Equals(object obj);
                /*0x20954e0*/ bool Equals(System.Runtime.InteropServices.ArrayWithOffset obj);
                /*0x2095354*/ int CalculateCount();
            }

            class UnmanagedFunctionPointerAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.CallingConvention m_callingConvention;
                /*0x14*/ System.Runtime.InteropServices.CharSet CharSet;
                /*0x18*/ bool BestFitMapping;
                /*0x19*/ bool ThrowOnUnmappableChar;
                /*0x1a*/ bool SetLastError;

                /*0x2095564*/ UnmanagedFunctionPointerAttribute(System.Runtime.InteropServices.CallingConvention callingConvention);
                /*0x209558c*/ System.Runtime.InteropServices.CallingConvention get_CallingConvention();
            }

            class TypeIdentifierAttribute : System.Attribute
            {
                /*0x10*/ string Scope_;
                /*0x18*/ string Identifier_;

                /*0x2095594*/ TypeIdentifierAttribute();
                /*0x209559c*/ TypeIdentifierAttribute(string scope, string identifier);
                /*0x20955c8*/ string get_Scope();
                /*0x20955d0*/ string get_Identifier();
            }

            class AllowReversePInvokeCallsAttribute : System.Attribute
            {
                /*0x20955d8*/ AllowReversePInvokeCallsAttribute();
            }

            class DispIdAttribute : System.Attribute
            {
                /*0x10*/ int _val;

                /*0x20955e0*/ DispIdAttribute(int dispId);
                /*0x2095608*/ int get_Value();
            }

            enum ComInterfaceType
            {
                InterfaceIsDual = 0,
                InterfaceIsIUnknown = 1,
                InterfaceIsIDispatch = 2,
                InterfaceIsIInspectable = 3,
            }

            class InterfaceTypeAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.ComInterfaceType _val;

                /*0x2095610*/ InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType interfaceType);
                /*0x2095638*/ InterfaceTypeAttribute(short interfaceType);
                /*0x2095664*/ System.Runtime.InteropServices.ComInterfaceType get_Value();
            }

            class ComDefaultInterfaceAttribute : System.Attribute
            {
                /*0x10*/ System.Type _val;

                /*0x209566c*/ ComDefaultInterfaceAttribute(System.Type defaultInterface);
                /*0x2095694*/ System.Type get_Value();
            }

            enum ClassInterfaceType
            {
                None = 0,
                AutoDispatch = 1,
                AutoDual = 2,
            }

            class ClassInterfaceAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.ClassInterfaceType _val;

                /*0x209569c*/ ClassInterfaceAttribute(System.Runtime.InteropServices.ClassInterfaceType classInterfaceType);
                /*0x20956c4*/ ClassInterfaceAttribute(short classInterfaceType);
                /*0x20956f0*/ System.Runtime.InteropServices.ClassInterfaceType get_Value();
            }

            class ComVisibleAttribute : System.Attribute
            {
                /*0x10*/ bool _val;

                /*0x20956f8*/ ComVisibleAttribute(bool visibility);
                /*0x2095720*/ bool get_Value();
            }

            class TypeLibImportClassAttribute : System.Attribute
            {
                /*0x10*/ string _importClassName;

                /*0x2095728*/ TypeLibImportClassAttribute(System.Type importClass);
                /*0x2095768*/ string get_Value();
            }

            class LCIDConversionAttribute : System.Attribute
            {
                /*0x10*/ int _val;

                /*0x2095770*/ LCIDConversionAttribute(int lcid);
                /*0x2095798*/ int get_Value();
            }

            class ComRegisterFunctionAttribute : System.Attribute
            {
                /*0x20957a0*/ ComRegisterFunctionAttribute();
            }

            class ComUnregisterFunctionAttribute : System.Attribute
            {
                /*0x20957a8*/ ComUnregisterFunctionAttribute();
            }

            class ProgIdAttribute : System.Attribute
            {
                /*0x10*/ string _val;

                /*0x20957b0*/ ProgIdAttribute(string progId);
                /*0x20957d8*/ string get_Value();
            }

            class ImportedFromTypeLibAttribute : System.Attribute
            {
                /*0x10*/ string _val;

                /*0x20957e0*/ ImportedFromTypeLibAttribute(string tlbFile);
                /*0x2095808*/ string get_Value();
            }

            enum IDispatchImplType
            {
                SystemDefinedImpl = 0,
                InternalImpl = 1,
                CompatibleImpl = 2,
            }

            class IDispatchImplAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.IDispatchImplType _val;

                /*0x2095810*/ IDispatchImplAttribute(System.Runtime.InteropServices.IDispatchImplType implType);
                /*0x2095838*/ IDispatchImplAttribute(short implType);
                /*0x2095864*/ System.Runtime.InteropServices.IDispatchImplType get_Value();
            }

            class ComSourceInterfacesAttribute : System.Attribute
            {
                /*0x10*/ string _val;

                /*0x209586c*/ ComSourceInterfacesAttribute(string sourceInterfaces);
                /*0x2095894*/ ComSourceInterfacesAttribute(System.Type sourceInterface);
                /*0x20958d8*/ ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2);
                /*0x2095984*/ ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2, System.Type sourceInterface3);
                /*0x2095b58*/ ComSourceInterfacesAttribute(System.Type sourceInterface1, System.Type sourceInterface2, System.Type sourceInterface3, System.Type sourceInterface4);
                /*0x2095da0*/ string get_Value();
            }

            class ComConversionLossAttribute : System.Attribute
            {
                /*0x2095da8*/ ComConversionLossAttribute();
            }

            enum TypeLibTypeFlags
            {
                FAppObject = 1,
                FCanCreate = 2,
                FLicensed = 4,
                FPreDeclId = 8,
                FHidden = 16,
                FControl = 32,
                FDual = 64,
                FNonExtensible = 128,
                FOleAutomation = 256,
                FRestricted = 512,
                FAggregatable = 1024,
                FReplaceable = 2048,
                FDispatchable = 4096,
                FReverseBind = 8192,
            }

            enum TypeLibFuncFlags
            {
                FRestricted = 1,
                FSource = 2,
                FBindable = 4,
                FRequestEdit = 8,
                FDisplayBind = 16,
                FDefaultBind = 32,
                FHidden = 64,
                FUsesGetLastError = 128,
                FDefaultCollelem = 256,
                FUiDefault = 512,
                FNonBrowsable = 1024,
                FReplaceable = 2048,
                FImmediateBind = 4096,
            }

            enum TypeLibVarFlags
            {
                FReadOnly = 1,
                FSource = 2,
                FBindable = 4,
                FRequestEdit = 8,
                FDisplayBind = 16,
                FDefaultBind = 32,
                FHidden = 64,
                FRestricted = 128,
                FDefaultCollelem = 256,
                FUiDefault = 512,
                FNonBrowsable = 1024,
                FReplaceable = 2048,
                FImmediateBind = 4096,
            }

            class TypeLibTypeAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.TypeLibTypeFlags _val;

                /*0x2095db0*/ TypeLibTypeAttribute(System.Runtime.InteropServices.TypeLibTypeFlags flags);
                /*0x2095dd8*/ TypeLibTypeAttribute(short flags);
                /*0x2095e04*/ System.Runtime.InteropServices.TypeLibTypeFlags get_Value();
            }

            class TypeLibFuncAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.TypeLibFuncFlags _val;

                /*0x2095e0c*/ TypeLibFuncAttribute(System.Runtime.InteropServices.TypeLibFuncFlags flags);
                /*0x2095e34*/ TypeLibFuncAttribute(short flags);
                /*0x2095e60*/ System.Runtime.InteropServices.TypeLibFuncFlags get_Value();
            }

            class TypeLibVarAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.TypeLibVarFlags _val;

                /*0x2095e68*/ TypeLibVarAttribute(System.Runtime.InteropServices.TypeLibVarFlags flags);
                /*0x2095e90*/ TypeLibVarAttribute(short flags);
                /*0x2095ebc*/ System.Runtime.InteropServices.TypeLibVarFlags get_Value();
            }

            enum VarEnum
            {
                VT_EMPTY = 0,
                VT_NULL = 1,
                VT_I2 = 2,
                VT_I4 = 3,
                VT_R4 = 4,
                VT_R8 = 5,
                VT_CY = 6,
                VT_DATE = 7,
                VT_BSTR = 8,
                VT_DISPATCH = 9,
                VT_ERROR = 10,
                VT_BOOL = 11,
                VT_VARIANT = 12,
                VT_UNKNOWN = 13,
                VT_DECIMAL = 14,
                VT_I1 = 16,
                VT_UI1 = 17,
                VT_UI2 = 18,
                VT_UI4 = 19,
                VT_I8 = 20,
                VT_UI8 = 21,
                VT_INT = 22,
                VT_UINT = 23,
                VT_VOID = 24,
                VT_HRESULT = 25,
                VT_PTR = 26,
                VT_SAFEARRAY = 27,
                VT_CARRAY = 28,
                VT_USERDEFINED = 29,
                VT_LPSTR = 30,
                VT_LPWSTR = 31,
                VT_RECORD = 36,
                VT_FILETIME = 64,
                VT_BLOB = 65,
                VT_STREAM = 66,
                VT_STORAGE = 67,
                VT_STREAMED_OBJECT = 68,
                VT_STORED_OBJECT = 69,
                VT_BLOB_OBJECT = 70,
                VT_CF = 71,
                VT_CLSID = 72,
                VT_VECTOR = 4096,
                VT_ARRAY = 8192,
                VT_BYREF = 16384,
            }

            enum UnmanagedType
            {
                Bool = 2,
                I1 = 3,
                U1 = 4,
                I2 = 5,
                U2 = 6,
                I4 = 7,
                U4 = 8,
                I8 = 9,
                U8 = 10,
                R4 = 11,
                R8 = 12,
                Currency = 15,
                BStr = 19,
                LPStr = 20,
                LPWStr = 21,
                LPTStr = 22,
                ByValTStr = 23,
                IUnknown = 25,
                IDispatch = 26,
                Struct = 27,
                Interface = 28,
                SafeArray = 29,
                ByValArray = 30,
                SysInt = 31,
                SysUInt = 32,
                VBByRefStr = 34,
                AnsiBStr = 35,
                TBStr = 36,
                VariantBool = 37,
                FunctionPtr = 38,
                AsAny = 40,
                LPArray = 42,
                LPStruct = 43,
                CustomMarshaler = 44,
                Error = 45,
                IInspectable = 46,
                HString = 47,
                LPUTF8Str = 48,
            }

            class ComImportAttribute : System.Attribute
            {
                static /*0x2095ec4*/ System.Attribute GetCustomAttribute(System.RuntimeType type);
                static /*0x2095f44*/ bool IsDefined(System.RuntimeType type);
                /*0x2095f3c*/ ComImportAttribute();
            }

            class GuidAttribute : System.Attribute
            {
                /*0x10*/ string _val;

                /*0x2095f64*/ GuidAttribute(string guid);
                /*0x2095f8c*/ string get_Value();
            }

            class PreserveSigAttribute : System.Attribute
            {
                static /*0x2095f94*/ System.Attribute GetCustomAttribute(System.Reflection.RuntimeMethodInfo method);
                static /*0x2096020*/ bool IsDefined(System.Reflection.RuntimeMethodInfo method);
                /*0x2096018*/ PreserveSigAttribute();
            }

            class InAttribute : System.Attribute
            {
                static /*0x2096048*/ System.Attribute GetCustomAttribute(System.Reflection.RuntimeParameterInfo parameter);
                static /*0x20960c8*/ bool IsDefined(System.Reflection.RuntimeParameterInfo parameter);
                /*0x20960c0*/ InAttribute();
            }

            class OutAttribute : System.Attribute
            {
                static /*0x20960dc*/ System.Attribute GetCustomAttribute(System.Reflection.RuntimeParameterInfo parameter);
                static /*0x209615c*/ bool IsDefined(System.Reflection.RuntimeParameterInfo parameter);
                /*0x2096154*/ OutAttribute();
            }

            class OptionalAttribute : System.Attribute
            {
                static /*0x2096170*/ System.Attribute GetCustomAttribute(System.Reflection.RuntimeParameterInfo parameter);
                static /*0x20961f0*/ bool IsDefined(System.Reflection.RuntimeParameterInfo parameter);
                /*0x20961e8*/ OptionalAttribute();
            }

            enum DllImportSearchPath
            {
                UseDllDirectoryForDependencies = 256,
                ApplicationDirectory = 512,
                UserDirectories = 1024,
                System32 = 2048,
                SafeDirectories = 4096,
                AssemblyDirectory = 2,
                LegacyBehavior = 0,
            }

            class DefaultDllImportSearchPathsAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.DllImportSearchPath _paths;

                /*0x2096204*/ DefaultDllImportSearchPathsAttribute(System.Runtime.InteropServices.DllImportSearchPath paths);
                /*0x209622c*/ System.Runtime.InteropServices.DllImportSearchPath get_Paths();
            }

            class DllImportAttribute : System.Attribute
            {
                /*0x10*/ string _val;
                /*0x18*/ string EntryPoint;
                /*0x20*/ System.Runtime.InteropServices.CharSet CharSet;
                /*0x24*/ bool SetLastError;
                /*0x25*/ bool ExactSpelling;
                /*0x26*/ bool PreserveSig;
                /*0x28*/ System.Runtime.InteropServices.CallingConvention CallingConvention;
                /*0x2c*/ bool BestFitMapping;
                /*0x2d*/ bool ThrowOnUnmappableChar;

                static /*0x2096234*/ System.Attribute GetCustomAttribute(System.Reflection.RuntimeMethodInfo method);
                static /*0x2096478*/ bool IsDefined(System.Reflection.RuntimeMethodInfo method);
                /*0x20963ec*/ DllImportAttribute(string dllName, string entryPoint, System.Runtime.InteropServices.CharSet charSet, bool exactSpelling, bool setLastError, bool preserveSig, System.Runtime.InteropServices.CallingConvention callingConvention, bool bestFitMapping, bool throwOnUnmappableChar);
                /*0x20964a0*/ DllImportAttribute(string dllName);
                /*0x20964c8*/ string get_Value();
            }

            class StructLayoutAttribute : System.Attribute
            {
                static int DEFAULT_PACKING_SIZE = 8;
                /*0x10*/ System.Runtime.InteropServices.LayoutKind _val;
                /*0x14*/ int Pack;
                /*0x18*/ int Size;
                /*0x1c*/ System.Runtime.InteropServices.CharSet CharSet;

                static /*0x20964d0*/ System.Runtime.InteropServices.StructLayoutAttribute GetCustomAttribute(System.RuntimeType type);
                static /*0x20965f0*/ bool IsDefined(System.RuntimeType type);
                /*0x2096648*/ StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind layoutKind, int pack, int size, System.Runtime.InteropServices.CharSet charSet);
                /*0x2096688*/ StructLayoutAttribute(System.Runtime.InteropServices.LayoutKind layoutKind);
                /*0x20966b0*/ StructLayoutAttribute(short layoutKind);
                /*0x20966dc*/ System.Runtime.InteropServices.LayoutKind get_Value();
            }

            class FieldOffsetAttribute : System.Attribute
            {
                /*0x10*/ int _val;

                static /*0x20966e4*/ System.Attribute GetCustomAttribute(System.Reflection.RuntimeFieldInfo field);
                static /*0x20967f0*/ bool IsDefined(System.Reflection.RuntimeFieldInfo field);
                /*0x20967c8*/ FieldOffsetAttribute(int offset);
                /*0x2096808*/ int get_Value();
            }

            class ComAliasNameAttribute : System.Attribute
            {
                /*0x10*/ string _val;

                /*0x2096810*/ ComAliasNameAttribute(string alias);
                /*0x2096838*/ string get_Value();
            }

            class AutomationProxyAttribute : System.Attribute
            {
                /*0x10*/ bool _val;

                /*0x2096840*/ AutomationProxyAttribute(bool val);
                /*0x2096868*/ bool get_Value();
            }

            class PrimaryInteropAssemblyAttribute : System.Attribute
            {
                /*0x10*/ int _major;
                /*0x14*/ int _minor;

                /*0x2096870*/ PrimaryInteropAssemblyAttribute(int major, int minor);
                /*0x209689c*/ int get_MajorVersion();
                /*0x20968a4*/ int get_MinorVersion();
            }

            class CoClassAttribute : System.Attribute
            {
                /*0x10*/ System.Type _CoClass;

                /*0x20968ac*/ CoClassAttribute(System.Type coClass);
                /*0x20968d4*/ System.Type get_CoClass();
            }

            class ComEventInterfaceAttribute : System.Attribute
            {
                /*0x10*/ System.Type _SourceInterface;
                /*0x18*/ System.Type _EventProvider;

                /*0x20968dc*/ ComEventInterfaceAttribute(System.Type SourceInterface, System.Type EventProvider);
                /*0x2096908*/ System.Type get_SourceInterface();
                /*0x2096910*/ System.Type get_EventProvider();
            }

            class TypeLibVersionAttribute : System.Attribute
            {
                /*0x10*/ int _major;
                /*0x14*/ int _minor;

                /*0x2096918*/ TypeLibVersionAttribute(int major, int minor);
                /*0x2096944*/ int get_MajorVersion();
                /*0x209694c*/ int get_MinorVersion();
            }

            class ComCompatibleVersionAttribute : System.Attribute
            {
                /*0x10*/ int _major;
                /*0x14*/ int _minor;
                /*0x18*/ int _build;
                /*0x1c*/ int _revision;

                /*0x2096954*/ ComCompatibleVersionAttribute(int major, int minor, int build, int revision);
                /*0x2096994*/ int get_MajorVersion();
                /*0x209699c*/ int get_MinorVersion();
                /*0x20969a4*/ int get_BuildNumber();
                /*0x20969ac*/ int get_RevisionNumber();
            }

            class BestFitMappingAttribute : System.Attribute
            {
                /*0x10*/ bool _bestFitMapping;
                /*0x11*/ bool ThrowOnUnmappableChar;

                /*0x20969b4*/ BestFitMappingAttribute(bool BestFitMapping);
                /*0x20969dc*/ bool get_BestFitMapping();
            }

            class DefaultCharSetAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.InteropServices.CharSet _CharSet;

                /*0x20969e4*/ DefaultCharSetAttribute(System.Runtime.InteropServices.CharSet charSet);
                /*0x2096a0c*/ System.Runtime.InteropServices.CharSet get_CharSet();
            }

            class SetWin32ContextInIDispatchAttribute : System.Attribute
            {
                /*0x2096a14*/ SetWin32ContextInIDispatchAttribute();
            }

            class ManagedToNativeComInteropStubAttribute : System.Attribute
            {
                /*0x10*/ System.Type _classType;
                /*0x18*/ string _methodName;

                /*0x2096a1c*/ ManagedToNativeComInteropStubAttribute(System.Type classType, string methodName);
                /*0x2096a48*/ System.Type get_ClassType();
                /*0x2096a50*/ string get_MethodName();
            }

            enum CallingConvention
            {
                Winapi = 1,
                Cdecl = 2,
                StdCall = 3,
                ThisCall = 4,
                FastCall = 5,
            }

            class CriticalHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
            {
                /*0x10*/ nint handle;
                /*0x18*/ bool _isClosed;

                static /*0x2096c10*/ void FireCustomerDebugProbe();
                /*0x2096a58*/ CriticalHandle(nint invalidHandleValue);
                /*0x2096a84*/ void Finalize();
                /*0x2096b24*/ void Cleanup();
                /*0x2096c18*/ void SetHandle(nint handle);
                /*0x2096c20*/ bool get_IsClosed();
                bool get_IsInvalid();
                /*0x2096c28*/ void Close();
                /*0x2096c38*/ void Dispose();
                /*0x2096c48*/ void Dispose(bool disposing);
                /*0x2096c4c*/ void SetHandleAsInvalid();
                bool ReleaseHandle();
            }

            class DispatchWrapper
            {
                /*0x10*/ object m_WrappedObject;

                /*0x2096cac*/ DispatchWrapper(object obj);
                /*0x2096d14*/ object get_WrappedObject();
            }

            enum CustomQueryInterfaceResult
            {
                Handled = 0,
                NotHandled = 1,
                Failed = 2,
            }

            interface ICustomQueryInterface
            {
                System.Runtime.InteropServices.CustomQueryInterfaceResult GetInterface(ref System.Guid iid, ref nint ppv);
            }

            enum AssemblyRegistrationFlags
            {
                None = 0,
                SetCodeBase = 1,
            }

            interface IRegistrationServices
            {
                bool RegisterAssembly(System.Reflection.Assembly assembly, System.Runtime.InteropServices.AssemblyRegistrationFlags flags);
                bool UnregisterAssembly(System.Reflection.Assembly assembly);
                System.Type[] GetRegistrableTypesInAssembly(System.Reflection.Assembly assembly);
                string GetProgIdForType(System.Type type);
                void RegisterTypeForComClients(System.Type type, ref System.Guid g);
                System.Guid GetManagedCategoryGuid();
                bool TypeRequiresRegistration(System.Type type);
                bool TypeRepresentsComType(System.Type type);
            }

            class ObjectCreationDelegate : System.MulticastDelegate
            {
                /*0x2096d1c*/ ObjectCreationDelegate(object object, nint method);
                /*0x2096de0*/ nint Invoke(nint aggregator);
                /*0x2096df4*/ System.IAsyncResult BeginInvoke(nint aggregator, System.AsyncCallback callback, object object);
                /*0x2096e78*/ nint EndInvoke(System.IAsyncResult result);
            }

            class RuntimeEnvironment
            {
                static /*0x2096ea8*/ bool FromGlobalAccessCache(System.Reflection.Assembly a);
                static /*0x2096ec8*/ string GetSystemVersion();
                static /*0x2096f20*/ string GetRuntimeDirectory();
                static /*0x2096f24*/ string GetRuntimeDirectoryImpl();
                static /*0x2096ff4*/ string get_SystemConfigurationFile();
                static /*0x2096ffc*/ nint GetRuntimeInterfaceImpl(System.Guid clsid, System.Guid riid);
                static /*0x209703c*/ nint GetRuntimeInterfaceAsIntPtr(System.Guid clsid, System.Guid riid);
                static /*0x2097044*/ object GetRuntimeInterfaceAsObject(System.Guid clsid, System.Guid riid);
                /*0x2096ea0*/ RuntimeEnvironment();
            }

            class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.IDisposable
            {
                static int RefCount_Mask = 2147483644;
                static int RefCount_One = 4;
                /*0x10*/ nint handle;
                /*0x18*/ int _state;
                /*0x1c*/ bool _ownsHandle;
                /*0x1d*/ bool _fullyInitialized;

                /*0x20971e4*/ SafeHandle(nint invalidHandleValue, bool ownsHandle);
                /*0x209727c*/ SafeHandle();
                /*0x20972c4*/ void Finalize();
                /*0x2097364*/ void SetHandle(nint handle);
                /*0x209736c*/ nint DangerousGetHandle();
                /*0x2097374*/ bool get_IsClosed();
                bool get_IsInvalid();
                /*0x2097380*/ void Close();
                /*0x2097390*/ void Dispose();
                /*0x20973a0*/ void Dispose(bool disposing);
                bool ReleaseHandle();
                /*0x2097478*/ void SetHandleAsInvalid();
                /*0x2094548*/ void DangerousAddRef(ref bool success);
                /*0x20946f4*/ void DangerousRelease();
                /*0x20973bc*/ void InternalDispose();
                /*0x2097464*/ void InternalFinalize();
                /*0x20974fc*/ void DangerousReleaseInternal(bool dispose);
            }

            struct CONNECTDATA
            {
                /*0x10*/ object pUnk;
                /*0x18*/ int dwCookie;
            }

            enum TYPEKIND
            {
                TKIND_ENUM = 0,
                TKIND_RECORD = 1,
                TKIND_MODULE = 2,
                TKIND_INTERFACE = 3,
                TKIND_DISPATCH = 4,
                TKIND_COCLASS = 5,
                TKIND_ALIAS = 6,
                TKIND_UNION = 7,
                TKIND_MAX = 8,
            }

            enum TYPEFLAGS
            {
                TYPEFLAG_FAPPOBJECT = 1,
                TYPEFLAG_FCANCREATE = 2,
                TYPEFLAG_FLICENSED = 4,
                TYPEFLAG_FPREDECLID = 8,
                TYPEFLAG_FHIDDEN = 16,
                TYPEFLAG_FCONTROL = 32,
                TYPEFLAG_FDUAL = 64,
                TYPEFLAG_FNONEXTENSIBLE = 128,
                TYPEFLAG_FOLEAUTOMATION = 256,
                TYPEFLAG_FRESTRICTED = 512,
                TYPEFLAG_FAGGREGATABLE = 1024,
                TYPEFLAG_FREPLACEABLE = 2048,
                TYPEFLAG_FDISPATCHABLE = 4096,
                TYPEFLAG_FREVERSEBIND = 8192,
                TYPEFLAG_FPROXY = 16384,
            }

            enum IMPLTYPEFLAGS
            {
                IMPLTYPEFLAG_FDEFAULT = 1,
                IMPLTYPEFLAG_FSOURCE = 2,
                IMPLTYPEFLAG_FRESTRICTED = 4,
                IMPLTYPEFLAG_FDEFAULTVTABLE = 8,
            }

            struct TYPEATTR
            {
                static int MEMBER_ID_NIL = -1;
                /*0x10*/ System.Guid guid;
                /*0x20*/ int lcid;
                /*0x24*/ int dwReserved;
                /*0x28*/ int memidConstructor;
                /*0x2c*/ int memidDestructor;
                /*0x30*/ nint lpstrSchema;
                /*0x38*/ int cbSizeInstance;
                /*0x3c*/ System.Runtime.InteropServices.TYPEKIND typekind;
                /*0x40*/ short cFuncs;
                /*0x42*/ short cVars;
                /*0x44*/ short cImplTypes;
                /*0x46*/ short cbSizeVft;
                /*0x48*/ short cbAlignment;
                /*0x4a*/ System.Runtime.InteropServices.TYPEFLAGS wTypeFlags;
                /*0x4c*/ short wMajorVerNum;
                /*0x4e*/ short wMinorVerNum;
                /*0x50*/ System.Runtime.InteropServices.TYPEDESC tdescAlias;
                /*0x60*/ System.Runtime.InteropServices.IDLDESC idldescType;
            }

            struct FUNCDESC
            {
                /*0x10*/ int memid;
                /*0x18*/ nint lprgscode;
                /*0x20*/ nint lprgelemdescParam;
                /*0x28*/ System.Runtime.InteropServices.FUNCKIND funckind;
                /*0x2c*/ System.Runtime.InteropServices.INVOKEKIND invkind;
                /*0x30*/ System.Runtime.InteropServices.CALLCONV callconv;
                /*0x34*/ short cParams;
                /*0x36*/ short cParamsOpt;
                /*0x38*/ short oVft;
                /*0x3a*/ short cScodes;
                /*0x40*/ System.Runtime.InteropServices.ELEMDESC elemdescFunc;
                /*0x60*/ short wFuncFlags;
            }

            enum IDLFLAG
            {
                IDLFLAG_NONE = 0,
                IDLFLAG_FIN = 1,
                IDLFLAG_FOUT = 2,
                IDLFLAG_FLCID = 4,
                IDLFLAG_FRETVAL = 8,
            }

            struct IDLDESC
            {
                /*0x10*/ int dwReserved;
                /*0x14*/ System.Runtime.InteropServices.IDLFLAG wIDLFlags;
            }

            enum PARAMFLAG
            {
                PARAMFLAG_NONE = 0,
                PARAMFLAG_FIN = 1,
                PARAMFLAG_FOUT = 2,
                PARAMFLAG_FLCID = 4,
                PARAMFLAG_FRETVAL = 8,
                PARAMFLAG_FOPT = 16,
                PARAMFLAG_FHASDEFAULT = 32,
                PARAMFLAG_FHASCUSTDATA = 64,
            }

            struct PARAMDESC
            {
                /*0x10*/ nint lpVarValue;
                /*0x18*/ System.Runtime.InteropServices.PARAMFLAG wParamFlags;
            }

            struct TYPEDESC
            {
                /*0x10*/ nint lpValue;
                /*0x18*/ short vt;
            }

            struct ELEMDESC
            {
                /*0x10*/ System.Runtime.InteropServices.TYPEDESC tdesc;
                /*0x20*/ System.Runtime.InteropServices.ELEMDESC.DESCUNION desc;

                struct DESCUNION
                {
                    /*0x10*/ System.Runtime.InteropServices.IDLDESC idldesc;
                    /*0x10*/ System.Runtime.InteropServices.PARAMDESC paramdesc;
                }
            }

            struct VARDESC
            {
                /*0x10*/ int memid;
                /*0x18*/ string lpstrSchema;
                /*0x20*/ System.Runtime.InteropServices.ELEMDESC elemdescVar;
                /*0x40*/ short wVarFlags;
                /*0x44*/ System.Runtime.InteropServices.VarEnum varkind;
            }

            struct DISPPARAMS
            {
                /*0x10*/ nint rgvarg;
                /*0x18*/ nint rgdispidNamedArgs;
                /*0x20*/ int cArgs;
                /*0x24*/ int cNamedArgs;
            }

            struct EXCEPINFO
            {
                /*0x10*/ short wCode;
                /*0x12*/ short wReserved;
                /*0x18*/ string bstrSource;
                /*0x20*/ string bstrDescription;
                /*0x28*/ string bstrHelpFile;
                /*0x30*/ int dwHelpContext;
                /*0x38*/ nint pvReserved;
                /*0x40*/ nint pfnDeferredFillIn;
            }

            enum FUNCKIND
            {
                FUNC_VIRTUAL = 0,
                FUNC_PUREVIRTUAL = 1,
                FUNC_NONVIRTUAL = 2,
                FUNC_STATIC = 3,
                FUNC_DISPATCH = 4,
            }

            enum INVOKEKIND
            {
                INVOKE_FUNC = 1,
                INVOKE_PROPERTYGET = 2,
                INVOKE_PROPERTYPUT = 4,
                INVOKE_PROPERTYPUTREF = 8,
            }

            enum CALLCONV
            {
                CC_CDECL = 1,
                CC_MSCPASCAL = 2,
                CC_PASCAL = 2,
                CC_MACPASCAL = 3,
                CC_STDCALL = 4,
                CC_RESERVED = 5,
                CC_SYSCALL = 6,
                CC_MPWCDECL = 7,
                CC_MPWPASCAL = 8,
                CC_MAX = 9,
            }

            enum FUNCFLAGS
            {
                FUNCFLAG_FRESTRICTED = 1,
                FUNCFLAG_FSOURCE = 2,
                FUNCFLAG_FBINDABLE = 4,
                FUNCFLAG_FREQUESTEDIT = 8,
                FUNCFLAG_FDISPLAYBIND = 16,
                FUNCFLAG_FDEFAULTBIND = 32,
                FUNCFLAG_FHIDDEN = 64,
                FUNCFLAG_FUSESGETLASTERROR = 128,
                FUNCFLAG_FDEFAULTCOLLELEM = 256,
                FUNCFLAG_FUIDEFAULT = 512,
                FUNCFLAG_FNONBROWSABLE = 1024,
                FUNCFLAG_FREPLACEABLE = 2048,
                FUNCFLAG_FIMMEDIATEBIND = 4096,
            }

            enum VARFLAGS
            {
                VARFLAG_FREADONLY = 1,
                VARFLAG_FSOURCE = 2,
                VARFLAG_FBINDABLE = 4,
                VARFLAG_FREQUESTEDIT = 8,
                VARFLAG_FDISPLAYBIND = 16,
                VARFLAG_FDEFAULTBIND = 32,
                VARFLAG_FHIDDEN = 64,
                VARFLAG_FRESTRICTED = 128,
                VARFLAG_FDEFAULTCOLLELEM = 256,
                VARFLAG_FUIDEFAULT = 512,
                VARFLAG_FNONBROWSABLE = 1024,
                VARFLAG_FREPLACEABLE = 2048,
                VARFLAG_FIMMEDIATEBIND = 4096,
            }

            class RuntimeInformation
            {
                static /*0x0*/ System.Runtime.InteropServices.Architecture _osArchitecture;
                static /*0x4*/ System.Runtime.InteropServices.Architecture _processArchitecture;
                static /*0x8*/ System.Runtime.InteropServices.OSPlatform _osPlatform;

                static /*0x209766c*/ RuntimeInformation();
                static /*0x2097d30*/ string GetRuntimeArchitecture();
                static /*0x2097d34*/ string GetOSName();
                static /*0x2097d38*/ string get_FrameworkDescription();
                static /*0x2097db0*/ bool IsOSPlatform(System.Runtime.InteropServices.OSPlatform osPlatform);
                static /*0x2097e44*/ string get_OSDescription();
                static /*0x2097e64*/ System.Runtime.InteropServices.Architecture get_OSArchitecture();
                static /*0x2097ebc*/ System.Runtime.InteropServices.Architecture get_ProcessArchitecture();
            }

            struct BINDPTR
            {
                /*0x10*/ nint lpfuncdesc;
                /*0x10*/ nint lptcomp;
                /*0x10*/ nint lpvardesc;
            }

            struct BIND_OPTS
            {
                /*0x10*/ int cbStruct;
                /*0x14*/ int grfFlags;
                /*0x18*/ int grfMode;
                /*0x1c*/ int dwTickCountDeadline;
            }

            class ComEventsHelper
            {
                static /*0x2097f14*/ void Combine(object rcw, System.Guid iid, int dispid, System.Delegate d);
                static /*0x2097f54*/ System.Delegate Remove(object rcw, System.Guid iid, int dispid, System.Delegate d);
            }

            enum DESCKIND
            {
                DESCKIND_NONE = 0,
                DESCKIND_FUNCDESC = 1,
                DESCKIND_VARDESC = 2,
                DESCKIND_TYPECOMP = 3,
                DESCKIND_IMPLICITAPPOBJ = 4,
                DESCKIND_MAX = 5,
            }

            enum ExporterEventKind
            {
                NOTIF_TYPECONVERTED = 0,
                NOTIF_CONVERTWARNING = 1,
                ERROR_REFTOINVALIDASSEMBLY = 2,
            }

            class ExtensibleClassFactory
            {
                static /*0x0*/ System.Collections.Hashtable hashtable;

                static /*0x20981dc*/ ExtensibleClassFactory();
                static /*0x2097f9c*/ System.Runtime.InteropServices.ObjectCreationDelegate GetObjectCreationCallback(System.Type t);
                static /*0x209803c*/ void RegisterObjectCreationCallback(System.Runtime.InteropServices.ObjectCreationDelegate callback);
                /*0x2097f94*/ ExtensibleClassFactory();
            }

            struct FILETIME
            {
                /*0x10*/ int dwLowDateTime;
                /*0x14*/ int dwHighDateTime;
            }

            struct GCHandle
            {
                /*0x10*/ nint handle;

                static /*0x2098510*/ System.Runtime.InteropServices.GCHandle Alloc(object value);
                static /*0x2098564*/ System.Runtime.InteropServices.GCHandle Alloc(object value, System.Runtime.InteropServices.GCHandleType type);
                static /*0x20986ac*/ nint op_Explicit(System.Runtime.InteropServices.GCHandle value);
                static /*0x20986b0*/ System.Runtime.InteropServices.GCHandle op_Explicit(nint value);
                static /*0x20987a0*/ bool CheckCurrentDomain(nint handle);
                static /*0x20983f8*/ object GetTarget(nint handle);
                static /*0x2098338*/ nint GetTargetHandle(object obj, nint handle, System.Runtime.InteropServices.GCHandleType type);
                static /*0x20986a8*/ void FreeHandle(nint handle);
                static /*0x209850c*/ nint GetAddrOfPinnedObject(nint handle);
                static /*0x20987a4*/ bool op_Equality(System.Runtime.InteropServices.GCHandle a, System.Runtime.InteropServices.GCHandle b);
                static /*0x20987ac*/ bool op_Inequality(System.Runtime.InteropServices.GCHandle a, System.Runtime.InteropServices.GCHandle b);
                static /*0x2098850*/ System.Runtime.InteropServices.GCHandle FromIntPtr(nint value);
                static /*0x2098854*/ nint ToIntPtr(System.Runtime.InteropServices.GCHandle value);
                /*0x2098254*/ GCHandle(nint h);
                /*0x209825c*/ GCHandle(object obj);
                /*0x20982c4*/ GCHandle(object value, System.Runtime.InteropServices.GCHandleType type);
                /*0x209833c*/ bool get_IsAllocated();
                /*0x2098390*/ object get_Target();
                /*0x20983fc*/ void set_Target(object value);
                /*0x2098424*/ nint AddrOfPinnedObject();
                /*0x20985cc*/ void Free();
                /*0x20987c8*/ bool Equals(object o);
                /*0x2098848*/ int GetHashCode();
            }

            enum ImporterEventKind
            {
                NOTIF_TYPECONVERTED = 0,
                NOTIF_CONVERTWARNING = 1,
                ERROR_REFTOINVALIDTYPELIB = 2,
            }

            enum LIBFLAGS
            {
                LIBFLAG_FRESTRICTED = 1,
                LIBFLAG_FCONTROL = 2,
                LIBFLAG_FHIDDEN = 4,
                LIBFLAG_FHASDISKIMAGE = 8,
            }

            class Marshal
            {
                static /*0x0*/ int SystemMaxDBCSCharSize;
                static /*0x4*/ int SystemDefaultCharSize;
                static /*0x8*/ System.Collections.Generic.Dictionary<System.ValueTuple<System.Type, string>, System.Runtime.InteropServices.ICustomMarshaler> MarshalerInstanceCache;
                static /*0x10*/ object MarshalerInstanceCacheLock;

                static /*0x209edf4*/ Marshal();
                static /*0x2098858*/ int AddRefInternal(nint pUnk);
                static /*0x209885c*/ int AddRef(nint pUnk);
                static /*0x209892c*/ bool AreComObjectsAvailableForCleanup();
                static /*0x2098934*/ void CleanupUnusedObjectsInCurrentContext();
                static /*0x2098988*/ nint AllocCoTaskMem(int cb);
                static /*0x209898c*/ nint AllocCoTaskMemSize(nuint sizet);
                static /*0x2098990*/ nint AllocHGlobal(nint cb);
                static /*0x2098994*/ nint AllocHGlobal(int cb);
                static /*0x20989fc*/ object BindToMoniker(string monikerName);
                static /*0x2098a3c*/ void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
                static /*0x2098a7c*/ void copy_to_unmanaged(System.Array source, int startIndex, nint destination, int length);
                static /*0x2098afc*/ void copy_to_unmanaged_fixed(System.Array source, int startIndex, nint destination, int length, void* fixed_source_element);
                static /*0x2098b00*/ bool skip_fixed(System.Array array, int startIndex);
                static /*0x2098b34*/ void copy_to_unmanaged(byte[] source, int startIndex, nint destination, int length);
                static /*0x2098c1c*/ void copy_to_unmanaged(char[] source, int startIndex, nint destination, int length);
                static /*0x2098d04*/ void Copy(byte[] source, int startIndex, nint destination, int length);
                static /*0x2098df8*/ void Copy(char[] source, int startIndex, nint destination, int length);
                static /*0x2098eec*/ void Copy(short[] source, int startIndex, nint destination, int length);
                static /*0x2098fe0*/ void Copy(int[] source, int startIndex, nint destination, int length);
                static /*0x20990d4*/ void Copy(long[] source, int startIndex, nint destination, int length);
                static /*0x20991c8*/ void Copy(float[] source, int startIndex, nint destination, int length);
                static /*0x20992bc*/ void Copy(double[] source, int startIndex, nint destination, int length);
                static /*0x20993b0*/ void Copy(nint[] source, int startIndex, nint destination, int length);
                static /*0x20994a4*/ void copy_from_unmanaged(nint source, int startIndex, System.Array destination, int length);
                static /*0x2099524*/ void copy_from_unmanaged_fixed(nint source, int startIndex, System.Array destination, int length, void* fixed_destination_element);
                static /*0x2099528*/ void Copy(nint source, byte[] destination, int startIndex, int length);
                static /*0x209961c*/ void Copy(nint source, char[] destination, int startIndex, int length);
                static /*0x2099710*/ void Copy(nint source, short[] destination, int startIndex, int length);
                static /*0x2099804*/ void Copy(nint source, int[] destination, int startIndex, int length);
                static /*0x20998f8*/ void Copy(nint source, long[] destination, int startIndex, int length);
                static /*0x20999ec*/ void Copy(nint source, float[] destination, int startIndex, int length);
                static /*0x2099ae0*/ void Copy(nint source, double[] destination, int startIndex, int length);
                static /*0x2099bd4*/ void Copy(nint source, nint[] destination, int startIndex, int length);
                static /*0x2099cc8*/ nint CreateAggregatedObject(nint pOuter, object o);
                static nint CreateAggregatedObject<T>(nint pOuter, T o);
                static /*0x2099d08*/ object CreateWrapperOfType(object o, System.Type t);
                static TWrapper CreateWrapperOfType<T, TWrapper>(T o);
                static /*0x2099d58*/ void DestroyStructure(nint ptr, System.Type structuretype);
                static void DestroyStructure<T>(nint ptr);
                static /*0x2099d5c*/ void FreeBSTR(nint ptr);
                static /*0x2099d60*/ void FreeCoTaskMem(nint ptr);
                static /*0x2099d64*/ void FreeHGlobal(nint hglobal);
                static /*0x2099d68*/ void ClearBSTR(nint ptr);
                static /*0x2099e84*/ void ZeroFreeBSTR(nint s);
                static /*0x2099ee0*/ void ClearAnsi(nint ptr);
                static /*0x2099f98*/ void ClearUnicode(nint ptr);
                static /*0x209a0bc*/ void ZeroFreeCoTaskMemAnsi(nint s);
                static /*0x209a118*/ void ZeroFreeCoTaskMemUnicode(nint s);
                static /*0x209a174*/ void ZeroFreeCoTaskMemUTF8(nint s);
                static /*0x209a1d0*/ void ZeroFreeGlobalAllocAnsi(nint s);
                static /*0x209a22c*/ void ZeroFreeGlobalAllocUnicode(nint s);
                static /*0x209a288*/ System.Guid GenerateGuidForType(System.Type type);
                static /*0x209a2a8*/ string GenerateProgIdForType(System.Type type);
                static /*0x209a75c*/ object GetActiveObject(string progID);
                static /*0x209a79c*/ nint GetCCW(object o, System.Type T);
                static /*0x209a7a0*/ nint GetComInterfaceForObjectInternal(object o, System.Type T);
                static /*0x209a804*/ nint GetComInterfaceForObject(object o, System.Type T);
                static /*0x209a878*/ nint GetComInterfaceForObject(object o, System.Type T, System.Runtime.InteropServices.CustomQueryInterfaceMode mode);
                static nint GetComInterfaceForObject<T, TInterface>(T o);
                static /*0x209a8b8*/ nint GetComInterfaceForObjectInContext(object o, System.Type t);
                static /*0x209a8f8*/ object GetComObjectData(object obj, object key);
                static /*0x209a948*/ int GetComSlotForMethodInfo(System.Reflection.MemberInfo m);
                static /*0x209a988*/ int GetEndComSlot(System.Type t);
                static /*0x209a9c8*/ nint GetExceptionPointers();
                static /*0x209aa08*/ nint GetHINSTANCE(System.Reflection.Module m);
                static /*0x209ab18*/ int GetExceptionCode();
                static /*0x2094f98*/ int GetHRForException(System.Exception e);
                static /*0x209ab58*/ int GetHRForLastWin32Error();
                static /*0x209ab98*/ nint GetIDispatchForObjectInternal(object o);
                static /*0x209ab9c*/ nint GetIDispatchForObject(object o);
                static /*0x209ac00*/ nint GetIDispatchForObjectInContext(object o);
                static /*0x209ac40*/ nint GetITypeInfoForType(System.Type t);
                static /*0x209ac80*/ nint GetIUnknownForObjectInContext(object o);
                static /*0x209acc0*/ nint GetManagedThunkForUnmanagedMethodPtr(nint pfnMethodToWrap, nint pbSignature, int cbSignature);
                static /*0x209ad00*/ System.Reflection.MemberInfo GetMethodInfoForComSlot(System.Type t, int slot, ref System.Runtime.InteropServices.ComMemberType memberType);
                static /*0x209ad40*/ nint GetIUnknownForObjectInternal(object o);
                static /*0x209ad44*/ nint GetIUnknownForObject(object o);
                static /*0x209ada8*/ void GetNativeVariantForObject(object obj, nint pDstNativeVariant);
                static void GetNativeVariantForObject<T>(T obj, nint pDstNativeVariant);
                static /*0x209ae8c*/ object GetObjectForCCW(nint pUnk);
                static /*0x2097190*/ object GetObjectForIUnknown(nint pUnk);
                static /*0x209ae90*/ object GetObjectForNativeVariant(nint pSrcNativeVariant);
                static T GetObjectForNativeVariant<T>(nint pSrcNativeVariant);
                static /*0x209afd0*/ object[] GetObjectsForNativeVariants(nint aSrcNativeVariant, int cVars);
                static T[] GetObjectsForNativeVariants<T>(nint aSrcNativeVariant, int cVars);
                static /*0x209b1b4*/ int GetStartComSlot(System.Type t);
                static /*0x209b1f4*/ System.Type GetTypeFromCLSID(System.Guid clsid);
                static /*0x209b234*/ string GetTypeInfoName(System.Runtime.InteropServices.ComTypes.ITypeInfo typeInfo);
                static /*0x209b274*/ object GetUniqueObjectForIUnknown(nint unknown);
                static /*0x209b2b4*/ bool IsComObject(object o);
                static /*0x2096c0c*/ int GetLastWin32Error();
                static /*0x209b2bc*/ nint OffsetOf(System.Type t, string fieldName);
                static nint OffsetOf<T>(string fieldName);
                static /*0x209b2c0*/ void Prelink(System.Reflection.MethodInfo m);
                static /*0x209b2c4*/ void PrelinkAll(System.Type c);
                static /*0x209b2c8*/ string PtrToStringAnsi(nint ptr);
                static /*0x209b2cc*/ string PtrToStringAnsi(nint ptr, int len);
                static /*0x209b2d0*/ string PtrToStringUTF8(nint ptr);
                static /*0x209b324*/ string PtrToStringUTF8(nint ptr, int byteLen);
                static /*0x209b388*/ string PtrToStringAuto(nint ptr);
                static /*0x209b420*/ string PtrToStringAuto(nint ptr, int len);
                static /*0x209b41c*/ string PtrToStringUni(nint ptr);
                static /*0x209b4cc*/ string PtrToStringUni(nint ptr, int len);
                static /*0x209b4d0*/ string PtrToStringBSTR(nint ptr);
                static /*0x209b4d4*/ void PtrToStructure(nint ptr, object structure);
                static /*0x209afcc*/ object PtrToStructure(nint ptr, System.Type structureType);
                static void PtrToStructure<T>(nint ptr, T structure);
                static T PtrToStructure<T>(nint ptr);
                static /*0x209b4d8*/ int QueryInterfaceInternal(nint pUnk, ref System.Guid iid, ref nint ppv);
                static /*0x209b4dc*/ int QueryInterface(nint pUnk, ref System.Guid iid, ref nint ppv);
                static /*0x209b5c4*/ byte ReadByte(nint ptr);
                static /*0x2099f7c*/ byte ReadByte(nint ptr, int ofs);
                static /*0x209b5dc*/ byte ReadByte(object ptr, int ofs);
                static /*0x209b61c*/ short ReadInt16(nint ptr);
                static /*0x209a074*/ short ReadInt16(nint ptr, int ofs);
                static /*0x209b674*/ short ReadInt16(object ptr, int ofs);
                static /*0x209b6b4*/ int ReadInt32(nint ptr);
                static /*0x2099e14*/ int ReadInt32(nint ptr, int ofs);
                static /*0x209b6f4*/ int ReadInt32(object ptr, int ofs);
                static /*0x209b734*/ long ReadInt64(nint ptr);
                static /*0x209b794*/ long ReadInt64(nint ptr, int ofs);
                static /*0x209b7e0*/ long ReadInt64(object ptr, int ofs);
                static /*0x209b820*/ nint ReadIntPtr(nint ptr);
                static /*0x209b8a8*/ nint ReadIntPtr(nint ptr, int ofs);
                static /*0x209b944*/ nint ReadIntPtr(object ptr, int ofs);
                static /*0x209b984*/ nint ReAllocCoTaskMem(nint pv, int cb);
                static /*0x209b988*/ nint ReAllocHGlobal(nint pv, nint cb);
                static /*0x209b98c*/ int ReleaseInternal(nint pUnk);
                static /*0x209b990*/ int Release(nint pUnk);
                static /*0x209ba60*/ int ReleaseComObjectInternal(object co);
                static /*0x209ba64*/ int ReleaseComObject(object o);
                static /*0x209bb28*/ int SizeOf(object structure);
                static /*0x209b1b0*/ int SizeOf(System.Type t);
                static int SizeOf<T>();
                static int SizeOf<T>(T structure);
                static /*0x209bb98*/ uint SizeOfType(System.Type type);
                static uint AlignedSizeOf<T>();
                static /*0x209bbec*/ nint StringToBSTR(string s);
                static /*0x209bc8c*/ nint StringToCoTaskMemAnsi(string s);
                static /*0x209be7c*/ nint StringToCoTaskMemAuto(string s);
                static /*0x209bf10*/ nint StringToCoTaskMemUni(string s);
                static /*0x209c000*/ nint StringToHGlobalAnsi(char* s, int length);
                static /*0x209c004*/ nint StringToHGlobalAnsi(string s);
                static /*0x209bce0*/ nint StringToAllocatedMemoryUTF8(string s);
                static /*0x209c078*/ nint StringToHGlobalAuto(string s);
                static /*0x209c180*/ nint StringToHGlobalUni(char* s, int length);
                static /*0x209c10c*/ nint StringToHGlobalUni(string s);
                static /*0x209c184*/ nint SecureStringToBSTR(System.Security.SecureString s);
                static /*0x209c30c*/ nint SecureStringCoTaskMemAllocator(int len);
                static /*0x209c360*/ nint SecureStringGlobalAllocator(int len);
                static /*0x209c3b4*/ nint SecureStringToAnsi(System.Security.SecureString s, System.Runtime.InteropServices.Marshal.SecureStringAllocator allocator);
                static /*0x209c678*/ nint SecureStringToUnicode(System.Security.SecureString s, System.Runtime.InteropServices.Marshal.SecureStringAllocator allocator);
                static /*0x209c90c*/ nint SecureStringToCoTaskMemAnsi(System.Security.SecureString s);
                static /*0x209ca70*/ nint SecureStringToCoTaskMemUnicode(System.Security.SecureString s);
                static /*0x209cb10*/ nint SecureStringToGlobalAllocAnsi(System.Security.SecureString s);
                static /*0x209cc00*/ nint SecureStringToGlobalAllocUnicode(System.Security.SecureString s);
                static /*0x209ccf0*/ void StructureToPtr(object structure, nint ptr, bool fDeleteOld);
                static void StructureToPtr<T>(T structure, nint ptr, bool fDeleteOld);
                static /*0x209ccf8*/ void ThrowExceptionForHR(int errorCode);
                static /*0x209cdd0*/ void ThrowExceptionForHR(int errorCode, nint errorInfo);
                static /*0x209bc88*/ nint BufferToBSTR(char* ptr, int slen);
                static /*0x209ce9c*/ nint UnsafeAddrOfPinnedArrayElement(System.Array arr, int index);
                static nint UnsafeAddrOfPinnedArrayElement<T>(T[] arr, int index);
                static /*0x209cea0*/ void WriteByte(nint ptr, byte val);
                static /*0x2099e60*/ void WriteByte(nint ptr, int ofs, byte val);
                static /*0x209cebc*/ void WriteByte(object ptr, int ofs, byte val);
                static /*0x209cefc*/ void WriteInt16(nint ptr, short val);
                static /*0x209a028*/ void WriteInt16(nint ptr, int ofs, short val);
                static /*0x209cf40*/ void WriteInt16(object ptr, int ofs, short val);
                static /*0x209cf80*/ void WriteInt16(nint ptr, char val);
                static /*0x209cfe8*/ void WriteInt16(nint ptr, int ofs, char val);
                static /*0x209d054*/ void WriteInt16(object ptr, int ofs, char val);
                static /*0x209d094*/ void WriteInt32(nint ptr, int val);
                static /*0x209d0dc*/ void WriteInt32(nint ptr, int ofs, int val);
                static /*0x209d12c*/ void WriteInt32(object ptr, int ofs, int val);
                static /*0x209d16c*/ void WriteInt64(nint ptr, long val);
                static /*0x209d1b4*/ void WriteInt64(nint ptr, int ofs, long val);
                static /*0x209d204*/ void WriteInt64(object ptr, int ofs, long val);
                static /*0x209d244*/ void WriteIntPtr(nint ptr, nint val);
                static /*0x209d2fc*/ void WriteIntPtr(nint ptr, int ofs, nint val);
                static /*0x209d3cc*/ void WriteIntPtr(object ptr, int ofs, nint val);
                static /*0x209d40c*/ System.Exception ConvertHrToException(int errorCode);
                static /*0x209cd70*/ System.Exception GetExceptionForHR(int errorCode);
                static /*0x209ce48*/ System.Exception GetExceptionForHR(int errorCode, nint errorInfo);
                static /*0x209e174*/ int FinalReleaseComObject(object o);
                static /*0x209e1b8*/ System.Delegate GetDelegateForFunctionPointerInternal(nint ptr, System.Type t);
                static /*0x209e1bc*/ System.Delegate GetDelegateForFunctionPointer(nint ptr, System.Type t);
                static TDelegate GetDelegateForFunctionPointer<TDelegate>(nint ptr);
                static /*0x209e420*/ nint GetFunctionPointerForDelegateInternal(System.Delegate d);
                static /*0x209e424*/ nint GetFunctionPointerForDelegate(System.Delegate d);
                static nint GetFunctionPointerForDelegate<TDelegate>(TDelegate d);
                static /*0x2096c14*/ void SetLastWin32Error(int error);
                static /*0x209e4c8*/ nint GetRawIUnknownForComObjectNoAddRef(object o);
                static /*0x209e4cc*/ int GetHRForException_WinRT(System.Exception e);
                static /*0x209e4d0*/ object GetNativeActivationFactory(System.Type type);
                static /*0x209e4d4*/ System.Runtime.InteropServices.ICustomMarshaler GetCustomMarshalerInstance(System.Type type, string cookie);
                static /*0x209ecf0*/ nint StringToCoTaskMemUTF8(string s);
                static /*0x209ee9c*/ System.Threading.Thread GetThreadFromFiberCookie(int cookie);
                static /*0x209eed4*/ object GetTypedObjectForIUnknown(nint pUnk, System.Type t);
                static /*0x209ef0c*/ System.Type GetTypeForITypeInfo(nint piTypeInfo);
                static /*0x209ef44*/ string GetTypeInfoName(System.Runtime.InteropServices.UCOMITypeInfo pTI);
                static /*0x209ef7c*/ System.Guid GetTypeLibGuid(System.Runtime.InteropServices.ComTypes.ITypeLib typelib);
                static /*0x209efb4*/ System.Guid GetTypeLibGuid(System.Runtime.InteropServices.UCOMITypeLib pTLB);
                static /*0x209efec*/ System.Guid GetTypeLibGuidForAssembly(System.Reflection.Assembly asm);
                static /*0x209f024*/ int GetTypeLibLcid(System.Runtime.InteropServices.ComTypes.ITypeLib typelib);
                static /*0x209f05c*/ int GetTypeLibLcid(System.Runtime.InteropServices.UCOMITypeLib pTLB);
                static /*0x209f094*/ string GetTypeLibName(System.Runtime.InteropServices.ComTypes.ITypeLib typelib);
                static /*0x209f0cc*/ string GetTypeLibName(System.Runtime.InteropServices.UCOMITypeLib pTLB);
                static /*0x209f104*/ void GetTypeLibVersionForAssembly(System.Reflection.Assembly inputAssembly, ref int majorVersion, ref int minorVersion);
                static /*0x209f13c*/ nint GetUnmanagedThunkForManagedMethodPtr(nint pfnMethodToWrap, nint pbSignature, int cbSignature);
                static /*0x209f174*/ bool IsTypeVisibleFromCom(System.Type t);
                static /*0x209f1ac*/ int NumParamBytes(System.Reflection.MethodInfo m);
                static /*0x209f1e4*/ void ReleaseThreadCache();
                static /*0x209f21c*/ bool SetComObjectData(object obj, object key, object data);

                class SecureStringAllocator : System.MulticastDelegate
                {
                    /*0x209c9ac*/ SecureStringAllocator(object object, nint method);
                    /*0x209f254*/ nint Invoke(int len);
                }

                class MarshalerInstanceKeyComparer : System.Collections.Generic.IEqualityComparer<System.ValueTuple<System.Type, string>>
                {
                    /*0x209f330*/ MarshalerInstanceKeyComparer();
                    /*0x209f268*/ bool Equals(System.ValueTuple<System.Type, string> lhs, System.ValueTuple<System.Type, string> rhs);
                    /*0x209f2dc*/ int GetHashCode(System.ValueTuple<System.Type, string> key);
                }

                class <>c
                {
                    static /*0x0*/ System.Runtime.InteropServices.Marshal.<> <>9;
                    static /*0x8*/ System.Func<System.Collections.Generic.Dictionary<System.ValueTuple<System.Type, string>, System.Runtime.InteropServices.ICustomMarshaler>> <>9__201_0;

                    static /*0x209f338*/ <>c();
                    /*0x209f39c*/ <>c();
                    /*0x209f3a4*/ System.Collections.Generic.Dictionary<System.ValueTuple<System.Type, string>, System.Runtime.InteropServices.ICustomMarshaler> <GetCustomMarshalerInstance>b__201_0();
                }
            }

            class MarshalAsAttribute : System.Attribute
            {
                /*0x10*/ string MarshalCookie;
                /*0x18*/ string MarshalType;
                /*0x20*/ System.Type MarshalTypeRef;
                /*0x28*/ System.Type SafeArrayUserDefinedSubType;
                /*0x30*/ System.Runtime.InteropServices.UnmanagedType utype;
                /*0x34*/ System.Runtime.InteropServices.UnmanagedType ArraySubType;
                /*0x38*/ System.Runtime.InteropServices.VarEnum SafeArraySubType;
                /*0x3c*/ int SizeConst;
                /*0x40*/ int IidParameterIndex;
                /*0x44*/ short SizeParamIndex;

                /*0x209f444*/ MarshalAsAttribute(short unmanagedType);
                /*0x209f470*/ MarshalAsAttribute(System.Runtime.InteropServices.UnmanagedType unmanagedType);
                /*0x209f498*/ System.Runtime.InteropServices.UnmanagedType get_Value();
                /*0x209f4a0*/ System.Runtime.InteropServices.MarshalAsAttribute Copy();
            }

            enum RegistrationClassContext
            {
                DisableActivateAsActivator = 32768,
                EnableActivateAsActivator = 65536,
                EnableCodeDownload = 8192,
                FromDefaultContext = 131072,
                InProcessHandler = 2,
                InProcessHandler16 = 32,
                InProcessServer = 1,
                InProcessServer16 = 8,
                LocalServer = 4,
                NoCodeDownload = 1024,
                NoCustomMarshal = 4096,
                NoFailureLog = 16384,
                RemoteServer = 16,
                Reserved1 = 64,
                Reserved2 = 128,
                Reserved3 = 256,
                Reserved4 = 512,
                Reserved5 = 2048,
            }

            struct STATSTG
            {
                /*0x10*/ string pwcsName;
                /*0x18*/ int type;
                /*0x20*/ long cbSize;
                /*0x28*/ System.Runtime.InteropServices.FILETIME mtime;
                /*0x30*/ System.Runtime.InteropServices.FILETIME ctime;
                /*0x38*/ System.Runtime.InteropServices.FILETIME atime;
                /*0x40*/ int grfMode;
                /*0x44*/ int grfLocksSupported;
                /*0x48*/ System.Guid clsid;
                /*0x58*/ int grfStateBits;
                /*0x5c*/ int reserved;
            }

            enum SYSKIND
            {
                SYS_WIN16 = 0,
                SYS_WIN32 = 1,
                SYS_MAC = 2,
            }

            struct TYPELIBATTR
            {
                /*0x10*/ System.Guid guid;
                /*0x20*/ int lcid;
                /*0x24*/ System.Runtime.InteropServices.SYSKIND syskind;
                /*0x28*/ short wMajorVerNum;
                /*0x2a*/ short wMinorVerNum;
                /*0x2c*/ System.Runtime.InteropServices.LIBFLAGS wLibFlags;
            }

            interface _Activator
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _Assembly
            {
                string ToString();
                bool Equals(object other);
                int GetHashCode();
                System.Type GetType();
                string get_CodeBase();
                string get_EscapedCodeBase();
                System.Reflection.AssemblyName GetName();
                System.Reflection.AssemblyName GetName(bool copiedName);
                string get_FullName();
                System.Reflection.MethodInfo get_EntryPoint();
                System.Type GetType(string name);
                System.Type GetType(string name, bool throwOnError);
                System.Type[] GetExportedTypes();
                System.Type[] GetTypes();
                System.IO.Stream GetManifestResourceStream(System.Type type, string name);
                System.IO.Stream GetManifestResourceStream(string name);
                System.IO.FileStream GetFile(string name);
                System.IO.FileStream[] GetFiles();
                System.IO.FileStream[] GetFiles(bool getResourceModules);
                string[] GetManifestResourceNames();
                System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName);
                string get_Location();
                object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                object[] GetCustomAttributes(bool inherit);
                bool IsDefined(System.Type attributeType, bool inherit);
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                System.Type GetType(string name, bool throwOnError, bool ignoreCase);
                System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture);
                System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture, System.Version version);
                System.Reflection.Module LoadModule(string moduleName, byte[] rawModule);
                System.Reflection.Module LoadModule(string moduleName, byte[] rawModule, byte[] rawSymbolStore);
                object CreateInstance(string typeName);
                object CreateInstance(string typeName, bool ignoreCase);
                object CreateInstance(string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
                System.Reflection.Module[] GetLoadedModules();
                System.Reflection.Module[] GetLoadedModules(bool getResourceModules);
                System.Reflection.Module[] GetModules();
                System.Reflection.Module[] GetModules(bool getResourceModules);
                System.Reflection.Module GetModule(string name);
                System.Reflection.AssemblyName[] GetReferencedAssemblies();
                void add_ModuleResolve(System.Reflection.ModuleResolveEventHandler value);
                void remove_ModuleResolve(System.Reflection.ModuleResolveEventHandler value);
                System.Security.Policy.Evidence get_Evidence();
                bool get_GlobalAssemblyCache();
            }

            interface _AssemblyName
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _Attribute
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _ConstructorInfo
            {
                bool Equals(object other);
                object[] GetCustomAttributes(bool inherit);
                object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                int GetHashCode();
                System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
                System.Reflection.ParameterInfo[] GetParameters();
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
                System.Type GetType();
                object Invoke_5(object[] parameters);
                object Invoke_3(object obj, object[] parameters);
                object Invoke_4(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                object Invoke_2(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                bool IsDefined(System.Type attributeType, bool inherit);
                string ToString();
                System.Reflection.MethodAttributes get_Attributes();
                System.Reflection.CallingConventions get_CallingConvention();
                System.Type get_DeclaringType();
                bool get_IsAbstract();
                bool get_IsAssembly();
                bool get_IsConstructor();
                bool get_IsFamily();
                bool get_IsFamilyAndAssembly();
                bool get_IsFamilyOrAssembly();
                bool get_IsFinal();
                bool get_IsHideBySig();
                bool get_IsPrivate();
                bool get_IsPublic();
                bool get_IsSpecialName();
                bool get_IsStatic();
                bool get_IsVirtual();
                System.Reflection.MemberTypes get_MemberType();
                System.RuntimeMethodHandle get_MethodHandle();
                string get_Name();
                System.Type get_ReflectedType();
            }

            interface _EventInfo
            {
                void AddEventHandler(object target, System.Delegate handler);
                bool Equals(object other);
                System.Reflection.MethodInfo GetAddMethod();
                System.Reflection.MethodInfo GetAddMethod(bool nonPublic);
                object[] GetCustomAttributes(bool inherit);
                object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                int GetHashCode();
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
                System.Reflection.MethodInfo GetRaiseMethod();
                System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic);
                System.Reflection.MethodInfo GetRemoveMethod();
                System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic);
                System.Type GetType();
                bool IsDefined(System.Type attributeType, bool inherit);
                void RemoveEventHandler(object target, System.Delegate handler);
                string ToString();
                System.Reflection.EventAttributes get_Attributes();
                System.Type get_DeclaringType();
                System.Type get_EventHandlerType();
                bool get_IsMulticast();
                bool get_IsSpecialName();
                System.Reflection.MemberTypes get_MemberType();
                string get_Name();
                System.Type get_ReflectedType();
            }

            interface _Exception
            {
                string get_HelpLink();
                void set_HelpLink(string value);
                System.Exception get_InnerException();
                string get_Message();
                string get_Source();
                void set_Source(string value);
                string get_StackTrace();
                System.Reflection.MethodBase get_TargetSite();
                bool Equals(object obj);
                System.Exception GetBaseException();
                int GetHashCode();
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                System.Type GetType();
                string ToString();
            }

            interface _FieldInfo
            {
                bool Equals(object other);
                object[] GetCustomAttributes(bool inherit);
                object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                int GetHashCode();
                System.Type GetType();
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
                object GetValue(object obj);
                object GetValueDirect(System.TypedReference obj);
                bool IsDefined(System.Type attributeType, bool inherit);
                void SetValue(object obj, object value);
                void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
                void SetValueDirect(System.TypedReference obj, object value);
                string ToString();
                System.Reflection.FieldAttributes get_Attributes();
                System.Type get_DeclaringType();
                System.RuntimeFieldHandle get_FieldHandle();
                System.Type get_FieldType();
                bool get_IsAssembly();
                bool get_IsFamily();
                bool get_IsFamilyAndAssembly();
                bool get_IsFamilyOrAssembly();
                bool get_IsInitOnly();
                bool get_IsLiteral();
                bool get_IsNotSerialized();
                bool get_IsPinvokeImpl();
                bool get_IsPrivate();
                bool get_IsPublic();
                bool get_IsSpecialName();
                bool get_IsStatic();
                System.Reflection.MemberTypes get_MemberType();
                string get_Name();
                System.Type get_ReflectedType();
            }

            interface _MemberInfo
            {
                bool Equals(object other);
                object[] GetCustomAttributes(bool inherit);
                object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                int GetHashCode();
                System.Type GetType();
                bool IsDefined(System.Type attributeType, bool inherit);
                string ToString();
                System.Type get_DeclaringType();
                System.Reflection.MemberTypes get_MemberType();
                string get_Name();
                System.Type get_ReflectedType();
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _MethodBase
            {
                bool Equals(object other);
                object[] GetCustomAttributes(bool inherit);
                object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                int GetHashCode();
                System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
                System.Reflection.ParameterInfo[] GetParameters();
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
                System.Type GetType();
                object Invoke(object obj, object[] parameters);
                object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                bool IsDefined(System.Type attributeType, bool inherit);
                string ToString();
                System.Reflection.MethodAttributes get_Attributes();
                System.Reflection.CallingConventions get_CallingConvention();
                System.Type get_DeclaringType();
                bool get_IsAbstract();
                bool get_IsAssembly();
                bool get_IsConstructor();
                bool get_IsFamily();
                bool get_IsFamilyAndAssembly();
                bool get_IsFamilyOrAssembly();
                bool get_IsFinal();
                bool get_IsHideBySig();
                bool get_IsPrivate();
                bool get_IsPublic();
                bool get_IsSpecialName();
                bool get_IsStatic();
                bool get_IsVirtual();
                System.Reflection.MemberTypes get_MemberType();
                System.RuntimeMethodHandle get_MethodHandle();
                string get_Name();
                System.Type get_ReflectedType();
            }

            interface _MethodInfo
            {
                void GetTypeInfoCount(ref uint pcTInfo);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
                string ToString();
                bool Equals(object other);
                int GetHashCode();
                System.Type GetType();
                System.Reflection.MemberTypes get_MemberType();
                string get_Name();
                System.Type get_DeclaringType();
                System.Type get_ReflectedType();
                object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                object[] GetCustomAttributes(bool inherit);
                bool IsDefined(System.Type attributeType, bool inherit);
                System.Reflection.ParameterInfo[] GetParameters();
                System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
                System.RuntimeMethodHandle get_MethodHandle();
                System.Reflection.MethodAttributes get_Attributes();
                System.Reflection.CallingConventions get_CallingConvention();
                object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                bool get_IsPublic();
                bool get_IsPrivate();
                bool get_IsFamily();
                bool get_IsAssembly();
                bool get_IsFamilyAndAssembly();
                bool get_IsFamilyOrAssembly();
                bool get_IsStatic();
                bool get_IsFinal();
                bool get_IsVirtual();
                bool get_IsHideBySig();
                bool get_IsAbstract();
                bool get_IsSpecialName();
                bool get_IsConstructor();
                object Invoke(object obj, object[] parameters);
                System.Type get_ReturnType();
                System.Reflection.ICustomAttributeProvider get_ReturnTypeCustomAttributes();
                System.Reflection.MethodInfo GetBaseDefinition();
            }

            interface _MethodRental
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _Module
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _ParameterInfo
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _PropertyInfo
            {
                bool Equals(object other);
                System.Reflection.MethodInfo[] GetAccessors();
                System.Reflection.MethodInfo[] GetAccessors(bool nonPublic);
                object[] GetCustomAttributes(bool inherit);
                object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                System.Reflection.MethodInfo GetGetMethod();
                System.Reflection.MethodInfo GetGetMethod(bool nonPublic);
                int GetHashCode();
                System.Reflection.ParameterInfo[] GetIndexParameters();
                System.Reflection.MethodInfo GetSetMethod();
                System.Reflection.MethodInfo GetSetMethod(bool nonPublic);
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
                System.Type GetType();
                object GetValue(object obj, object[] index);
                object GetValue(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
                bool IsDefined(System.Type attributeType, bool inherit);
                void SetValue(object obj, object value, object[] index);
                void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
                string ToString();
                System.Reflection.PropertyAttributes get_Attributes();
                bool get_CanRead();
                bool get_CanWrite();
                System.Type get_DeclaringType();
                bool get_IsSpecialName();
                System.Reflection.MemberTypes get_MemberType();
                string get_Name();
                System.Type get_PropertyType();
                System.Type get_ReflectedType();
            }

            interface _SignatureHelper
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _Thread
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _Type
            {
                void GetTypeInfoCount(ref uint pcTInfo);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
                string ToString();
                bool Equals(object other);
                int GetHashCode();
                System.Type GetType();
                System.Reflection.MemberTypes get_MemberType();
                string get_Name();
                System.Type get_DeclaringType();
                System.Type get_ReflectedType();
                object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                object[] GetCustomAttributes(bool inherit);
                bool IsDefined(System.Type attributeType, bool inherit);
                System.Guid get_GUID();
                System.Reflection.Module get_Module();
                System.Reflection.Assembly get_Assembly();
                System.RuntimeTypeHandle get_TypeHandle();
                string get_FullName();
                string get_Namespace();
                string get_AssemblyQualifiedName();
                int GetArrayRank();
                System.Type get_BaseType();
                System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
                System.Type GetInterface(string name, bool ignoreCase);
                System.Type[] GetInterfaces();
                System.Type[] FindInterfaces(System.Reflection.TypeFilter filter, object filterCriteria);
                System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
                System.Reflection.EventInfo[] GetEvents();
                System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
                System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
                System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
                System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
                System.Reflection.MemberInfo[] GetDefaultMembers();
                System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);
                System.Type GetElementType();
                bool IsSubclassOf(System.Type c);
                bool IsInstanceOfType(object o);
                bool IsAssignableFrom(System.Type c);
                System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType);
                System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr);
                System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
                System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
                System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
                System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr);
                System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
                System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr);
                System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
                object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
                System.Type get_UnderlyingSystemType();
                object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);
                object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);
                System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                System.Reflection.ConstructorInfo GetConstructor(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                System.Reflection.ConstructorInfo GetConstructor(System.Type[] types);
                System.Reflection.ConstructorInfo[] GetConstructors();
                System.Reflection.ConstructorInfo get_TypeInitializer();
                System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                System.Reflection.MethodInfo GetMethod(string name, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                System.Reflection.MethodInfo GetMethod(string name, System.Type[] types);
                System.Reflection.MethodInfo GetMethod(string name);
                System.Reflection.MethodInfo[] GetMethods();
                System.Reflection.FieldInfo GetField(string name);
                System.Reflection.FieldInfo[] GetFields();
                System.Type GetInterface(string name);
                System.Reflection.EventInfo GetEvent(string name);
                System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType, System.Type[] types);
                System.Reflection.PropertyInfo GetProperty(string name, System.Type[] types);
                System.Reflection.PropertyInfo GetProperty(string name, System.Type returnType);
                System.Reflection.PropertyInfo GetProperty(string name);
                System.Reflection.PropertyInfo[] GetProperties();
                System.Type[] GetNestedTypes();
                System.Type GetNestedType(string name);
                System.Reflection.MemberInfo[] GetMember(string name);
                System.Reflection.MemberInfo[] GetMembers();
                System.Reflection.TypeAttributes get_Attributes();
                bool get_IsNotPublic();
                bool get_IsPublic();
                bool get_IsNestedPublic();
                bool get_IsNestedPrivate();
                bool get_IsNestedFamily();
                bool get_IsNestedAssembly();
                bool get_IsNestedFamANDAssem();
                bool get_IsNestedFamORAssem();
                bool get_IsAutoLayout();
                bool get_IsLayoutSequential();
                bool get_IsExplicitLayout();
                bool get_IsClass();
                bool get_IsInterface();
                bool get_IsValueType();
                bool get_IsAbstract();
                bool get_IsSealed();
                bool get_IsEnum();
                bool get_IsSpecialName();
                bool get_IsImport();
                bool get_IsSerializable();
                bool get_IsAnsiClass();
                bool get_IsUnicodeClass();
                bool get_IsAutoClass();
                bool get_IsArray();
                bool get_IsByRef();
                bool get_IsPointer();
                bool get_IsPrimitive();
                bool get_IsCOMObject();
                bool get_HasElementType();
                bool get_IsContextful();
                bool get_IsMarshalByRef();
                bool Equals(System.Type o);
            }

            class AddrofIntrinsics
            {
                static nint AddrOf<T>(T ftn);
            }

            namespace WindowsRuntime
            {
                class DefaultInterfaceAttribute : System.Attribute
                {
                    /*0x10*/ System.Type m_defaultInterface;

                    /*0x209f504*/ DefaultInterfaceAttribute(System.Type defaultInterface);
                    /*0x209f52c*/ System.Type get_DefaultInterface();
                }

                class WindowsRuntimeImportAttribute : System.Attribute
                {
                    /*0x209f534*/ WindowsRuntimeImportAttribute();
                }

                class InterfaceImplementedInVersionAttribute : System.Attribute
                {
                    /*0x10*/ System.Type m_interfaceType;
                    /*0x18*/ byte m_majorVersion;
                    /*0x19*/ byte m_minorVersion;
                    /*0x1a*/ byte m_buildVersion;
                    /*0x1b*/ byte m_revisionVersion;

                    /*0x209f53c*/ InterfaceImplementedInVersionAttribute(System.Type interfaceType, byte majorVersion, byte minorVersion, byte buildVersion, byte revisionVersion);
                    /*0x209f594*/ System.Type get_InterfaceType();
                    /*0x209f59c*/ byte get_MajorVersion();
                    /*0x209f5a4*/ byte get_MinorVersion();
                    /*0x209f5ac*/ byte get_BuildVersion();
                    /*0x209f5b4*/ byte get_RevisionVersion();
                }

                class ReadOnlyArrayAttribute : System.Attribute
                {
                    /*0x209f5bc*/ ReadOnlyArrayAttribute();
                }

                class WriteOnlyArrayAttribute : System.Attribute
                {
                    /*0x209f5c4*/ WriteOnlyArrayAttribute();
                }

                class ReturnValueNameAttribute : System.Attribute
                {
                    /*0x10*/ string m_Name;

                    /*0x209f5cc*/ ReturnValueNameAttribute(string name);
                    /*0x209f5f4*/ string get_Name();
                }

                struct EventRegistrationToken
                {
                    /*0x10*/ ulong m_value;

                    static /*0x209f60c*/ bool op_Equality(System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken left, System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken right);
                    static /*0x209f6f0*/ bool op_Inequality(System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken left, System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken right);
                    /*0x209f5fc*/ EventRegistrationToken(ulong value);
                    /*0x209f604*/ ulong get_Value();
                    /*0x209f678*/ bool Equals(object obj);
                    /*0x209f760*/ int GetHashCode();
                }

                class EventRegistrationTokenTable<T>
                {
                    /*0x0*/ System.Collections.Generic.Dictionary<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken, T> m_tokens;
                    /*0x0*/ T m_invokeList;

                    static System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken GetPreferredToken(T handler);
                    static System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<T> GetOrCreateEventRegistrationTokenTable(ref System.Runtime.InteropServices.WindowsRuntime.EventRegistrationTokenTable<T> refEventTable);
                    EventRegistrationTokenTable();
                    T get_InvocationList();
                    void set_InvocationList(T value);
                    System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken AddEventHandler(T handler);
                    System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken AddEventHandlerNoLock(T handler);
                    T ExtractHandler(System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token);
                    void RemoveEventHandler(System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token);
                    void RemoveEventHandler(T handler);
                    void RemoveEventHandlerNoLock(System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token);
                }

                interface IActivationFactory
                {
                    /*0x209f768*/ object ActivateInstance();
                }

                interface IRestrictedErrorInfo
                {
                    /*0x209f780*/ void GetErrorDetails(ref string description, ref int error, ref string restrictedDescription, ref string capabilitySid);
                    /*0x209f834*/ void GetReference(ref string reference);
                }

                class WindowsRuntimeMarshal
                {
                    static /*0x0*/ bool s_haveBlueErrorApis;
                    static /*0x4*/ System.Guid s_iidIErrorInfo;

                    static /*0x20a0830*/ WindowsRuntimeMarshal();
                    static void AddEventHandler<T>(System.Func<T, System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> addMethod, System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, T handler);
                    static void RemoveEventHandler<T>(System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, T handler);
                    static /*0x209f88c*/ void RemoveAllEventHandlers(System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod);
                    static /*0x209f998*/ int GetRegistrationTokenCacheSize();
                    static /*0x209fcc4*/ void CallRemoveMethods(System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, System.Collections.Generic.List<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> tokensToRemove);
                    static /*0x209fff0*/ string HStringToString(nint hstring);
                    static /*0x20a00c8*/ System.Exception GetExceptionForHR(int hresult, System.Exception innerException, string messageResource);
                    static /*0x20a01c8*/ System.Exception GetExceptionForHR(int hresult, System.Exception innerException);
                    static /*0x20a0230*/ bool RoOriginateLanguageException(int error, string message, nint languageException);
                    static /*0x20a0364*/ void RoReportUnhandledError(System.Runtime.InteropServices.WindowsRuntime.IRestrictedErrorInfo error);
                    static /*0x20a046c*/ bool ReportUnhandledError(System.Exception e);
                    static /*0x20a04b4*/ System.Runtime.InteropServices.WindowsRuntime.IActivationFactory GetActivationFactory(System.Type type);
                    static /*0x20a055c*/ nint StringToHString(string s);
                    static /*0x20a06a4*/ string PtrToStringHString(nint ptr);
                    static /*0x20a075c*/ void FreeHString(nint ptr);

                    struct EventRegistrationTokenList
                    {
                        /*0x10*/ System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken firstToken;
                        /*0x18*/ System.Collections.Generic.List<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> restTokens;

                        /*0x20a18e0*/ EventRegistrationTokenList(System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token);
                        /*0x20a18e8*/ bool Push(System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token);
                        /*0x20a19e4*/ bool Pop(ref System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token);
                        /*0x20a1a98*/ void CopyTo(System.Collections.Generic.List<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> tokens);
                    }

                    class ManagedEventRegistrationImpl
                    {
                        static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Collections.Generic.Dictionary<System.Reflection.MethodInfo, System.Collections.Generic.Dictionary<object, System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.EventRegistrationTokenList>>> s_eventRegistrations;

                        static /*0x20a2198*/ ManagedEventRegistrationImpl();
                        static void AddEventHandler<T>(System.Func<T, System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> addMethod, System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, T handler);
                        static /*0x20a1b6c*/ System.Collections.Generic.Dictionary<object, System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.EventRegistrationTokenList> GetEventRegistrationTokenTable(object instance, System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod);
                        static void RemoveEventHandler<T>(System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, T handler);
                        static /*0x20a1e84*/ void RemoveAllEventHandlers(System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod);
                    }

                    class NativeOrStaticEventRegistrationImpl
                    {
                        static /*0x0*/ System.Collections.Generic.Dictionary<System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventCacheKey, System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventCacheEntry> s_eventRegistrations;
                        static /*0x8*/ System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.MyReaderWriterLock s_eventCacheRWLock;

                        static /*0x20a2d24*/ NativeOrStaticEventRegistrationImpl();
                        static /*0x20a2228*/ object GetInstanceKey(System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod);
                        static void AddEventHandler<T>(System.Func<T, System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> addMethod, System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, T handler);
                        static /*0x20a22e4*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventRegistrationTokenListWithCount> GetEventRegistrationTokenTableNoCreate(object instance, System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, ref System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.TokenListCount tokenListCount);
                        static /*0x20a2604*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventRegistrationTokenListWithCount> GetOrCreateEventRegistrationTokenTable(object instance, System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, ref System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.TokenListCount tokenListCount);
                        static /*0x20a2354*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventRegistrationTokenListWithCount> GetEventRegistrationTokenTableInternal(object instance, System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, ref System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.TokenListCount tokenListCount, bool createIfNotFound);
                        static void RemoveEventHandler<T>(System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod, T handler);
                        static /*0x20a26a0*/ void RemoveAllEventHandlers(System.Action<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> removeMethod);

                        struct EventCacheKey
                        {
                            /*0x10*/ object target;
                            /*0x18*/ System.Reflection.MethodInfo method;

                            /*0x20a2e38*/ string ToString();
                        }

                        class EventCacheKeyEqualityComparer : System.Collections.Generic.IEqualityComparer<System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventCacheKey>
                        {
                            /*0x20a2e28*/ EventCacheKeyEqualityComparer();
                            /*0x20a2ffc*/ bool Equals(System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventCacheKey lhs, System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventCacheKey rhs);
                            /*0x20a3048*/ int GetHashCode(System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventCacheKey key);
                        }

                        class EventRegistrationTokenListWithCount
                        {
                            /*0x10*/ System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.TokenListCount _tokenListCount;
                            /*0x18*/ System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.EventRegistrationTokenList _tokenList;

                            /*0x20a3094*/ EventRegistrationTokenListWithCount(System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.TokenListCount tokenListCount, System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token);
                            /*0x20a30e4*/ void Finalize();
                            /*0x20a32ec*/ void Push(System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token);
                            /*0x20a32f4*/ bool Pop(ref System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken token);
                            /*0x20a2d1c*/ void CopyTo(System.Collections.Generic.List<System.Runtime.InteropServices.WindowsRuntime.EventRegistrationToken> tokens);
                        }

                        class TokenListCount
                        {
                            /*0x10*/ int _count;
                            /*0x18*/ System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventCacheKey _key;

                            /*0x20a2674*/ TokenListCount(System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventCacheKey key);
                            /*0x20a30d8*/ void Inc();
                            /*0x20a3184*/ void Dec();
                            /*0x20a3370*/ void CleanupCache();
                        }

                        struct EventCacheEntry
                        {
                            /*0x10*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.EventRegistrationTokenListWithCount> registrationTable;
                            /*0x18*/ System.Runtime.InteropServices.WindowsRuntime.WindowsRuntimeMarshal.NativeOrStaticEventRegistrationImpl.TokenListCount tokenListCount;
                        }

                        class ReaderWriterLockTimedOutException : System.ApplicationException
                        {
                            /*0x20a33f8*/ ReaderWriterLockTimedOutException();
                        }

                        class MyReaderWriterLock
                        {
                            /*0x10*/ int myLock;
                            /*0x14*/ int owners;
                            /*0x18*/ uint numWriteWaiters;
                            /*0x1c*/ uint numReadWaiters;
                            /*0x20*/ System.Threading.EventWaitHandle writeEvent;
                            /*0x28*/ System.Threading.EventWaitHandle readEvent;

                            /*0x20a2e30*/ MyReaderWriterLock();
                            /*0x20a2ca4*/ void AcquireReaderLock(int millisecondsTimeout);
                            /*0x20a32fc*/ void AcquireWriterLock(int millisecondsTimeout);
                            /*0x20a363c*/ void ReleaseReaderLock();
                            /*0x20a36b8*/ void ReleaseWriterLock();
                            /*0x20a3434*/ void LazyCreateEvent(ref System.Threading.EventWaitHandle waitEvent, bool makeAutoResetEvent);
                            /*0x20a34f4*/ void WaitOnEvent(System.Threading.EventWaitHandle waitEvent, ref uint numWaiters, int millisecondsTimeout);
                            /*0x20a3660*/ void ExitAndWakeUpAppropriateWaiters();
                            /*0x20a3400*/ void EnterMyLock();
                            /*0x20a36dc*/ void EnterMyLockSpin();
                            /*0x20a3634*/ void ExitMyLock();
                        }
                    }
                }

                class DesignerNamespaceResolveEventArgs : System.EventArgs
                {
                    /*0x10*/ string <NamespaceName>k__BackingField;
                    /*0x18*/ System.Collections.ObjectModel.Collection<string> <ResolvedAssemblyFiles>k__BackingField;

                    /*0x20a3748*/ DesignerNamespaceResolveEventArgs(string namespaceName);
                    /*0x20a37fc*/ string get_NamespaceName();
                    /*0x20a3804*/ void set_NamespaceName(string value);
                    /*0x20a380c*/ System.Collections.ObjectModel.Collection<string> get_ResolvedAssemblyFiles();
                    /*0x20a3814*/ void set_ResolvedAssemblyFiles(System.Collections.ObjectModel.Collection<string> value);
                }

                class NamespaceResolveEventArgs : System.EventArgs
                {
                    /*0x10*/ string <NamespaceName>k__BackingField;
                    /*0x18*/ System.Reflection.Assembly <RequestingAssembly>k__BackingField;
                    /*0x20*/ System.Collections.ObjectModel.Collection<System.Reflection.Assembly> <ResolvedAssemblies>k__BackingField;

                    /*0x20a381c*/ NamespaceResolveEventArgs(string namespaceName, System.Reflection.Assembly requestingAssembly);
                    /*0x20a38d4*/ string get_NamespaceName();
                    /*0x20a38dc*/ void set_NamespaceName(string value);
                    /*0x20a38e4*/ System.Reflection.Assembly get_RequestingAssembly();
                    /*0x20a38ec*/ void set_RequestingAssembly(System.Reflection.Assembly value);
                    /*0x20a38f4*/ System.Collections.ObjectModel.Collection<System.Reflection.Assembly> get_ResolvedAssemblies();
                    /*0x20a38fc*/ void set_ResolvedAssemblies(System.Collections.ObjectModel.Collection<System.Reflection.Assembly> value);
                }

                class UnsafeNativeMethods
                {
                    static /*0x20a3904*/ int WindowsCreateString(string sourceString, int length, nint* hstring);
                    static /*0x20a3944*/ int WindowsDeleteString(nint hstring);
                    static /*0x20a3984*/ char* WindowsGetStringRawBuffer(nint hstring, uint* length);
                    static /*0x20a39c4*/ bool RoOriginateLanguageException(int error, string message, nint languageException);
                    static /*0x20a3a04*/ void RoReportUnhandledError(System.Runtime.InteropServices.WindowsRuntime.IRestrictedErrorInfo error);
                    static /*0x20a3a44*/ System.Runtime.InteropServices.WindowsRuntime.IRestrictedErrorInfo GetRestrictedErrorInfo();
                }

                class WindowsRuntimeMetadata
                {
                    static /*0x0*/ System.EventHandler<System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs> DesignerNamespaceResolve;
                    static /*0x8*/ System.EventHandler<System.Runtime.InteropServices.WindowsRuntime.NamespaceResolveEventArgs> ReflectionOnlyNamespaceResolve;

                    static /*0x20a3a84*/ System.Collections.Generic.IEnumerable<string> ResolveNamespace(string namespaceName, System.Collections.Generic.IEnumerable<string> packageGraphFilePaths);
                    static /*0x20a3ac4*/ System.Collections.Generic.IEnumerable<string> ResolveNamespace(string namespaceName, string windowsSdkFilePath, System.Collections.Generic.IEnumerable<string> packageGraphFilePaths);
                    static /*0x20a3b04*/ void add_DesignerNamespaceResolve(System.EventHandler<System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs> value);
                    static /*0x20a3bd0*/ void remove_DesignerNamespaceResolve(System.EventHandler<System.Runtime.InteropServices.WindowsRuntime.DesignerNamespaceResolveEventArgs> value);
                    static /*0x20a3c9c*/ void add_ReflectionOnlyNamespaceResolve(System.EventHandler<System.Runtime.InteropServices.WindowsRuntime.NamespaceResolveEventArgs> value);
                    static /*0x20a3d6c*/ void remove_ReflectionOnlyNamespaceResolve(System.EventHandler<System.Runtime.InteropServices.WindowsRuntime.NamespaceResolveEventArgs> value);
                }
            }

            namespace Expando
            {
                interface IExpando : System.Reflection.IReflect
                {
                    System.Reflection.FieldInfo AddField(string name);
                    System.Reflection.PropertyInfo AddProperty(string name);
                    System.Reflection.MethodInfo AddMethod(string name, System.Delegate method);
                    void RemoveMember(System.Reflection.MemberInfo m);
                }
            }

            namespace ComTypes
            {
                interface IConnectionPoint
                {
                    /*0x20a3e3c*/ void GetConnectionInterface(ref System.Guid pIID);
                    /*0x20a3e74*/ void GetConnectionPointContainer(ref System.Runtime.InteropServices.ComTypes.IConnectionPointContainer ppCPC);
                    /*0x20a3f48*/ void Advise(object pUnkSink, ref int pdwCookie);
                    /*0x20a3ffc*/ void Unadvise(int dwCookie);
                    /*0x20a4034*/ void EnumConnections(ref System.Runtime.InteropServices.ComTypes.IEnumConnections ppEnum);
                }

                interface IConnectionPointContainer
                {
                    /*0x20a4108*/ void EnumConnectionPoints(ref System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints ppEnum);
                    /*0x20a41dc*/ void FindConnectionPoint(ref System.Guid riid, ref System.Runtime.InteropServices.ComTypes.IConnectionPoint ppCP);
                }

                struct BIND_OPTS
                {
                    /*0x10*/ int cbStruct;
                    /*0x14*/ int grfFlags;
                    /*0x18*/ int grfMode;
                    /*0x1c*/ int dwTickCountDeadline;
                }

                interface IBindCtx
                {
                    /*0x20a42b8*/ void RegisterObjectBound(object punk);
                    /*0x20a4364*/ void RevokeObjectBound(object punk);
                    /*0x20a4410*/ void ReleaseBoundObjects();
                    /*0x20a4440*/ void SetBindOptions(ref System.Runtime.InteropServices.ComTypes.BIND_OPTS pbindopts);
                    /*0x20a4478*/ void GetBindOptions(ref System.Runtime.InteropServices.ComTypes.BIND_OPTS pbindopts);
                    /*0x20a44b0*/ void GetRunningObjectTable(ref System.Runtime.InteropServices.ComTypes.IRunningObjectTable pprot);
                    /*0x20a4584*/ void RegisterObjectParam(string pszKey, object punk);
                    /*0x20a4644*/ void GetObjectParam(string pszKey, ref object ppunk);
                    /*0x20a4728*/ void EnumObjectParam(ref System.Runtime.InteropServices.ComTypes.IEnumString ppenum);
                    /*0x20a47fc*/ int RevokeObjectParam(string pszKey);
                }

                interface IEnumConnectionPoints
                {
                    /*0x20a482c*/ int Next(int celt, System.Runtime.InteropServices.ComTypes.IConnectionPoint[] rgelt, nint pceltFetched);
                    /*0x20a4844*/ int Skip(int celt);
                    /*0x20a486c*/ void Reset();
                    /*0x20a489c*/ void Clone(ref System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints ppenum);
                }

                struct CONNECTDATA
                {
                    /*0x10*/ object pUnk;
                    /*0x18*/ int dwCookie;
                }

                interface IEnumConnections
                {
                    /*0x20a4970*/ int Next(int celt, System.Runtime.InteropServices.ComTypes.CONNECTDATA[] rgelt, nint pceltFetched);
                    /*0x20a4a88*/ int Skip(int celt);
                    /*0x20a4ab0*/ void Reset();
                    /*0x20a4ae0*/ void Clone(ref System.Runtime.InteropServices.ComTypes.IEnumConnections ppenum);
                }

                interface IEnumMoniker
                {
                    /*0x20a4bb4*/ int Next(int celt, System.Runtime.InteropServices.ComTypes.IMoniker[] rgelt, nint pceltFetched);
                    /*0x20a4bcc*/ int Skip(int celt);
                    /*0x20a4bf4*/ void Reset();
                    /*0x20a4c24*/ void Clone(ref System.Runtime.InteropServices.ComTypes.IEnumMoniker ppenum);
                }

                interface IEnumString
                {
                    /*0x20a4cf8*/ int Next(int celt, string[] rgelt, nint pceltFetched);
                    /*0x20a4dec*/ int Skip(int celt);
                    /*0x20a4e14*/ void Reset();
                    /*0x20a4e44*/ void Clone(ref System.Runtime.InteropServices.ComTypes.IEnumString ppenum);
                }

                interface IEnumVARIANT
                {
                    /*0x20a4f18*/ int Next(int celt, object[] rgVar, nint pceltFetched);
                    /*0x20a4f30*/ int Skip(int celt);
                    /*0x20a4f58*/ int Reset();
                    /*0x20a4f78*/ System.Runtime.InteropServices.ComTypes.IEnumVARIANT Clone();
                }

                struct FILETIME
                {
                    /*0x10*/ int dwLowDateTime;
                    /*0x14*/ int dwHighDateTime;
                }

                interface IMoniker
                {
                    /*0x20a5040*/ void GetClassID(ref System.Guid pClassID);
                    /*0x20a5078*/ int IsDirty();
                    /*0x20a5098*/ void Load(System.Runtime.InteropServices.ComTypes.IStream pStm);
                    /*0x20a5144*/ void Save(System.Runtime.InteropServices.ComTypes.IStream pStm, bool fClearDirty);
                    /*0x20a51f8*/ void GetSizeMax(ref long pcbSize);
                    /*0x20a5230*/ void BindToObject(System.Runtime.InteropServices.ComTypes.IBindCtx pbc, System.Runtime.InteropServices.ComTypes.IMoniker pmkToLeft, ref System.Guid riidResult, ref object ppvResult);
                    /*0x20a53e8*/ void BindToStorage(System.Runtime.InteropServices.ComTypes.IBindCtx pbc, System.Runtime.InteropServices.ComTypes.IMoniker pmkToLeft, ref System.Guid riid, ref object ppvObj);
                    /*0x20a55a0*/ void Reduce(System.Runtime.InteropServices.ComTypes.IBindCtx pbc, int dwReduceHowFar, ref System.Runtime.InteropServices.ComTypes.IMoniker ppmkToLeft, ref System.Runtime.InteropServices.ComTypes.IMoniker ppmkReduced);
                    /*0x20a57a8*/ void ComposeWith(System.Runtime.InteropServices.ComTypes.IMoniker pmkRight, bool fOnlyIfNotGeneric, ref System.Runtime.InteropServices.ComTypes.IMoniker ppmkComposite);
                    /*0x20a58f8*/ void Enum(bool fForward, ref System.Runtime.InteropServices.ComTypes.IEnumMoniker ppenumMoniker);
                    /*0x20a59d4*/ int IsEqual(System.Runtime.InteropServices.ComTypes.IMoniker pmkOtherMoniker);
                    /*0x20a5a74*/ void Hash(ref int pdwHash);
                    /*0x20a5aac*/ int IsRunning(System.Runtime.InteropServices.ComTypes.IBindCtx pbc, System.Runtime.InteropServices.ComTypes.IMoniker pmkToLeft, System.Runtime.InteropServices.ComTypes.IMoniker pmkNewlyRunning);
                    /*0x20a5c28*/ void GetTimeOfLastChange(System.Runtime.InteropServices.ComTypes.IBindCtx pbc, System.Runtime.InteropServices.ComTypes.IMoniker pmkToLeft, ref System.Runtime.InteropServices.ComTypes.FILETIME pFileTime);
                    /*0x20a5d50*/ void Inverse(ref System.Runtime.InteropServices.ComTypes.IMoniker ppmk);
                    /*0x20a5e24*/ void CommonPrefixWith(System.Runtime.InteropServices.ComTypes.IMoniker pmkOther, ref System.Runtime.InteropServices.ComTypes.IMoniker ppmkPrefix);
                    /*0x20a5f64*/ void RelativePathTo(System.Runtime.InteropServices.ComTypes.IMoniker pmkOther, ref System.Runtime.InteropServices.ComTypes.IMoniker ppmkRelPath);
                    /*0x20a60a4*/ void GetDisplayName(System.Runtime.InteropServices.ComTypes.IBindCtx pbc, System.Runtime.InteropServices.ComTypes.IMoniker pmkToLeft, ref string ppszDisplayName);
                    /*0x20a61d8*/ void ParseDisplayName(System.Runtime.InteropServices.ComTypes.IBindCtx pbc, System.Runtime.InteropServices.ComTypes.IMoniker pmkToLeft, string pszDisplayName, ref int pchEaten, ref System.Runtime.InteropServices.ComTypes.IMoniker ppmkOut);
                    /*0x20a63a8*/ int IsSystemMoniker(ref int pdwMksys);
                }

                interface IPersistFile
                {
                    /*0x20a63d0*/ void GetClassID(ref System.Guid pClassID);
                    /*0x20a6408*/ int IsDirty();
                    /*0x20a6428*/ void Load(string pszFileName, int dwMode);
                    /*0x20a6478*/ void Save(string pszFileName, bool fRemember);
                    /*0x20a64c8*/ void SaveCompleted(string pszFileName);
                    /*0x20a6508*/ void GetCurFile(ref string ppszFileName);
                }

                interface IRunningObjectTable
                {
                    /*0x20a6560*/ int Register(int grfFlags, object punkObject, System.Runtime.InteropServices.ComTypes.IMoniker pmkObjectName);
                    /*0x20a6688*/ void Revoke(int dwRegister);
                    /*0x20a66c0*/ int IsRunning(System.Runtime.InteropServices.ComTypes.IMoniker pmkObjectName);
                    /*0x20a6760*/ int GetObject(System.Runtime.InteropServices.ComTypes.IMoniker pmkObjectName, ref object ppunkObject);
                    /*0x20a689c*/ void NoteChangeTime(int dwRegister, ref System.Runtime.InteropServices.ComTypes.FILETIME pfiletime);
                    /*0x20a68e4*/ int GetTimeOfLastChange(System.Runtime.InteropServices.ComTypes.IMoniker pmkObjectName, ref System.Runtime.InteropServices.ComTypes.FILETIME pfiletime);
                    /*0x20a698c*/ void EnumRunning(ref System.Runtime.InteropServices.ComTypes.IEnumMoniker ppenumMoniker);
                }

                struct STATSTG
                {
                    /*0x10*/ string pwcsName;
                    /*0x18*/ int type;
                    /*0x20*/ long cbSize;
                    /*0x28*/ System.Runtime.InteropServices.ComTypes.FILETIME mtime;
                    /*0x30*/ System.Runtime.InteropServices.ComTypes.FILETIME ctime;
                    /*0x38*/ System.Runtime.InteropServices.ComTypes.FILETIME atime;
                    /*0x40*/ int grfMode;
                    /*0x44*/ int grfLocksSupported;
                    /*0x48*/ System.Guid clsid;
                    /*0x58*/ int grfStateBits;
                    /*0x5c*/ int reserved;
                }

                interface IStream
                {
                    /*0x20a6a60*/ void Read(byte[] pv, int cb, nint pcbRead);
                    /*0x20a6b20*/ void Write(byte[] pv, int cb, nint pcbWritten);
                    /*0x20a6b78*/ void Seek(long dlibMove, int dwOrigin, nint plibNewPosition);
                    /*0x20a6bc8*/ void SetSize(long libNewSize);
                    /*0x20a6c00*/ void CopyTo(System.Runtime.InteropServices.ComTypes.IStream pstm, long cb, nint pcbRead, nint pcbWritten);
                    /*0x20a6cd0*/ void Commit(int grfCommitFlags);
                    /*0x20a6d08*/ void Revert();
                    /*0x20a6d38*/ void LockRegion(long libOffset, long cb, int dwLockType);
                    /*0x20a6d88*/ void UnlockRegion(long libOffset, long cb, int dwLockType);
                    /*0x20a6dd8*/ void Stat(ref System.Runtime.InteropServices.ComTypes.STATSTG pstatstg, int grfStatFlag);
                    /*0x20a6e84*/ void Clone(ref System.Runtime.InteropServices.ComTypes.IStream ppstm);
                }

                enum DESCKIND
                {
                    DESCKIND_NONE = 0,
                    DESCKIND_FUNCDESC = 1,
                    DESCKIND_VARDESC = 2,
                    DESCKIND_TYPECOMP = 3,
                    DESCKIND_IMPLICITAPPOBJ = 4,
                    DESCKIND_MAX = 5,
                }

                struct BINDPTR
                {
                    /*0x10*/ nint lpfuncdesc;
                    /*0x10*/ nint lpvardesc;
                    /*0x10*/ nint lptcomp;
                }

                interface ITypeComp
                {
                    /*0x20a6f58*/ void Bind(string szName, int lHashVal, short wFlags, ref System.Runtime.InteropServices.ComTypes.ITypeInfo ppTInfo, ref System.Runtime.InteropServices.ComTypes.DESCKIND pDescKind, ref System.Runtime.InteropServices.ComTypes.BINDPTR pBindPtr);
                    /*0x20a706c*/ void BindType(string szName, int lHashVal, ref System.Runtime.InteropServices.ComTypes.ITypeInfo ppTInfo, ref System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp);
                }

                enum TYPEKIND
                {
                    TKIND_ENUM = 0,
                    TKIND_RECORD = 1,
                    TKIND_MODULE = 2,
                    TKIND_INTERFACE = 3,
                    TKIND_DISPATCH = 4,
                    TKIND_COCLASS = 5,
                    TKIND_ALIAS = 6,
                    TKIND_UNION = 7,
                    TKIND_MAX = 8,
                }

                enum TYPEFLAGS
                {
                    TYPEFLAG_FAPPOBJECT = 1,
                    TYPEFLAG_FCANCREATE = 2,
                    TYPEFLAG_FLICENSED = 4,
                    TYPEFLAG_FPREDECLID = 8,
                    TYPEFLAG_FHIDDEN = 16,
                    TYPEFLAG_FCONTROL = 32,
                    TYPEFLAG_FDUAL = 64,
                    TYPEFLAG_FNONEXTENSIBLE = 128,
                    TYPEFLAG_FOLEAUTOMATION = 256,
                    TYPEFLAG_FRESTRICTED = 512,
                    TYPEFLAG_FAGGREGATABLE = 1024,
                    TYPEFLAG_FREPLACEABLE = 2048,
                    TYPEFLAG_FDISPATCHABLE = 4096,
                    TYPEFLAG_FREVERSEBIND = 8192,
                    TYPEFLAG_FPROXY = 16384,
                }

                enum IMPLTYPEFLAGS
                {
                    IMPLTYPEFLAG_FDEFAULT = 1,
                    IMPLTYPEFLAG_FSOURCE = 2,
                    IMPLTYPEFLAG_FRESTRICTED = 4,
                    IMPLTYPEFLAG_FDEFAULTVTABLE = 8,
                }

                struct TYPEATTR
                {
                    static int MEMBER_ID_NIL = -1;
                    /*0x10*/ System.Guid guid;
                    /*0x20*/ int lcid;
                    /*0x24*/ int dwReserved;
                    /*0x28*/ int memidConstructor;
                    /*0x2c*/ int memidDestructor;
                    /*0x30*/ nint lpstrSchema;
                    /*0x38*/ int cbSizeInstance;
                    /*0x3c*/ System.Runtime.InteropServices.ComTypes.TYPEKIND typekind;
                    /*0x40*/ short cFuncs;
                    /*0x42*/ short cVars;
                    /*0x44*/ short cImplTypes;
                    /*0x46*/ short cbSizeVft;
                    /*0x48*/ short cbAlignment;
                    /*0x4a*/ System.Runtime.InteropServices.ComTypes.TYPEFLAGS wTypeFlags;
                    /*0x4c*/ short wMajorVerNum;
                    /*0x4e*/ short wMinorVerNum;
                    /*0x50*/ System.Runtime.InteropServices.ComTypes.TYPEDESC tdescAlias;
                    /*0x60*/ System.Runtime.InteropServices.ComTypes.IDLDESC idldescType;
                }

                struct FUNCDESC
                {
                    /*0x10*/ int memid;
                    /*0x18*/ nint lprgscode;
                    /*0x20*/ nint lprgelemdescParam;
                    /*0x28*/ System.Runtime.InteropServices.ComTypes.FUNCKIND funckind;
                    /*0x2c*/ System.Runtime.InteropServices.ComTypes.INVOKEKIND invkind;
                    /*0x30*/ System.Runtime.InteropServices.ComTypes.CALLCONV callconv;
                    /*0x34*/ short cParams;
                    /*0x36*/ short cParamsOpt;
                    /*0x38*/ short oVft;
                    /*0x3a*/ short cScodes;
                    /*0x40*/ System.Runtime.InteropServices.ComTypes.ELEMDESC elemdescFunc;
                    /*0x60*/ short wFuncFlags;
                }

                enum IDLFLAG
                {
                    IDLFLAG_NONE = 0,
                    IDLFLAG_FIN = 1,
                    IDLFLAG_FOUT = 2,
                    IDLFLAG_FLCID = 4,
                    IDLFLAG_FRETVAL = 8,
                }

                struct IDLDESC
                {
                    /*0x10*/ nint dwReserved;
                    /*0x18*/ System.Runtime.InteropServices.ComTypes.IDLFLAG wIDLFlags;
                }

                enum PARAMFLAG
                {
                    PARAMFLAG_NONE = 0,
                    PARAMFLAG_FIN = 1,
                    PARAMFLAG_FOUT = 2,
                    PARAMFLAG_FLCID = 4,
                    PARAMFLAG_FRETVAL = 8,
                    PARAMFLAG_FOPT = 16,
                    PARAMFLAG_FHASDEFAULT = 32,
                    PARAMFLAG_FHASCUSTDATA = 64,
                }

                struct PARAMDESC
                {
                    /*0x10*/ nint lpVarValue;
                    /*0x18*/ System.Runtime.InteropServices.ComTypes.PARAMFLAG wParamFlags;
                }

                struct TYPEDESC
                {
                    /*0x10*/ nint lpValue;
                    /*0x18*/ short vt;
                }

                struct ELEMDESC
                {
                    /*0x10*/ System.Runtime.InteropServices.ComTypes.TYPEDESC tdesc;
                    /*0x20*/ System.Runtime.InteropServices.ComTypes.ELEMDESC.DESCUNION desc;

                    struct DESCUNION
                    {
                        /*0x10*/ System.Runtime.InteropServices.ComTypes.IDLDESC idldesc;
                        /*0x10*/ System.Runtime.InteropServices.ComTypes.PARAMDESC paramdesc;
                    }
                }

                enum VARKIND
                {
                    VAR_PERINSTANCE = 0,
                    VAR_STATIC = 1,
                    VAR_CONST = 2,
                    VAR_DISPATCH = 3,
                }

                struct VARDESC
                {
                    /*0x10*/ int memid;
                    /*0x18*/ string lpstrSchema;
                    /*0x20*/ System.Runtime.InteropServices.ComTypes.VARDESC.DESCUNION desc;
                    /*0x28*/ System.Runtime.InteropServices.ComTypes.ELEMDESC elemdescVar;
                    /*0x48*/ short wVarFlags;
                    /*0x4c*/ System.Runtime.InteropServices.ComTypes.VARKIND varkind;

                    struct DESCUNION
                    {
                        /*0x10*/ int oInst;
                        /*0x10*/ nint lpvarValue;
                    }
                }

                struct DISPPARAMS
                {
                    /*0x10*/ nint rgvarg;
                    /*0x18*/ nint rgdispidNamedArgs;
                    /*0x20*/ int cArgs;
                    /*0x24*/ int cNamedArgs;
                }

                struct EXCEPINFO
                {
                    /*0x10*/ short wCode;
                    /*0x12*/ short wReserved;
                    /*0x18*/ string bstrSource;
                    /*0x20*/ string bstrDescription;
                    /*0x28*/ string bstrHelpFile;
                    /*0x30*/ int dwHelpContext;
                    /*0x38*/ nint pvReserved;
                    /*0x40*/ nint pfnDeferredFillIn;
                    /*0x48*/ int scode;
                }

                enum FUNCKIND
                {
                    FUNC_VIRTUAL = 0,
                    FUNC_PUREVIRTUAL = 1,
                    FUNC_NONVIRTUAL = 2,
                    FUNC_STATIC = 3,
                    FUNC_DISPATCH = 4,
                }

                enum INVOKEKIND
                {
                    INVOKE_FUNC = 1,
                    INVOKE_PROPERTYGET = 2,
                    INVOKE_PROPERTYPUT = 4,
                    INVOKE_PROPERTYPUTREF = 8,
                }

                enum CALLCONV
                {
                    CC_CDECL = 1,
                    CC_MSCPASCAL = 2,
                    CC_PASCAL = 2,
                    CC_MACPASCAL = 3,
                    CC_STDCALL = 4,
                    CC_RESERVED = 5,
                    CC_SYSCALL = 6,
                    CC_MPWCDECL = 7,
                    CC_MPWPASCAL = 8,
                    CC_MAX = 9,
                }

                enum FUNCFLAGS
                {
                    FUNCFLAG_FRESTRICTED = 1,
                    FUNCFLAG_FSOURCE = 2,
                    FUNCFLAG_FBINDABLE = 4,
                    FUNCFLAG_FREQUESTEDIT = 8,
                    FUNCFLAG_FDISPLAYBIND = 16,
                    FUNCFLAG_FDEFAULTBIND = 32,
                    FUNCFLAG_FHIDDEN = 64,
                    FUNCFLAG_FUSESGETLASTERROR = 128,
                    FUNCFLAG_FDEFAULTCOLLELEM = 256,
                    FUNCFLAG_FUIDEFAULT = 512,
                    FUNCFLAG_FNONBROWSABLE = 1024,
                    FUNCFLAG_FREPLACEABLE = 2048,
                    FUNCFLAG_FIMMEDIATEBIND = 4096,
                }

                enum VARFLAGS
                {
                    VARFLAG_FREADONLY = 1,
                    VARFLAG_FSOURCE = 2,
                    VARFLAG_FBINDABLE = 4,
                    VARFLAG_FREQUESTEDIT = 8,
                    VARFLAG_FDISPLAYBIND = 16,
                    VARFLAG_FDEFAULTBIND = 32,
                    VARFLAG_FHIDDEN = 64,
                    VARFLAG_FRESTRICTED = 128,
                    VARFLAG_FDEFAULTCOLLELEM = 256,
                    VARFLAG_FUIDEFAULT = 512,
                    VARFLAG_FNONBROWSABLE = 1024,
                    VARFLAG_FREPLACEABLE = 2048,
                    VARFLAG_FIMMEDIATEBIND = 4096,
                }

                interface ITypeInfo
                {
                    /*0x20a71cc*/ void GetTypeAttr(ref nint ppTypeAttr);
                    /*0x20a7204*/ void GetTypeComp(ref System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp);
                    /*0x20a72d8*/ void GetFuncDesc(int index, ref nint ppFuncDesc);
                    /*0x20a7320*/ void GetVarDesc(int index, ref nint ppVarDesc);
                    /*0x20a7368*/ void GetNames(int memid, string[] rgBstrNames, int cMaxNames, ref int pcNames);
                    /*0x20a7478*/ void GetRefTypeOfImplType(int index, ref int href);
                    /*0x20a74c0*/ void GetImplTypeFlags(int index, ref System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags);
                    /*0x20a7508*/ void GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId);
                    /*0x20a7660*/ void Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, nint pVarResult, nint pExcepInfo, ref int puArgErr);
                    /*0x20a7760*/ void GetDocumentation(int index, ref string strName, ref string strDocString, ref int dwHelpContext, ref string strHelpFile);
                    /*0x20a781c*/ void GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, nint pBstrDllName, nint pBstrName, nint pwOrdinal);
                    /*0x20a7884*/ void GetRefTypeInfo(int hRef, ref System.Runtime.InteropServices.ComTypes.ITypeInfo ppTI);
                    /*0x20a7960*/ void AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, ref nint ppv);
                    /*0x20a79b0*/ void CreateInstance(object pUnkOuter, ref System.Guid riid, ref object ppvObj);
                    /*0x20a7b00*/ void GetMops(int memid, ref string pBstrMops);
                    /*0x20a7b60*/ void GetContainingTypeLib(ref System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, ref int pIndex);
                    /*0x20a7c3c*/ void ReleaseTypeAttr(nint pTypeAttr);
                    /*0x20a7c64*/ void ReleaseFuncDesc(nint pFuncDesc);
                    /*0x20a7c8c*/ void ReleaseVarDesc(nint pVarDesc);
                }

                interface ITypeInfo2 : System.Runtime.InteropServices.ComTypes.ITypeInfo
                {
                    /*0x20a7cb4*/ void GetTypeAttr(ref nint ppTypeAttr);
                    /*0x20a7cec*/ void GetTypeComp(ref System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp);
                    /*0x20a7dc0*/ void GetFuncDesc(int index, ref nint ppFuncDesc);
                    /*0x20a7e08*/ void GetVarDesc(int index, ref nint ppVarDesc);
                    /*0x20a7e50*/ void GetNames(int memid, string[] rgBstrNames, int cMaxNames, ref int pcNames);
                    /*0x20a7f60*/ void GetRefTypeOfImplType(int index, ref int href);
                    /*0x20a7fa8*/ void GetImplTypeFlags(int index, ref System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS pImplTypeFlags);
                    /*0x20a7ff0*/ void GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId);
                    /*0x20a8148*/ void Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.ComTypes.DISPPARAMS pDispParams, nint pVarResult, nint pExcepInfo, ref int puArgErr);
                    /*0x20a8248*/ void GetDocumentation(int index, ref string strName, ref string strDocString, ref int dwHelpContext, ref string strHelpFile);
                    /*0x20a8304*/ void GetDllEntry(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, nint pBstrDllName, nint pBstrName, nint pwOrdinal);
                    /*0x20a836c*/ void GetRefTypeInfo(int hRef, ref System.Runtime.InteropServices.ComTypes.ITypeInfo ppTI);
                    /*0x20a8448*/ void AddressOfMember(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, ref nint ppv);
                    /*0x20a8498*/ void CreateInstance(object pUnkOuter, ref System.Guid riid, ref object ppvObj);
                    /*0x20a85e8*/ void GetMops(int memid, ref string pBstrMops);
                    /*0x20a8648*/ void GetContainingTypeLib(ref System.Runtime.InteropServices.ComTypes.ITypeLib ppTLB, ref int pIndex);
                    /*0x20a8724*/ void ReleaseTypeAttr(nint pTypeAttr);
                    /*0x20a874c*/ void ReleaseFuncDesc(nint pFuncDesc);
                    /*0x20a8774*/ void ReleaseVarDesc(nint pVarDesc);
                    /*0x20a879c*/ void GetTypeKind(ref System.Runtime.InteropServices.ComTypes.TYPEKIND pTypeKind);
                    /*0x20a87d4*/ void GetTypeFlags(ref int pTypeFlags);
                    /*0x20a880c*/ void GetFuncIndexOfMemId(int memid, System.Runtime.InteropServices.ComTypes.INVOKEKIND invKind, ref int pFuncIndex);
                    /*0x20a885c*/ void GetVarIndexOfMemId(int memid, ref int pVarIndex);
                    /*0x20a88a4*/ void GetCustData(ref System.Guid guid, ref object pVarVal);
                    /*0x20a8910*/ void GetFuncCustData(int index, ref System.Guid guid, ref object pVarVal);
                    /*0x20a8984*/ void GetParamCustData(int indexFunc, int indexParam, ref System.Guid guid, ref object pVarVal);
                    /*0x20a8a08*/ void GetVarCustData(int index, ref System.Guid guid, ref object pVarVal);
                    /*0x20a8a7c*/ void GetImplTypeCustData(int index, ref System.Guid guid, ref object pVarVal);
                    /*0x20a8af0*/ void GetDocumentation2(int memid, ref string pbstrHelpString, ref int pdwHelpStringContext, ref string pbstrHelpStringDll);
                    /*0x20a8b8c*/ void GetAllCustData(nint pCustData);
                    /*0x20a8bc4*/ void GetAllFuncCustData(int index, nint pCustData);
                    /*0x20a8c0c*/ void GetAllParamCustData(int indexFunc, int indexParam, nint pCustData);
                    /*0x20a8c5c*/ void GetAllVarCustData(int index, nint pCustData);
                    /*0x20a8ca4*/ void GetAllImplTypeCustData(int index, nint pCustData);
                }

                enum SYSKIND
                {
                    SYS_WIN16 = 0,
                    SYS_WIN32 = 1,
                    SYS_MAC = 2,
                    SYS_WIN64 = 3,
                }

                enum LIBFLAGS
                {
                    LIBFLAG_FRESTRICTED = 1,
                    LIBFLAG_FCONTROL = 2,
                    LIBFLAG_FHIDDEN = 4,
                    LIBFLAG_FHASDISKIMAGE = 8,
                }

                struct TYPELIBATTR
                {
                    /*0x10*/ System.Guid guid;
                    /*0x20*/ int lcid;
                    /*0x24*/ System.Runtime.InteropServices.ComTypes.SYSKIND syskind;
                    /*0x28*/ short wMajorVerNum;
                    /*0x2a*/ short wMinorVerNum;
                    /*0x2c*/ System.Runtime.InteropServices.ComTypes.LIBFLAGS wLibFlags;
                }

                interface ITypeLib
                {
                    /*0x20a8cec*/ int GetTypeInfoCount();
                    /*0x20a8d0c*/ void GetTypeInfo(int index, ref System.Runtime.InteropServices.ComTypes.ITypeInfo ppTI);
                    /*0x20a8de8*/ void GetTypeInfoType(int index, ref System.Runtime.InteropServices.ComTypes.TYPEKIND pTKind);
                    /*0x20a8e30*/ void GetTypeInfoOfGuid(ref System.Guid guid, ref System.Runtime.InteropServices.ComTypes.ITypeInfo ppTInfo);
                    /*0x20a8f0c*/ void GetLibAttr(ref nint ppTLibAttr);
                    /*0x20a8f44*/ void GetTypeComp(ref System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp);
                    /*0x20a9018*/ void GetDocumentation(int index, ref string strName, ref string strDocString, ref int dwHelpContext, ref string strHelpFile);
                    /*0x20a90d4*/ bool IsName(string szNameBuf, int lHashVal);
                    /*0x20a9138*/ void FindName(string szNameBuf, int lHashVal, System.Runtime.InteropServices.ComTypes.ITypeInfo[] ppTInfo, int[] rgMemId, ref short pcFound);
                    /*0x20a9150*/ void ReleaseTLibAttr(nint pTLibAttr);
                }

                interface ITypeLib2 : System.Runtime.InteropServices.ComTypes.ITypeLib
                {
                    /*0x20a9178*/ int GetTypeInfoCount();
                    /*0x20a9198*/ void GetTypeInfo(int index, ref System.Runtime.InteropServices.ComTypes.ITypeInfo ppTI);
                    /*0x20a9274*/ void GetTypeInfoType(int index, ref System.Runtime.InteropServices.ComTypes.TYPEKIND pTKind);
                    /*0x20a92bc*/ void GetTypeInfoOfGuid(ref System.Guid guid, ref System.Runtime.InteropServices.ComTypes.ITypeInfo ppTInfo);
                    /*0x20a9398*/ void GetLibAttr(ref nint ppTLibAttr);
                    /*0x20a93d0*/ void GetTypeComp(ref System.Runtime.InteropServices.ComTypes.ITypeComp ppTComp);
                    /*0x20a94a4*/ void GetDocumentation(int index, ref string strName, ref string strDocString, ref int dwHelpContext, ref string strHelpFile);
                    /*0x20a9560*/ bool IsName(string szNameBuf, int lHashVal);
                    /*0x20a95c4*/ void FindName(string szNameBuf, int lHashVal, System.Runtime.InteropServices.ComTypes.ITypeInfo[] ppTInfo, int[] rgMemId, ref short pcFound);
                    /*0x20a95dc*/ void ReleaseTLibAttr(nint pTLibAttr);
                    /*0x20a9604*/ void GetCustData(ref System.Guid guid, ref object pVarVal);
                    /*0x20a9670*/ void GetDocumentation2(int index, ref string pbstrHelpString, ref int pdwHelpStringContext, ref string pbstrHelpStringDll);
                    /*0x20a970c*/ void GetLibStatistics(nint pcUniqueNames, ref int pcchUniqueNames);
                    /*0x20a9754*/ void GetAllCustData(nint pCustData);
                }
            }
        }

        namespace ExceptionServices
        {
            class FirstChanceExceptionEventArgs : System.EventArgs
            {
                /*0x10*/ System.Exception <Exception>k__BackingField;

                /*0x20a978c*/ FirstChanceExceptionEventArgs(System.Exception exception);
                /*0x20a97f8*/ System.Exception get_Exception();
            }

            class HandleProcessCorruptedStateExceptionsAttribute : System.Attribute
            {
                /*0x20a9800*/ HandleProcessCorruptedStateExceptionsAttribute();
            }

            class ExceptionDispatchInfo
            {
                /*0x10*/ System.Exception m_Exception;
                /*0x18*/ object m_stackTrace;

                static /*0x20a9938*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo Capture(System.Exception source);
                static /*0x20a9a50*/ void Throw(System.Exception source);
                /*0x20a9808*/ ExceptionDispatchInfo(System.Exception exception);
                /*0x20a9a68*/ ExceptionDispatchInfo();
                /*0x20a9930*/ object get_BinaryStackTraceArray();
                /*0x20a9a04*/ System.Exception get_SourceException();
                /*0x20a9a0c*/ void Throw();
            }
        }

        namespace ConstrainedExecution
        {
            enum Cer
            {
                None = 0,
                MayFail = 1,
                Success = 2,
            }

            enum Consistency
            {
                MayCorruptProcess = 0,
                MayCorruptAppDomain = 1,
                MayCorruptInstance = 2,
                WillNotCorruptState = 3,
            }

            class ReliabilityContractAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.ConstrainedExecution.Consistency <ConsistencyGuarantee>k__BackingField;
                /*0x14*/ System.Runtime.ConstrainedExecution.Cer <Cer>k__BackingField;

                /*0x20a9aa0*/ ReliabilityContractAttribute(System.Runtime.ConstrainedExecution.Consistency consistencyGuarantee, System.Runtime.ConstrainedExecution.Cer cer);
                /*0x20a9acc*/ System.Runtime.ConstrainedExecution.Consistency get_ConsistencyGuarantee();
                /*0x20a9ad4*/ System.Runtime.ConstrainedExecution.Cer get_Cer();
            }

            class PrePrepareMethodAttribute : System.Attribute
            {
                /*0x20a9adc*/ PrePrepareMethodAttribute();
            }

            class CriticalFinalizerObject
            {
                /*0x20a9ae4*/ CriticalFinalizerObject();
                /*0x20a9aec*/ void Finalize();
            }
        }

        namespace CompilerServices
        {
            class AccessedThroughPropertyAttribute : System.Attribute
            {
                /*0x10*/ string <PropertyName>k__BackingField;

                /*0x20a9af4*/ AccessedThroughPropertyAttribute(string propertyName);
                /*0x20a9b1c*/ string get_PropertyName();
            }

            struct AsyncIteratorMethodBuilder
            {
                /*0x10*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder _methodBuilder;

                static /*0x20a9b24*/ System.Runtime.CompilerServices.AsyncIteratorMethodBuilder Create();
                void MoveNext<TStateMachine>(ref TStateMachine stateMachine);
                void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                /*0x20a9b30*/ void Complete();
                /*0x20a9bac*/ object get_ObjectIdForDebugger();
            }

            class AsyncIteratorStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                /*0x20a9bb4*/ AsyncIteratorStateMachineAttribute(System.Type stateMachineType);
            }

            class AsyncMethodBuilderAttribute : System.Attribute
            {
                /*0x10*/ System.Type <BuilderType>k__BackingField;

                /*0x20a9c04*/ AsyncMethodBuilderAttribute(System.Type builderType);
                /*0x20a9c2c*/ System.Type get_BuilderType();
            }

            class AsyncStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                /*0x20a9c34*/ AsyncStateMachineAttribute(System.Type stateMachineType);
            }

            struct AsyncValueTaskMethodBuilder
            {
                /*0x10*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder _methodBuilder;
                /*0x28*/ bool _haveResult;
                /*0x29*/ bool _useBuilder;

                static /*0x20a9c5c*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder Create();
                void Start<TStateMachine>(ref TStateMachine stateMachine);
                /*0x20a9c68*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                /*0x20a9cc4*/ void SetResult();
                /*0x20a9cdc*/ void SetException(System.Exception exception);
                /*0x20a9d38*/ System.Threading.Tasks.ValueTask get_Task();
                void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
            }

            struct AsyncValueTaskMethodBuilder<TResult>
            {
                /*0x0*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<TResult> _methodBuilder;
                /*0x0*/ TResult _result;
                /*0x0*/ bool _haveResult;
                /*0x0*/ bool _useBuilder;

                static System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<TResult> Create();
                void Start<TStateMachine>(ref TStateMachine stateMachine);
                void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                void SetResult(TResult result);
                void SetException(System.Exception exception);
                System.Threading.Tasks.ValueTask<TResult> get_Task();
                void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
            }

            class CallerFilePathAttribute : System.Attribute
            {
                /*0x20a9dc8*/ CallerFilePathAttribute();
            }

            class CallerLineNumberAttribute : System.Attribute
            {
                /*0x20a9dd0*/ CallerLineNumberAttribute();
            }

            class CallerMemberNameAttribute : System.Attribute
            {
                /*0x20a9dd8*/ CallerMemberNameAttribute();
            }

            class CompilerGeneratedAttribute : System.Attribute
            {
                /*0x20a9de0*/ CompilerGeneratedAttribute();
            }

            class CompilerGlobalScopeAttribute : System.Attribute
            {
                /*0x20a9de8*/ CompilerGlobalScopeAttribute();
            }

            struct ConfiguredAsyncDisposable
            {
                /*0x10*/ System.IAsyncDisposable _source;
                /*0x18*/ bool _continueOnCapturedContext;

                /*0x20a9df0*/ ConfiguredAsyncDisposable(System.IAsyncDisposable source, bool continueOnCapturedContext);
                /*0x20a9e00*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable DisposeAsync();
            }

            struct ConfiguredCancelableAsyncEnumerable<T>
            {
                /*0x0*/ System.Collections.Generic.IAsyncEnumerable<T> _enumerable;
                /*0x0*/ System.Threading.CancellationToken _cancellationToken;
                /*0x0*/ bool _continueOnCapturedContext;

                ConfiguredCancelableAsyncEnumerable(System.Collections.Generic.IAsyncEnumerable<T> enumerable, bool continueOnCapturedContext, System.Threading.CancellationToken cancellationToken);
                System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> ConfigureAwait(bool continueOnCapturedContext);
                System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable<T> WithCancellation(System.Threading.CancellationToken cancellationToken);
                System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable.Enumerator<T> GetAsyncEnumerator();

                struct Enumerator<T>
                {
                    /*0x0*/ System.Collections.Generic.IAsyncEnumerator<T> _enumerator;
                    /*0x0*/ bool _continueOnCapturedContext;

                    Enumerator(System.Collections.Generic.IAsyncEnumerator<T> enumerator, bool continueOnCapturedContext);
                }
            }

            struct ConfiguredValueTaskAwaitable
            {
                /*0x10*/ System.Threading.Tasks.ValueTask _value;

                /*0x20a9eb0*/ ConfiguredValueTaskAwaitable(System.Threading.Tasks.ValueTask value);
                /*0x20a9eb8*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter GetAwaiter();

                struct ConfiguredValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    /*0x10*/ System.Threading.Tasks.ValueTask _value;

                    /*0x20a9ec4*/ ConfiguredValueTaskAwaiter(System.Threading.Tasks.ValueTask value);
                    /*0x20a9ecc*/ bool get_IsCompleted();
                    /*0x20a9fd4*/ void GetResult();
                    /*0x20aa0d4*/ void OnCompleted(System.Action continuation);
                    /*0x20aa298*/ void UnsafeOnCompleted(System.Action continuation);
                }
            }

            struct ConfiguredValueTaskAwaitable<TResult>
            {
                /*0x0*/ System.Threading.Tasks.ValueTask<TResult> _value;

                ConfiguredValueTaskAwaitable(System.Threading.Tasks.ValueTask<TResult> value);
                System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<TResult> GetAwaiter();

                struct ConfiguredValueTaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    /*0x0*/ System.Threading.Tasks.ValueTask<TResult> _value;

                    ConfiguredValueTaskAwaiter(System.Threading.Tasks.ValueTask<TResult> value);
                    bool get_IsCompleted();
                    TResult GetResult();
                    void OnCompleted(System.Action continuation);
                    void UnsafeOnCompleted(System.Action continuation);
                }
            }

            class CustomConstantAttribute : System.Attribute
            {
                /*0x20aa458*/ CustomConstantAttribute();
                object get_Value();
            }

            class DateTimeConstantAttribute : System.Runtime.CompilerServices.CustomConstantAttribute
            {
                /*0x10*/ System.DateTime _date;

                /*0x20aa460*/ DateTimeConstantAttribute(long ticks);
                /*0x20aa4a0*/ object get_Value();
            }

            class DecimalConstantAttribute : System.Attribute
            {
                /*0x10*/ decimal _dec;

                /*0x20aa4fc*/ DecimalConstantAttribute(byte scale, byte sign, uint hi, uint mid, uint low);
                /*0x20aa598*/ DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
                /*0x20aa634*/ decimal get_Value();
            }

            class DisablePrivateReflectionAttribute : System.Attribute
            {
                /*0x20aa640*/ DisablePrivateReflectionAttribute();
            }

            class DiscardableAttribute : System.Attribute
            {
                /*0x20aa648*/ DiscardableAttribute();
            }

            class ExtensionAttribute : System.Attribute
            {
                /*0x20aa650*/ ExtensionAttribute();
            }

            class FixedAddressValueTypeAttribute : System.Attribute
            {
                /*0x20aa658*/ FixedAddressValueTypeAttribute();
            }

            class FixedBufferAttribute : System.Attribute
            {
                /*0x10*/ System.Type <ElementType>k__BackingField;
                /*0x18*/ int <Length>k__BackingField;

                /*0x20aa660*/ FixedBufferAttribute(System.Type elementType, int length);
                /*0x20aa690*/ System.Type get_ElementType();
                /*0x20aa698*/ int get_Length();
            }

            class FormattableStringFactory
            {
                static /*0x20aa6a0*/ System.FormattableString Create(string format, object[] arguments);

                class ConcreteFormattableString : System.FormattableString
                {
                    /*0x10*/ string _format;
                    /*0x18*/ object[] _arguments;

                    /*0x20aa780*/ ConcreteFormattableString(string format, object[] arguments);
                    /*0x20aa7ac*/ string get_Format();
                    /*0x20aa7b4*/ object[] GetArguments();
                    /*0x20aa7bc*/ int get_ArgumentCount();
                    /*0x20aa7d8*/ object GetArgument(int index);
                    /*0x20aa808*/ string ToString(System.IFormatProvider formatProvider);
                }
            }

            interface IAsyncStateMachine
            {
                void MoveNext();
                void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            interface INotifyCompletion
            {
                void OnCompleted(System.Action continuation);
            }

            interface ICriticalNotifyCompletion : System.Runtime.CompilerServices.INotifyCompletion
            {
                void UnsafeOnCompleted(System.Action continuation);
            }

            interface ITuple
            {
                int get_Length();
                object get_Item(int index);
            }

            class IndexerNameAttribute : System.Attribute
            {
                /*0x20aa81c*/ IndexerNameAttribute(string indexerName);
            }

            class IntrinsicAttribute : System.Attribute
            {
                /*0x20aa824*/ IntrinsicAttribute();
            }

            class IsByRefLikeAttribute : System.Attribute
            {
                /*0x20aa82c*/ IsByRefLikeAttribute();
            }

            class IsConst
            {
            }

            class IsReadOnlyAttribute : System.Attribute
            {
                /*0x20aa834*/ IsReadOnlyAttribute();
            }

            class IsVolatile
            {
            }

            class IteratorStateMachineAttribute : System.Runtime.CompilerServices.StateMachineAttribute
            {
                /*0x20aa83c*/ IteratorStateMachineAttribute(System.Type stateMachineType);
            }

            class ReferenceAssemblyAttribute : System.Attribute
            {
                /*0x10*/ string <Description>k__BackingField;

                /*0x20aa864*/ ReferenceAssemblyAttribute();
                /*0x20aa86c*/ ReferenceAssemblyAttribute(string description);
                /*0x20aa894*/ string get_Description();
            }

            class RuntimeCompatibilityAttribute : System.Attribute
            {
                /*0x10*/ bool <WrapNonExceptionThrows>k__BackingField;

                /*0x20aa89c*/ RuntimeCompatibilityAttribute();
                /*0x20aa8a4*/ bool get_WrapNonExceptionThrows();
                /*0x20aa8ac*/ void set_WrapNonExceptionThrows(bool value);
            }

            class RuntimeFeature
            {
                static string PortablePdb = "PortablePdb";
                static string DefaultImplementationsOfInterfaces = "DefaultImplementationsOfInterfaces";

                static /*0x20aa8b8*/ bool IsSupported(string feature);
                static /*0x20aa98c*/ bool get_IsDynamicCodeSupported();
                static /*0x20aa994*/ bool get_IsDynamicCodeCompiled();
            }

            class RuntimeWrappedException : System.Exception
            {
                /*0x90*/ object _wrappedException;

                /*0x20aa99c*/ RuntimeWrappedException(object thrownObject);
                /*0x20aaa2c*/ RuntimeWrappedException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x20aac10*/ RuntimeWrappedException();
                /*0x20aab2c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x20aac08*/ object get_WrappedException();
            }

            class SpecialNameAttribute : System.Attribute
            {
                /*0x20aac48*/ SpecialNameAttribute();
            }

            class StateMachineAttribute : System.Attribute
            {
                /*0x10*/ System.Type <StateMachineType>k__BackingField;

                /*0x20a9bdc*/ StateMachineAttribute(System.Type stateMachineType);
                /*0x20aac50*/ System.Type get_StateMachineType();
            }

            class StringFreezingAttribute : System.Attribute
            {
                /*0x20aac58*/ StringFreezingAttribute();
            }

            class SuppressIldasmAttribute : System.Attribute
            {
                /*0x20aac60*/ SuppressIldasmAttribute();
            }

            class TupleElementNamesAttribute : System.Attribute
            {
                /*0x10*/ string[] _transformNames;

                /*0x20aac68*/ TupleElementNamesAttribute(string[] transformNames);
                /*0x20aace0*/ System.Collections.Generic.IList<string> get_TransformNames();
            }

            class TypeForwardedFromAttribute : System.Attribute
            {
                /*0x10*/ string <AssemblyFullName>k__BackingField;

                /*0x20aace8*/ TypeForwardedFromAttribute(string assemblyFullName);
                /*0x20aad6c*/ string get_AssemblyFullName();
            }

            class TypeForwardedToAttribute : System.Attribute
            {
                /*0x10*/ System.Type <Destination>k__BackingField;

                /*0x20aad74*/ TypeForwardedToAttribute(System.Type destination);
                /*0x20aad9c*/ System.Type get_Destination();
            }

            class UnsafeValueTypeAttribute : System.Attribute
            {
                /*0x20aada4*/ UnsafeValueTypeAttribute();
            }

            struct ValueTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                static /*0x0*/ System.Action<object> s_invokeActionDelegate;
                /*0x10*/ System.Threading.Tasks.ValueTask _value;

                static /*0x20ab2f4*/ ValueTaskAwaiter();
                /*0x20aadac*/ ValueTaskAwaiter(System.Threading.Tasks.ValueTask value);
                /*0x20aadb4*/ bool get_IsCompleted();
                /*0x20aaebc*/ void GetResult();
                /*0x20aafbc*/ void OnCompleted(System.Action continuation);
                /*0x20ab158*/ void UnsafeOnCompleted(System.Action continuation);

                class <>c
                {
                    static /*0x0*/ System.Runtime.CompilerServices.ValueTaskAwaiter.<> <>9;

                    static /*0x20ab3b8*/ <>c();
                    /*0x20ab41c*/ <>c();
                    /*0x20ab424*/ void <.cctor>b__9_0(object state);
                }
            }

            struct ValueTaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
            {
                /*0x0*/ System.Threading.Tasks.ValueTask<TResult> _value;

                ValueTaskAwaiter(System.Threading.Tasks.ValueTask<TResult> value);
                bool get_IsCompleted();
                TResult GetResult();
                void OnCompleted(System.Action continuation);
                void UnsafeOnCompleted(System.Action continuation);
            }

            struct TaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ITaskAwaiter
            {
                /*0x10*/ System.Threading.Tasks.Task m_task;

                static /*0x20ab578*/ void ValidateEnd(System.Threading.Tasks.Task task);
                static /*0x20ab5c4*/ void HandleNonSuccessAndDebuggerNotification(System.Threading.Tasks.Task task);
                static /*0x20ab624*/ void ThrowForNonSuccess(System.Threading.Tasks.Task task);
                static /*0x20ab4bc*/ void OnCompletedInternal(System.Threading.Tasks.Task task, System.Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);
                static /*0x20ab778*/ System.Action OutputWaitEtwEvents(System.Threading.Tasks.Task task, System.Action continuation);
                /*0x20ab498*/ TaskAwaiter(System.Threading.Tasks.Task task);
                /*0x20ab4a0*/ bool get_IsCompleted();
                /*0x20ab148*/ void OnCompleted(System.Action continuation);
                /*0x20ab2e4*/ void UnsafeOnCompleted(System.Action continuation);
                /*0x20ab570*/ void GetResult();

                class <>c__DisplayClass11_0
                {
                    /*0x10*/ System.Threading.Tasks.Task task;
                    /*0x18*/ System.Action continuation;

                    /*0x20ab954*/ <>c__DisplayClass11_0();
                    /*0x20ab95c*/ void <OutputWaitEtwEvents>b__0();
                }
            }

            struct TaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.ITaskAwaiter
            {
                /*0x0*/ System.Threading.Tasks.Task<TResult> m_task;

                TaskAwaiter(System.Threading.Tasks.Task<TResult> task);
                bool get_IsCompleted();
                void OnCompleted(System.Action continuation);
                void UnsafeOnCompleted(System.Action continuation);
                TResult GetResult();
            }

            interface ITaskAwaiter
            {
            }

            interface IConfiguredTaskAwaiter
            {
            }

            struct ConfiguredTaskAwaitable
            {
                /*0x10*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter m_configuredTaskAwaiter;

                /*0x20abad0*/ ConfiguredTaskAwaitable(System.Threading.Tasks.Task task, bool continueOnCapturedContext);
                /*0x20abaf8*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter GetAwaiter();

                struct ConfiguredTaskAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.IConfiguredTaskAwaiter
                {
                    /*0x10*/ System.Threading.Tasks.Task m_task;
                    /*0x18*/ bool m_continueOnCapturedContext;

                    /*0x20abae8*/ ConfiguredTaskAwaiter(System.Threading.Tasks.Task task, bool continueOnCapturedContext);
                    /*0x20abb04*/ bool get_IsCompleted();
                    /*0x20aa284*/ void OnCompleted(System.Action continuation);
                    /*0x20aa444*/ void UnsafeOnCompleted(System.Action continuation);
                    /*0x20abb20*/ void GetResult();
                }
            }

            struct ConfiguredTaskAwaitable<TResult>
            {
                /*0x0*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter;

                ConfiguredTaskAwaitable(System.Threading.Tasks.Task<TResult> task, bool continueOnCapturedContext);
                System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<TResult> GetAwaiter();

                struct ConfiguredTaskAwaiter<TResult> : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion, System.Runtime.CompilerServices.IConfiguredTaskAwaiter
                {
                    /*0x0*/ System.Threading.Tasks.Task<TResult> m_task;
                    /*0x0*/ bool m_continueOnCapturedContext;

                    ConfiguredTaskAwaiter(System.Threading.Tasks.Task<TResult> task, bool continueOnCapturedContext);
                    bool get_IsCompleted();
                    void OnCompleted(System.Action continuation);
                    void UnsafeOnCompleted(System.Action continuation);
                    TResult GetResult();
                }
            }

            class ReflectionBlockedAttribute : System.Attribute
            {
                /*0x20abb28*/ ReflectionBlockedAttribute();
            }

            class ContractHelper
            {
                static int COR_E_CODECONTRACTFAILED = -2146233022;
                static /*0x0*/ System.EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs> contractFailedEvent;
                static /*0x8*/ object lockObject;

                static /*0x20ac93c*/ ContractHelper();
                static /*0x20abb30*/ string RaiseContractFailedEvent(System.Diagnostics.Contracts.ContractFailureKind failureKind, string userMessage, string conditionText, System.Exception innerException);
                static /*0x20ac0ac*/ void TriggerFailure(System.Diagnostics.Contracts.ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, System.Exception innerException);
                static /*0x20abbdc*/ void RaiseContractFailedEventImplementation(System.Diagnostics.Contracts.ContractFailureKind failureKind, string userMessage, string conditionText, System.Exception innerException, ref string resultFailureMessage);
                static /*0x20ac130*/ void TriggerFailureImplementation(System.Diagnostics.Contracts.ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, System.Exception innerException);
                static /*0x20ac5d0*/ void add_InternalContractFailed(System.EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs> value);
                static /*0x20ac788*/ void remove_InternalContractFailed(System.EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs> value);
                static /*0x20ac43c*/ string GetResourceNameForFailure(System.Diagnostics.Contracts.ContractFailureKind failureKind, bool withCondition);
                static /*0x20ac290*/ string GetDisplayMessage(System.Diagnostics.Contracts.ContractFailureKind failureKind, string userMessage, string conditionText);
                static /*0x20ac3f4*/ void TriggerCodeContractEscalationPolicy(System.Diagnostics.Contracts.ContractFailureKind failureKind, string message, string conditionText, System.Exception innerException);
            }

            struct AsyncVoidMethodBuilder
            {
                /*0x10*/ System.Threading.SynchronizationContext m_synchronizationContext;
                /*0x18*/ System.Runtime.CompilerServices.AsyncMethodBuilderCore m_coreState;
                /*0x28*/ System.Threading.Tasks.Task m_task;

                static /*0x20ac9b4*/ System.Runtime.CompilerServices.AsyncVoidMethodBuilder Create();
                void Start<TStateMachine>(ref TStateMachine stateMachine);
                /*0x20ac9f4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                /*0x20acac4*/ void SetResult();
                /*0x20acc30*/ void SetException(System.Exception exception);
                /*0x20acb8c*/ void NotifySynchronizationContextOfCompletion();
                /*0x20acb20*/ System.Threading.Tasks.Task get_Task();
                /*0x20ad050*/ object get_ObjectIdForDebugger();
            }

            struct AsyncTaskMethodBuilder
            {
                static /*0x0*/ System.Threading.Tasks.Task<System.Threading.Tasks.VoidTaskResult> s_cachedCompleted;
                /*0x10*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<System.Threading.Tasks.VoidTaskResult> m_builder;

                static /*0x20ad0b8*/ AsyncTaskMethodBuilder();
                static /*0x20ad054*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder Create();
                void Start<TStateMachine>(ref TStateMachine stateMachine);
                /*0x20a9c6c*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                /*0x20a9d80*/ System.Threading.Tasks.Task get_Task();
                /*0x20a9b34*/ void SetResult();
                /*0x20a9ce0*/ void SetException(System.Exception exception);
                /*0x20ad060*/ void SetNotificationForWaitCompletion(bool enabled);
                /*0x20a9bb0*/ object get_ObjectIdForDebugger();
            }

            struct AsyncTaskMethodBuilder<TResult>
            {
                static /*0x0*/ System.Threading.Tasks.Task<TResult> s_defaultResultTask;
                /*0x0*/ System.Runtime.CompilerServices.AsyncMethodBuilderCore m_coreState;
                /*0x0*/ System.Threading.Tasks.Task<TResult> m_task;

                static AsyncTaskMethodBuilder();
                static System.Runtime.CompilerServices.AsyncTaskMethodBuilder<TResult> Create();
                static System.Threading.Tasks.Task<TResult> GetTaskForResult(TResult result);
                void Start<TStateMachine>(ref TStateMachine stateMachine);
                void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                void AwaitOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                void AwaitUnsafeOnCompleted<TAwaiter, TStateMachine>(ref TAwaiter awaiter, ref TStateMachine stateMachine);
                System.Threading.Tasks.Task<TResult> get_Task();
                void SetResult(TResult result);
                void SetResult(System.Threading.Tasks.Task<TResult> completedTask);
                void SetException(System.Exception exception);
                void SetNotificationForWaitCompletion(bool enabled);
                object get_ObjectIdForDebugger();
            }

            class AsyncTaskCache
            {
                static int INCLUSIVE_INT32_MIN = -1;
                static int EXCLUSIVE_INT32_MAX = 9;
                static /*0x0*/ System.Threading.Tasks.Task<bool> TrueTask;
                static /*0x8*/ System.Threading.Tasks.Task<bool> FalseTask;
                static /*0x10*/ System.Threading.Tasks.Task<int> Int32Tasks;

                static /*0x20ad238*/ AsyncTaskCache();
                static /*0x20ad130*/ System.Threading.Tasks.Task<int> CreateInt32Tasks();
                static System.Threading.Tasks.Task<TResult> CreateCacheableTask<TResult>(TResult result);
            }

            struct AsyncMethodBuilderCore
            {
                /*0x10*/ System.Runtime.CompilerServices.IAsyncStateMachine m_stateMachine;
                /*0x18*/ System.Action m_defaultContextAction;

                static void Start<TStateMachine>(ref TStateMachine stateMachine);
                static /*0x20acd64*/ void ThrowAsync(System.Exception exception, System.Threading.SynchronizationContext targetContext);
                static /*0x20ad588*/ System.Action CreateContinuationWrapper(System.Action continuation, System.Action invokeAction, System.Threading.Tasks.Task innerTask);
                static /*0x20ad838*/ System.Action TryGetStateMachineForDebugger(System.Action action);
                static /*0x20ad990*/ System.Threading.Tasks.Task TryGetContinuationTask(System.Action action);
                /*0x20ac9fc*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                /*0x20ad2c8*/ System.Action GetCompletionAction(System.Threading.Tasks.Task taskForTracing, ref System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner runnerToInitialize);
                /*0x20ad4c0*/ System.Action OutputAsyncCausalityEvents(System.Threading.Tasks.Task innerTask, System.Action continuation);
                /*0x20ad648*/ void PostBoxInitialization(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine, System.Runtime.CompilerServices.AsyncMethodBuilderCore.MoveNextRunner runner, System.Threading.Tasks.Task builtTask);

                class MoveNextRunner
                {
                    static /*0x0*/ System.Threading.ContextCallback s_invokeMoveNext;
                    /*0x10*/ System.Threading.ExecutionContext m_context;
                    /*0x18*/ System.Runtime.CompilerServices.IAsyncStateMachine m_stateMachine;

                    static /*0x20adc30*/ void InvokeMoveNext(object stateMachine);
                    /*0x20ad494*/ MoveNextRunner(System.Threading.ExecutionContext context, System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
                    /*0x20ada24*/ void Run();
                }

                class ContinuationWrapper
                {
                    /*0x10*/ System.Action m_continuation;
                    /*0x18*/ System.Action m_invokeAction;
                    /*0x20*/ System.Threading.Tasks.Task m_innerTask;

                    /*0x20ad7ec*/ ContinuationWrapper(System.Action continuation, System.Action invokeAction, System.Threading.Tasks.Task innerTask);
                    /*0x20add10*/ void Invoke();
                }

                class <>c__DisplayClass5_0
                {
                    /*0x10*/ System.Threading.Tasks.Task innerTask;
                    /*0x18*/ System.Action continuation;

                    /*0x20ad580*/ <>c__DisplayClass5_0();
                    /*0x20add34*/ void <OutputAsyncCausalityEvents>b__0();
                }

                class <>c
                {
                    static /*0x0*/ System.Runtime.CompilerServices.AsyncMethodBuilderCore.<> <>9;
                    static /*0x8*/ System.Threading.SendOrPostCallback <>9__7_0;
                    static /*0x10*/ System.Threading.WaitCallback <>9__7_1;

                    static /*0x20add90*/ <>c();
                    /*0x20addf4*/ <>c();
                    /*0x20addfc*/ void <ThrowAsync>b__7_0(object state);
                    /*0x20ade50*/ void <ThrowAsync>b__7_1(object state);
                }
            }

            struct YieldAwaitable
            {
                /*0x20adea4*/ System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter GetAwaiter();

                struct YieldAwaiter : System.Runtime.CompilerServices.ICriticalNotifyCompletion, System.Runtime.CompilerServices.INotifyCompletion
                {
                    static /*0x0*/ System.Threading.WaitCallback s_waitCallbackRunAction;
                    static /*0x8*/ System.Threading.SendOrPostCallback s_sendOrPostCallbackRunAction;

                    static /*0x20ae274*/ YieldAwaiter();
                    static /*0x20adf0c*/ void QueueContinuation(System.Action continuation, bool flowContext);
                    static /*0x20ae204*/ void RunAction(object state);
                    /*0x20adeac*/ bool get_IsCompleted();
                    /*0x20adeb4*/ void OnCompleted(System.Action continuation);
                    /*0x20ae1ac*/ void UnsafeOnCompleted(System.Action continuation);
                    /*0x20ae270*/ void GetResult();
                }
            }

            class AssemblyAttributesGoHere
            {
                /*0x20ae350*/ AssemblyAttributesGoHere();
            }

            class AssemblyAttributesGoHereS
            {
                /*0x20ae358*/ AssemblyAttributesGoHereS();
            }

            class AssemblyAttributesGoHereM
            {
                /*0x20ae360*/ AssemblyAttributesGoHereM();
            }

            class AssemblyAttributesGoHereSM
            {
                /*0x20ae368*/ AssemblyAttributesGoHereSM();
            }

            enum LoadHint
            {
                Default = 0,
                Always = 1,
                Sometimes = 2,
            }

            class DefaultDependencyAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.CompilerServices.LoadHint loadHint;

                /*0x20ae370*/ DefaultDependencyAttribute(System.Runtime.CompilerServices.LoadHint loadHintArgument);
                /*0x20ae398*/ System.Runtime.CompilerServices.LoadHint get_LoadHint();
            }

            class DependencyAttribute : System.Attribute
            {
                /*0x10*/ string dependentAssembly;
                /*0x18*/ System.Runtime.CompilerServices.LoadHint loadHint;

                /*0x20ae3a0*/ DependencyAttribute(string dependentAssemblyArgument, System.Runtime.CompilerServices.LoadHint loadHintArgument);
                /*0x20ae3d0*/ string get_DependentAssembly();
                /*0x20ae3d8*/ System.Runtime.CompilerServices.LoadHint get_LoadHint();
            }

            class CallConvCdecl
            {
                /*0x20ae3e0*/ CallConvCdecl();
            }

            class CallConvStdcall
            {
                /*0x20ae3e8*/ CallConvStdcall();
            }

            class CallConvThiscall
            {
                /*0x20ae3f0*/ CallConvThiscall();
            }

            class CallConvFastcall
            {
                /*0x20ae3f8*/ CallConvFastcall();
            }

            enum CompilationRelaxations
            {
                NoStringInterning = 8,
            }

            class CompilationRelaxationsAttribute : System.Attribute
            {
                /*0x10*/ int m_relaxations;

                /*0x20ae400*/ CompilationRelaxationsAttribute(int relaxations);
                /*0x20ae428*/ CompilationRelaxationsAttribute(System.Runtime.CompilerServices.CompilationRelaxations relaxations);
                /*0x20ae450*/ int get_CompilationRelaxations();
            }

            class CompilerMarshalOverride
            {
            }

            class DecoratedNameAttribute : System.Attribute
            {
                /*0x20ae458*/ DecoratedNameAttribute(string decoratedName);
            }

            class HasCopySemanticsAttribute : System.Attribute
            {
                /*0x20ae460*/ HasCopySemanticsAttribute();
            }

            class IDispatchConstantAttribute : System.Runtime.CompilerServices.CustomConstantAttribute
            {
                /*0x20ae468*/ IDispatchConstantAttribute();
                /*0x20ae470*/ object get_Value();
            }

            class InternalsVisibleToAttribute : System.Attribute
            {
                /*0x10*/ string _assemblyName;
                /*0x18*/ bool _allInternalsVisible;

                /*0x20ae4d0*/ InternalsVisibleToAttribute(string assemblyName);
                /*0x20ae500*/ string get_AssemblyName();
                /*0x20ae508*/ bool get_AllInternalsVisible();
                /*0x20ae510*/ void set_AllInternalsVisible(bool value);
            }

            class FriendAccessAllowedAttribute : System.Attribute
            {
                /*0x20ae51c*/ FriendAccessAllowedAttribute();
            }

            class IsBoxed
            {
            }

            class IsByValue
            {
            }

            class IsCopyConstructed
            {
            }

            class IsExplicitlyDereferenced
            {
            }

            class IsImplicitlyDereferenced
            {
            }

            class IsJitIntrinsic
            {
            }

            class IsLong
            {
            }

            class IsPinned
            {
            }

            class IsSignUnspecifiedByte
            {
            }

            class IsUdtReturn
            {
            }

            class IUnknownConstantAttribute : System.Runtime.CompilerServices.CustomConstantAttribute
            {
                /*0x20ae524*/ IUnknownConstantAttribute();
                /*0x20ae52c*/ object get_Value();
            }

            enum MethodImplOptions
            {
                Unmanaged = 4,
                ForwardRef = 16,
                PreserveSig = 128,
                InternalCall = 4096,
                Synchronized = 32,
                NoInlining = 8,
                AggressiveInlining = 256,
                NoOptimization = 64,
                SecurityMitigations = 1024,
            }

            enum MethodCodeType
            {
                IL = 0,
                Native = 1,
                OPTIL = 2,
                Runtime = 3,
            }

            class MethodImplAttribute : System.Attribute
            {
                /*0x10*/ System.Runtime.CompilerServices.MethodImplOptions _val;
                /*0x14*/ System.Runtime.CompilerServices.MethodCodeType MethodCodeType;

                /*0x20ae58c*/ MethodImplAttribute(System.Reflection.MethodImplAttributes methodImplAttributes);
                /*0x20ae5bc*/ MethodImplAttribute(System.Runtime.CompilerServices.MethodImplOptions methodImplOptions);
                /*0x20ae5e4*/ MethodImplAttribute(short value);
                /*0x20ae610*/ MethodImplAttribute();
                /*0x20ae618*/ System.Runtime.CompilerServices.MethodImplOptions get_Value();
            }

            class NativeCppClassAttribute : System.Attribute
            {
                /*0x20ae620*/ NativeCppClassAttribute();
            }

            class RequiredAttributeAttribute : System.Attribute
            {
                /*0x10*/ System.Type requiredContract;

                /*0x20ae628*/ RequiredAttributeAttribute(System.Type requiredContract);
                /*0x20ae650*/ System.Type get_RequiredContract();
            }

            class ScopelessEnumAttribute : System.Attribute
            {
                /*0x20ae658*/ ScopelessEnumAttribute();
            }

            class SuppressMergeCheckAttribute : System.Attribute
            {
                /*0x20ae660*/ SuppressMergeCheckAttribute();
            }

            class TypeDependencyAttribute : System.Attribute
            {
                /*0x10*/ string typeName;

                /*0x20ae668*/ TypeDependencyAttribute(string typeName);
            }

            class JitHelpers
            {
                static T UnsafeCast<T>(object o);
                static int UnsafeEnumCast<T>(T val);
                static long UnsafeEnumCastLong<T>(T val);
            }

            struct Ephemeron
            {
                /*0x10*/ object key;
                /*0x18*/ object value;
            }

            class ConditionalWeakTable<TKey, TValue> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
            {
                static int INITIAL_SIZE = 13;
                static float LOAD_FACTOR = 0.699999988079071;
                static float COMPACT_FACTOR = 0.5;
                static float EXPAND_FACTOR = 1.100000023841858;
                /*0x0*/ System.Runtime.CompilerServices.Ephemeron[] data;
                /*0x0*/ object _lock;
                /*0x0*/ int size;

                ConditionalWeakTable();
                void Finalize();
                void RehashWithoutResize();
                void RecomputeSize();
                void Rehash();
                void AddOrUpdate(TKey key, TValue value);
                void Add(TKey key, TValue value);
                bool Remove(TKey key);
                bool TryGetValue(TKey key, ref TValue value);
                TValue GetOrCreateValue(TKey key);
                TValue GetValue(TKey key, System.Runtime.CompilerServices.ConditionalWeakTable.CreateValueCallback<TKey, TValue> createValueCallback);
                TKey FindEquivalentKeyUnsafe(TKey key, ref TValue value);
                void Clear();
                System.Collections.Generic.ICollection<TKey> get_Keys();
                System.Collections.Generic.ICollection<TValue> get_Values();
                System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();

                class CreateValueCallback<TKey, TValue> : System.MulticastDelegate
                {
                    CreateValueCallback(object object, nint method);
                    TValue Invoke(TKey key);
                }

                class Enumerator<TKey, TValue> : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<TKey, TValue> _table;
                    /*0x0*/ int _currentIndex;
                    /*0x0*/ System.Collections.Generic.KeyValuePair<TKey, TValue> _current;

                    Enumerator(System.Runtime.CompilerServices.ConditionalWeakTable<TKey, TValue> table);
                    void Finalize();
                    void Dispose();
                    bool MoveNext();
                    System.Collections.Generic.KeyValuePair<TKey, TValue> get_Current();
                    object System.Collections.IEnumerator.get_Current();
                    void Reset();
                }

                class <>c<TKey, TValue>
                {
                    static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable.<>c<TKey, TValue> <>9;
                    static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable.CreateValueCallback<TKey, TValue> <>9__17_0;

                    static <>c();
                    <>c();
                    TValue <GetOrCreateValue>b__17_0(TKey k);
                }
            }

            class PreserveDependencyAttribute : System.Attribute
            {
                /*0x10*/ string <Condition>k__BackingField;

                /*0x20ae6e0*/ PreserveDependencyAttribute(string memberSignature);
                /*0x20ae6e8*/ PreserveDependencyAttribute(string memberSignature, string typeName);
                /*0x20ae6f0*/ PreserveDependencyAttribute(string memberSignature, string typeName, string assembly);
                /*0x20ae6f8*/ string get_Condition();
                /*0x20ae700*/ void set_Condition(string value);
            }

            class RuntimeHelpers
            {
                static /*0x20ae708*/ void InitializeArray(System.Array array, nint fldHandle);
                static /*0x20ae70c*/ void InitializeArray(System.Array array, System.RuntimeFieldHandle fldHandle);
                static /*0x20ae7b4*/ int get_OffsetToStringData();
                static /*0x20ae7b8*/ int GetHashCode(object o);
                static /*0x20ae7c0*/ bool Equals(object o1, object o2);
                static /*0x20ae878*/ object GetObjectValue(object obj);
                static /*0x20ae87c*/ void RunClassConstructor(nint type);
                static /*0x20ae880*/ void RunClassConstructor(System.RuntimeTypeHandle type);
                static /*0x20ae940*/ bool SufficientExecutionStack();
                static /*0x20ae944*/ void EnsureSufficientExecutionStack();
                static /*0x20ae994*/ bool TryEnsureSufficientExecutionStack();
                static /*0x20ae998*/ void ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);
                static /*0x20ac28c*/ void PrepareConstrainedRegions();
                static /*0x20ae99c*/ void PrepareConstrainedRegionsNoOP();
                static /*0x20ae9a0*/ void ProbeForSufficientStack();
                static /*0x20ae9a4*/ void PrepareDelegate(System.Delegate d);
                static /*0x20ac784*/ void PrepareContractedDelegate(System.Delegate d);
                static /*0x20ae9a8*/ void PrepareMethod(System.RuntimeMethodHandle method);
                static /*0x20ae9ac*/ void PrepareMethod(System.RuntimeMethodHandle method, System.RuntimeTypeHandle[] instantiation);
                static /*0x20ae9b0*/ void RunModuleConstructor(System.ModuleHandle module);
                static /*0x20aea80*/ void RunModuleConstructor(nint module);
                static bool IsReferenceOrContainsReferences<T>();
                static /*0x20aea84*/ object GetUninitializedObject(System.Type type);
                static T[] GetSubArray<T>(T[] array, System.Range range);

                class TryCode : System.MulticastDelegate
                {
                    /*0x20aeadc*/ TryCode(object object, nint method);
                    /*0x20aec08*/ void Invoke(object userData);
                }

                class CleanupCode : System.MulticastDelegate
                {
                    /*0x20aec1c*/ CleanupCode(object object, nint method);
                    /*0x20aed4c*/ void Invoke(object userData, bool exceptionThrown);
                }
            }

            class Unsafe
            {
                static ref T Add<T>(ref T source, int elementOffset);
                static ref T Add<T>(ref T source, nint elementOffset);
                static void* Add<T>(void* source, int elementOffset);
                static ref T AddByteOffset<T>(ref T source, nint byteOffset);
                static bool AreSame<T>(ref T left, ref T right);
                static T As<T>(object o);
                static ref TTo As<TFrom, TTo>(ref TFrom source);
                static void* AsPointer<T>(ref T value);
                static ref T AsRef<T>(void* source);
                static ref T AsRef<T>(ref T source);
                static nint ByteOffset<T>(ref T origin, ref T target);
                static /*0x20aed64*/ void CopyBlock(ref byte destination, ref byte source, uint byteCount);
                static /*0x20aed6c*/ void InitBlockUnaligned(ref byte startAddress, byte value, uint byteCount);
                static /*0x20aed74*/ void InitBlockUnaligned(void* startAddress, byte value, uint byteCount);
                static T Read<T>(void* source);
                static T ReadUnaligned<T>(void* source);
                static T ReadUnaligned<T>(ref byte source);
                static int SizeOf<T>();
                static ref T Subtract<T>(ref T source, int elementOffset);
                static void WriteUnaligned<T>(ref byte destination, T value);
                static void WriteUnaligned<T>(void* destination, T value);
                static bool IsAddressGreaterThan<T>(ref T left, ref T right);
                static bool IsAddressLessThan<T>(ref T left, ref T right);
                static ref T AddByteOffset<T>(ref T source, ulong byteOffset);
            }

            class EnumeratorCancellationAttribute : System.Attribute
            {
                /*0x20aed7c*/ EnumeratorCancellationAttribute();
            }

            class SwitchExpressionException : System.InvalidOperationException
            {
                /*0x90*/ object <UnmatchedValue>k__BackingField;

                /*0x20aed84*/ SwitchExpressionException();
                /*0x20aedd0*/ SwitchExpressionException(System.Exception innerException);
                /*0x20aee2c*/ SwitchExpressionException(object unmatchedValue);
                /*0x20aee50*/ SwitchExpressionException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x20aef2c*/ SwitchExpressionException(string message);
                /*0x20aef34*/ SwitchExpressionException(string message, System.Exception innerException);
                /*0x20aef3c*/ object get_UnmatchedValue();
                /*0x20aef44*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x20af020*/ string get_Message();
            }

            class DependencyReductionRootAttribute : System.Attribute
            {
                /*0x20af0c8*/ DependencyReductionRootAttribute();
            }
        }
    }

    namespace Resources
    {
        interface IResourceReader : System.Collections.IEnumerable, System.IDisposable
        {
            void Close();
            System.Collections.IDictionaryEnumerator GetEnumerator();
        }

        class MissingManifestResourceException : System.SystemException
        {
            /*0x20af0d0*/ MissingManifestResourceException();
            /*0x20af12c*/ MissingManifestResourceException(string message);
            /*0x20af150*/ MissingManifestResourceException(string message, System.Exception inner);
            /*0x20af174*/ MissingManifestResourceException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class MissingSatelliteAssemblyException : System.SystemException
        {
            /*0x90*/ string _cultureName;

            /*0x20af17c*/ MissingSatelliteAssemblyException();
            /*0x20af1d8*/ MissingSatelliteAssemblyException(string message);
            /*0x20af1fc*/ MissingSatelliteAssemblyException(string message, string cultureName);
            /*0x20af230*/ MissingSatelliteAssemblyException(string message, System.Exception inner);
            /*0x20af254*/ MissingSatelliteAssemblyException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20af25c*/ string get_CultureName();
        }

        class NeutralResourcesLanguageAttribute : System.Attribute
        {
            /*0x10*/ string <CultureName>k__BackingField;
            /*0x18*/ System.Resources.UltimateResourceFallbackLocation <Location>k__BackingField;

            /*0x20af264*/ NeutralResourcesLanguageAttribute(string cultureName);
            /*0x20af2e0*/ NeutralResourcesLanguageAttribute(string cultureName, System.Resources.UltimateResourceFallbackLocation location);
            /*0x20af4b0*/ string get_CultureName();
            /*0x20af4b8*/ System.Resources.UltimateResourceFallbackLocation get_Location();
        }

        class ResourceFallbackManager : System.Collections.Generic.IEnumerable<System.Globalization.CultureInfo>, System.Collections.IEnumerable
        {
            /*0x10*/ System.Globalization.CultureInfo m_startingCulture;
            /*0x18*/ System.Globalization.CultureInfo m_neutralResourcesCulture;
            /*0x20*/ bool m_useParents;

            /*0x20af4c0*/ ResourceFallbackManager(System.Globalization.CultureInfo startingCulture, System.Globalization.CultureInfo neutralResourcesCulture, bool useParents);
            /*0x20af548*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x20af54c*/ System.Collections.Generic.IEnumerator<System.Globalization.CultureInfo> GetEnumerator();

            class <GetEnumerator>d__5 : System.Collections.Generic.IEnumerator<System.Globalization.CultureInfo>, System.IDisposable, System.Collections.IEnumerator
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Globalization.CultureInfo <>2__current;
                /*0x20*/ System.Resources.ResourceFallbackManager <>4__this;
                /*0x28*/ bool <reachedNeutralResourcesCulture>5__2;
                /*0x30*/ System.Globalization.CultureInfo <currentCulture>5__3;

                /*0x20af5b4*/ <GetEnumerator>d__5(int <>1__state);
                /*0x20af5dc*/ void System.IDisposable.Dispose();
                /*0x20af5e0*/ bool MoveNext();
                /*0x20af7a8*/ System.Globalization.CultureInfo System.Collections.Generic.IEnumerator<System.Globalization.CultureInfo>.get_Current();
                /*0x20af7b0*/ void System.Collections.IEnumerator.Reset();
                /*0x20af7f0*/ object System.Collections.IEnumerator.get_Current();
            }
        }

        enum ResourceTypeCode
        {
            Null = 0,
            String = 1,
            Boolean = 2,
            Char = 3,
            Byte = 4,
            SByte = 5,
            Int16 = 6,
            UInt16 = 7,
            Int32 = 8,
            UInt32 = 9,
            Int64 = 10,
            UInt64 = 11,
            Single = 12,
            Double = 13,
            Decimal = 14,
            DateTime = 15,
            TimeSpan = 16,
            LastPrimitive = 16,
            ByteArray = 32,
            Stream = 33,
            StartOfUserTypes = 64,
        }

        class RuntimeResourceSet : System.Resources.ResourceSet, System.Collections.IEnumerable
        {
            static int Version = 2;
            /*0x28*/ System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> _resCache;
            /*0x30*/ System.Resources.ResourceReader _defaultReader;
            /*0x38*/ System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> _caseInsensitiveTable;
            /*0x40*/ bool _haveReadFromReader;

            /*0x20af7f8*/ RuntimeResourceSet(string fileName);
            /*0x20afa24*/ RuntimeResourceSet(System.IO.Stream stream);
            /*0x20afb1c*/ void Dispose(bool disposing);
            /*0x20afd4c*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x20afe50*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x20afd50*/ System.Collections.IDictionaryEnumerator GetEnumeratorHelper();
            /*0x20afe54*/ string GetString(string key);
            /*0x20b07d4*/ string GetString(string key, bool ignoreCase);
            /*0x20b0850*/ object GetObject(string key);
            /*0x20b085c*/ object GetObject(string key, bool ignoreCase);
            /*0x20afec4*/ object GetObject(string key, bool ignoreCase, bool isString);
            /*0x20b1124*/ object ResolveResourceLocator(System.Resources.ResourceLocator resLocation, string key, System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> copyOfCache, bool keyInWrongCase);
        }

        class SatelliteContractVersionAttribute : System.Attribute
        {
            /*0x10*/ string <Version>k__BackingField;

            /*0x20b12a4*/ SatelliteContractVersionAttribute(string version);
            /*0x20b131c*/ string get_Version();
        }

        enum UltimateResourceFallbackLocation
        {
            MainAssembly = 0,
            Satellite = 1,
        }

        interface IResourceWriter : System.IDisposable
        {
            void AddResource(string name, string value);
            void AddResource(string name, object value);
            void AddResource(string name, byte[] value);
            void Close();
            void Generate();
        }

        class FastResourceComparer : System.Collections.IComparer, System.Collections.IEqualityComparer, System.Collections.Generic.IComparer<string>, System.Collections.Generic.IEqualityComparer<string>
        {
            static /*0x0*/ System.Resources.FastResourceComparer Default;

            static /*0x20b1794*/ FastResourceComparer();
            static /*0x20b13b0*/ int HashFunction(string key);
            static /*0x20b15c8*/ int CompareOrdinal(string a, byte[] bytes, int bCharLength);
            static /*0x20b1684*/ int CompareOrdinal(byte[] bytes, int aCharLength, string b);
            static /*0x20b16f8*/ int CompareOrdinal(byte* a, int byteLen, string b);
            /*0x20b178c*/ FastResourceComparer();
            /*0x20b1324*/ int GetHashCode(object key);
            /*0x20b141c*/ int GetHashCode(string key);
            /*0x20b1470*/ int Compare(object a, object b);
            /*0x20b150c*/ int Compare(string a, string b);
            /*0x20b151c*/ bool Equals(string a, string b);
            /*0x20b152c*/ bool Equals(object a, object b);
        }

        class FileBasedResourceGroveler : System.Resources.IResourceGroveler
        {
            /*0x10*/ System.Resources.ResourceManager.ResourceManagerMediator _mediator;

            /*0x20b17f8*/ FileBasedResourceGroveler(System.Resources.ResourceManager.ResourceManagerMediator mediator);
            /*0x20b1820*/ System.Resources.ResourceSet GrovelForResourceSet(System.Globalization.CultureInfo culture, System.Collections.Generic.Dictionary<string, System.Resources.ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, ref System.Threading.StackCrawlMark stackMark);
            /*0x20b1f38*/ bool HasNeutralResources(System.Globalization.CultureInfo culture, string defaultResName);
            /*0x20b1b84*/ string FindResourceFile(System.Globalization.CultureInfo culture, string fileName);
            /*0x20b1c68*/ System.Resources.ResourceSet CreateResourceSet(string file);
        }

        interface IResourceGroveler
        {
            System.Resources.ResourceSet GrovelForResourceSet(System.Globalization.CultureInfo culture, System.Collections.Generic.Dictionary<string, System.Resources.ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, ref System.Threading.StackCrawlMark stackMark);
            bool HasNeutralResources(System.Globalization.CultureInfo culture, string defaultResName);
        }

        class ManifestBasedResourceGroveler : System.Resources.IResourceGroveler
        {
            /*0x10*/ System.Resources.ResourceManager.ResourceManagerMediator _mediator;

            static /*0x20b3860*/ System.Globalization.CultureInfo GetNeutralResourcesLanguage(System.Reflection.Assembly a, ref System.Resources.UltimateResourceFallbackLocation fallbackLocation);
            static /*0x20b3b84*/ bool GetNeutralResourcesLanguageAttribute(System.Reflection.Assembly assembly, ref string cultureName, ref short fallbackLocation);
            /*0x20b2018*/ ManifestBasedResourceGroveler(System.Resources.ResourceManager.ResourceManagerMediator mediator);
            /*0x20b2040*/ System.Resources.ResourceSet GrovelForResourceSet(System.Globalization.CultureInfo culture, System.Collections.Generic.Dictionary<string, System.Resources.ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists, ref System.Threading.StackCrawlMark stackMark);
            /*0x20b36a8*/ bool HasNeutralResources(System.Globalization.CultureInfo culture, string defaultResName);
            /*0x20b2304*/ System.Globalization.CultureInfo UltimateFallbackFixup(System.Globalization.CultureInfo lookForCulture);
            /*0x20b2a58*/ System.Resources.ResourceSet CreateResourceSet(System.IO.Stream store, System.Reflection.Assembly assembly);
            /*0x20b298c*/ System.IO.Stream GetManifestResourceStream(System.Reflection.RuntimeAssembly satellite, string fileName, ref System.Threading.StackCrawlMark stackMark);
            /*0x20b3d6c*/ System.IO.Stream CaseInsensitiveManifestResourceStreamLookup(System.Reflection.RuntimeAssembly satellite, string name);
            /*0x20b24a8*/ System.Reflection.RuntimeAssembly GetSatelliteAssembly(System.Globalization.CultureInfo lookForCulture, ref System.Threading.StackCrawlMark stackMark);
            /*0x20b3bf8*/ bool CanUseDefaultResourceClasses(string readerTypeName, string resSetTypeName);
            /*0x20b41a0*/ string GetSatelliteAssemblyName();
            /*0x20b2620*/ void HandleSatelliteMissing();
            /*0x20b33b4*/ void HandleResourceStreamMissing(string fileName);
        }

        class ResourceManager
        {
            static string ResFileExtension = ".resources";
            static int ResFileExtensionLength = 10;
            static /*0x0*/ int MagicNumber;
            static /*0x4*/ int HeaderVersionNumber;
            static /*0x8*/ System.Type _minResourceSet;
            static /*0x10*/ string ResReaderTypeName;
            static /*0x18*/ string ResSetTypeName;
            static /*0x20*/ string MscorlibName;
            static /*0x28*/ int DEBUG;
            /*0x10*/ string BaseNameField;
            /*0x18*/ System.Collections.Hashtable ResourceSets;
            /*0x20*/ System.Collections.Generic.Dictionary<string, System.Resources.ResourceSet> _resourceSets;
            /*0x28*/ string moduleDir;
            /*0x30*/ System.Reflection.Assembly MainAssembly;
            /*0x38*/ System.Type _locationInfo;
            /*0x40*/ System.Type _userResourceSet;
            /*0x48*/ System.Globalization.CultureInfo _neutralResourcesCulture;
            /*0x50*/ System.Resources.ResourceManager.CultureNameResourceSetPair _lastUsedResourceCache;
            /*0x58*/ bool _ignoreCase;
            /*0x59*/ bool UseManifest;
            /*0x5a*/ bool UseSatelliteAssem;
            /*0x5c*/ System.Resources.UltimateResourceFallbackLocation _fallbackLoc;
            /*0x60*/ System.Version _satelliteContractVersion;
            /*0x68*/ bool _lookedForSatelliteContractVersion;
            /*0x70*/ System.Reflection.Assembly _callingAssembly;
            /*0x78*/ System.Reflection.RuntimeAssembly m_callingAssembly;
            /*0x80*/ System.Resources.IResourceGroveler resourceGroveler;

            static /*0x20b8350*/ ResourceManager();
            static /*0x20b5c98*/ System.Resources.ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, System.Type usingResourceSet);
            static /*0x20b6570*/ void AddResourceSet(System.Collections.Generic.Dictionary<string, System.Resources.ResourceSet> localResourceSets, string cultureName, ref System.Resources.ResourceSet rs);
            static /*0x20b6fa8*/ System.Version GetSatelliteContractVersion(System.Reflection.Assembly a);
            static /*0x20b772c*/ System.Globalization.CultureInfo GetNeutralResourcesLanguage(System.Reflection.Assembly a);
            static /*0x20b4220*/ bool CompareNames(string asmTypeName1, string typeName2, System.Reflection.AssemblyName asmName2);
            /*0x20b45bc*/ ResourceManager();
            /*0x20b4710*/ ResourceManager(string baseName, string resourceDir, System.Type usingResourceSet);
            /*0x20b48ec*/ ResourceManager(string baseName, System.Reflection.Assembly assembly);
            /*0x20b4d48*/ ResourceManager(string baseName, System.Reflection.Assembly assembly, System.Type usingResourceSet);
            /*0x20b5164*/ ResourceManager(System.Type resourceSource);
            /*0x20b44a0*/ void Init();
            /*0x20b5490*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x20b54a0*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x20b5670*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x20b4bec*/ void CommonAssemblyInit();
            /*0x20b56e0*/ string get_BaseName();
            /*0x20b56e8*/ bool get_IgnoreCase();
            /*0x20b56f0*/ void set_IgnoreCase(bool value);
            /*0x20b56fc*/ System.Type get_ResourceSetType();
            /*0x20b57a4*/ System.Resources.UltimateResourceFallbackLocation get_FallbackLocation();
            /*0x20b57ac*/ void set_FallbackLocation(System.Resources.UltimateResourceFallbackLocation value);
            /*0x20b57b4*/ void ReleaseAllResources();
            /*0x20b5d10*/ string GetResourceFileName(System.Globalization.CultureInfo culture);
            /*0x20b5e4c*/ System.Resources.ResourceSet GetFirstResourceSet(System.Globalization.CultureInfo culture);
            /*0x20b621c*/ System.Resources.ResourceSet GetResourceSet(System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);
            /*0x20b6718*/ System.Resources.ResourceSet InternalGetResourceSet(System.Globalization.CultureInfo culture, bool createIfNotExists, bool tryParents);
            /*0x20b673c*/ System.Resources.ResourceSet InternalGetResourceSet(System.Globalization.CultureInfo requestedCulture, bool createIfNotExists, bool tryParents, ref System.Threading.StackCrawlMark stackMark);
            /*0x20b4be8*/ void SetAppXConfiguration();
            /*0x20b7744*/ string GetString(string name);
            /*0x20b7758*/ string GetString(string name, System.Globalization.CultureInfo culture);
            /*0x20b7c2c*/ object GetObject(string name);
            /*0x20b8218*/ object GetObject(string name, System.Globalization.CultureInfo culture);
            /*0x20b7c38*/ object GetObject(string name, System.Globalization.CultureInfo culture, bool wrapUnmanagedMemStream);
            /*0x20b8220*/ System.IO.UnmanagedMemoryStream GetStream(string name);
            /*0x20b8228*/ System.IO.UnmanagedMemoryStream GetStream(string name, System.Globalization.CultureInfo culture);

            class CultureNameResourceSetPair
            {
                /*0x10*/ string lastCultureName;
                /*0x18*/ System.Resources.ResourceSet lastResourceSet;

                /*0x20b4690*/ CultureNameResourceSetPair();
            }

            class ResourceManagerMediator
            {
                /*0x10*/ System.Resources.ResourceManager _rm;

                /*0x20b4698*/ ResourceManagerMediator(System.Resources.ResourceManager rm);
                /*0x20b1fe0*/ string get_ModuleDir();
                /*0x20b1c4c*/ System.Type get_LocationInfo();
                /*0x20b1ffc*/ System.Type get_UserResourceSet();
                /*0x20b1c30*/ string get_BaseNameField();
                /*0x20b3844*/ System.Globalization.CultureInfo get_NeutralResourcesCulture();
                /*0x20b1b64*/ string GetResourceFileName(System.Globalization.CultureInfo culture);
                /*0x20b40f4*/ bool get_LookedForSatelliteContractVersion();
                /*0x20b4180*/ void set_LookedForSatelliteContractVersion(bool value);
                /*0x20b4204*/ System.Version get_SatelliteContractVersion();
                /*0x20b4164*/ void set_SatelliteContractVersion(System.Version value);
                /*0x20b4110*/ System.Version ObtainSatelliteContractVersion(System.Reflection.Assembly a);
                /*0x20b2408*/ System.Resources.UltimateResourceFallbackLocation get_FallbackLoc();
                /*0x20b3d50*/ System.Reflection.RuntimeAssembly get_CallingAssembly();
                /*0x20b2424*/ System.Reflection.RuntimeAssembly get_MainAssembly();
                /*0x20b4480*/ string get_BaseName();
            }
        }

        struct ResourceLocator
        {
            /*0x10*/ object _value;
            /*0x18*/ int _dataPos;

            static /*0x20b0f88*/ bool CanCache(System.Resources.ResourceTypeCode value);
            /*0x20b0f94*/ ResourceLocator(int dataPos, object value);
            /*0x20b84c4*/ int get_DataPosition();
            /*0x20b84cc*/ object get_Value();
            /*0x20b84d4*/ void set_Value(object value);
        }

        class ResourceReader : System.Resources.IResourceReader, System.Collections.IEnumerable, System.IDisposable
        {
            static int DefaultFileStreamBufferSize = 4096;
            /*0x10*/ System.IO.BinaryReader _store;
            /*0x18*/ System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> _resCache;
            /*0x20*/ long _nameSectionOffset;
            /*0x28*/ long _dataSectionOffset;
            /*0x30*/ int[] _nameHashes;
            /*0x38*/ int* _nameHashesPtr;
            /*0x40*/ int[] _namePositions;
            /*0x48*/ int* _namePositionsPtr;
            /*0x50*/ System.RuntimeType[] _typeTable;
            /*0x58*/ int[] _typeNamePositions;
            /*0x60*/ System.Runtime.Serialization.Formatters.Binary.BinaryFormatter _objFormatter;
            /*0x68*/ int _numResources;
            /*0x70*/ System.IO.UnmanagedMemoryStream _ums;
            /*0x78*/ int _version;

            static /*0x20b8b1c*/ int ReadUnalignedI4(int* p);
            /*0x20b84dc*/ ResourceReader(string fileName);
            /*0x20b8890*/ ResourceReader(System.IO.Stream stream);
            /*0x20af938*/ ResourceReader(System.IO.Stream stream, System.Collections.Generic.Dictionary<string, System.Resources.ResourceLocator> resCache);
            /*0x20afc5c*/ void Close();
            /*0x20b8ae0*/ void Dispose();
            /*0x20b8aa0*/ void Dispose(bool disposing);
            /*0x20b8b24*/ void SkipInt32();
            /*0x20b8b60*/ void SkipString();
            /*0x20b8c18*/ int GetNameHash(int index);
            /*0x20b8c5c*/ int GetNamePosition(int index);
            /*0x20b8d7c*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x20b8d80*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x20b0fa0*/ System.Resources.ResourceReader.ResourceEnumerator GetEnumeratorInternal();
            /*0x20b0868*/ int FindPosForResource(string name);
            /*0x20b8e84*/ bool CompareStringEqualsName(string name);
            /*0x20b9098*/ string AllocateStringForNameIndex(int index, ref int dataOffset);
            /*0x20b9998*/ object GetValueForNameIndex(int index);
            /*0x20b0c40*/ string LoadString(int pos);
            /*0x20ba20c*/ object LoadObject(int pos);
            /*0x20b0ef0*/ object LoadObject(int pos, ref System.Resources.ResourceTypeCode typeCode);
            /*0x20b9c44*/ object LoadObjectV1(int pos);
            /*0x20ba238*/ object _LoadObjectV1(int pos);
            /*0x20b9d44*/ object LoadObjectV2(int pos, ref System.Resources.ResourceTypeCode typeCode);
            /*0x20bac48*/ object _LoadObjectV2(int pos, ref System.Resources.ResourceTypeCode typeCode);
            /*0x20baa70*/ object DeserializeObject(int typeIndex);
            /*0x20b871c*/ void ReadResources();
            /*0x20bb394*/ void _ReadResources();
            /*0x20b9e44*/ System.RuntimeType FindType(int typeIndex);
            /*0x20bba7c*/ void GetResourceData(string resourceName, ref string resourceType, ref byte[] resourceData);
            /*0x20bc320*/ string TypeNameFromTypeCode(System.Resources.ResourceTypeCode typeCode);

            class ResourceEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
            {
                /*0x10*/ System.Resources.ResourceReader _reader;
                /*0x18*/ bool _currentIsValid;
                /*0x1c*/ int _currentName;
                /*0x20*/ int _dataPosition;

                /*0x20b8e50*/ ResourceEnumerator(System.Resources.ResourceReader reader);
                /*0x20b10c8*/ bool MoveNext();
                /*0x20b1010*/ object get_Key();
                /*0x20bc544*/ object get_Current();
                /*0x20bc8ec*/ int get_DataPosition();
                /*0x20bc5a8*/ System.Collections.DictionaryEntry get_Entry();
                /*0x20bc8f4*/ object get_Value();
                /*0x20bc9a4*/ void Reset();
            }
        }

        class ResourceSet : System.IDisposable, System.Collections.IEnumerable
        {
            /*0x10*/ System.Resources.IResourceReader Reader;
            /*0x18*/ System.Collections.Hashtable Table;
            /*0x20*/ System.Collections.Hashtable _caseInsensitiveTable;

            /*0x20bca30*/ ResourceSet();
            /*0x20af930*/ ResourceSet(bool junk);
            /*0x20bcaac*/ ResourceSet(string fileName);
            /*0x20bcb3c*/ ResourceSet(System.IO.Stream stream);
            /*0x20bcbcc*/ ResourceSet(System.Resources.IResourceReader reader);
            /*0x20bca4c*/ void CommonInit();
            /*0x20bcc5c*/ void Close();
            /*0x20afc98*/ void Dispose(bool disposing);
            /*0x20b6f98*/ void Dispose();
            /*0x20bcc6c*/ System.Type GetDefaultReader();
            /*0x20bccd8*/ System.Type GetDefaultWriter();
            /*0x20bcd44*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x20bcdcc*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x20bcd48*/ System.Collections.IDictionaryEnumerator GetEnumeratorHelper();
            /*0x20bcdd0*/ string GetString(string name);
            /*0x20bd00c*/ string GetString(string name, bool ignoreCase);
            /*0x20bd4e0*/ object GetObject(string name);
            /*0x20bd4e4*/ object GetObject(string name, bool ignoreCase);
            /*0x20bd524*/ void ReadResources();
            /*0x20bcf38*/ object GetObjectInternal(string name);
            /*0x20bd210*/ object GetCaseInsensitiveObjectInternal(string name);
        }

        class ResourceWriter : System.Resources.IResourceWriter, System.IDisposable
        {
            static int _ExpectedNumberOfResources = 1000;
            static int AverageNameSize = 40;
            static int AverageValueSize = 40;
            static int _DefaultBufferSize = 4096;
            /*0x10*/ System.Func<System.Type, string> typeConverter;
            /*0x18*/ System.Collections.Generic.Dictionary<string, object> _resourceList;
            /*0x20*/ System.IO.Stream _output;
            /*0x28*/ System.Collections.Generic.Dictionary<string, object> _caseInsensitiveDups;
            /*0x30*/ System.Collections.Generic.Dictionary<string, System.Resources.ResourceWriter.PrecannedResource> _preserializedData;

            static /*0x20bfe30*/ void Write7BitEncodedInt(System.IO.BinaryWriter store, int value);
            /*0x20bd758*/ ResourceWriter(string fileName);
            /*0x20bd940*/ ResourceWriter(System.IO.Stream stream);
            /*0x20bd748*/ System.Func<System.Type, string> get_TypeNameConverter();
            /*0x20bd750*/ void set_TypeNameConverter(System.Func<System.Type, string> value);
            /*0x20bdb58*/ void AddResource(string name, string value);
            /*0x20bdc88*/ void AddResource(string name, object value);
            /*0x20bdf84*/ void AddResource(string name, System.IO.Stream value);
            /*0x20be04c*/ void AddResource(string name, System.IO.Stream value, bool closeAfterWrite);
            /*0x20bde1c*/ void AddResourceInternal(string name, System.IO.Stream value, bool closeAfterWrite);
            /*0x20be144*/ void AddResource(string name, byte[] value);
            /*0x20be274*/ void AddResourceData(string name, string typeName, byte[] serializedData);
            /*0x20be4f0*/ void Close();
            /*0x20be4f8*/ void Dispose(bool disposing);
            /*0x20bf5c0*/ void Dispose();
            /*0x20be538*/ void Generate();
            /*0x20bf5c8*/ System.Resources.ResourceTypeCode FindTypeCode(object value, System.Collections.Generic.List<string> types);
            /*0x20bfe9c*/ void WriteValue(System.Resources.ResourceTypeCode typeCode, object value, System.IO.BinaryWriter writer, System.Runtime.Serialization.IFormatter objFormatter);

            class PrecannedResource
            {
                /*0x10*/ string TypeName;
                /*0x18*/ byte[] Data;

                /*0x20be4c4*/ PrecannedResource(string typeName, byte[] data);
            }

            class StreamWrapper
            {
                /*0x10*/ System.IO.Stream m_stream;
                /*0x18*/ bool m_closeAfterWrite;

                /*0x20be114*/ StreamWrapper(System.IO.Stream s, bool closeAfterWrite);
            }
        }

        enum Win32ResourceType
        {
            RT_CURSOR = 1,
            RT_FONT = 8,
            RT_BITMAP = 2,
            RT_ICON = 3,
            RT_MENU = 4,
            RT_DIALOG = 5,
            RT_STRING = 6,
            RT_FONTDIR = 7,
            RT_ACCELERATOR = 9,
            RT_RCDATA = 10,
            RT_MESSAGETABLE = 11,
            RT_GROUP_CURSOR = 12,
            RT_GROUP_ICON = 14,
            RT_VERSION = 16,
            RT_DLGINCLUDE = 17,
            RT_PLUGPLAY = 19,
            RT_VXD = 20,
            RT_ANICURSOR = 21,
            RT_ANIICON = 22,
            RT_HTML = 23,
        }

        class NameOrId
        {
            /*0x10*/ string name;
            /*0x18*/ int id;

            /*0x20c07e4*/ NameOrId(string name);
            /*0x20c080c*/ NameOrId(int id);
            /*0x20c0834*/ bool get_IsName();
            /*0x20c0844*/ string get_Name();
            /*0x20c084c*/ int get_Id();
            /*0x20c0854*/ string ToString();
        }

        class Win32Resource
        {
            /*0x10*/ System.Resources.NameOrId type;
            /*0x18*/ System.Resources.NameOrId name;
            /*0x20*/ int language;

            /*0x20c08ec*/ Win32Resource(System.Resources.NameOrId type, System.Resources.NameOrId name, int language);
            /*0x20c0928*/ Win32Resource(System.Resources.Win32ResourceType type, int name, int language);
            /*0x20c09d8*/ System.Resources.Win32ResourceType get_ResourceType();
            /*0x20c0a04*/ System.Resources.NameOrId get_Name();
            /*0x20c0a0c*/ System.Resources.NameOrId get_Type();
            /*0x20c0a14*/ int get_Language();
            void WriteTo(System.IO.Stream s);
            /*0x20c0a1c*/ string ToString();
        }

        class Win32EncodedResource : System.Resources.Win32Resource
        {
            /*0x28*/ byte[] data;

            /*0x20c0c1c*/ Win32EncodedResource(System.Resources.NameOrId type, System.Resources.NameOrId name, int language, byte[] data);
            /*0x20c0c60*/ byte[] get_Data();
            /*0x20c0c68*/ void WriteTo(System.IO.Stream s);
        }

        class Win32IconResource : System.Resources.Win32Resource
        {
            /*0x28*/ System.Resources.ICONDIRENTRY icon;

            /*0x20c0ca0*/ Win32IconResource(int id, int language, System.Resources.ICONDIRENTRY icon);
            /*0x20c0cd4*/ System.Resources.ICONDIRENTRY get_Icon();
            /*0x20c0cdc*/ void WriteTo(System.IO.Stream s);
        }

        class Win32GroupIconResource : System.Resources.Win32Resource
        {
            /*0x28*/ System.Resources.Win32IconResource[] icons;

            /*0x20c0d18*/ Win32GroupIconResource(int id, int language, System.Resources.Win32IconResource[] icons);
            /*0x20c0d4c*/ void WriteTo(System.IO.Stream s);
        }

        class Win32VersionResource : System.Resources.Win32Resource
        {
            /*0x28*/ string[] WellKnownProperties;
            /*0x30*/ long signature;
            /*0x38*/ int struct_version;
            /*0x40*/ long file_version;
            /*0x48*/ long product_version;
            /*0x50*/ int file_flags_mask;
            /*0x54*/ int file_flags;
            /*0x58*/ int file_os;
            /*0x5c*/ int file_type;
            /*0x60*/ int file_subtype;
            /*0x68*/ long file_date;
            /*0x70*/ int file_lang;
            /*0x74*/ int file_codepage;
            /*0x78*/ System.Collections.Hashtable properties;

            /*0x20c1094*/ Win32VersionResource(int id, int language, bool compilercontext);
            /*0x20c145c*/ string get_Version();
            /*0x20c1670*/ void set_Version(string value);
            /*0x20c186c*/ void set_Item(string key, string value);
            /*0x20c1890*/ string get_Comments();
            /*0x20c191c*/ void set_Comments(string value);
            /*0x20c19d4*/ string get_CompanyName();
            /*0x20c1a60*/ void set_CompanyName(string value);
            /*0x20c1b18*/ string get_LegalCopyright();
            /*0x20c1ba4*/ void set_LegalCopyright(string value);
            /*0x20c1c5c*/ string get_LegalTrademarks();
            /*0x20c1ce8*/ void set_LegalTrademarks(string value);
            /*0x20c1da0*/ string get_OriginalFilename();
            /*0x20c1e2c*/ void set_OriginalFilename(string value);
            /*0x20c1ee4*/ string get_ProductName();
            /*0x20c1f70*/ void set_ProductName(string value);
            /*0x20c2028*/ string get_ProductVersion();
            /*0x20c20b4*/ void set_ProductVersion(string value);
            /*0x20c22e4*/ string get_InternalName();
            /*0x20c2370*/ void set_InternalName(string value);
            /*0x20c2428*/ string get_FileDescription();
            /*0x20c24b4*/ void set_FileDescription(string value);
            /*0x20c256c*/ int get_FileLanguage();
            /*0x20c2574*/ void set_FileLanguage(int value);
            /*0x20c257c*/ string get_FileVersion();
            /*0x20c2608*/ void set_FileVersion(string value);
            /*0x20c2838*/ void emit_padding(System.IO.BinaryWriter w);
            /*0x20c2898*/ void patch_length(System.IO.BinaryWriter w, long len_pos);
            /*0x20c2934*/ void WriteTo(System.IO.Stream ms);
        }

        class Win32ResFileReader
        {
            /*0x10*/ System.IO.Stream res_file;

            /*0x20c3834*/ Win32ResFileReader(System.IO.Stream s);
            /*0x20c385c*/ int read_int16();
            /*0x20c38c0*/ int read_int32();
            /*0x20c38fc*/ bool read_padding();
            /*0x20c394c*/ System.Resources.NameOrId read_ordinal();
            /*0x20c3b1c*/ System.Collections.ICollection ReadResources();
        }

        class ICONDIRENTRY
        {
            /*0x10*/ byte bWidth;
            /*0x11*/ byte bHeight;
            /*0x12*/ byte bColorCount;
            /*0x13*/ byte bReserved;
            /*0x14*/ short wPlanes;
            /*0x16*/ short wBitCount;
            /*0x18*/ int dwBytesInRes;
            /*0x1c*/ int dwImageOffset;
            /*0x20*/ byte[] image;

            /*0x20c3ee0*/ ICONDIRENTRY();
            /*0x20c3cc4*/ string ToString();
        }

        class Win32IconFileReader
        {
            /*0x10*/ System.IO.Stream iconFile;

            /*0x20c3ee8*/ Win32IconFileReader(System.IO.Stream s);
            /*0x20c3f10*/ System.Resources.ICONDIRENTRY[] ReadIcons();
        }
    }

    namespace Reflection
    {
        class AmbiguousMatchException : System.SystemException
        {
            /*0x20c447c*/ AmbiguousMatchException();
            /*0x20c44d8*/ AmbiguousMatchException(string message);
            /*0x20c44fc*/ AmbiguousMatchException(string message, System.Exception inner);
            /*0x20c4520*/ AmbiguousMatchException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class AssemblyAlgorithmIdAttribute : System.Attribute
        {
            /*0x10*/ uint <AlgorithmId>k__BackingField;

            /*0x20c4528*/ AssemblyAlgorithmIdAttribute(System.Configuration.Assemblies.AssemblyHashAlgorithm algorithmId);
            /*0x20c4550*/ AssemblyAlgorithmIdAttribute(uint algorithmId);
            /*0x20c4578*/ uint get_AlgorithmId();
        }

        class AssemblyCompanyAttribute : System.Attribute
        {
            /*0x10*/ string <Company>k__BackingField;

            /*0x20c4580*/ AssemblyCompanyAttribute(string company);
            /*0x20c45a8*/ string get_Company();
        }

        class AssemblyConfigurationAttribute : System.Attribute
        {
            /*0x10*/ string <Configuration>k__BackingField;

            /*0x20c45b0*/ AssemblyConfigurationAttribute(string configuration);
            /*0x20c45d8*/ string get_Configuration();
        }

        enum AssemblyContentType
        {
            Default = 0,
            WindowsRuntime = 1,
        }

        class AssemblyCopyrightAttribute : System.Attribute
        {
            /*0x10*/ string <Copyright>k__BackingField;

            /*0x20c45e0*/ AssemblyCopyrightAttribute(string copyright);
            /*0x20c4608*/ string get_Copyright();
        }

        class AssemblyCultureAttribute : System.Attribute
        {
            /*0x10*/ string <Culture>k__BackingField;

            /*0x20c4610*/ AssemblyCultureAttribute(string culture);
            /*0x20c4638*/ string get_Culture();
        }

        class AssemblyDefaultAliasAttribute : System.Attribute
        {
            /*0x10*/ string <DefaultAlias>k__BackingField;

            /*0x20c4640*/ AssemblyDefaultAliasAttribute(string defaultAlias);
            /*0x20c4668*/ string get_DefaultAlias();
        }

        class AssemblyDelaySignAttribute : System.Attribute
        {
            /*0x10*/ bool <DelaySign>k__BackingField;

            /*0x20c4670*/ AssemblyDelaySignAttribute(bool delaySign);
            /*0x20c4698*/ bool get_DelaySign();
        }

        class AssemblyDescriptionAttribute : System.Attribute
        {
            /*0x10*/ string <Description>k__BackingField;

            /*0x20c46a0*/ AssemblyDescriptionAttribute(string description);
            /*0x20c46c8*/ string get_Description();
        }

        class AssemblyFileVersionAttribute : System.Attribute
        {
            /*0x10*/ string <Version>k__BackingField;

            /*0x20c46d0*/ AssemblyFileVersionAttribute(string version);
            /*0x20c4748*/ string get_Version();
        }

        class AssemblyFlagsAttribute : System.Attribute
        {
            /*0x10*/ System.Reflection.AssemblyNameFlags _flags;

            /*0x20c4750*/ AssemblyFlagsAttribute(uint flags);
            /*0x20c4788*/ AssemblyFlagsAttribute(int assemblyFlags);
            /*0x20c47b0*/ AssemblyFlagsAttribute(System.Reflection.AssemblyNameFlags assemblyFlags);
            /*0x20c4778*/ uint get_Flags();
            /*0x20c4780*/ int get_AssemblyFlags();
        }

        class AssemblyInformationalVersionAttribute : System.Attribute
        {
            /*0x10*/ string <InformationalVersion>k__BackingField;

            /*0x20c47d8*/ AssemblyInformationalVersionAttribute(string informationalVersion);
            /*0x20c4800*/ string get_InformationalVersion();
        }

        class AssemblyKeyFileAttribute : System.Attribute
        {
            /*0x10*/ string <KeyFile>k__BackingField;

            /*0x20c4808*/ AssemblyKeyFileAttribute(string keyFile);
            /*0x20c4830*/ string get_KeyFile();
        }

        class AssemblyKeyNameAttribute : System.Attribute
        {
            /*0x10*/ string <KeyName>k__BackingField;

            /*0x20c4838*/ AssemblyKeyNameAttribute(string keyName);
            /*0x20c4860*/ string get_KeyName();
        }

        class AssemblyMetadataAttribute : System.Attribute
        {
            /*0x10*/ string <Key>k__BackingField;
            /*0x18*/ string <Value>k__BackingField;

            /*0x20c4868*/ AssemblyMetadataAttribute(string key, string value);
            /*0x20c4894*/ string get_Key();
            /*0x20c489c*/ string get_Value();
        }

        enum AssemblyNameFlags
        {
            None = 0,
            PublicKey = 1,
            EnableJITcompileOptimizer = 16384,
            EnableJITcompileTracking = 32768,
            Retargetable = 256,
        }

        class AssemblyProductAttribute : System.Attribute
        {
            /*0x10*/ string <Product>k__BackingField;

            /*0x20c48a4*/ AssemblyProductAttribute(string product);
            /*0x20c48cc*/ string get_Product();
        }

        class AssemblySignatureKeyAttribute : System.Attribute
        {
            /*0x10*/ string <PublicKey>k__BackingField;
            /*0x18*/ string <Countersignature>k__BackingField;

            /*0x20c48d4*/ AssemblySignatureKeyAttribute(string publicKey, string countersignature);
            /*0x20c4900*/ string get_PublicKey();
            /*0x20c4908*/ string get_Countersignature();
        }

        class AssemblyTitleAttribute : System.Attribute
        {
            /*0x10*/ string <Title>k__BackingField;

            /*0x20c4910*/ AssemblyTitleAttribute(string title);
            /*0x20c4938*/ string get_Title();
        }

        class AssemblyTrademarkAttribute : System.Attribute
        {
            /*0x10*/ string <Trademark>k__BackingField;

            /*0x20c4940*/ AssemblyTrademarkAttribute(string trademark);
            /*0x20c4968*/ string get_Trademark();
        }

        class AssemblyVersionAttribute : System.Attribute
        {
            /*0x10*/ string <Version>k__BackingField;

            /*0x20c4970*/ AssemblyVersionAttribute(string version);
            /*0x20c4998*/ string get_Version();
        }

        class Binder
        {
            /*0x20c49a0*/ Binder();
            System.Reflection.FieldInfo BindToField(System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);
            System.Reflection.MethodBase BindToMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, ref object state);
            object ChangeType(object value, System.Type type, System.Globalization.CultureInfo culture);
            void ReorderArgumentArray(ref object[] args, object state);
            System.Reflection.MethodBase SelectMethod(System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            System.Reflection.PropertyInfo SelectProperty(System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, System.Type returnType, System.Type[] indexes, System.Reflection.ParameterModifier[] modifiers);
            /*0x20c49a8*/ bool CanChangeType(object value, System.Type type, System.Globalization.CultureInfo culture);
        }

        enum BindingFlags
        {
            Default = 0,
            IgnoreCase = 1,
            DeclaredOnly = 2,
            Instance = 4,
            Static = 8,
            Public = 16,
            NonPublic = 32,
            FlattenHierarchy = 64,
            InvokeMethod = 256,
            CreateInstance = 512,
            GetField = 1024,
            SetField = 2048,
            GetProperty = 4096,
            SetProperty = 8192,
            PutDispProperty = 16384,
            PutRefDispProperty = 32768,
            ExactBinding = 65536,
            SuppressChangeType = 131072,
            OptionalParamBinding = 262144,
            IgnoreReturn = 16777216,
            DoNotWrapExceptions = 33554432,
        }

        enum CallingConventions
        {
            Standard = 1,
            VarArgs = 2,
            Any = 3,
            HasThis = 32,
            ExplicitThis = 64,
        }

        class ConstructorInfo : System.Reflection.MethodBase, System.Runtime.InteropServices._ConstructorInfo
        {
            static /*0x0*/ string ConstructorName;
            static /*0x8*/ string TypeConstructorName;

            static /*0x20c4ac8*/ ConstructorInfo();
            static /*0x20c4a08*/ bool op_Equality(System.Reflection.ConstructorInfo left, System.Reflection.ConstructorInfo right);
            static /*0x20c4a34*/ bool op_Inequality(System.Reflection.ConstructorInfo left, System.Reflection.ConstructorInfo right);
            /*0x20c49b0*/ ConstructorInfo();
            /*0x20c49c0*/ System.Reflection.MemberTypes get_MemberType();
            /*0x20c49c8*/ object Invoke(object[] parameters);
            object Invoke(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x20c49e8*/ bool Equals(object obj);
            /*0x20c49f8*/ int GetHashCode();
            /*0x20c4b54*/ void System.Runtime.InteropServices._ConstructorInfo.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20c4b8c*/ System.Type System.Runtime.InteropServices._ConstructorInfo.GetType();
            /*0x20c4bc4*/ void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20c4bfc*/ void System.Runtime.InteropServices._ConstructorInfo.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20c4c34*/ void System.Runtime.InteropServices._ConstructorInfo.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            /*0x20c4c6c*/ object System.Runtime.InteropServices._ConstructorInfo.Invoke_2(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x20c4ca4*/ object System.Runtime.InteropServices._ConstructorInfo.Invoke_3(object obj, object[] parameters);
            /*0x20c4cdc*/ object System.Runtime.InteropServices._ConstructorInfo.Invoke_4(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x20c4d14*/ object System.Runtime.InteropServices._ConstructorInfo.Invoke_5(object[] parameters);
        }

        class CustomAttributeFormatException : System.FormatException
        {
            /*0x20c4d4c*/ CustomAttributeFormatException();
            /*0x20c4dac*/ CustomAttributeFormatException(string message);
            /*0x20c4dd4*/ CustomAttributeFormatException(string message, System.Exception inner);
            /*0x20c4df8*/ CustomAttributeFormatException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class DefaultMemberAttribute : System.Attribute
        {
            /*0x10*/ string <MemberName>k__BackingField;

            /*0x20c4e00*/ DefaultMemberAttribute(string memberName);
            /*0x20c4e28*/ string get_MemberName();
        }

        enum EventAttributes
        {
            None = 0,
            SpecialName = 512,
            RTSpecialName = 1024,
            ReservedMask = 1024,
        }

        class EventInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._EventInfo
        {
            /*0x10*/ System.Reflection.EventInfo.AddEventAdapter cached_add_event;

            static /*0x20c5290*/ bool op_Equality(System.Reflection.EventInfo left, System.Reflection.EventInfo right);
            static /*0x20c52bc*/ bool op_Inequality(System.Reflection.EventInfo left, System.Reflection.EventInfo right);
            static /*0x20c54bc*/ System.Reflection.EventInfo internal_from_handle_type(nint event_handle, nint type_handle);
            static /*0x20c54c0*/ System.Reflection.EventInfo GetEventFromHandle(Mono.RuntimeEventHandle handle, System.RuntimeTypeHandle reflectedType);
            /*0x20c4e30*/ EventInfo();
            /*0x20c4e40*/ System.Reflection.MemberTypes get_MemberType();
            System.Reflection.EventAttributes get_Attributes();
            /*0x20c4e48*/ bool get_IsSpecialName();
            /*0x20c4e68*/ System.Reflection.MethodInfo[] GetOtherMethods();
            /*0x20c4e7c*/ System.Reflection.MethodInfo[] GetOtherMethods(bool nonPublic);
            /*0x20c4ea4*/ System.Reflection.MethodInfo get_AddMethod();
            /*0x20c4eb8*/ System.Reflection.MethodInfo get_RemoveMethod();
            /*0x20c4ecc*/ System.Reflection.MethodInfo get_RaiseMethod();
            /*0x20c4ee0*/ System.Reflection.MethodInfo GetAddMethod();
            /*0x20c4ef4*/ System.Reflection.MethodInfo GetRemoveMethod();
            /*0x20c4f08*/ System.Reflection.MethodInfo GetRaiseMethod();
            System.Reflection.MethodInfo GetAddMethod(bool nonPublic);
            System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic);
            System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic);
            /*0x20c4f1c*/ bool get_IsMulticast();
            /*0x20c4fcc*/ System.Type get_EventHandlerType();
            /*0x20c50f8*/ void RemoveEventHandler(object target, System.Delegate handler);
            /*0x20c5270*/ bool Equals(object obj);
            /*0x20c5280*/ int GetHashCode();
            /*0x20c52f8*/ void AddEventHandler(object target, System.Delegate handler);
            /*0x20c55a8*/ void System.Runtime.InteropServices._EventInfo.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20c55e0*/ System.Type System.Runtime.InteropServices._EventInfo.GetType();
            /*0x20c5618*/ void System.Runtime.InteropServices._EventInfo.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20c5650*/ void System.Runtime.InteropServices._EventInfo.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20c5688*/ void System.Runtime.InteropServices._EventInfo.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);

            class AddEventAdapter : System.MulticastDelegate
            {
                /*0x20c56c0*/ AddEventAdapter(object object, nint method);
                /*0x20c57f0*/ void Invoke(object _this, System.Delegate dele);
            }
        }

        enum ExceptionHandlingClauseOptions
        {
            Clause = 0,
            Filter = 1,
            Finally = 2,
            Fault = 4,
        }

        enum FieldAttributes
        {
            FieldAccessMask = 7,
            PrivateScope = 0,
            Private = 1,
            FamANDAssem = 2,
            Assembly = 3,
            Family = 4,
            FamORAssem = 5,
            Public = 6,
            Static = 16,
            InitOnly = 32,
            Literal = 64,
            NotSerialized = 128,
            SpecialName = 512,
            PinvokeImpl = 8192,
            RTSpecialName = 1024,
            HasFieldMarshal = 4096,
            HasDefault = 32768,
            HasFieldRVA = 256,
            ReservedMask = 38144,
        }

        class FieldInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._FieldInfo
        {
            static /*0x20c59ec*/ bool op_Equality(System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);
            static /*0x20c5a18*/ bool op_Inequality(System.Reflection.FieldInfo left, System.Reflection.FieldInfo right);
            static /*0x20c5c20*/ System.Reflection.FieldInfo internal_from_handle_type(nint field_handle, nint type_handle);
            static /*0x20c5c24*/ System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle handle);
            static /*0x20c5cdc*/ System.Reflection.FieldInfo GetFieldFromHandle(System.RuntimeFieldHandle handle, System.RuntimeTypeHandle declaringType);
            /*0x20c5804*/ FieldInfo();
            /*0x20c580c*/ System.Reflection.MemberTypes get_MemberType();
            System.Reflection.FieldAttributes get_Attributes();
            System.Type get_FieldType();
            /*0x20c5814*/ bool get_IsInitOnly();
            /*0x20c5834*/ bool get_IsLiteral();
            /*0x20c5854*/ bool get_IsNotSerialized();
            /*0x20c5874*/ bool get_IsPinvokeImpl();
            /*0x20c5894*/ bool get_IsSpecialName();
            /*0x20c58b4*/ bool get_IsStatic();
            /*0x20c58d4*/ bool get_IsAssembly();
            /*0x20c58fc*/ bool get_IsFamily();
            /*0x20c5924*/ bool get_IsFamilyAndAssembly();
            /*0x20c594c*/ bool get_IsFamilyOrAssembly();
            /*0x20c5974*/ bool get_IsPrivate();
            /*0x20c599c*/ bool get_IsPublic();
            /*0x20c59c4*/ bool get_IsSecurityCritical();
            /*0x20c59cc*/ bool get_IsSecuritySafeCritical();
            /*0x20c59d4*/ bool get_IsSecurityTransparent();
            System.RuntimeFieldHandle get_FieldHandle();
            /*0x20c59dc*/ bool Equals(object obj);
            /*0x20c59e4*/ int GetHashCode();
            object GetValue(object obj);
            /*0x20c5a54*/ void SetValue(object obj, object value);
            void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            /*0x20c5ae0*/ void SetValueDirect(System.TypedReference obj, object value);
            /*0x20c5b30*/ object GetValueDirect(System.TypedReference obj);
            /*0x20c5b80*/ object GetRawConstantValue();
            /*0x20c5bd0*/ System.Type[] GetOptionalCustomModifiers();
            /*0x20c5bf8*/ System.Type[] GetRequiredCustomModifiers();
            /*0x20c5dc4*/ int GetFieldOffset();
            /*0x20c5e14*/ System.Runtime.InteropServices.MarshalAsAttribute get_marshal_info();
            /*0x20c5e18*/ object[] GetPseudoCustomAttributes();
            /*0x20c6034*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData();
            /*0x20c69b0*/ void System.Runtime.InteropServices._FieldInfo.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20c69e8*/ System.Type System.Runtime.InteropServices._FieldInfo.GetType();
            /*0x20c6a20*/ void System.Runtime.InteropServices._FieldInfo.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20c6a58*/ void System.Runtime.InteropServices._FieldInfo.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20c6a90*/ void System.Runtime.InteropServices._FieldInfo.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        }

        enum GenericParameterAttributes
        {
            None = 0,
            VarianceMask = 3,
            Covariant = 1,
            Contravariant = 2,
            SpecialConstraintMask = 28,
            ReferenceTypeConstraint = 4,
            NotNullableValueTypeConstraint = 8,
            DefaultConstructorConstraint = 16,
        }

        interface ICustomAttributeProvider
        {
            object[] GetCustomAttributes(bool inherit);
            object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            bool IsDefined(System.Type attributeType, bool inherit);
        }

        interface IReflect
        {
            System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.PropertyInfo GetProperty(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr);
            System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
            object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
            System.Type get_UnderlyingSystemType();
        }

        interface IReflectableType
        {
            System.Reflection.TypeInfo GetTypeInfo();
        }

        enum ImageFileMachine
        {
            I386 = 332,
            IA64 = 512,
            AMD64 = 34404,
            ARM = 452,
        }

        struct InterfaceMapping
        {
            /*0x10*/ System.Type TargetType;
            /*0x18*/ System.Type InterfaceType;
            /*0x20*/ System.Reflection.MethodInfo[] TargetMethods;
            /*0x28*/ System.Reflection.MethodInfo[] InterfaceMethods;
        }

        class IntrospectionExtensions
        {
            static /*0x20c6ac8*/ System.Reflection.TypeInfo GetTypeInfo(System.Type type);
        }

        class InvalidFilterCriteriaException : System.ApplicationException
        {
            /*0x20c6cfc*/ InvalidFilterCriteriaException();
            /*0x20c6d5c*/ InvalidFilterCriteriaException(string message);
            /*0x20c6d84*/ InvalidFilterCriteriaException(string message, System.Exception inner);
            /*0x20c6da8*/ InvalidFilterCriteriaException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class ManifestResourceInfo
        {
            /*0x10*/ System.Reflection.Assembly <ReferencedAssembly>k__BackingField;
            /*0x18*/ string <FileName>k__BackingField;
            /*0x20*/ System.Reflection.ResourceLocation <ResourceLocation>k__BackingField;

            /*0x20c6db0*/ ManifestResourceInfo(System.Reflection.Assembly containingAssembly, string containingFileName, System.Reflection.ResourceLocation resourceLocation);
            /*0x20c6dec*/ System.Reflection.Assembly get_ReferencedAssembly();
            /*0x20c6df4*/ string get_FileName();
            /*0x20c6dfc*/ System.Reflection.ResourceLocation get_ResourceLocation();
        }

        class MemberFilter : System.MulticastDelegate
        {
            /*0x20c6e04*/ MemberFilter(object object, nint method);
            /*0x20c6f34*/ bool Invoke(System.Reflection.MemberInfo m, object filterCriteria);
            /*0x20c6f48*/ System.IAsyncResult BeginInvoke(System.Reflection.MemberInfo m, object filterCriteria, System.AsyncCallback callback, object object);
            /*0x20c6f70*/ bool EndInvoke(System.IAsyncResult result);
        }

        class MemberInfo : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._MemberInfo
        {
            static /*0x20c710c*/ bool op_Equality(System.Reflection.MemberInfo left, System.Reflection.MemberInfo right);
            static /*0x20c769c*/ bool op_Inequality(System.Reflection.MemberInfo left, System.Reflection.MemberInfo right);
            /*0x20c4e38*/ MemberInfo();
            System.Reflection.MemberTypes get_MemberType();
            string get_Name();
            System.Type get_DeclaringType();
            System.Type get_ReflectedType();
            /*0x20c6f98*/ System.Reflection.Module get_Module();
            /*0x20c706c*/ bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other);
            bool IsDefined(System.Type attributeType, bool inherit);
            object[] GetCustomAttributes(bool inherit);
            object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20c7094*/ System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> get_CustomAttributes();
            /*0x20c70a4*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20c70cc*/ int get_MetadataToken();
            /*0x20c5278*/ bool Equals(object obj);
            /*0x20c5288*/ int GetHashCode();
            /*0x20c76b4*/ bool CacheEquals(object o);
            bool HasSameMetadataDefinitionAsCore<TOther>(System.Reflection.MemberInfo other);
            /*0x20c76f4*/ void System.Runtime.InteropServices._MemberInfo.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20c772c*/ System.Type System.Runtime.InteropServices._MemberInfo.GetType();
            /*0x20c7764*/ void System.Runtime.InteropServices._MemberInfo.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20c779c*/ void System.Runtime.InteropServices._MemberInfo.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20c77d4*/ void System.Runtime.InteropServices._MemberInfo.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        }

        enum MemberTypes
        {
            Constructor = 1,
            Event = 2,
            Field = 4,
            Method = 8,
            Property = 16,
            TypeInfo = 32,
            Custom = 64,
            NestedType = 128,
            All = 191,
        }

        enum MethodAttributes
        {
            MemberAccessMask = 7,
            PrivateScope = 0,
            Private = 1,
            FamANDAssem = 2,
            Assembly = 3,
            Family = 4,
            FamORAssem = 5,
            Public = 6,
            Static = 16,
            Final = 32,
            Virtual = 64,
            HideBySig = 128,
            CheckAccessOnOverride = 512,
            VtableLayoutMask = 256,
            ReuseSlot = 0,
            NewSlot = 256,
            Abstract = 1024,
            SpecialName = 2048,
            PinvokeImpl = 8192,
            UnmanagedExport = 8,
            RTSpecialName = 4096,
            HasSecurity = 16384,
            RequireSecObject = 32768,
            ReservedMask = 53248,
        }

        class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase
        {
            static /*0x20c7480*/ bool op_Equality(System.Reflection.MethodBase left, System.Reflection.MethodBase right);
            static /*0x20c7468*/ bool op_Inequality(System.Reflection.MethodBase left, System.Reflection.MethodBase right);
            static /*0x20c80fc*/ System.Reflection.MethodBase GetMethodFromHandle(System.RuntimeMethodHandle handle);
            static /*0x20c8308*/ System.Reflection.MethodBase GetMethodFromHandle(System.RuntimeMethodHandle handle, System.RuntimeTypeHandle declaringType);
            static /*0x20c7df4*/ string ConstructParameters(System.Type[] parameterTypes, System.Reflection.CallingConventions callingConvention, bool serialization);
            static /*0x20c83fc*/ System.Reflection.MethodBase GetCurrentMethod();
            /*0x20c49b8*/ MethodBase();
            System.Reflection.ParameterInfo[] GetParameters();
            System.Reflection.MethodAttributes get_Attributes();
            /*0x20c780c*/ System.Reflection.MethodImplAttributes get_MethodImplementationFlags();
            System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
            /*0x20c781c*/ System.Reflection.MethodBody GetMethodBody();
            /*0x20c785c*/ System.Reflection.CallingConventions get_CallingConvention();
            /*0x20c7864*/ bool get_IsAbstract();
            /*0x20c7884*/ bool get_IsConstructor();
            /*0x20c7928*/ bool get_IsFinal();
            /*0x20c7948*/ bool get_IsHideBySig();
            /*0x20c7968*/ bool get_IsSpecialName();
            /*0x20c5474*/ bool get_IsStatic();
            /*0x20c7988*/ bool get_IsVirtual();
            /*0x20c79a8*/ bool get_IsAssembly();
            /*0x20c79d0*/ bool get_IsFamily();
            /*0x20c79f8*/ bool get_IsFamilyAndAssembly();
            /*0x20c7a20*/ bool get_IsFamilyOrAssembly();
            /*0x20c7a48*/ bool get_IsPrivate();
            /*0x20c7a70*/ bool get_IsPublic();
            /*0x20c7a98*/ bool get_IsConstructedGenericMethod();
            /*0x20c7ae0*/ bool get_IsGenericMethod();
            /*0x20c7ae8*/ bool get_IsGenericMethodDefinition();
            /*0x20c7af0*/ System.Type[] GetGenericArguments();
            /*0x20c7b40*/ bool get_ContainsGenericParameters();
            /*0x20c5250*/ object Invoke(object obj, object[] parameters);
            object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            System.RuntimeMethodHandle get_MethodHandle();
            /*0x20c7b48*/ bool get_IsSecurityCritical();
            /*0x20c7b70*/ bool get_IsSecuritySafeCritical();
            /*0x20c7b98*/ bool get_IsSecurityTransparent();
            /*0x20c49f0*/ bool Equals(object obj);
            /*0x20c4a00*/ int GetHashCode();
            /*0x20c7bfc*/ System.Reflection.ParameterInfo[] GetParametersInternal();
            /*0x20c7c0c*/ int GetParametersCount();
            /*0x20c7c34*/ System.Type GetParameterType(int pos);
            /*0x20c7c74*/ int get_next_table_index(object obj, int table, int count);
            /*0x20c7cc4*/ string FormatNameAndSig(bool serialization);
            /*0x20c7fe0*/ System.Type[] GetParameterTypes();
            /*0x20c80ec*/ System.Reflection.ParameterInfo[] GetParametersNoCopy();
            /*0x20c844c*/ void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20c8484*/ System.Type System.Runtime.InteropServices._MethodBase.GetType();
            /*0x20c84bc*/ void System.Runtime.InteropServices._MethodBase.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20c84f4*/ void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20c852c*/ void System.Runtime.InteropServices._MethodBase.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        }

        enum MethodImplAttributes
        {
            CodeTypeMask = 3,
            IL = 0,
            Native = 1,
            OPTIL = 2,
            Runtime = 3,
            ManagedMask = 4,
            Unmanaged = 4,
            Managed = 0,
            ForwardRef = 16,
            PreserveSig = 128,
            InternalCall = 4096,
            Synchronized = 32,
            NoInlining = 8,
            AggressiveInlining = 256,
            NoOptimization = 64,
            MaxMethodImplVal = 65535,
            SecurityMitigations = 1024,
        }

        class MethodInfo : System.Reflection.MethodBase, System.Runtime.InteropServices._MethodInfo
        {
            static /*0x20c5224*/ bool op_Equality(System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);
            static /*0x20c7bc0*/ bool op_Inequality(System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);
            /*0x20c8564*/ MethodInfo();
            /*0x20c856c*/ System.Reflection.MemberTypes get_MemberType();
            /*0x20c8574*/ System.Reflection.ParameterInfo get_ReturnParameter();
            /*0x20c859c*/ System.Type get_ReturnType();
            /*0x20c85c4*/ System.Type[] GetGenericArguments();
            /*0x20c8614*/ System.Reflection.MethodInfo GetGenericMethodDefinition();
            /*0x20c8664*/ System.Reflection.MethodInfo MakeGenericMethod(System.Type[] typeArguments);
            System.Reflection.MethodInfo GetBaseDefinition();
            System.Reflection.ICustomAttributeProvider get_ReturnTypeCustomAttributes();
            /*0x20c86b4*/ System.Delegate CreateDelegate(System.Type delegateType);
            /*0x20c8704*/ System.Delegate CreateDelegate(System.Type delegateType, object target);
            /*0x20c8754*/ bool Equals(object obj);
            /*0x20c875c*/ int GetHashCode();
            /*0x20c8764*/ int get_GenericParameterCount();
            /*0x20c878c*/ void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20c87c4*/ System.Type System.Runtime.InteropServices._MethodInfo.GetType();
            /*0x20c87fc*/ void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20c8834*/ void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20c886c*/ void System.Runtime.InteropServices._MethodInfo.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        }

        class Missing : System.Runtime.Serialization.ISerializable
        {
            static /*0x0*/ System.Reflection.Missing Value;

            static /*0x20c88ec*/ Missing();
            /*0x20c88a4*/ Missing();
            /*0x20c88ac*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class Module : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Module
        {
            static System.Reflection.BindingFlags DefaultLookup = 28;
            static /*0x0*/ System.Reflection.TypeFilter FilterTypeName;
            static /*0x8*/ System.Reflection.TypeFilter FilterTypeNameIgnoreCase;

            static /*0x20c969c*/ Module();
            static /*0x20c928c*/ bool op_Equality(System.Reflection.Module left, System.Reflection.Module right);
            static /*0x20c92b8*/ bool op_Inequality(System.Reflection.Module left, System.Reflection.Module right);
            static /*0x20c935c*/ bool FilterTypeNameImpl(System.Type cls, object filterCriteria);
            static /*0x20c9498*/ bool FilterTypeNameIgnoreCaseImpl(System.Type cls, object filterCriteria);
            static /*0x20c9614*/ System.Guid Mono_GetGuid(System.Reflection.Module module);
            /*0x20c8950*/ Module();
            /*0x20c8958*/ System.Reflection.Assembly get_Assembly();
            /*0x20c8980*/ string get_FullyQualifiedName();
            /*0x20c89a8*/ string get_Name();
            /*0x20c89d0*/ int get_MDStreamVersion();
            /*0x20c89f8*/ System.Guid get_ModuleVersionId();
            /*0x20c8a20*/ string get_ScopeName();
            /*0x20c8a48*/ System.ModuleHandle get_ModuleHandle();
            /*0x20c8a58*/ System.ModuleHandle GetModuleHandleImpl();
            /*0x20c8ab0*/ void GetPEKind(ref System.Reflection.PortableExecutableKinds peKind, ref System.Reflection.ImageFileMachine machine);
            /*0x20c8ad8*/ bool IsResource();
            /*0x20c8b00*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20c8b28*/ System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> get_CustomAttributes();
            /*0x20c8b38*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20c8b60*/ object[] GetCustomAttributes(bool inherit);
            /*0x20c8b88*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20c8bb0*/ System.Reflection.MethodInfo GetMethod(string name);
            /*0x20c8c2c*/ System.Reflection.MethodInfo GetMethod(string name, System.Type[] types);
            /*0x20c8c44*/ System.Reflection.MethodInfo GetMethod(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20c8db8*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20c8de0*/ System.Reflection.MethodInfo[] GetMethods();
            /*0x20c8df4*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingFlags);
            /*0x20c8e1c*/ System.Reflection.FieldInfo GetField(string name);
            /*0x20c8e30*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x20c8e58*/ System.Reflection.FieldInfo[] GetFields();
            /*0x20c8e6c*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingFlags);
            /*0x20c8e94*/ System.Type[] GetTypes();
            /*0x20c8ebc*/ System.Type GetType(string className);
            /*0x20c8ed4*/ System.Type GetType(string className, bool ignoreCase);
            /*0x20c8eec*/ System.Type GetType(string className, bool throwOnError, bool ignoreCase);
            /*0x20c8f14*/ System.Type[] FindTypes(System.Reflection.TypeFilter filter, object filterCriteria);
            /*0x20c90dc*/ int get_MetadataToken();
            /*0x20c9104*/ System.Reflection.FieldInfo ResolveField(int metadataToken);
            /*0x20c911c*/ System.Reflection.FieldInfo ResolveField(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            /*0x20c9144*/ System.Reflection.MemberInfo ResolveMember(int metadataToken);
            /*0x20c915c*/ System.Reflection.MemberInfo ResolveMember(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            /*0x20c9184*/ System.Reflection.MethodBase ResolveMethod(int metadataToken);
            /*0x20c919c*/ System.Reflection.MethodBase ResolveMethod(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            /*0x20c91c4*/ byte[] ResolveSignature(int metadataToken);
            /*0x20c91ec*/ string ResolveString(int metadataToken);
            /*0x20c9214*/ System.Type ResolveType(int metadataToken);
            /*0x20c922c*/ System.Type ResolveType(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            /*0x20c9254*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20c927c*/ bool Equals(object o);
            /*0x20c9284*/ int GetHashCode();
            /*0x20c934c*/ string ToString();
            /*0x20c9604*/ System.Guid get_MvId();
            /*0x20c9634*/ System.Guid GetModuleVersionId();
            /*0x20c9674*/ System.Security.Cryptography.X509Certificates.X509Certificate GetSignerCertificate();
            /*0x20c9898*/ void System.Runtime.InteropServices._Module.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20c98d0*/ void System.Runtime.InteropServices._Module.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20c9908*/ void System.Runtime.InteropServices._Module.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20c9940*/ void System.Runtime.InteropServices._Module.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        }

        class ModuleResolveEventHandler : System.MulticastDelegate
        {
            /*0x20c9978*/ ModuleResolveEventHandler(object object, nint method);
            /*0x20c9aa8*/ System.Reflection.Module Invoke(object sender, System.ResolveEventArgs e);
            /*0x20c9abc*/ System.IAsyncResult BeginInvoke(object sender, System.ResolveEventArgs e, System.AsyncCallback callback, object object);
            /*0x20c9ae4*/ System.Reflection.Module EndInvoke(System.IAsyncResult result);
        }

        class ObfuscateAssemblyAttribute : System.Attribute
        {
            /*0x10*/ bool <AssemblyIsPrivate>k__BackingField;
            /*0x11*/ bool <StripAfterObfuscation>k__BackingField;

            /*0x20c9af0*/ ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
            /*0x20c9b20*/ bool get_AssemblyIsPrivate();
            /*0x20c9b28*/ bool get_StripAfterObfuscation();
            /*0x20c9b30*/ void set_StripAfterObfuscation(bool value);
        }

        class ObfuscationAttribute : System.Attribute
        {
            /*0x10*/ bool <StripAfterObfuscation>k__BackingField;
            /*0x11*/ bool <Exclude>k__BackingField;
            /*0x12*/ bool <ApplyToMembers>k__BackingField;
            /*0x18*/ string <Feature>k__BackingField;

            /*0x20c9b3c*/ ObfuscationAttribute();
            /*0x20c9b9c*/ bool get_StripAfterObfuscation();
            /*0x20c9ba4*/ void set_StripAfterObfuscation(bool value);
            /*0x20c9bb0*/ bool get_Exclude();
            /*0x20c9bb8*/ void set_Exclude(bool value);
            /*0x20c9bc4*/ bool get_ApplyToMembers();
            /*0x20c9bcc*/ void set_ApplyToMembers(bool value);
            /*0x20c9bd8*/ string get_Feature();
            /*0x20c9be0*/ void set_Feature(string value);
        }

        enum ParameterAttributes
        {
            None = 0,
            In = 1,
            Out = 2,
            Lcid = 4,
            Retval = 8,
            Optional = 16,
            HasDefault = 4096,
            HasFieldMarshal = 8192,
            Reserved3 = 16384,
            Reserved4 = 32768,
            ReservedMask = 61440,
        }

        class ParameterInfo : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.IObjectReference, System.Runtime.InteropServices._ParameterInfo
        {
            static int MetadataToken_ParamDef = 134217728;
            /*0x10*/ System.Reflection.ParameterAttributes AttrsImpl;
            /*0x18*/ System.Type ClassImpl;
            /*0x20*/ object DefaultValueImpl;
            /*0x28*/ System.Reflection.MemberInfo MemberImpl;
            /*0x30*/ string NameImpl;
            /*0x38*/ int PositionImpl;

            /*0x20c9be8*/ ParameterInfo();
            /*0x20c9bf0*/ System.Reflection.ParameterAttributes get_Attributes();
            /*0x20c9bf8*/ System.Reflection.MemberInfo get_Member();
            /*0x20c9c00*/ string get_Name();
            /*0x20c9c08*/ System.Type get_ParameterType();
            /*0x20c9c10*/ int get_Position();
            /*0x20c9c18*/ bool get_IsIn();
            /*0x20c9c34*/ bool get_IsLcid();
            /*0x20c9c50*/ bool get_IsOptional();
            /*0x20c9c6c*/ bool get_IsOut();
            /*0x20c9c88*/ bool get_IsRetval();
            /*0x20c9ca4*/ object get_DefaultValue();
            /*0x20c9ccc*/ object get_RawDefaultValue();
            /*0x20c9cf4*/ bool get_HasDefaultValue();
            /*0x20c9d1c*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20c9dd0*/ System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> get_CustomAttributes();
            /*0x20c9de0*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20c9e08*/ object[] GetCustomAttributes(bool inherit);
            /*0x20c9e84*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20c9f88*/ System.Type[] GetOptionalCustomModifiers();
            /*0x20ca004*/ System.Type[] GetRequiredCustomModifiers();
            /*0x20ca080*/ int get_MetadataToken();
            /*0x20ca088*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
            /*0x20ca370*/ string ToString();
            /*0x20ca3fc*/ void System.Runtime.InteropServices._ParameterInfo.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20ca434*/ void System.Runtime.InteropServices._ParameterInfo.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20ca46c*/ void System.Runtime.InteropServices._ParameterInfo.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20ca4a4*/ void System.Runtime.InteropServices._ParameterInfo.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        }

        struct ParameterModifier
        {
            /*0x10*/ bool[] _byRef;

            /*0x20ca4dc*/ ParameterModifier(int parameterCount);
            /*0x20ca584*/ bool get_Item(int index);
            /*0x20ca5b4*/ void set_Item(int index, bool value);
        }

        class Pointer : System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ void* _ptr;
            /*0x18*/ System.Type _ptrType;

            static /*0x20ca614*/ object Box(void* ptr, System.Type type);
            static /*0x20ca79c*/ void* Unbox(object ptr);
            /*0x20ca5e8*/ Pointer(void* ptr, System.Type ptrType);
            /*0x20ca8a8*/ Pointer();
            /*0x20ca854*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20ca894*/ System.Type GetPointerType();
            /*0x20ca89c*/ nint GetPointerValue();
        }

        enum PortableExecutableKinds
        {
            NotAPortableExecutableImage = 0,
            ILOnly = 1,
            Required32Bit = 2,
            PE32Plus = 4,
            Unmanaged32Bit = 8,
            Preferred32Bit = 16,
        }

        enum ProcessorArchitecture
        {
            None = 0,
            MSIL = 1,
            X86 = 2,
            IA64 = 3,
            Amd64 = 4,
            Arm = 5,
        }

        enum PropertyAttributes
        {
            None = 0,
            SpecialName = 512,
            RTSpecialName = 1024,
            HasDefault = 4096,
            Reserved2 = 8192,
            Reserved3 = 16384,
            Reserved4 = 32768,
            ReservedMask = 62464,
        }

        class PropertyInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._PropertyInfo
        {
            static /*0x20c7670*/ bool op_Equality(System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right);
            static /*0x20c7634*/ bool op_Inequality(System.Reflection.PropertyInfo left, System.Reflection.PropertyInfo right);
            /*0x20ca8e0*/ PropertyInfo();
            /*0x20ca8e8*/ System.Reflection.MemberTypes get_MemberType();
            System.Type get_PropertyType();
            System.Reflection.ParameterInfo[] GetIndexParameters();
            System.Reflection.PropertyAttributes get_Attributes();
            /*0x20ca8f0*/ bool get_IsSpecialName();
            bool get_CanRead();
            bool get_CanWrite();
            /*0x20ca910*/ System.Reflection.MethodInfo[] GetAccessors();
            System.Reflection.MethodInfo[] GetAccessors(bool nonPublic);
            /*0x20ca924*/ System.Reflection.MethodInfo get_GetMethod();
            /*0x20ca938*/ System.Reflection.MethodInfo GetGetMethod();
            System.Reflection.MethodInfo GetGetMethod(bool nonPublic);
            /*0x20ca94c*/ System.Reflection.MethodInfo get_SetMethod();
            /*0x20ca960*/ System.Reflection.MethodInfo GetSetMethod();
            System.Reflection.MethodInfo GetSetMethod(bool nonPublic);
            /*0x20ca974*/ System.Type[] GetOptionalCustomModifiers();
            /*0x20ca9f0*/ System.Type[] GetRequiredCustomModifiers();
            /*0x20caa6c*/ object GetValue(object obj);
            /*0x20caa80*/ object GetValue(object obj, object[] index);
            object GetValue(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            /*0x20caaa0*/ object GetConstantValue();
            /*0x20caac8*/ object GetRawConstantValue();
            /*0x20caaf0*/ void SetValue(object obj, object value);
            /*0x20cab04*/ void SetValue(object obj, object value, object[] index);
            void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            /*0x20cab24*/ bool Equals(object obj);
            /*0x20cab2c*/ int GetHashCode();
            /*0x20cab34*/ void System.Runtime.InteropServices._PropertyInfo.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20cab6c*/ System.Type System.Runtime.InteropServices._PropertyInfo.GetType();
            /*0x20caba4*/ void System.Runtime.InteropServices._PropertyInfo.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20cabdc*/ void System.Runtime.InteropServices._PropertyInfo.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20cac14*/ void System.Runtime.InteropServices._PropertyInfo.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        }

        class ReflectionContext
        {
            /*0x20cac4c*/ ReflectionContext();
            System.Reflection.Assembly MapAssembly(System.Reflection.Assembly assembly);
            System.Reflection.TypeInfo MapType(System.Reflection.TypeInfo type);
            /*0x20cac54*/ System.Reflection.TypeInfo GetTypeForObject(object value);
        }

        class ReflectionTypeLoadException : System.SystemException, System.Runtime.Serialization.ISerializable
        {
            /*0x90*/ System.Type[] <Types>k__BackingField;
            /*0x98*/ System.Exception[] <LoaderExceptions>k__BackingField;

            /*0x20cacd4*/ ReflectionTypeLoadException(System.Type[] classes, System.Exception[] exceptions);
            /*0x20cad10*/ ReflectionTypeLoadException(System.Type[] classes, System.Exception[] exceptions, string message);
            /*0x20cad4c*/ ReflectionTypeLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20cae84*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20cafac*/ System.Type[] get_Types();
            /*0x20cafb4*/ System.Exception[] get_LoaderExceptions();
            /*0x20cafbc*/ string get_Message();
            /*0x20cb100*/ string ToString();
            /*0x20cafc4*/ string CreateString(bool isMessage);
        }

        enum ResourceAttributes
        {
            Public = 1,
            Private = 2,
        }

        enum ResourceLocation
        {
            ContainedInAnotherAssembly = 2,
            ContainedInManifestFile = 4,
            Embedded = 1,
        }

        class SignatureArrayType : System.Reflection.SignatureHasElementType
        {
            /*0x20*/ int _rank;
            /*0x24*/ bool _isMultiDim;

            /*0x20cb108*/ SignatureArrayType(System.Reflection.SignatureType elementType, int rank, bool isMultiDim);
            /*0x20cb168*/ bool IsArrayImpl();
            /*0x20cb170*/ bool IsByRefImpl();
            /*0x20cb178*/ bool IsPointerImpl();
            /*0x20cb180*/ bool get_IsSZArray();
            /*0x20cb190*/ bool get_IsVariableBoundArray();
            /*0x20cb198*/ int GetArrayRank();
            /*0x20cb1a0*/ string get_Suffix();
        }

        class SignatureByRefType : System.Reflection.SignatureHasElementType
        {
            /*0x20cb268*/ SignatureByRefType(System.Reflection.SignatureType elementType);
            /*0x20cb28c*/ bool IsArrayImpl();
            /*0x20cb294*/ bool IsByRefImpl();
            /*0x20cb29c*/ bool IsPointerImpl();
            /*0x20cb2a4*/ bool get_IsSZArray();
            /*0x20cb2ac*/ bool get_IsVariableBoundArray();
            /*0x20cb2b4*/ int GetArrayRank();
            /*0x20cb304*/ string get_Suffix();
        }

        class SignatureConstructedGenericType : System.Reflection.SignatureType
        {
            /*0x18*/ System.Type _genericTypeDefinition;
            /*0x20*/ System.Type[] _genericTypeArguments;

            /*0x20cb344*/ SignatureConstructedGenericType(System.Type genericTypeDefinition, System.Type[] typeArguments);
            /*0x20cb540*/ bool get_IsTypeDefinition();
            /*0x20cb548*/ bool get_IsGenericTypeDefinition();
            /*0x20cb550*/ bool HasElementTypeImpl();
            /*0x20cb558*/ bool IsArrayImpl();
            /*0x20cb560*/ bool IsByRefImpl();
            /*0x20cb568*/ bool get_IsByRefLike();
            /*0x20cb58c*/ bool IsPointerImpl();
            /*0x20cb594*/ bool get_IsSZArray();
            /*0x20cb59c*/ bool get_IsVariableBoundArray();
            /*0x20cb5a4*/ bool get_IsConstructedGenericType();
            /*0x20cb5ac*/ bool get_IsGenericParameter();
            /*0x20cb5b4*/ bool get_IsGenericTypeParameter();
            /*0x20cb5bc*/ bool get_IsGenericMethodParameter();
            /*0x20cb5c4*/ bool get_ContainsGenericParameters();
            /*0x20cb63c*/ System.Reflection.SignatureType get_ElementType();
            /*0x20cb644*/ int GetArrayRank();
            /*0x20cb694*/ System.Type GetGenericTypeDefinition();
            /*0x20cb69c*/ System.Type[] GetGenericArguments();
            /*0x20cb6ac*/ System.Type[] get_GenericTypeArguments();
            /*0x20cb724*/ int get_GenericParameterPosition();
            /*0x20cb774*/ string get_Name();
            /*0x20cb798*/ string get_Namespace();
            /*0x20cb7bc*/ string ToString();
        }

        class SignatureGenericMethodParameterType : System.Reflection.SignatureGenericParameterType
        {
            /*0x20cb8e0*/ SignatureGenericMethodParameterType(int position);
            /*0x20cb928*/ bool get_IsGenericTypeParameter();
            /*0x20cb930*/ bool get_IsGenericMethodParameter();
            /*0x20cb938*/ string get_Name();
        }

        class SignatureGenericParameterType : System.Reflection.SignatureType
        {
            /*0x18*/ int _position;

            /*0x20cb904*/ SignatureGenericParameterType(int position);
            /*0x20cb9b8*/ bool get_IsTypeDefinition();
            /*0x20cb9c0*/ bool get_IsGenericTypeDefinition();
            /*0x20cb9c8*/ bool HasElementTypeImpl();
            /*0x20cb9d0*/ bool IsArrayImpl();
            /*0x20cb9d8*/ bool IsByRefImpl();
            /*0x20cb9e0*/ bool get_IsByRefLike();
            /*0x20cb9e8*/ bool IsPointerImpl();
            /*0x20cb9f0*/ bool get_IsSZArray();
            /*0x20cb9f8*/ bool get_IsVariableBoundArray();
            /*0x20cba00*/ bool get_IsConstructedGenericType();
            /*0x20cba08*/ bool get_IsGenericParameter();
            bool get_IsGenericMethodParameter();
            /*0x20cba10*/ bool get_ContainsGenericParameters();
            /*0x20cba18*/ System.Reflection.SignatureType get_ElementType();
            /*0x20cba20*/ int GetArrayRank();
            /*0x20cba70*/ System.Type GetGenericTypeDefinition();
            /*0x20cbac0*/ System.Type[] GetGenericArguments();
            /*0x20cbb3c*/ System.Type[] get_GenericTypeArguments();
            /*0x20cbbb8*/ int get_GenericParameterPosition();
            string get_Name();
            /*0x20cbbc0*/ string get_Namespace();
            /*0x20cbbc8*/ string ToString();
        }

        class SignatureHasElementType : System.Reflection.SignatureType
        {
            /*0x18*/ System.Reflection.SignatureType _elementType;

            /*0x20cb144*/ SignatureHasElementType(System.Reflection.SignatureType elementType);
            /*0x20cbbd8*/ bool get_IsTypeDefinition();
            /*0x20cbbe0*/ bool get_IsGenericTypeDefinition();
            /*0x20cbbe8*/ bool HasElementTypeImpl();
            bool IsArrayImpl();
            bool IsByRefImpl();
            /*0x20cbbf0*/ bool get_IsByRefLike();
            bool IsPointerImpl();
            bool get_IsSZArray();
            bool get_IsVariableBoundArray();
            /*0x20cbbf8*/ bool get_IsConstructedGenericType();
            /*0x20cbc00*/ bool get_IsGenericParameter();
            /*0x20cbc08*/ bool get_IsGenericTypeParameter();
            /*0x20cbc10*/ bool get_IsGenericMethodParameter();
            /*0x20cbc18*/ bool get_ContainsGenericParameters();
            /*0x20cbc3c*/ System.Reflection.SignatureType get_ElementType();
            int GetArrayRank();
            /*0x20cbc44*/ System.Type GetGenericTypeDefinition();
            /*0x20cbc94*/ System.Type[] GetGenericArguments();
            /*0x20cbd10*/ System.Type[] get_GenericTypeArguments();
            /*0x20cbd8c*/ int get_GenericParameterPosition();
            /*0x20cbddc*/ string get_Name();
            /*0x20cbe34*/ string get_Namespace();
            /*0x20cbe58*/ string ToString();
            string get_Suffix();
        }

        class SignaturePointerType : System.Reflection.SignatureHasElementType
        {
            /*0x20cbeac*/ SignaturePointerType(System.Reflection.SignatureType elementType);
            /*0x20cbed0*/ bool IsArrayImpl();
            /*0x20cbed8*/ bool IsByRefImpl();
            /*0x20cbee0*/ bool IsPointerImpl();
            /*0x20cbee8*/ bool get_IsSZArray();
            /*0x20cbef0*/ bool get_IsVariableBoundArray();
            /*0x20cbef8*/ int GetArrayRank();
            /*0x20cbf48*/ string get_Suffix();
        }

        class SignatureType : System.Type
        {
            /*0x20cb4e8*/ SignatureType();
            /*0x20cbf88*/ bool get_IsSignatureType();
            bool get_IsTypeDefinition();
            bool HasElementTypeImpl();
            bool IsArrayImpl();
            bool get_IsSZArray();
            bool get_IsVariableBoundArray();
            bool IsByRefImpl();
            bool get_IsByRefLike();
            bool IsPointerImpl();
            /*0x20cbf90*/ bool get_IsGenericType();
            bool get_IsGenericTypeDefinition();
            bool get_IsConstructedGenericType();
            bool get_IsGenericParameter();
            bool get_IsGenericTypeParameter();
            bool get_IsGenericMethodParameter();
            bool get_ContainsGenericParameters();
            /*0x20cbfd0*/ System.Reflection.MemberTypes get_MemberType();
            /*0x20cbfd8*/ System.Type MakeArrayType();
            /*0x20cc044*/ System.Type MakeArrayType(int rank);
            /*0x20cc0f8*/ System.Type MakeByRefType();
            /*0x20cc158*/ System.Type MakePointerType();
            /*0x20cc1b8*/ System.Type MakeGenericType(System.Type[] typeArguments);
            /*0x20cc208*/ System.Type GetElementType();
            int GetArrayRank();
            System.Type GetGenericTypeDefinition();
            System.Type[] get_GenericTypeArguments();
            System.Type[] GetGenericArguments();
            int get_GenericParameterPosition();
            System.Reflection.SignatureType get_ElementType();
            /*0x20cc218*/ System.Type get_UnderlyingSystemType();
            string get_Name();
            string get_Namespace();
            /*0x20cc21c*/ string get_FullName();
            /*0x20cc224*/ string get_AssemblyQualifiedName();
            string ToString();
            /*0x20cc22c*/ System.Reflection.Assembly get_Assembly();
            /*0x20cc27c*/ System.Reflection.Module get_Module();
            /*0x20cc2cc*/ System.Type get_ReflectedType();
            /*0x20cc31c*/ System.Type get_BaseType();
            /*0x20cc36c*/ System.Type[] GetInterfaces();
            /*0x20cc3bc*/ bool IsAssignableFrom(System.Type c);
            /*0x20cc40c*/ int get_MetadataToken();
            /*0x20cc45c*/ bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other);
            /*0x20cc4ac*/ System.Type get_DeclaringType();
            /*0x20cc4fc*/ System.Reflection.MethodBase get_DeclaringMethod();
            /*0x20cc54c*/ System.Type[] GetGenericParameterConstraints();
            /*0x20cc59c*/ System.Reflection.GenericParameterAttributes get_GenericParameterAttributes();
            /*0x20cc5ec*/ bool IsEnumDefined(object value);
            /*0x20cc63c*/ string GetEnumName(object value);
            /*0x20cc68c*/ string[] GetEnumNames();
            /*0x20cc6dc*/ System.Type GetEnumUnderlyingType();
            /*0x20cc72c*/ System.Array GetEnumValues();
            /*0x20cc77c*/ System.Guid get_GUID();
            /*0x20cc7cc*/ System.TypeCode GetTypeCodeImpl();
            /*0x20cc81c*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
            /*0x20cc86c*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
            /*0x20cc8bc*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x20cc90c*/ System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
            /*0x20cc95c*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x20cc9ac*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
            /*0x20cc9fc*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
            /*0x20cca4c*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
            /*0x20cca9c*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x20ccaec*/ System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
            /*0x20ccb3c*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
            /*0x20ccb8c*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
            /*0x20ccbdc*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20ccc2c*/ System.Reflection.MethodInfo GetMethodImpl(string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20ccc7c*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20ccccc*/ System.Reflection.MemberInfo[] FindMembers(System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);
            /*0x20ccd1c*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x20ccd6c*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
            /*0x20ccdbc*/ System.Reflection.MemberInfo[] GetDefaultMembers();
            /*0x20cce0c*/ System.Reflection.EventInfo[] GetEvents();
            /*0x20cce5c*/ object[] GetCustomAttributes(bool inherit);
            /*0x20cceac*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20ccefc*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20ccf4c*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20ccf9c*/ System.Type GetInterface(string name, bool ignoreCase);
            /*0x20ccfec*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20cd03c*/ bool IsCOMObjectImpl();
            /*0x20cd08c*/ bool IsPrimitiveImpl();
            /*0x20cd0dc*/ System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> get_CustomAttributes();
            /*0x20cd12c*/ System.Type[] FindInterfaces(System.Reflection.TypeFilter filter, object filterCriteria);
            /*0x20cd17c*/ System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType);
            /*0x20cd1cc*/ bool IsContextfulImpl();
            /*0x20cd21c*/ bool get_IsEnum();
            /*0x20cd26c*/ bool IsEquivalentTo(System.Type other);
            /*0x20cd2bc*/ bool IsInstanceOfType(object o);
            /*0x20cd30c*/ bool IsMarshalByRefImpl();
            /*0x20cd35c*/ bool get_IsSecurityCritical();
            /*0x20cd3ac*/ bool get_IsSecuritySafeCritical();
            /*0x20cd3fc*/ bool get_IsSecurityTransparent();
            /*0x20cd44c*/ bool get_IsSerializable();
            /*0x20cd49c*/ bool IsSubclassOf(System.Type c);
            /*0x20cd4ec*/ bool IsValueTypeImpl();
            /*0x20cd53c*/ System.Runtime.InteropServices.StructLayoutAttribute get_StructLayoutAttribute();
            /*0x20cd58c*/ System.RuntimeTypeHandle get_TypeHandle();
        }

        class SignatureTypeExtensions
        {
            static /*0x20cd5dc*/ bool MatchesParameterTypeExactly(System.Type pattern, System.Reflection.ParameterInfo parameter);
            static /*0x20cd694*/ bool MatchesExactly(System.Reflection.SignatureType pattern, System.Type actual);
            static /*0x20cda3c*/ System.Type TryResolveAgainstGenericMethod(System.Reflection.SignatureType signatureType, System.Reflection.MethodInfo genericMethod);
            static /*0x20cda74*/ System.Type TryResolve(System.Reflection.SignatureType signatureType, System.Type[] genericMethodParameters);
            static /*0x20cde30*/ System.Type TryMakeArrayType(System.Type type);
            static /*0x20cdecc*/ System.Type TryMakeArrayType(System.Type type, int rank);
            static /*0x20cdf68*/ System.Type TryMakeByRefType(System.Type type);
            static /*0x20ce004*/ System.Type TryMakePointerType(System.Type type);
            static /*0x20ce0a0*/ System.Type TryMakeGenericType(System.Type type, System.Type[] instantiation);
        }

        class TargetException : System.ApplicationException
        {
            /*0x20ce13c*/ TargetException();
            /*0x20c5494*/ TargetException(string message);
            /*0x20ce168*/ TargetException(string message, System.Exception inner);
            /*0x20ce18c*/ TargetException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class TargetInvocationException : System.ApplicationException
        {
            /*0x20ce194*/ TargetInvocationException(System.Exception inner);
            /*0x20ce200*/ TargetInvocationException(string message, System.Exception inner);
            /*0x20ce224*/ TargetInvocationException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class TargetParameterCountException : System.ApplicationException
        {
            /*0x20ce22c*/ TargetParameterCountException();
            /*0x20ce288*/ TargetParameterCountException(string message);
            /*0x20ce2ac*/ TargetParameterCountException(string message, System.Exception inner);
            /*0x20ce2d0*/ TargetParameterCountException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum TypeAttributes
        {
            VisibilityMask = 7,
            NotPublic = 0,
            Public = 1,
            NestedPublic = 2,
            NestedPrivate = 3,
            NestedFamily = 4,
            NestedAssembly = 5,
            NestedFamANDAssem = 6,
            NestedFamORAssem = 7,
            LayoutMask = 24,
            AutoLayout = 0,
            SequentialLayout = 8,
            ExplicitLayout = 16,
            ClassSemanticsMask = 32,
            Class = 0,
            Interface = 32,
            Abstract = 128,
            Sealed = 256,
            SpecialName = 1024,
            Import = 4096,
            Serializable = 8192,
            WindowsRuntime = 16384,
            StringFormatMask = 196608,
            AnsiClass = 0,
            UnicodeClass = 65536,
            AutoClass = 131072,
            CustomFormatClass = 196608,
            CustomFormatMask = 12582912,
            BeforeFieldInit = 1048576,
            RTSpecialName = 2048,
            HasSecurity = 262144,
            ReservedMask = 264192,
        }

        class TypeDelegator : System.Reflection.TypeInfo
        {
            /*0x18*/ System.Type typeImpl;

            /*0x20ce38c*/ TypeDelegator();
            /*0x20c6c34*/ TypeDelegator(System.Type delegatingType);
            /*0x20ce2d8*/ bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo);
            /*0x20ce3e8*/ System.Guid get_GUID();
            /*0x20ce40c*/ int get_MetadataToken();
            /*0x20ce430*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
            /*0x20ce45c*/ System.Reflection.Module get_Module();
            /*0x20ce480*/ System.Reflection.Assembly get_Assembly();
            /*0x20ce4a4*/ System.RuntimeTypeHandle get_TypeHandle();
            /*0x20ce4c8*/ string get_Name();
            /*0x20ce4ec*/ string get_FullName();
            /*0x20ce510*/ string get_Namespace();
            /*0x20ce534*/ string get_AssemblyQualifiedName();
            /*0x20ce558*/ System.Type get_BaseType();
            /*0x20ce57c*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20ce598*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
            /*0x20ce5bc*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20ce5e8*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
            /*0x20ce60c*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x20ce630*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
            /*0x20ce654*/ System.Type GetInterface(string name, bool ignoreCase);
            /*0x20ce67c*/ System.Type[] GetInterfaces();
            /*0x20ce6a0*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x20ce6c4*/ System.Reflection.EventInfo[] GetEvents();
            /*0x20ce6e8*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20ce7d8*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
            /*0x20ce7fc*/ System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
            /*0x20ce820*/ System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
            /*0x20ce844*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x20ce868*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
            /*0x20ce88c*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
            /*0x20ce8b0*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
            /*0x20ce8cc*/ bool get_IsTypeDefinition();
            /*0x20ce8f0*/ bool get_IsSZArray();
            /*0x20ce914*/ bool IsArrayImpl();
            /*0x20ce930*/ bool IsPrimitiveImpl();
            /*0x20ce94c*/ bool IsByRefImpl();
            /*0x20ce968*/ bool get_IsGenericTypeParameter();
            /*0x20ce98c*/ bool get_IsGenericMethodParameter();
            /*0x20ce9b0*/ bool IsPointerImpl();
            /*0x20ce9cc*/ bool IsValueTypeImpl();
            /*0x20ce9e8*/ bool IsCOMObjectImpl();
            /*0x20cea04*/ bool get_IsByRefLike();
            /*0x20cea28*/ bool get_IsConstructedGenericType();
            /*0x20cea4c*/ bool get_IsCollectible();
            /*0x20cea70*/ System.Type GetElementType();
            /*0x20cea94*/ bool HasElementTypeImpl();
            /*0x20ceab0*/ System.Type get_UnderlyingSystemType();
            /*0x20cead4*/ object[] GetCustomAttributes(bool inherit);
            /*0x20ceafc*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20ceb24*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20ceb4c*/ System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType);
        }

        class TypeFilter : System.MulticastDelegate
        {
            /*0x20c9768*/ TypeFilter(object object, nint method);
            /*0x20ceb8c*/ bool Invoke(System.Type m, object filterCriteria);
            /*0x20ceba0*/ System.IAsyncResult BeginInvoke(System.Type m, object filterCriteria, System.AsyncCallback callback, object object);
            /*0x20cebc8*/ bool EndInvoke(System.IAsyncResult result);
        }

        class TypeInfo : System.Type, System.Reflection.IReflectableType
        {
            static System.Reflection.BindingFlags DeclaredOnlyLookup = 62;

            /*0x20ce390*/ TypeInfo();
            /*0x20cebf0*/ System.Reflection.TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
            /*0x20cebf4*/ System.Type AsType();
            /*0x20cebf8*/ System.Type[] get_GenericTypeParameters();
            /*0x20cec88*/ System.Reflection.EventInfo GetDeclaredEvent(string name);
            /*0x20cec9c*/ System.Reflection.FieldInfo GetDeclaredField(string name);
            /*0x20cecb0*/ System.Reflection.MethodInfo GetDeclaredMethod(string name);
            /*0x20cecbc*/ System.Reflection.TypeInfo GetDeclaredNestedType(string name);
            /*0x20cece8*/ System.Reflection.PropertyInfo GetDeclaredProperty(string name);
            /*0x20cecf4*/ System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> GetDeclaredMethods(string name);
            /*0x20cedb0*/ System.Collections.Generic.IEnumerable<System.Reflection.ConstructorInfo> get_DeclaredConstructors();
            /*0x20cedc4*/ System.Collections.Generic.IEnumerable<System.Reflection.EventInfo> get_DeclaredEvents();
            /*0x20cedd8*/ System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo> get_DeclaredFields();
            /*0x20cedec*/ System.Collections.Generic.IEnumerable<System.Reflection.MemberInfo> get_DeclaredMembers();
            /*0x20cee00*/ System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> get_DeclaredMethods();
            /*0x20cee14*/ System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo> get_DeclaredNestedTypes();
            /*0x20ceec0*/ System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> get_DeclaredProperties();
            /*0x20ceed4*/ System.Collections.Generic.IEnumerable<System.Type> get_ImplementedInterfaces();
            /*0x20ceee4*/ bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo);

            class <GetDeclaredMethods>d__10 : System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Reflection.MethodInfo>, System.IDisposable, System.Collections.IEnumerator
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Reflection.MethodInfo <>2__current;
                /*0x20*/ int <>l__initialThreadId;
                /*0x28*/ System.Reflection.TypeInfo <>4__this;
                /*0x30*/ string name;
                /*0x38*/ string <>3__name;
                /*0x40*/ System.Reflection.MethodInfo[] <>7__wrap1;
                /*0x48*/ int <>7__wrap2;

                /*0x20ced7c*/ <GetDeclaredMethods>d__10(int <>1__state);
                /*0x20cf060*/ void System.IDisposable.Dispose();
                /*0x20cf064*/ bool MoveNext();
                /*0x20cf14c*/ System.Reflection.MethodInfo System.Collections.Generic.IEnumerator<System.Reflection.MethodInfo>.get_Current();
                /*0x20cf154*/ void System.Collections.IEnumerator.Reset();
                /*0x20cf194*/ object System.Collections.IEnumerator.get_Current();
                /*0x20cf19c*/ System.Collections.Generic.IEnumerator<System.Reflection.MethodInfo> System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo>.GetEnumerator();
                /*0x20cf248*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            }

            class <get_DeclaredNestedTypes>d__22 : System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Reflection.TypeInfo>, System.IDisposable, System.Collections.IEnumerator
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Reflection.TypeInfo <>2__current;
                /*0x20*/ int <>l__initialThreadId;
                /*0x28*/ System.Reflection.TypeInfo <>4__this;
                /*0x30*/ System.Type[] <>7__wrap1;
                /*0x38*/ int <>7__wrap2;

                /*0x20cee8c*/ <get_DeclaredNestedTypes>d__22(int <>1__state);
                /*0x20cf24c*/ void System.IDisposable.Dispose();
                /*0x20cf250*/ bool MoveNext();
                /*0x20cf308*/ System.Reflection.TypeInfo System.Collections.Generic.IEnumerator<System.Reflection.TypeInfo>.get_Current();
                /*0x20cf310*/ void System.Collections.IEnumerator.Reset();
                /*0x20cf350*/ object System.Collections.IEnumerator.get_Current();
                /*0x20cf358*/ System.Collections.Generic.IEnumerator<System.Reflection.TypeInfo> System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>.GetEnumerator();
                /*0x20cf3fc*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            }
        }

        class Requires
        {
            static /*0x20cf400*/ void NotNull(object obj, string name);
        }

        class TypeExtensions
        {
            static /*0x20cf454*/ System.Reflection.ConstructorInfo GetConstructor(System.Type type, System.Type[] types);
            static /*0x20cf4c0*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Type type);
            static /*0x20cf51c*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Type type, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cf590*/ System.Reflection.MemberInfo[] GetDefaultMembers(System.Type type);
            static /*0x20cf5f4*/ System.Reflection.EventInfo GetEvent(System.Type type, string name);
            static /*0x20cf660*/ System.Reflection.EventInfo GetEvent(System.Type type, string name, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cf6dc*/ System.Reflection.EventInfo[] GetEvents(System.Type type);
            static /*0x20cf740*/ System.Reflection.EventInfo[] GetEvents(System.Type type, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cf7b4*/ System.Reflection.FieldInfo GetField(System.Type type, string name);
            static /*0x20cf820*/ System.Reflection.FieldInfo GetField(System.Type type, string name, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cf89c*/ System.Reflection.FieldInfo[] GetFields(System.Type type);
            static /*0x20cf8f8*/ System.Reflection.FieldInfo[] GetFields(System.Type type, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cf96c*/ System.Type[] GetGenericArguments(System.Type type);
            static /*0x20cf9d0*/ System.Type[] GetInterfaces(System.Type type);
            static /*0x20cfa34*/ System.Reflection.MemberInfo[] GetMember(System.Type type, string name);
            static /*0x20cfaa0*/ System.Reflection.MemberInfo[] GetMember(System.Type type, string name, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cfb1c*/ System.Reflection.MemberInfo[] GetMembers(System.Type type);
            static /*0x20cfb78*/ System.Reflection.MemberInfo[] GetMembers(System.Type type, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cfbec*/ System.Reflection.MethodInfo GetMethod(System.Type type, string name);
            static /*0x20cfc58*/ System.Reflection.MethodInfo GetMethod(System.Type type, string name, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cfccc*/ System.Reflection.MethodInfo GetMethod(System.Type type, string name, System.Type[] types);
            static /*0x20cfd40*/ System.Reflection.MethodInfo[] GetMethods(System.Type type);
            static /*0x20cfd9c*/ System.Reflection.MethodInfo[] GetMethods(System.Type type, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cfe10*/ System.Type GetNestedType(System.Type type, string name, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cfe8c*/ System.Type[] GetNestedTypes(System.Type type, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cff00*/ System.Reflection.PropertyInfo[] GetProperties(System.Type type);
            static /*0x20cff5c*/ System.Reflection.PropertyInfo[] GetProperties(System.Type type, System.Reflection.BindingFlags bindingAttr);
            static /*0x20cffd0*/ System.Reflection.PropertyInfo GetProperty(System.Type type, string name);
            static /*0x20d003c*/ System.Reflection.PropertyInfo GetProperty(System.Type type, string name, System.Reflection.BindingFlags bindingAttr);
            static /*0x20d00b0*/ System.Reflection.PropertyInfo GetProperty(System.Type type, string name, System.Type returnType);
            static /*0x20d0124*/ System.Reflection.PropertyInfo GetProperty(System.Type type, string name, System.Type returnType, System.Type[] types);
            static /*0x20d01a8*/ bool IsAssignableFrom(System.Type type, System.Type c);
            static /*0x20d021c*/ bool IsInstanceOfType(System.Type type, object o);
        }

        class AssemblyExtensions
        {
            static /*0x20d0290*/ System.Type[] GetExportedTypes(System.Reflection.Assembly assembly);
            static /*0x20d02f4*/ System.Reflection.Module[] GetModules(System.Reflection.Assembly assembly);
            static /*0x20d0370*/ System.Type[] GetTypes(System.Reflection.Assembly assembly);
        }

        class EventInfoExtensions
        {
            static /*0x20d03d4*/ System.Reflection.MethodInfo GetAddMethod(System.Reflection.EventInfo eventInfo);
            static /*0x20d043c*/ System.Reflection.MethodInfo GetAddMethod(System.Reflection.EventInfo eventInfo, bool nonPublic);
            static /*0x20d04b0*/ System.Reflection.MethodInfo GetRaiseMethod(System.Reflection.EventInfo eventInfo);
            static /*0x20d0518*/ System.Reflection.MethodInfo GetRaiseMethod(System.Reflection.EventInfo eventInfo, bool nonPublic);
            static /*0x20d058c*/ System.Reflection.MethodInfo GetRemoveMethod(System.Reflection.EventInfo eventInfo);
            static /*0x20d05f4*/ System.Reflection.MethodInfo GetRemoveMethod(System.Reflection.EventInfo eventInfo, bool nonPublic);
        }

        class MemberInfoExtensions
        {
            static /*0x20d0668*/ bool HasMetadataToken(System.Reflection.MemberInfo member);
            static /*0x20d0778*/ int GetMetadataToken(System.Reflection.MemberInfo member);
            static /*0x20d074c*/ int GetMetadataTokenOrZeroOrThrow(System.Reflection.MemberInfo member);
        }

        class MethodInfoExtensions
        {
            static /*0x20d0834*/ System.Reflection.MethodInfo GetBaseDefinition(System.Reflection.MethodInfo method);
        }

        class ModuleExtensions
        {
            static /*0x20d0898*/ bool HasModuleVersionId(System.Reflection.Module module);
            static /*0x20d08e8*/ System.Guid GetModuleVersionId(System.Reflection.Module module);
        }

        class PropertyInfoExtensions
        {
            static /*0x20d094c*/ System.Reflection.MethodInfo[] GetAccessors(System.Reflection.PropertyInfo property);
            static /*0x20d09b4*/ System.Reflection.MethodInfo[] GetAccessors(System.Reflection.PropertyInfo property, bool nonPublic);
            static /*0x20d0a28*/ System.Reflection.MethodInfo GetGetMethod(System.Reflection.PropertyInfo property);
            static /*0x20d0a90*/ System.Reflection.MethodInfo GetGetMethod(System.Reflection.PropertyInfo property, bool nonPublic);
            static /*0x20d0b04*/ System.Reflection.MethodInfo GetSetMethod(System.Reflection.PropertyInfo property);
            static /*0x20d0b6c*/ System.Reflection.MethodInfo GetSetMethod(System.Reflection.PropertyInfo property, bool nonPublic);
        }

        class AssemblyNameProxy : System.MarshalByRefObject
        {
            /*0x20d0dbc*/ AssemblyNameProxy();
            /*0x20d0be0*/ System.Reflection.AssemblyName GetAssemblyName(string assemblyFile);
        }

        class RuntimeReflectionExtensions
        {
            static System.Reflection.BindingFlags Everything = 60;

            static /*0x20d0dc4*/ System.Collections.Generic.IEnumerable<System.Reflection.FieldInfo> GetRuntimeFields(System.Type type);
            static /*0x20d0e90*/ System.Collections.Generic.IEnumerable<System.Reflection.MethodInfo> GetRuntimeMethods(System.Type type);
            static /*0x20d0f5c*/ System.Collections.Generic.IEnumerable<System.Reflection.PropertyInfo> GetRuntimeProperties(System.Type type);
            static /*0x20d1028*/ System.Collections.Generic.IEnumerable<System.Reflection.EventInfo> GetRuntimeEvents(System.Type type);
            static /*0x20d10f4*/ System.Reflection.FieldInfo GetRuntimeField(System.Type type, string name);
            static /*0x20d11c4*/ System.Reflection.MethodInfo GetRuntimeMethod(System.Type type, string name, System.Type[] parameters);
            static /*0x20d129c*/ System.Reflection.PropertyInfo GetRuntimeProperty(System.Type type, string name);
            static /*0x20d136c*/ System.Reflection.EventInfo GetRuntimeEvent(System.Type type, string name);
            static /*0x20d143c*/ System.Reflection.MethodInfo GetRuntimeBaseDefinition(System.Reflection.MethodInfo method);
            static /*0x20d14a4*/ System.Reflection.InterfaceMapping GetRuntimeInterfaceMap(System.Reflection.TypeInfo typeInfo, System.Type interfaceType);
            static /*0x20d1598*/ System.Reflection.MethodInfo GetMethodInfo(System.Delegate del);
        }

        struct CustomAttributeNamedArgument
        {
            /*0x10*/ System.Reflection.CustomAttributeTypedArgument <TypedValue>k__BackingField;
            /*0x20*/ bool <IsField>k__BackingField;
            /*0x28*/ string <MemberName>k__BackingField;
            /*0x30*/ System.Type _attributeType;
            /*0x38*/ System.Reflection.MemberInfo _lazyMemberInfo;

            static /*0x20d1b94*/ bool op_Equality(System.Reflection.CustomAttributeNamedArgument left, System.Reflection.CustomAttributeNamedArgument right);
            static /*0x20d1c14*/ bool op_Inequality(System.Reflection.CustomAttributeNamedArgument left, System.Reflection.CustomAttributeNamedArgument right);
            /*0x20d15f4*/ CustomAttributeNamedArgument(System.Type attributeType, string memberName, bool isField, System.Reflection.CustomAttributeTypedArgument typedValue);
            /*0x20d161c*/ CustomAttributeNamedArgument(System.Reflection.MemberInfo memberInfo, object value);
            /*0x20d1850*/ CustomAttributeNamedArgument(System.Reflection.MemberInfo memberInfo, System.Reflection.CustomAttributeTypedArgument typedArgument);
            /*0x20d197c*/ System.Reflection.CustomAttributeTypedArgument get_TypedValue();
            /*0x20d1988*/ bool get_IsField();
            /*0x20d1990*/ string get_MemberName();
            /*0x20d1998*/ System.Reflection.MemberInfo get_MemberInfo();
            /*0x20d1ab0*/ bool Equals(object obj);
            /*0x20d1b28*/ int GetHashCode();
            /*0x20d1c98*/ string ToString();
        }

        struct CustomAttributeTypedArgument
        {
            /*0x10*/ System.Type <ArgumentType>k__BackingField;
            /*0x18*/ object <Value>k__BackingField;

            static /*0x20d2b40*/ bool op_Equality(System.Reflection.CustomAttributeTypedArgument left, System.Reflection.CustomAttributeTypedArgument right);
            static /*0x20d2bb8*/ bool op_Inequality(System.Reflection.CustomAttributeTypedArgument left, System.Reflection.CustomAttributeTypedArgument right);
            static /*0x20d29a4*/ object CanonicalizeValue(object value);
            /*0x20d291c*/ CustomAttributeTypedArgument(object value);
            /*0x20c66c4*/ CustomAttributeTypedArgument(System.Type argumentType, object value);
            /*0x20d2a5c*/ System.Type get_ArgumentType();
            /*0x20d2a64*/ object get_Value();
            /*0x20d2a6c*/ bool Equals(object obj);
            /*0x20d2adc*/ int GetHashCode();
            /*0x20d2c34*/ string ToString();
            /*0x20d2024*/ string ToString(bool typed);
        }

        class MissingMetadataException : System.TypeAccessException
        {
            /*0x20d2c3c*/ MissingMetadataException();
            /*0x20d2c44*/ MissingMetadataException(string message);
        }

        class CustomAttributeExtensions
        {
            static /*0x20d2c4c*/ System.Attribute GetCustomAttribute(System.Reflection.Assembly element, System.Type attributeType);
            static /*0x20d2c54*/ System.Attribute GetCustomAttribute(System.Reflection.Module element, System.Type attributeType);
            static /*0x20d2c5c*/ System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType);
            static /*0x20d2c64*/ System.Attribute GetCustomAttribute(System.Reflection.ParameterInfo element, System.Type attributeType);
            static T GetCustomAttribute<T>(System.Reflection.Assembly element);
            static T GetCustomAttribute<T>(System.Reflection.Module element);
            static T GetCustomAttribute<T>(System.Reflection.MemberInfo element);
            static T GetCustomAttribute<T>(System.Reflection.ParameterInfo element);
            static /*0x20d2c6c*/ System.Attribute GetCustomAttribute(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit);
            static /*0x20d2c78*/ System.Attribute GetCustomAttribute(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit);
            static T GetCustomAttribute<T>(System.Reflection.MemberInfo element, bool inherit);
            static T GetCustomAttribute<T>(System.Reflection.ParameterInfo element, bool inherit);
            static /*0x20d2c84*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.Assembly element);
            static /*0x20d2c8c*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.Module element);
            static /*0x20d2c94*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.MemberInfo element);
            static /*0x20d2c9c*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.ParameterInfo element);
            static /*0x20d2ca4*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.MemberInfo element, bool inherit);
            static /*0x20d2cb0*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.ParameterInfo element, bool inherit);
            static /*0x20d2cbc*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.Assembly element, System.Type attributeType);
            static /*0x20d2cc4*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.Module element, System.Type attributeType);
            static /*0x20d2ccc*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.MemberInfo element, System.Type attributeType);
            static /*0x20d2cd4*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.ParameterInfo element, System.Type attributeType);
            static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(System.Reflection.Assembly element);
            static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(System.Reflection.Module element);
            static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(System.Reflection.MemberInfo element);
            static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(System.Reflection.ParameterInfo element);
            static /*0x20d2cdc*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit);
            static /*0x20d2ce8*/ System.Collections.Generic.IEnumerable<System.Attribute> GetCustomAttributes(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit);
            static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(System.Reflection.MemberInfo element, bool inherit);
            static System.Collections.Generic.IEnumerable<T> GetCustomAttributes<T>(System.Reflection.ParameterInfo element, bool inherit);
            static /*0x20d2cf4*/ bool IsDefined(System.Reflection.Assembly element, System.Type attributeType);
            static /*0x20d2cfc*/ bool IsDefined(System.Reflection.Module element, System.Type attributeType);
            static /*0x20d2d04*/ bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType);
            static /*0x20d2d0c*/ bool IsDefined(System.Reflection.ParameterInfo element, System.Type attributeType);
            static /*0x20d2d14*/ bool IsDefined(System.Reflection.MemberInfo element, System.Type attributeType, bool inherit);
            static /*0x20d2d20*/ bool IsDefined(System.Reflection.ParameterInfo element, System.Type attributeType, bool inherit);
        }

        enum CorElementType
        {
            End = 0,
            Void = 1,
            Boolean = 2,
            Char = 3,
            I1 = 4,
            U1 = 5,
            I2 = 6,
            U2 = 7,
            I4 = 8,
            U4 = 9,
            I8 = 10,
            U8 = 11,
            R4 = 12,
            R8 = 13,
            String = 14,
            Ptr = 15,
            ByRef = 16,
            ValueType = 17,
            Class = 18,
            Var = 19,
            Array = 20,
            GenericInst = 21,
            TypedByRef = 22,
            I = 24,
            U = 25,
            FnPtr = 27,
            Object = 28,
            SzArray = 29,
            MVar = 30,
            CModReqd = 31,
            CModOpt = 32,
            Internal = 33,
            Max = 34,
            Modifier = 64,
            Sentinel = 65,
            Pinned = 69,
            ELEMENT_TYPE_END = 0,
            ELEMENT_TYPE_VOID = 1,
            ELEMENT_TYPE_BOOLEAN = 2,
            ELEMENT_TYPE_CHAR = 3,
            ELEMENT_TYPE_I1 = 4,
            ELEMENT_TYPE_U1 = 5,
            ELEMENT_TYPE_I2 = 6,
            ELEMENT_TYPE_U2 = 7,
            ELEMENT_TYPE_I4 = 8,
            ELEMENT_TYPE_U4 = 9,
            ELEMENT_TYPE_I8 = 10,
            ELEMENT_TYPE_U8 = 11,
            ELEMENT_TYPE_R4 = 12,
            ELEMENT_TYPE_R8 = 13,
            ELEMENT_TYPE_STRING = 14,
            ELEMENT_TYPE_PTR = 15,
            ELEMENT_TYPE_BYREF = 16,
            ELEMENT_TYPE_VALUETYPE = 17,
            ELEMENT_TYPE_CLASS = 18,
            ELEMENT_TYPE_VAR = 19,
            ELEMENT_TYPE_ARRAY = 20,
            ELEMENT_TYPE_GENERICINST = 21,
            ELEMENT_TYPE_TYPEDBYREF = 22,
            ELEMENT_TYPE_I = 24,
            ELEMENT_TYPE_U = 25,
            ELEMENT_TYPE_FNPTR = 27,
            ELEMENT_TYPE_OBJECT = 28,
            ELEMENT_TYPE_SZARRAY = 29,
            ELEMENT_TYPE_MVAR = 30,
            ELEMENT_TYPE_CMOD_REQD = 31,
            ELEMENT_TYPE_CMOD_OPT = 32,
            ELEMENT_TYPE_INTERNAL = 33,
            ELEMENT_TYPE_MAX = 34,
            ELEMENT_TYPE_MODIFIER = 64,
            ELEMENT_TYPE_SENTINEL = 65,
            ELEMENT_TYPE_PINNED = 69,
        }

        enum MdSigCallingConvention
        {
            CallConvMask = 15,
            Default = 0,
            C = 1,
            StdCall = 2,
            ThisCall = 3,
            FastCall = 4,
            Vararg = 5,
            Field = 6,
            LocalSig = 7,
            Property = 8,
            Unmgd = 9,
            GenericInst = 10,
            Generic = 16,
            HasThis = 32,
            ExplicitThis = 64,
        }

        enum PInvokeAttributes
        {
            NoMangle = 1,
            CharSetMask = 6,
            CharSetNotSpec = 0,
            CharSetAnsi = 2,
            CharSetUnicode = 4,
            CharSetAuto = 6,
            BestFitUseAssem = 0,
            BestFitEnabled = 16,
            BestFitDisabled = 32,
            BestFitMask = 48,
            ThrowOnUnmappableCharUseAssem = 0,
            ThrowOnUnmappableCharEnabled = 4096,
            ThrowOnUnmappableCharDisabled = 8192,
            ThrowOnUnmappableCharMask = 12288,
            SupportsLastError = 64,
            CallConvMask = 1792,
            CallConvWinapi = 256,
            CallConvCdecl = 512,
            CallConvStdcall = 768,
            CallConvThiscall = 1024,
            CallConvFastcall = 1280,
            MaxValue = 65535,
        }

        enum MethodSemanticsAttributes
        {
            Setter = 1,
            Getter = 2,
            Other = 4,
            AddOn = 8,
            RemoveOn = 16,
            Fire = 32,
        }

        enum MetadataTokenType
        {
            Module = 0,
            TypeRef = 16777216,
            TypeDef = 33554432,
            FieldDef = 67108864,
            MethodDef = 100663296,
            ParamDef = 134217728,
            InterfaceImpl = 150994944,
            MemberRef = 167772160,
            CustomAttribute = 201326592,
            Permission = 234881024,
            Signature = 285212672,
            Event = 335544320,
            Property = 385875968,
            ModuleRef = 436207616,
            TypeSpec = 452984832,
            Assembly = 536870912,
            AssemblyRef = 587202560,
            File = 637534208,
            ExportedType = 654311424,
            ManifestResource = 671088640,
            GenericPar = 704643072,
            MethodSpec = 721420288,
            String = 1879048192,
            Name = 1895825408,
            BaseType = 1912602624,
            Invalid = 2147483647,
        }

        class MemberInfoSerializationHolder : System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IObjectReference
        {
            /*0x10*/ string m_memberName;
            /*0x18*/ System.RuntimeType m_reflectedType;
            /*0x20*/ string m_signature;
            /*0x28*/ string m_signature2;
            /*0x30*/ System.Reflection.MemberTypes m_memberType;
            /*0x38*/ System.Runtime.Serialization.SerializationInfo m_info;

            static /*0x20d2d2c*/ void GetSerializationInfo(System.Runtime.Serialization.SerializationInfo info, string name, System.RuntimeType reflectedClass, string signature, System.Reflection.MemberTypes type);
            static /*0x20d2d3c*/ void GetSerializationInfo(System.Runtime.Serialization.SerializationInfo info, string name, System.RuntimeType reflectedClass, string signature, string signature2, System.Reflection.MemberTypes type, System.Type[] genericArguments);
            /*0x20d3054*/ MemberInfoSerializationHolder(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20d3378*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20d33d8*/ object GetRealObject(System.Runtime.Serialization.StreamingContext context);
        }

        class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.Serialization.ISerializable, System.Runtime.InteropServices._Assembly, System.Security.IEvidenceFactory
        {
            static /*0x20d43d4*/ void InternalGetAssemblyName(string assemblyFile, ref Mono.MonoAssemblyName aname, ref string codebase);
            static /*0x20d4434*/ string CreateQualifiedName(string assemblyName, string typeName);
            static /*0x20d4490*/ System.Reflection.Assembly GetAssembly(System.Type type);
            static /*0x20d4558*/ System.Reflection.Assembly GetEntryAssembly();
            static /*0x20d4b14*/ System.Reflection.Assembly LoadFrom(string assemblyFile, bool refOnly, ref System.Threading.StackCrawlMark stackMark);
            static /*0x20d4b1c*/ System.Reflection.Assembly LoadFile_internal(string assemblyFile, ref System.Threading.StackCrawlMark stackMark);
            static /*0x20d4b20*/ System.Reflection.Assembly LoadFrom(string assemblyFile);
            static /*0x20d4b40*/ System.Reflection.Assembly LoadFrom(string assemblyFile, System.Security.Policy.Evidence securityEvidence);
            static /*0x20d4b60*/ System.Reflection.Assembly LoadFrom(string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
            static /*0x20d4ba0*/ System.Reflection.Assembly LoadFrom(string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);
            static /*0x20d4be0*/ System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile);
            static /*0x20d4c00*/ System.Reflection.Assembly LoadFile(string path, System.Security.Policy.Evidence securityEvidence);
            static /*0x20d4d5c*/ System.Reflection.Assembly LoadFile(string path);
            static /*0x20d4d64*/ System.Reflection.Assembly Load(string assemblyString);
            static /*0x20d4d8c*/ System.Reflection.Assembly Load(string assemblyString, System.Security.Policy.Evidence assemblySecurity);
            static /*0x20d4dc4*/ System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef);
            static /*0x20d4dec*/ System.Reflection.Assembly Load(System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);
            static /*0x20d4e24*/ System.Reflection.Assembly Load(byte[] rawAssembly);
            static /*0x20d4e4c*/ System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore);
            static /*0x20d4e84*/ System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);
            static /*0x20d4ec4*/ System.Reflection.Assembly Load(byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);
            static /*0x20d4efc*/ System.Reflection.Assembly ReflectionOnlyLoad(byte[] rawAssembly);
            static /*0x20d4f30*/ System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString);
            static /*0x20d4f78*/ System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile);
            static /*0x20d4ff4*/ System.Reflection.Assembly LoadWithPartialName(string partialName);
            static /*0x20d5088*/ System.Reflection.Assembly load_with_partial_name(string name, System.Security.Policy.Evidence e);
            static /*0x20d5000*/ System.Reflection.Assembly LoadWithPartialName(string partialName, System.Security.Policy.Evidence securityEvidence);
            static /*0x20d508c*/ System.Reflection.Assembly LoadWithPartialName(string partialName, System.Security.Policy.Evidence securityEvidence, bool oldBehavior);
            static /*0x20d5470*/ System.Reflection.Assembly GetExecutingAssembly();
            static /*0x20d54b0*/ System.Reflection.Assembly GetCallingAssembly();
            static /*0x20d54b4*/ nint InternalGetReferencedAssemblies(System.Reflection.Assembly module);
            static /*0x20d54f8*/ System.Reflection.AssemblyName[] GetReferencedAssemblies(System.Reflection.Assembly module);
            static /*0x20d5b74*/ System.Exception CreateNIE();
            static /*0x20d5d7c*/ bool op_Equality(System.Reflection.Assembly left, System.Reflection.Assembly right);
            static /*0x20d4abc*/ bool op_Inequality(System.Reflection.Assembly left, System.Reflection.Assembly right);
            /*0x20d5eec*/ Assembly();
            /*0x20d3be0*/ void add_ModuleResolve(System.Reflection.ModuleResolveEventHandler value);
            /*0x20d3c20*/ void remove_ModuleResolve(System.Reflection.ModuleResolveEventHandler value);
            /*0x20d3c60*/ string get_CodeBase();
            /*0x20d3ca0*/ string get_EscapedCodeBase();
            /*0x20d3ce0*/ string get_FullName();
            /*0x20d3d20*/ System.Reflection.MethodInfo get_EntryPoint();
            /*0x20d3d60*/ System.Security.Policy.Evidence get_Evidence();
            /*0x20d3da0*/ System.Security.Policy.Evidence UnprotectedGetEvidence();
            /*0x20d3de0*/ nint get_MonoAssembly();
            /*0x20d3e20*/ void set_FromByteArray(bool value);
            /*0x20d3e60*/ string get_Location();
            /*0x20d3ea0*/ string get_ImageRuntimeVersion();
            /*0x20d3ee0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20d3f20*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20d3f60*/ object[] GetCustomAttributes(bool inherit);
            /*0x20d3fa0*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20d3fe0*/ System.IO.FileStream[] GetFiles();
            /*0x20d3ff4*/ System.IO.FileStream[] GetFiles(bool getResourceModules);
            /*0x20d4034*/ System.IO.FileStream GetFile(string name);
            /*0x20d4074*/ System.IO.Stream GetManifestResourceStream(string name);
            /*0x20d40b4*/ System.IO.Stream GetManifestResourceStream(System.Type type, string name);
            /*0x20d40f4*/ System.IO.Stream GetManifestResourceStream(System.Type type, string name, bool skipSecurityCheck, ref System.Threading.StackCrawlMark stackMark);
            /*0x20d427c*/ System.IO.Stream GetManifestResourceStream(string name, ref System.Threading.StackCrawlMark stackMark, bool skipSecurityCheck);
            /*0x20d428c*/ string GetSimpleName();
            /*0x20d42b8*/ byte[] GetPublicKey();
            /*0x20d42e4*/ System.Version GetVersion();
            /*0x20d4310*/ System.Reflection.AssemblyNameFlags GetFlags();
            /*0x20d433c*/ System.Type[] GetTypes(bool exportedOnly);
            /*0x20d4344*/ System.Type[] GetTypes();
            /*0x20d4358*/ System.Type[] GetExportedTypes();
            /*0x20d4398*/ System.Type GetType(string name, bool throwOnError);
            /*0x20d43b0*/ System.Type GetType(string name);
            /*0x20d43c8*/ System.Type InternalGetType(System.Reflection.Module module, string name, bool throwOnError, bool ignoreCase);
            /*0x20d43d8*/ System.Reflection.AssemblyName GetName(bool copiedName);
            /*0x20d4418*/ System.Reflection.AssemblyName GetName();
            /*0x20d442c*/ string ToString();
            /*0x20d455c*/ System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture, System.Version version, bool throwOnError, ref System.Threading.StackCrawlMark stackMark);
            /*0x20d4648*/ System.Reflection.RuntimeAssembly InternalGetSatelliteAssembly(string name, System.Globalization.CultureInfo culture, System.Version version, bool throwOnFileNotFound, ref System.Threading.StackCrawlMark stackMark);
            /*0x20d5008*/ System.Reflection.Module LoadModule(string moduleName, byte[] rawModule);
            /*0x20d5048*/ System.Reflection.Module LoadModule(string moduleName, byte[] rawModule, byte[] rawSymbolStore);
            /*0x20d5104*/ object CreateInstance(string typeName);
            /*0x20d510c*/ object CreateInstance(string typeName, bool ignoreCase);
            /*0x20d5274*/ object CreateInstance(string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);
            /*0x20d541c*/ System.Reflection.Module[] GetLoadedModules();
            /*0x20d035c*/ System.Reflection.Module[] GetModules();
            /*0x20d5430*/ System.Reflection.Module[] GetModulesInternal();
            /*0x20d54b8*/ string[] GetManifestResourceNames();
            /*0x20d5a78*/ System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName);
            /*0x20d5ab8*/ long get_HostContext();
            /*0x20d5ac0*/ System.Reflection.Module GetManifestModule();
            /*0x20d5b00*/ bool get_ReflectionOnly();
            /*0x20d5b40*/ int GetHashCode();
            /*0x20d5b48*/ bool Equals(object o);
            /*0x20d5b50*/ System.Security.SecurityRuleSet get_SecurityRuleSet();
            /*0x20d5be8*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20d5c28*/ bool get_IsFullyTrusted();
            /*0x20d5c30*/ System.Type GetType(string name, bool throwOnError, bool ignoreCase);
            /*0x20d5c54*/ System.Reflection.Module GetModule(string name);
            /*0x20d5c78*/ System.Reflection.AssemblyName[] GetReferencedAssemblies();
            /*0x20d5c9c*/ System.Reflection.Module[] GetModules(bool getResourceModules);
            /*0x20d5cc0*/ System.Reflection.Module[] GetLoadedModules(bool getResourceModules);
            /*0x20d5ce4*/ System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture);
            /*0x20d5d08*/ System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture, System.Version version);
            /*0x20d5d2c*/ System.Reflection.Module get_ManifestModule();
            /*0x20d5d50*/ bool get_GlobalAssemblyCache();
            /*0x20d5d74*/ bool get_IsDynamic();
            /*0x20d5dcc*/ System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo> get_DefinedTypes();
            /*0x20d5e78*/ System.Collections.Generic.IEnumerable<System.Type> get_ExportedTypes();
            /*0x20d5e88*/ System.Collections.Generic.IEnumerable<System.Reflection.Module> get_Modules();
            /*0x20d5e9c*/ System.Collections.Generic.IEnumerable<System.Reflection.CustomAttributeData> get_CustomAttributes();
            /*0x20d5eac*/ System.Type[] GetForwardedTypes();
            /*0x20d5ef4*/ System.Security.PermissionSet get_PermissionSet();
            /*0x20d5f2c*/ System.Type System.Runtime.InteropServices._Assembly.GetType();

            class ResolveEventHolder
            {
                /*0x10*/ System.Reflection.ModuleResolveEventHandler ModuleResolve;

                /*0x20d609c*/ ResolveEventHolder();
                /*0x20d5f64*/ void add_ModuleResolve(System.Reflection.ModuleResolveEventHandler value);
                /*0x20d6000*/ void remove_ModuleResolve(System.Reflection.ModuleResolveEventHandler value);
            }

            class <get_DefinedTypes>d__120 : System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Reflection.TypeInfo>, System.IDisposable, System.Collections.IEnumerator
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Reflection.TypeInfo <>2__current;
                /*0x20*/ int <>l__initialThreadId;
                /*0x28*/ System.Reflection.Assembly <>4__this;
                /*0x30*/ System.Type[] <>7__wrap1;
                /*0x38*/ int <>7__wrap2;

                /*0x20d5e44*/ <get_DefinedTypes>d__120(int <>1__state);
                /*0x20d60a4*/ void System.IDisposable.Dispose();
                /*0x20d60a8*/ bool MoveNext();
                /*0x20d615c*/ System.Reflection.TypeInfo System.Collections.Generic.IEnumerator<System.Reflection.TypeInfo>.get_Current();
                /*0x20d6164*/ void System.Collections.IEnumerator.Reset();
                /*0x20d61a4*/ object System.Collections.IEnumerator.get_Current();
                /*0x20d61ac*/ System.Collections.Generic.IEnumerator<System.Reflection.TypeInfo> System.Collections.Generic.IEnumerable<System.Reflection.TypeInfo>.GetEnumerator();
                /*0x20d6250*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            }
        }

        class AssemblyName : System.ICloneable, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.InteropServices._AssemblyName
        {
            /*0x10*/ string name;
            /*0x18*/ string codebase;
            /*0x20*/ int major;
            /*0x24*/ int minor;
            /*0x28*/ int build;
            /*0x2c*/ int revision;
            /*0x30*/ System.Globalization.CultureInfo cultureinfo;
            /*0x38*/ System.Reflection.AssemblyNameFlags flags;
            /*0x3c*/ System.Configuration.Assemblies.AssemblyHashAlgorithm hashalg;
            /*0x40*/ System.Reflection.StrongNameKeyPair keypair;
            /*0x48*/ byte[] publicKey;
            /*0x50*/ byte[] keyToken;
            /*0x58*/ System.Configuration.Assemblies.AssemblyVersionCompatibility versioncompat;
            /*0x60*/ System.Version version;
            /*0x68*/ System.Reflection.ProcessorArchitecture processor_architecture;
            /*0x6c*/ System.Reflection.AssemblyContentType contentType;

            static /*0x20d6254*/ bool ParseAssemblyName(nint name, ref Mono.MonoAssemblyName aname, ref bool is_version_definited, ref bool is_token_defined);
            static /*0x20d7168*/ void get_public_token(byte* token, byte* pubkey, int len);
            static /*0x20d716c*/ bool ReferenceMatchesDefinition(System.Reflection.AssemblyName reference, System.Reflection.AssemblyName definition);
            static /*0x20d0be8*/ System.Reflection.AssemblyName GetAssemblyName(string assemblyFile);
            static /*0x20d768c*/ Mono.MonoAssemblyName* GetNativeName(nint assembly_ptr);
            static /*0x20d7690*/ System.Reflection.AssemblyName Create(System.Reflection.Assembly assembly, bool fillCodebase);
            /*0x20d4a30*/ AssemblyName();
            /*0x20d6258*/ AssemblyName(string assemblyName);
            /*0x20d6500*/ AssemblyName(System.Runtime.Serialization.SerializationInfo si, System.Runtime.Serialization.StreamingContext sc);
            /*0x20d64f0*/ System.Reflection.ProcessorArchitecture get_ProcessorArchitecture();
            /*0x20d64f8*/ void set_ProcessorArchitecture(System.Reflection.ProcessorArchitecture value);
            /*0x20d6a08*/ string get_Name();
            /*0x20d6a10*/ void set_Name(string value);
            /*0x20d6a18*/ string get_CodeBase();
            /*0x20d6a20*/ void set_CodeBase(string value);
            /*0x20d6a28*/ string get_EscapedCodeBase();
            /*0x20d6aa4*/ System.Globalization.CultureInfo get_CultureInfo();
            /*0x20d6aac*/ void set_CultureInfo(System.Globalization.CultureInfo value);
            /*0x20d6ab4*/ System.Reflection.AssemblyNameFlags get_Flags();
            /*0x20d6abc*/ void set_Flags(System.Reflection.AssemblyNameFlags value);
            /*0x20d6ac4*/ string get_FullName();
            /*0x20d6f08*/ System.Configuration.Assemblies.AssemblyHashAlgorithm get_HashAlgorithm();
            /*0x20d6f10*/ void set_HashAlgorithm(System.Configuration.Assemblies.AssemblyHashAlgorithm value);
            /*0x20d6f18*/ System.Reflection.StrongNameKeyPair get_KeyPair();
            /*0x20d6f20*/ void set_KeyPair(System.Reflection.StrongNameKeyPair value);
            /*0x20d6f28*/ System.Version get_Version();
            /*0x20d4a70*/ void set_Version(System.Version value);
            /*0x20d6f30*/ System.Configuration.Assemblies.AssemblyVersionCompatibility get_VersionCompatibility();
            /*0x20d6f38*/ void set_VersionCompatibility(System.Configuration.Assemblies.AssemblyVersionCompatibility value);
            /*0x20d6f40*/ string ToString();
            /*0x20d6f68*/ byte[] GetPublicKey();
            /*0x20d6f70*/ byte[] GetPublicKeyToken();
            /*0x20d7058*/ bool get_IsPublicKeyValid();
            /*0x20d6e20*/ byte[] InternalGetPublicKeyToken();
            /*0x20d70dc*/ byte[] ComputePublicKeyToken();
            /*0x20d4a50*/ void SetPublicKey(byte[] publicKey);
            /*0x20d7200*/ void SetPublicKeyToken(byte[] publicKeyToken);
            /*0x20d7208*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20d7538*/ object Clone();
            /*0x20d75e8*/ void OnDeserialization(object sender);
            /*0x20d75f0*/ string get_CultureName();
            /*0x20d7608*/ void set_CultureName(string value);
            /*0x20d767c*/ System.Reflection.AssemblyContentType get_ContentType();
            /*0x20d7684*/ void set_ContentType(System.Reflection.AssemblyContentType value);
            /*0x20d57d8*/ void FillName(Mono.MonoAssemblyName* native, string codeBase, bool addVersion, bool addPublickey, bool defaultToken, bool assemblyRef);
            /*0x20d7764*/ void System.Runtime.InteropServices._AssemblyName.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
            /*0x20d779c*/ void System.Runtime.InteropServices._AssemblyName.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
            /*0x20d77d4*/ void System.Runtime.InteropServices._AssemblyName.GetTypeInfoCount(ref uint pcTInfo);
            /*0x20d780c*/ void System.Runtime.InteropServices._AssemblyName.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
        }

        class CustomAttributeData
        {
            /*0x10*/ System.Reflection.ConstructorInfo ctorInfo;
            /*0x18*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeTypedArgument> ctorArgs;
            /*0x20*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeNamedArgument> namedArgs;
            /*0x28*/ System.Reflection.CustomAttributeData.LazyCAttrData lazyData;

            static /*0x20d78ec*/ void ResolveArgumentsInternal(System.Reflection.ConstructorInfo ctor, System.Reflection.Assembly assembly, nint data, uint data_length, ref object[] ctorArgs, ref object[] namedArgs);
            static /*0x20d7ab8*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.Assembly target);
            static /*0x20d7b14*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.MemberInfo target);
            static /*0x20d7b70*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesInternal(System.RuntimeType target);
            static /*0x20d7bcc*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.Module target);
            static /*0x20d7c28*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributes(System.Reflection.ParameterInfo target);
            static T[] UnboxValues<T>(object[] values);
            /*0x20d7844*/ CustomAttributeData();
            /*0x20d784c*/ CustomAttributeData(System.Reflection.ConstructorInfo ctorInfo, System.Reflection.Assembly assembly, nint data, uint data_length);
            /*0x20c65c8*/ CustomAttributeData(System.Reflection.ConstructorInfo ctorInfo);
            /*0x20c6974*/ CustomAttributeData(System.Reflection.ConstructorInfo ctorInfo, System.Collections.Generic.IList<System.Reflection.CustomAttributeTypedArgument> ctorArgs, System.Collections.Generic.IList<System.Reflection.CustomAttributeNamedArgument> namedArgs);
            /*0x20d78f0*/ void ResolveArguments();
            /*0x20d7a80*/ System.Reflection.ConstructorInfo get_Constructor();
            /*0x20d7a88*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeTypedArgument> get_ConstructorArguments();
            /*0x20d7aa0*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeNamedArgument> get_NamedArguments();
            /*0x20d7c84*/ System.Type get_AttributeType();
            /*0x20d7ca8*/ string ToString();
            /*0x20d821c*/ bool Equals(object obj);
            /*0x20d889c*/ int GetHashCode();

            class LazyCAttrData
            {
                /*0x10*/ System.Reflection.Assembly assembly;
                /*0x18*/ nint data;
                /*0x20*/ uint data_length;

                /*0x20d78e4*/ LazyCAttrData();
            }
        }

        class ExceptionHandlingClause
        {
            /*0x10*/ System.Type catch_type;
            /*0x18*/ int filter_offset;
            /*0x1c*/ System.Reflection.ExceptionHandlingClauseOptions flags;
            /*0x20*/ int try_offset;
            /*0x24*/ int try_length;
            /*0x28*/ int handler_offset;
            /*0x2c*/ int handler_length;

            /*0x20d8b94*/ ExceptionHandlingClause();
            /*0x20d8b9c*/ System.Type get_CatchType();
            /*0x20d8ba4*/ int get_FilterOffset();
            /*0x20d8bac*/ System.Reflection.ExceptionHandlingClauseOptions get_Flags();
            /*0x20d8bb4*/ int get_HandlerLength();
            /*0x20d8bbc*/ int get_HandlerOffset();
            /*0x20d8bc4*/ int get_TryLength();
            /*0x20d8bcc*/ int get_TryOffset();
            /*0x20d8bd4*/ string ToString();
        }

        class LocalVariableInfo
        {
            /*0x10*/ System.Type type;
            /*0x18*/ bool is_pinned;
            /*0x1a*/ ushort position;

            /*0x20d8e98*/ LocalVariableInfo();
            /*0x20d8ea0*/ bool get_IsPinned();
            /*0x20d8ea8*/ int get_LocalIndex();
            /*0x20d8eb0*/ System.Type get_LocalType();
            /*0x20d8eb8*/ string ToString();
        }

        class MethodBody
        {
            /*0x10*/ System.Reflection.ExceptionHandlingClause[] clauses;
            /*0x18*/ System.Reflection.LocalVariableInfo[] locals;
            /*0x20*/ byte[] il;
            /*0x28*/ bool init_locals;
            /*0x2c*/ int sig_token;
            /*0x30*/ int max_stack;

            /*0x20d8f64*/ MethodBody();
            /*0x20d8f6c*/ MethodBody(System.Reflection.ExceptionHandlingClause[] clauses, System.Reflection.LocalVariableInfo[] locals, byte[] il, bool init_locals, int sig_token, int max_stack);
            /*0x20d8fc4*/ System.Collections.Generic.IList<System.Reflection.ExceptionHandlingClause> get_ExceptionHandlingClauses();
            /*0x20d900c*/ System.Collections.Generic.IList<System.Reflection.LocalVariableInfo> get_LocalVariables();
            /*0x20d9054*/ bool get_InitLocals();
            /*0x20d905c*/ int get_LocalSignatureMetadataToken();
            /*0x20d9064*/ int get_MaxStackSize();
            /*0x20d906c*/ byte[] GetILAsByteArray();
        }

        class RuntimeAssembly : System.Reflection.Assembly
        {
            /*0x10*/ nint _mono_assembly;
            /*0x18*/ object _evidence;
            /*0x20*/ System.Reflection.Assembly.ResolveEventHolder resolve_event_holder;
            /*0x28*/ object _minimum;
            /*0x30*/ object _optional;
            /*0x38*/ object _refuse;
            /*0x40*/ object _granted;
            /*0x48*/ object _denied;
            /*0x50*/ bool fromByteArray;
            /*0x58*/ string assemblyName;

            static /*0x20d9170*/ System.Reflection.RuntimeAssembly GetExecutingAssembly(ref System.Threading.StackCrawlMark stackMark);
            static /*0x20d91b0*/ System.Reflection.AssemblyName CreateAssemblyName(string assemblyString, bool forIntrospection, ref System.Reflection.RuntimeAssembly assemblyFromResolveEvent);
            static /*0x20d9304*/ System.Reflection.RuntimeAssembly InternalLoadAssemblyName(System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity, System.Reflection.RuntimeAssembly reqAssembly, ref System.Threading.StackCrawlMark stackMark, bool throwOnFileNotFound, bool forIntrospection, bool suppressSecurityChecks);
            static /*0x20d940c*/ System.Reflection.RuntimeAssembly LoadWithPartialNameInternal(string partialName, System.Security.Policy.Evidence securityEvidence, ref System.Threading.StackCrawlMark stackMark);
            static /*0x20d9494*/ System.Reflection.RuntimeAssembly LoadWithPartialNameInternal(System.Reflection.AssemblyName an, System.Security.Policy.Evidence securityEvidence, ref System.Threading.StackCrawlMark stackMark);
            static /*0x20d98dc*/ byte[] GetAotId();
            static /*0x20d9938*/ string get_code_base(System.Reflection.Assembly a, bool escaped);
            static /*0x20d9944*/ string get_fullname(System.Reflection.Assembly a);
            static /*0x20d9934*/ bool GetAotIdInternal(byte[] aotid);
            static /*0x20d9948*/ string InternalImageRuntimeVersion(System.Reflection.Assembly a);
            static /*0x20d9954*/ string GetCodeBase(System.Reflection.Assembly a, bool escaped);
            /*0x20d9074*/ RuntimeAssembly();
            /*0x20d90e0*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20d94bc*/ System.Reflection.AssemblyName GetName(bool copiedName);
            /*0x20d94c4*/ System.Type GetType(string name, bool throwOnError, bool ignoreCase);
            /*0x20d9588*/ System.Reflection.Module GetModule(string name);
            /*0x20d96bc*/ System.Reflection.AssemblyName[] GetReferencedAssemblies();
            /*0x20d96c0*/ System.Reflection.Module[] GetModules(bool getResourceModules);
            /*0x20d9858*/ System.Reflection.Module[] GetLoadedModules(bool getResourceModules);
            /*0x20d986c*/ System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture);
            /*0x20d9890*/ System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture, System.Version version);
            /*0x20d98b0*/ System.Reflection.Module get_ManifestModule();
            /*0x20d98c0*/ bool get_GlobalAssemblyCache();
            /*0x20d98c8*/ System.Type[] GetExportedTypes();
            /*0x20d9940*/ string get_location();
            /*0x20d98c4*/ bool get_global_assembly_cache();
            /*0x20d994c*/ System.Reflection.MethodInfo get_EntryPoint();
            /*0x20d9950*/ bool get_ReflectionOnly();
            /*0x20d995c*/ string get_CodeBase();
            /*0x20d9964*/ string get_EscapedCodeBase();
            /*0x20d996c*/ string get_FullName();
            /*0x20d9970*/ string get_ImageRuntimeVersion();
            /*0x20d9974*/ nint get_MonoAssembly();
            /*0x20d997c*/ void set_FromByteArray(bool value);
            /*0x20d9988*/ string get_Location();
            /*0x20d99ec*/ bool GetManifestResourceInfoInternal(string name, System.Reflection.ManifestResourceInfo info);
            /*0x20d99f0*/ System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName);
            /*0x20d9b00*/ string[] GetManifestResourceNames();
            /*0x20d9b04*/ nint GetManifestResourceInternal(string name, ref int size, ref System.Reflection.Module module);
            /*0x20d9b08*/ System.IO.Stream GetManifestResourceStream(string name);
            /*0x20d9eac*/ System.IO.Stream GetManifestResourceStream(System.Type type, string name);
            /*0x20d9eb4*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20d9f24*/ object[] GetCustomAttributes(bool inherit);
            /*0x20d9f8c*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20d9ffc*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20da000*/ void add_ModuleResolve(System.Reflection.ModuleResolveEventHandler value);
            /*0x20da018*/ void remove_ModuleResolve(System.Reflection.ModuleResolveEventHandler value);
            /*0x20da030*/ System.Reflection.Module GetManifestModule();
            /*0x20da034*/ System.Reflection.Module GetManifestModuleInternal();
            /*0x20da038*/ System.Reflection.Module[] GetModulesInternal();
            /*0x20da03c*/ object GetFilesInternal(string name, bool getResourceModules);
            /*0x20da044*/ System.IO.FileStream[] GetFiles(bool getResourceModules);
            /*0x20da30c*/ System.IO.FileStream GetFile(string name);
            /*0x20da45c*/ int GetHashCode();
            /*0x20da464*/ bool Equals(object o);
            /*0x20da504*/ string ToString();
            /*0x20da534*/ System.Security.Policy.Evidence get_Evidence();
            /*0x20da544*/ System.Security.Policy.Evidence UnprotectedGetEvidence();

            class UnmanagedMemoryStreamForModule : System.IO.UnmanagedMemoryStream
            {
                /*0x68*/ System.Reflection.Module module;

                /*0x20d9e84*/ UnmanagedMemoryStreamForModule(byte* pointer, long length, System.Reflection.Module module);
                /*0x20da54c*/ void Dispose(bool disposing);
            }
        }

        struct MonoEventInfo
        {
            /*0x10*/ System.Type declaring_type;
            /*0x18*/ System.Type reflected_type;
            /*0x20*/ string name;
            /*0x28*/ System.Reflection.MethodInfo add_method;
            /*0x30*/ System.Reflection.MethodInfo remove_method;
            /*0x38*/ System.Reflection.MethodInfo raise_method;
            /*0x40*/ System.Reflection.EventAttributes attrs;
            /*0x48*/ System.Reflection.MethodInfo[] other_methods;
        }

        class RuntimeEventInfo : System.Reflection.EventInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x18*/ nint klass;
            /*0x20*/ nint handle;

            static /*0x20da564*/ void get_event_info(System.Reflection.RuntimeEventInfo ev, ref System.Reflection.MonoEventInfo info);
            static /*0x20da568*/ System.Reflection.MonoEventInfo GetEventInfo(System.Reflection.RuntimeEventInfo ev);
            static /*0x20dae50*/ int get_metadata_token(System.Reflection.RuntimeEventInfo monoEvent);
            /*0x20daeac*/ RuntimeEventInfo();
            /*0x20da5a4*/ System.Reflection.Module get_Module();
            /*0x20da5c4*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x20da738*/ System.RuntimeType GetDeclaringTypeInternal();
            /*0x20da7c0*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x20da5a8*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x20da848*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20da5c8*/ System.Reflection.BindingFlags GetBindingFlags();
            /*0x20da8ec*/ System.Reflection.EventAttributes get_Attributes();
            /*0x20da918*/ System.Reflection.MethodInfo GetAddMethod(bool nonPublic);
            /*0x20da980*/ System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic);
            /*0x20da9e8*/ System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic);
            /*0x20daa50*/ System.Reflection.MethodInfo[] GetOtherMethods(bool nonPublic);
            /*0x20dabe8*/ System.Type get_DeclaringType();
            /*0x20dac14*/ System.Type get_ReflectedType();
            /*0x20dac40*/ string get_Name();
            /*0x20dac6c*/ string ToString();
            /*0x20dad00*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20dad70*/ object[] GetCustomAttributes(bool inherit);
            /*0x20dadd8*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20dae48*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20dae4c*/ int get_MetadataToken();
            /*0x20dae54*/ bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other);
        }

        class RtFieldInfo : System.Reflection.FieldInfo
        {
            /*0x20daeb4*/ RtFieldInfo();
            object UnsafeGetValue(object obj);
            void UnsafeSetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            void CheckConsistency(object target);
        }

        class RuntimeFieldInfo : System.Reflection.RtFieldInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ nint klass;
            /*0x18*/ System.RuntimeFieldHandle fhandle;
            /*0x20*/ string name;
            /*0x28*/ System.Type type;
            /*0x30*/ System.Reflection.FieldAttributes attrs;

            static /*0x20db9f8*/ void SetValueInternal(System.Reflection.FieldInfo fi, object obj, object value);
            static /*0x20dbd64*/ int get_core_clr_security_level();
            static /*0x20dbdc8*/ int get_metadata_token(System.Reflection.RuntimeFieldInfo monoField);
            /*0x20dbd50*/ RuntimeFieldInfo();
            /*0x20daebc*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x20daec4*/ System.Reflection.Module get_Module();
            /*0x20daee4*/ System.RuntimeType GetDeclaringTypeInternal();
            /*0x20daf6c*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x20daec8*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x20daff4*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20db0b0*/ object UnsafeGetValue(object obj);
            /*0x20db0b4*/ void CheckConsistency(object target);
            /*0x20db244*/ void UnsafeSetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            /*0x20db2a8*/ void SetValueDirect(System.TypedReference obj, object value);
            /*0x20db410*/ object GetValueDirect(System.TypedReference obj);
            /*0x20db570*/ System.Reflection.FieldAttributes get_Attributes();
            /*0x20db578*/ System.RuntimeFieldHandle get_FieldHandle();
            /*0x20db580*/ System.Type ResolveType();
            /*0x20db584*/ System.Type get_FieldType();
            /*0x20db600*/ System.Type GetParentType(bool declaring);
            /*0x20db608*/ System.Type get_ReflectedType();
            /*0x20db610*/ System.Type get_DeclaringType();
            /*0x20db618*/ string get_Name();
            /*0x20db620*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20db690*/ object[] GetCustomAttributes(bool inherit);
            /*0x20db6f8*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20db768*/ int GetFieldOffset();
            /*0x20db76c*/ object GetValueInternal(object obj);
            /*0x20db770*/ object GetValue(object obj);
            /*0x20db990*/ string ToString();
            /*0x20db9fc*/ void SetValue(object obj, object val, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
            /*0x20dbcc0*/ System.Reflection.RuntimeFieldInfo Clone(string newName);
            /*0x20dbd58*/ object GetRawConstantValue();
            /*0x20dbd5c*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20db90c*/ void CheckGeneric();
            /*0x20dbd6c*/ bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other);
            /*0x20dbdc4*/ int get_MetadataToken();
            /*0x20dbdcc*/ System.Type[] GetTypeModifiers(bool optional);
            /*0x20dbdd4*/ System.Type[] GetOptionalCustomModifiers();
            /*0x20dbe4c*/ System.Type[] GetRequiredCustomModifiers();
            /*0x20dbddc*/ System.Type[] GetCustomModifiers(bool optional);
        }

        struct MonoMethodInfo
        {
            /*0x10*/ System.Type parent;
            /*0x18*/ System.Type ret;
            /*0x20*/ System.Reflection.MethodAttributes attrs;
            /*0x24*/ System.Reflection.MethodImplAttributes iattrs;
            /*0x28*/ System.Reflection.CallingConventions callconv;

            static /*0x20dbe54*/ void get_method_info(nint handle, ref System.Reflection.MonoMethodInfo info);
            static /*0x20dbe58*/ int get_method_attributes(nint handle);
            static /*0x20dbe5c*/ System.Reflection.MonoMethodInfo GetMethodInfo(nint handle);
            static /*0x20dbe8c*/ System.Type GetDeclaringType(nint handle);
            static /*0x20dbeb4*/ System.Type GetReturnType(nint handle);
            static /*0x20dbedc*/ System.Reflection.MethodAttributes GetAttributes(nint handle);
            static /*0x20dbee0*/ System.Reflection.CallingConventions GetCallingConvention(nint handle);
            static /*0x20dbf08*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags(nint handle);
            static /*0x20dbf30*/ System.Reflection.ParameterInfo[] get_parameter_info(nint handle, System.Reflection.MemberInfo member);
            static /*0x20dbf34*/ System.Reflection.ParameterInfo[] GetParametersInfo(nint handle, System.Reflection.MemberInfo member);
            static /*0x20dbf38*/ System.Runtime.InteropServices.MarshalAsAttribute get_retval_marshal(nint handle);
            static /*0x20dbf3c*/ System.Reflection.ParameterInfo GetReturnParameterInfo(System.Reflection.RuntimeMethodInfo method);
        }

        class RuntimeMethodInfo : System.Reflection.MethodInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ nint mhandle;
            /*0x18*/ string name;
            /*0x20*/ System.Type reftype;

            static /*0x20dc720*/ System.Reflection.MethodBase GetMethodFromHandleNoGenericCheck(System.RuntimeMethodHandle handle);
            static /*0x20dc77c*/ System.Reflection.MethodBase GetMethodFromHandleNoGenericCheck(System.RuntimeMethodHandle handle, System.RuntimeTypeHandle reflectedType);
            static /*0x20dc784*/ System.Reflection.MethodBody GetMethodBodyInternal(nint handle);
            static /*0x20dc788*/ System.Reflection.MethodBody GetMethodBody(nint handle);
            static /*0x20dc78c*/ System.Reflection.MethodBase GetMethodFromHandleInternalType(nint method_handle, nint type_handle);
            static /*0x20dc774*/ System.Reflection.MethodBase GetMethodFromHandleInternalType_native(nint method_handle, nint type_handle, bool genericCheck);
            static /*0x20dc7c4*/ string get_name(System.Reflection.MethodBase method);
            static /*0x20dc7c8*/ System.Reflection.RuntimeMethodInfo get_base_method(System.Reflection.RuntimeMethodInfo method, bool definition);
            static /*0x20dc7d0*/ int get_metadata_token(System.Reflection.RuntimeMethodInfo method);
            static /*0x20dcc04*/ void ConvertValues(System.Reflection.Binder binder, object[] args, System.Reflection.ParameterInfo[] pinfo, System.Globalization.CultureInfo culture, System.Reflection.BindingFlags invokeAttr);
            static /*0x20ddfc8*/ int get_core_clr_security_level();
            /*0x20dc794*/ RuntimeMethodInfo();
            /*0x20dc79c*/ RuntimeMethodInfo(System.RuntimeMethodHandle mhandle);
            /*0x20dc020*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x20dc028*/ System.Reflection.Module get_Module();
            /*0x20dc0bc*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x20dc144*/ string FormatNameAndSig(bool serialization);
            /*0x20dc4a0*/ System.Delegate CreateDelegate(System.Type delegateType);
            /*0x20dc4b4*/ System.Delegate CreateDelegate(System.Type delegateType, object target);
            /*0x20dc4cc*/ string ToString();
            /*0x20dc02c*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x20dc55c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20dc684*/ string SerializationToString();
            /*0x20dc7d4*/ System.Reflection.MethodInfo GetBaseDefinition();
            /*0x20dc7dc*/ System.Reflection.MethodInfo GetBaseMethod();
            /*0x20dc7e4*/ System.Reflection.ParameterInfo get_ReturnParameter();
            /*0x20dc7e8*/ System.Type get_ReturnType();
            /*0x20dc814*/ System.Reflection.ICustomAttributeProvider get_ReturnTypeCustomAttributes();
            /*0x20dc818*/ int get_MetadataToken();
            /*0x20dc81c*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
            /*0x20dc848*/ System.Reflection.ParameterInfo[] GetParameters();
            /*0x20dc8d8*/ System.Reflection.ParameterInfo[] GetParametersInternal();
            /*0x20dc8e4*/ int GetParametersCount();
            /*0x20dc908*/ object InternalInvoke(object obj, object[] parameters, ref System.Exception exc);
            /*0x20dc90c*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x20dcec4*/ System.RuntimeMethodHandle get_MethodHandle();
            /*0x20dcecc*/ System.Reflection.MethodAttributes get_Attributes();
            /*0x20dced4*/ System.Reflection.CallingConventions get_CallingConvention();
            /*0x20dcf00*/ System.Type get_ReflectedType();
            /*0x20dcf08*/ System.Type get_DeclaringType();
            /*0x20dcf34*/ string get_Name();
            /*0x20dcf48*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20dcfb8*/ object[] GetCustomAttributes(bool inherit);
            /*0x20dd020*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20dd090*/ void GetPInvoke(ref System.Reflection.PInvokeAttributes flags, ref string entryPoint, ref string dllName);
            /*0x20dd094*/ object[] GetPseudoCustomAttributes();
            /*0x20dd200*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData();
            /*0x20dd3d0*/ System.Reflection.CustomAttributeData GetDllImportAttributeData();
            /*0x20ddb14*/ System.Reflection.MethodInfo MakeGenericMethod(System.Type[] methodInstantiation);
            /*0x20dde74*/ System.Reflection.MethodInfo MakeGenericMethod_impl(System.Type[] types);
            /*0x20dde78*/ System.Type[] GetGenericArguments();
            /*0x20dde7c*/ System.Reflection.MethodInfo GetGenericMethodDefinition_impl();
            /*0x20dde80*/ System.Reflection.MethodInfo GetGenericMethodDefinition();
            /*0x20ddee4*/ bool get_IsGenericMethodDefinition();
            /*0x20ddee8*/ bool get_IsGenericMethod();
            /*0x20ddeec*/ bool get_ContainsGenericParameters();
            /*0x20ddfb8*/ System.Reflection.MethodBody GetMethodBody();
            /*0x20ddfc0*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20ddfd0*/ bool get_IsSecurityTransparent();
            /*0x20ddfd8*/ bool get_IsSecurityCritical();
            /*0x20ddfe0*/ bool get_IsSecuritySafeCritical();
            /*0x20ddfe8*/ bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other);
        }

        class RuntimeConstructorInfo : System.Reflection.ConstructorInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ nint mhandle;
            /*0x18*/ string name;
            /*0x20*/ System.Type reftype;

            static /*0x20deacc*/ int get_core_clr_security_level();
            static /*0x20deb48*/ int get_metadata_token(System.Reflection.RuntimeConstructorInfo method);
            /*0x20deb4c*/ RuntimeConstructorInfo();
            /*0x20de040*/ System.Reflection.Module get_Module();
            /*0x20de044*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x20de0d0*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x20de0d8*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x20de160*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20de240*/ string SerializationToString();
            /*0x20de254*/ void SerializationInvoke(object target, System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20de36c*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
            /*0x20de398*/ System.Reflection.ParameterInfo[] GetParameters();
            /*0x20de3a4*/ System.Reflection.ParameterInfo[] GetParametersInternal();
            /*0x20de3b0*/ int GetParametersCount();
            /*0x20de3d0*/ object InternalInvoke(object obj, object[] parameters, ref System.Exception exc);
            /*0x20de3d4*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x20de4dc*/ object DoInvoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x20de6e0*/ object InternalInvoke(object obj, object[] parameters, bool wrapExceptions);
            /*0x20de840*/ object Invoke(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
            /*0x20de858*/ System.RuntimeMethodHandle get_MethodHandle();
            /*0x20de860*/ System.Reflection.MethodAttributes get_Attributes();
            /*0x20de868*/ System.Reflection.CallingConventions get_CallingConvention();
            /*0x20de894*/ bool get_ContainsGenericParameters();
            /*0x20de8c4*/ System.Type get_ReflectedType();
            /*0x20de8cc*/ System.Type get_DeclaringType();
            /*0x20de8f8*/ string get_Name();
            /*0x20de90c*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20de97c*/ object[] GetCustomAttributes(bool inherit);
            /*0x20de9e4*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20dea54*/ System.Reflection.MethodBody GetMethodBody();
            /*0x20dea5c*/ string ToString();
            /*0x20deac4*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20dead4*/ bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other);
            /*0x20deb2c*/ bool get_IsSecurityTransparent();
            /*0x20deb34*/ bool get_IsSecurityCritical();
            /*0x20deb3c*/ bool get_IsSecuritySafeCritical();
            /*0x20deb44*/ int get_MetadataToken();
        }

        class RuntimeModule : System.Reflection.Module
        {
            /*0x10*/ nint _impl;
            /*0x18*/ System.Reflection.Assembly assembly;
            /*0x20*/ string fqname;
            /*0x28*/ string name;
            /*0x30*/ string scopename;
            /*0x38*/ bool is_resource;
            /*0x3c*/ int token;

            static /*0x20df488*/ System.Reflection.FieldInfo ResolveField(System.Reflection.Module module, nint monoModule, int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            static /*0x20df890*/ System.Reflection.MemberInfo ResolveMember(System.Reflection.Module module, nint monoModule, int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            static /*0x20df988*/ System.Reflection.MethodBase ResolveMethod(System.Reflection.Module module, nint monoModule, int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            static /*0x20dfab8*/ string ResolveString(System.Reflection.Module module, nint monoModule, int metadataToken);
            static /*0x20dfb70*/ System.Type ResolveType(System.Reflection.Module module, nint monoModule, int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            static /*0x20dfcc8*/ byte[] ResolveSignature(System.Reflection.Module module, nint monoModule, int metadataToken);
            static /*0x20df704*/ System.Exception resolve_token_exception(string name, int metadataToken, System.Reflection.ResolveTokenError error, string tokenType);
            static /*0x20df5a8*/ nint[] ptrs_from_types(System.Type[] types);
            static /*0x20df0dc*/ int get_MetadataToken(System.Reflection.Module module);
            static /*0x20dec58*/ int GetMDStreamVersion(nint module);
            static /*0x20dfe84*/ System.Type[] InternalGetTypes(nint module);
            static /*0x20dff1c*/ nint GetHINSTANCE(nint module);
            static /*0x20dff18*/ void GetGuidInternal(nint module, byte[] guid);
            static /*0x20df000*/ System.Type GetGlobalType(nint module);
            static /*0x20dfcb4*/ nint ResolveTypeToken(nint module, int token, nint[] type_args, nint[] method_args, ref System.Reflection.ResolveTokenError error);
            static /*0x20dfaa4*/ nint ResolveMethodToken(nint module, int token, nint[] type_args, nint[] method_args, ref System.Reflection.ResolveTokenError error);
            static /*0x20df700*/ nint ResolveFieldToken(nint module, int token, nint[] type_args, nint[] method_args, ref System.Reflection.ResolveTokenError error);
            static /*0x20dfb54*/ string ResolveStringToken(nint module, int token, ref System.Reflection.ResolveTokenError error);
            static /*0x20df96c*/ System.Reflection.MemberInfo ResolveMemberToken(nint module, int token, nint[] type_args, nint[] method_args, ref System.Reflection.ResolveTokenError error);
            static /*0x20dfd64*/ byte[] ResolveSignature(nint module, int metadataToken, ref System.Reflection.ResolveTokenError error);
            static /*0x20df2e4*/ void GetPEKind(nint module, ref System.Reflection.PortableExecutableKinds peKind, ref System.Reflection.ImageFileMachine machine);
            /*0x20dff20*/ RuntimeModule();
            /*0x20deba4*/ System.Reflection.Assembly get_Assembly();
            /*0x20debac*/ string get_Name();
            /*0x20debb4*/ string get_ScopeName();
            /*0x20debbc*/ int get_MDStreamVersion();
            /*0x20dec5c*/ System.Guid get_ModuleVersionId();
            /*0x20dec6c*/ string get_FullyQualifiedName();
            /*0x20dec74*/ bool IsResource();
            /*0x20dec7c*/ System.Type[] FindTypes(System.Reflection.TypeFilter filter, object filterCriteria);
            /*0x20dee08*/ object[] GetCustomAttributes(bool inherit);
            /*0x20dee70*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20deee0*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
            /*0x20df004*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingFlags);
            /*0x20df0d8*/ int get_MetadataToken();
            /*0x20df0e0*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
            /*0x20df200*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingFlags);
            /*0x20df2d4*/ System.ModuleHandle GetModuleHandleImpl();
            /*0x20df2dc*/ void GetPEKind(ref System.Reflection.PortableExecutableKinds peKind, ref System.Reflection.ImageFileMachine machine);
            /*0x20df2e8*/ System.Type GetType(string className, bool throwOnError, bool ignoreCase);
            /*0x20df400*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20df470*/ System.Reflection.FieldInfo ResolveField(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            /*0x20df878*/ System.Reflection.MemberInfo ResolveMember(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            /*0x20df970*/ System.Reflection.MethodBase ResolveMethod(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            /*0x20dfaa8*/ string ResolveString(int metadataToken);
            /*0x20dfb58*/ System.Type ResolveType(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
            /*0x20dfcb8*/ byte[] ResolveSignature(int metadataToken);
            /*0x20dfd68*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20dfe7c*/ System.Type[] GetTypes();
            /*0x20dfe88*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20dfe04*/ System.Reflection.RuntimeAssembly GetRuntimeAssembly();
            /*0x20dfe90*/ nint get_MonoModule();
            /*0x20dfe98*/ System.Guid GetModuleVersionId();
        }

        enum ResolveTokenError
        {
            OutOfRange = 0,
            BadTable = 1,
            Other = 2,
        }

        class RuntimeParameterInfo : System.Reflection.ParameterInfo
        {
            /*0x40*/ System.Runtime.InteropServices.MarshalAsAttribute marshalAs;

            static /*0x20dc2a8*/ void FormatParameters(System.Text.StringBuilder sb, System.Reflection.ParameterInfo[] p, System.Reflection.CallingConventions callingConvention, bool serialization);
            static /*0x20e12d0*/ System.Type[] GetTypeModifiers(System.Type type, System.Reflection.MemberInfo member, int position, bool optional);
            static /*0x20e12d8*/ System.Reflection.ParameterInfo New(System.Reflection.ParameterInfo pinfo, System.Type type, System.Reflection.MemberInfo member, int position);
            static /*0x20e1360*/ System.Reflection.ParameterInfo New(System.Reflection.ParameterInfo pinfo, System.Reflection.MemberInfo member);
            static /*0x20dbf94*/ System.Reflection.ParameterInfo New(System.Type type, System.Reflection.MemberInfo member, System.Runtime.InteropServices.MarshalAsAttribute marshalAs);
            /*0x20dff78*/ RuntimeParameterInfo(string name, System.Type type, int position, int attrs, object defaultValue, System.Reflection.MemberInfo member, System.Runtime.InteropServices.MarshalAsAttribute marshalAs);
            /*0x20dffe0*/ RuntimeParameterInfo(System.Reflection.ParameterInfo pinfo, System.Type type, System.Reflection.MemberInfo member, int position);
            /*0x20e0080*/ RuntimeParameterInfo(System.Reflection.ParameterInfo pinfo, System.Reflection.MemberInfo member);
            /*0x20e01e0*/ RuntimeParameterInfo(System.Type type, System.Reflection.MemberInfo member, System.Runtime.InteropServices.MarshalAsAttribute marshalAs);
            /*0x20e0230*/ object get_DefaultValue();
            /*0x20e0544*/ object get_RawDefaultValue();
            /*0x20e0640*/ int get_MetadataToken();
            /*0x20e0830*/ object[] GetCustomAttributes(bool inherit);
            /*0x20e088c*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20e011c*/ object GetDefaultValueImpl(System.Reflection.ParameterInfo pinfo);
            /*0x20e08f8*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20e0968*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20e082c*/ int GetMetadataToken();
            /*0x20e0970*/ System.Type[] GetOptionalCustomModifiers();
            /*0x20e0a3c*/ object[] GetPseudoCustomAttributes();
            /*0x20e0c94*/ System.Reflection.CustomAttributeData[] GetPseudoCustomAttributesData();
            /*0x20e119c*/ System.Type[] GetRequiredCustomModifiers();
            /*0x20e11a4*/ bool get_HasDefaultValue();
            /*0x20e0978*/ System.Type[] GetCustomModifiers(bool optional);
        }

        struct MonoPropertyInfo
        {
            /*0x10*/ System.Type parent;
            /*0x18*/ System.Type declaring_type;
            /*0x20*/ string name;
            /*0x28*/ System.Reflection.MethodInfo get_method;
            /*0x30*/ System.Reflection.MethodInfo set_method;
            /*0x38*/ System.Reflection.PropertyAttributes attrs;
        }

        enum PInfo
        {
            Attributes = 1,
            GetMethod = 2,
            SetMethod = 4,
            ReflectedType = 8,
            DeclaringType = 16,
            Name = 32,
        }

        class GetterAdapter : System.MulticastDelegate
        {
            /*0x20e13d0*/ GetterAdapter(object object, nint method);
            /*0x20e14fc*/ object Invoke(object _this);
            /*0x20e1510*/ System.IAsyncResult BeginInvoke(object _this, System.AsyncCallback callback, object object);
            /*0x20e1530*/ object EndInvoke(System.IAsyncResult result);
        }

        class Getter<T, R> : System.MulticastDelegate
        {
            Getter(object object, nint method);
            R Invoke(T _this);
            System.IAsyncResult BeginInvoke(T _this, System.AsyncCallback callback, object object);
            R EndInvoke(System.IAsyncResult result);
        }

        class RuntimePropertyInfo : System.Reflection.PropertyInfo, System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ nint klass;
            /*0x18*/ nint prop;
            /*0x20*/ System.Reflection.MonoPropertyInfo info;
            /*0x50*/ System.Reflection.PInfo cached;
            /*0x58*/ System.Reflection.RuntimePropertyInfo.GetterAdapter cached_getter;

            static /*0x20e153c*/ void get_property_info(System.Reflection.RuntimePropertyInfo prop, ref System.Reflection.MonoPropertyInfo info, System.Reflection.PInfo req_info);
            static /*0x20e1540*/ System.Type[] GetTypeModifiers(System.Reflection.RuntimePropertyInfo prop, bool optional);
            static /*0x20e1548*/ object get_default_value(System.Reflection.RuntimePropertyInfo prop);
            static object GetterAdapterFrame<T, R>(System.Reflection.RuntimePropertyInfo.Getter<T, R> getter, object obj);
            static object StaticGetterAdapterFrame<R>(System.Reflection.RuntimePropertyInfo.StaticGetter<R> getter, object obj);
            static /*0x20e20b4*/ System.Reflection.RuntimePropertyInfo.GetterAdapter CreateGetterDelegate(System.Reflection.MethodInfo method);
            static /*0x20e28b0*/ int get_metadata_token(System.Reflection.RuntimePropertyInfo monoProperty);
            static /*0x20e28b4*/ System.Reflection.PropertyInfo internal_from_handle_type(nint event_handle, nint type_handle);
            static /*0x20e28b8*/ System.Reflection.PropertyInfo GetPropertyFromHandle(Mono.RuntimePropertyHandle handle, System.RuntimeTypeHandle reflectedType);
            /*0x20e29b4*/ RuntimePropertyInfo();
            /*0x20e154c*/ System.Reflection.BindingFlags get_BindingFlags();
            /*0x20e1554*/ System.Reflection.Module get_Module();
            /*0x20e1574*/ System.RuntimeType GetDeclaringTypeInternal();
            /*0x20e15fc*/ System.RuntimeType get_ReflectedTypeInternal();
            /*0x20e1558*/ System.Reflection.RuntimeModule GetRuntimeModule();
            /*0x20e1684*/ string ToString();
            /*0x20e168c*/ string FormatNameAndSig(bool serialization);
            /*0x20e1800*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20e18d4*/ string SerializationToString();
            /*0x20e18dc*/ void CachePropertyInfo(System.Reflection.PInfo flags);
            /*0x20e191c*/ System.Reflection.PropertyAttributes get_Attributes();
            /*0x20e1954*/ bool get_CanRead();
            /*0x20e1994*/ bool get_CanWrite();
            /*0x20e19d4*/ System.Type get_PropertyType();
            /*0x20e1a88*/ System.Type get_ReflectedType();
            /*0x20e1ac0*/ System.Type get_DeclaringType();
            /*0x20e1af8*/ string get_Name();
            /*0x20e1b30*/ System.Reflection.MethodInfo[] GetAccessors(bool nonPublic);
            /*0x20e1cac*/ System.Reflection.MethodInfo GetGetMethod(bool nonPublic);
            /*0x20e1d30*/ System.Reflection.ParameterInfo[] GetIndexParameters();
            /*0x20e1ef4*/ System.Reflection.MethodInfo GetSetMethod(bool nonPublic);
            /*0x20e1f78*/ object GetConstantValue();
            /*0x20e1f7c*/ object GetRawConstantValue();
            /*0x20e1f80*/ bool IsDefined(System.Type attributeType, bool inherit);
            /*0x20e1fec*/ object[] GetCustomAttributes(bool inherit);
            /*0x20e2048*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
            /*0x20e239c*/ object GetValue(object obj, object[] index);
            /*0x20e23bc*/ object GetValue(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            /*0x20e25c4*/ void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
            /*0x20e27cc*/ System.Type[] GetOptionalCustomModifiers();
            /*0x20e2844*/ System.Type[] GetRequiredCustomModifiers();
            /*0x20e27d4*/ System.Type[] GetCustomModifiers(bool optional);
            /*0x20e284c*/ System.Collections.Generic.IList<System.Reflection.CustomAttributeData> GetCustomAttributesData();
            /*0x20e2854*/ bool HasSameMetadataDefinitionAs(System.Reflection.MemberInfo other);
            /*0x20e28ac*/ int get_MetadataToken();

            class GetterAdapter : System.MulticastDelegate
            {
                /*0x20e29bc*/ GetterAdapter(object object, nint method);
                /*0x20e2ae8*/ object Invoke(object _this);
            }

            class Getter<T, R> : System.MulticastDelegate
            {
                Getter(object object, nint method);
                R Invoke(T _this);
            }

            class StaticGetter<R> : System.MulticastDelegate
            {
                StaticGetter(object object, nint method);
                R Invoke();
            }
        }

        class StrongNameKeyPair : System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
        {
            /*0x10*/ byte[] _publicKey;
            /*0x18*/ string _keyPairContainer;
            /*0x20*/ bool _keyPairExported;
            /*0x28*/ byte[] _keyPairArray;
            /*0x30*/ System.Security.Cryptography.RSA _rsa;

            /*0x20e2afc*/ StrongNameKeyPair(byte[] keyPairArray);
            /*0x20e2d94*/ StrongNameKeyPair(System.IO.FileStream keyPairFile);
            /*0x20e2ea0*/ StrongNameKeyPair(string keyPairContainer);
            /*0x20e2f1c*/ StrongNameKeyPair(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20e3108*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20e3250*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x20e2ce8*/ System.Security.Cryptography.RSA GetRSA();
            /*0x20e2b80*/ void LoadKey(byte[] key);
            /*0x20e3254*/ byte[] get_PublicKey();
            /*0x20e347c*/ Mono.Security.StrongName StrongName();
        }

        namespace Metadata
        {
            class AssemblyExtensions
            {
                static /*0x20e3520*/ bool TryGetRawMetadata(System.Reflection.Assembly assembly, ref byte* blob, ref int length);
            }
        }

        namespace Emit
        {
            enum OpCodeType
            {
                Annotation = 0,
                Macro = 1,
                Nternal = 2,
                Objmodel = 3,
                Prefix = 4,
                Primitive = 5,
            }

            enum OperandType
            {
                InlineBrTarget = 0,
                InlineField = 1,
                InlineI = 2,
                InlineI8 = 3,
                InlineMethod = 4,
                InlineNone = 5,
                InlinePhi = 6,
                InlineR = 7,
                InlineSig = 9,
                InlineString = 10,
                InlineSwitch = 11,
                InlineTok = 12,
                InlineType = 13,
                InlineVar = 14,
                ShortInlineBrTarget = 15,
                ShortInlineI = 16,
                ShortInlineR = 17,
                ShortInlineVar = 18,
            }

            enum PackingSize
            {
                Unspecified = 0,
                Size1 = 1,
                Size2 = 2,
                Size4 = 4,
                Size8 = 8,
                Size16 = 16,
                Size32 = 32,
                Size64 = 64,
                Size128 = 128,
            }

            enum StackBehaviour
            {
                Pop0 = 0,
                Pop1 = 1,
                Pop1_pop1 = 2,
                Popi = 3,
                Popi_pop1 = 4,
                Popi_popi = 5,
                Popi_popi8 = 6,
                Popi_popi_popi = 7,
                Popi_popr4 = 8,
                Popi_popr8 = 9,
                Popref = 10,
                Popref_pop1 = 11,
                Popref_popi = 12,
                Popref_popi_popi = 13,
                Popref_popi_popi8 = 14,
                Popref_popi_popr4 = 15,
                Popref_popi_popr8 = 16,
                Popref_popi_popref = 17,
                Push0 = 18,
                Push1 = 19,
                Push1_push1 = 20,
                Pushi = 21,
                Pushi8 = 22,
                Pushr4 = 23,
                Pushr8 = 24,
                Pushref = 25,
                Varpop = 26,
                Varpush = 27,
                Popref_popi_pop1 = 28,
            }

            struct ExceptionHandler : System.IEquatable<System.Reflection.Emit.ExceptionHandler>
            {
                /*0x10*/ int m_exceptionClass;
                /*0x14*/ int m_tryStartOffset;
                /*0x18*/ int m_tryEndOffset;
                /*0x1c*/ int m_filterOffset;
                /*0x20*/ int m_handlerStartOffset;
                /*0x24*/ int m_handlerEndOffset;
                /*0x28*/ System.Reflection.ExceptionHandlingClauseOptions m_kind;

                static /*0x20e39f4*/ bool IsValidKind(System.Reflection.ExceptionHandlingClauseOptions kind);
                static /*0x20e3b5c*/ bool op_Equality(System.Reflection.Emit.ExceptionHandler left, System.Reflection.Emit.ExceptionHandler right);
                static /*0x20e3b8c*/ bool op_Inequality(System.Reflection.Emit.ExceptionHandler left, System.Reflection.Emit.ExceptionHandler right);
                /*0x20e35a0*/ ExceptionHandler(int tryOffset, int tryLength, int filterOffset, int handlerOffset, int handlerLength, System.Reflection.ExceptionHandlingClauseOptions kind, int exceptionTypeToken);
                /*0x20e3a10*/ ExceptionHandler(int tryStartOffset, int tryEndOffset, int filterOffset, int handlerStartOffset, int handlerEndOffset, int kind, int exceptionTypeToken);
                /*0x20e3560*/ int get_ExceptionTypeToken();
                /*0x20e3568*/ int get_TryOffset();
                /*0x20e3570*/ int get_TryLength();
                /*0x20e357c*/ int get_FilterOffset();
                /*0x20e3584*/ int get_HandlerOffset();
                /*0x20e358c*/ int get_HandlerLength();
                /*0x20e3598*/ System.Reflection.ExceptionHandlingClauseOptions get_Kind();
                /*0x20e3a24*/ int GetHashCode();
                /*0x20e3a50*/ bool Equals(object obj);
                /*0x20e3ae0*/ bool Equals(System.Reflection.Emit.ExceptionHandler other);
            }

            class AssemblyBuilder : System.Reflection.Assembly, System.Runtime.InteropServices._AssemblyBuilder
            {
                static /*0x20e4148*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);
                static /*0x20e4188*/ System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable<System.Reflection.Emit.CustomAttributeBuilder> assemblyAttributes);
                /*0x20e3bc0*/ AssemblyBuilder();
                /*0x20e3bc8*/ string get_CodeBase();
                /*0x20e3c08*/ System.Reflection.MethodInfo get_EntryPoint();
                /*0x20e3c48*/ string get_EscapedCodeBase();
                /*0x20e3c88*/ System.Security.Policy.Evidence get_Evidence();
                /*0x20e3cc8*/ string get_FullName();
                /*0x20e3d08*/ bool get_GlobalAssemblyCache();
                /*0x20e3d48*/ string get_ImageRuntimeVersion();
                /*0x20e3d88*/ bool get_IsDynamic();
                /*0x20e3dc8*/ string get_Location();
                /*0x20e3e08*/ System.Reflection.Module get_ManifestModule();
                /*0x20e3e48*/ bool get_ReflectionOnly();
                /*0x20e3e88*/ void AddResourceFile(string name, string fileName);
                /*0x20e3ec8*/ void AddResourceFile(string name, string fileName, System.Reflection.ResourceAttributes attribute);
                /*0x20e3f08*/ System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, bool emitSymbolInfo);
                /*0x20e3f48*/ System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, string fileName);
                /*0x20e3f88*/ System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name, string fileName, bool emitSymbolInfo);
                /*0x20e3fc8*/ System.Resources.IResourceWriter DefineResource(string name, string description, string fileName);
                /*0x20e4008*/ System.Resources.IResourceWriter DefineResource(string name, string description, string fileName, System.Reflection.ResourceAttributes attribute);
                /*0x20e4048*/ void DefineUnmanagedResource(byte[] resource);
                /*0x20e4088*/ void DefineUnmanagedResource(string resourceFileName);
                /*0x20e40c8*/ void DefineVersionInfoResource();
                /*0x20e4108*/ void DefineVersionInfoResource(string product, string productVersion, string company, string copyright, string trademark);
                /*0x20e41c8*/ System.Reflection.Emit.ModuleBuilder DefineDynamicModule(string name);
                /*0x20e4208*/ bool Equals(object obj);
                /*0x20e4248*/ object[] GetCustomAttributes(bool inherit);
                /*0x20e4288*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20e42c8*/ System.Reflection.Emit.ModuleBuilder GetDynamicModule(string name);
                /*0x20e4308*/ System.Type[] GetExportedTypes();
                /*0x20e4348*/ System.IO.FileStream GetFile(string name);
                /*0x20e4388*/ System.IO.FileStream[] GetFiles(bool getResourceModules);
                /*0x20e43c8*/ int GetHashCode();
                /*0x20e4408*/ System.Reflection.Module[] GetLoadedModules(bool getResourceModules);
                /*0x20e4448*/ System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName);
                /*0x20e4488*/ string[] GetManifestResourceNames();
                /*0x20e44c8*/ System.IO.Stream GetManifestResourceStream(string name);
                /*0x20e4508*/ System.IO.Stream GetManifestResourceStream(System.Type type, string name);
                /*0x20e4548*/ System.Reflection.Module GetModule(string name);
                /*0x20e4588*/ System.Reflection.Module[] GetModules(bool getResourceModules);
                /*0x20e45c8*/ System.Reflection.AssemblyName GetName(bool copiedName);
                /*0x20e4608*/ System.Reflection.AssemblyName[] GetReferencedAssemblies();
                /*0x20e4648*/ System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture);
                /*0x20e4688*/ System.Reflection.Assembly GetSatelliteAssembly(System.Globalization.CultureInfo culture, System.Version version);
                /*0x20e46c8*/ System.Type GetType(string name, bool throwOnError, bool ignoreCase);
                /*0x20e4708*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20e4748*/ void Save(string assemblyFileName);
                /*0x20e4788*/ void Save(string assemblyFileName, System.Reflection.PortableExecutableKinds portableExecutableKind, System.Reflection.ImageFileMachine imageFileMachine);
                /*0x20e47c8*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20e4808*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20e4848*/ void SetEntryPoint(System.Reflection.MethodInfo entryMethod);
                /*0x20e4888*/ void SetEntryPoint(System.Reflection.MethodInfo entryMethod, System.Reflection.Emit.PEFileKinds fileKind);
                /*0x20e48c8*/ string ToString();
                /*0x20e4908*/ System.Security.PermissionSet get_PermissionSet();
                /*0x20e4940*/ void System.Runtime.InteropServices._AssemblyBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e4978*/ void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e49b0*/ void System.Runtime.InteropServices._AssemblyBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e49e8*/ void System.Runtime.InteropServices._AssemblyBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            enum AssemblyBuilderAccess
            {
                Run = 1,
                Save = 2,
                RunAndSave = 3,
                ReflectionOnly = 6,
                RunAndCollect = 9,
            }

            class ConstructorBuilder : System.Reflection.ConstructorInfo, System.Runtime.InteropServices._ConstructorBuilder
            {
                /*0x10*/ bool <InitLocals>k__BackingField;

                /*0x20e4a20*/ ConstructorBuilder();
                /*0x20e4a78*/ bool get_InitLocals();
                /*0x20e4a80*/ void set_InitLocals(bool value);
                /*0x20e4a8c*/ System.Reflection.MethodAttributes get_Attributes();
                /*0x20e4acc*/ System.Reflection.CallingConventions get_CallingConvention();
                /*0x20e4b0c*/ System.Type get_DeclaringType();
                /*0x20e4b4c*/ System.Reflection.Module get_Module();
                /*0x20e4b8c*/ string get_Name();
                /*0x20e4bcc*/ System.Type get_ReturnType();
                /*0x20e4c0c*/ System.Reflection.Emit.ParameterBuilder DefineParameter(int iSequence, System.Reflection.ParameterAttributes attributes, string strParamName);
                /*0x20e4c4c*/ System.Reflection.Emit.ILGenerator GetILGenerator();
                /*0x20e4c8c*/ System.Reflection.Emit.ILGenerator GetILGenerator(int streamSize);
                /*0x20e4ccc*/ System.Reflection.ParameterInfo[] GetParameters();
                /*0x20e4d0c*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20e4d4c*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20e4d8c*/ void SetImplementationFlags(System.Reflection.MethodImplAttributes attributes);
                /*0x20e4dcc*/ string get_Signature();
                /*0x20e4e0c*/ System.Reflection.Module GetModule();
                /*0x20e4e4c*/ System.Reflection.Emit.MethodToken GetToken();
                /*0x20e4e8c*/ void SetMethodBody(byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable<System.Reflection.Emit.ExceptionHandler> exceptionHandlers, System.Collections.Generic.IEnumerable<int> tokenFixups);
                /*0x20e4ecc*/ void AddDeclarativeSecurity(System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);
                /*0x20e4f0c*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
                /*0x20e4f4c*/ System.RuntimeMethodHandle get_MethodHandle();
                /*0x20e4f8c*/ object Invoke(System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                /*0x20e4fcc*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20e500c*/ object[] GetCustomAttributes(bool inherit);
                /*0x20e504c*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20e508c*/ System.Type get_ReflectedType();
                /*0x20e50cc*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                /*0x20e510c*/ void SetSymCustomAttribute(string name, byte[] data);
                /*0x20e514c*/ string ToString();
                /*0x20e518c*/ void System.Runtime.InteropServices._ConstructorBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e51c4*/ void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e51fc*/ void System.Runtime.InteropServices._ConstructorBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e5234*/ void System.Runtime.InteropServices._ConstructorBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class CustomAttributeBuilder : System.Runtime.InteropServices._CustomAttributeBuilder
            {
                /*0x20e526c*/ CustomAttributeBuilder(System.Reflection.ConstructorInfo con, object[] constructorArgs);
                /*0x20e52b4*/ CustomAttributeBuilder(System.Reflection.ConstructorInfo con, object[] constructorArgs, System.Reflection.FieldInfo[] namedFields, object[] fieldValues);
                /*0x20e52fc*/ CustomAttributeBuilder(System.Reflection.ConstructorInfo con, object[] constructorArgs, System.Reflection.PropertyInfo[] namedProperties, object[] propertyValues);
                /*0x20e5344*/ CustomAttributeBuilder(System.Reflection.ConstructorInfo con, object[] constructorArgs, System.Reflection.PropertyInfo[] namedProperties, object[] propertyValues, System.Reflection.FieldInfo[] namedFields, object[] fieldValues);
                /*0x20e538c*/ void System.Runtime.InteropServices._CustomAttributeBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e53c4*/ void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e53fc*/ void System.Runtime.InteropServices._CustomAttributeBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e5434*/ void System.Runtime.InteropServices._CustomAttributeBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class DynamicMethod : System.Reflection.MethodInfo
            {
                /*0x10*/ bool <InitLocals>k__BackingField;

                /*0x20e546c*/ DynamicMethod(string name, System.Type returnType, System.Type[] parameterTypes);
                /*0x20e54b4*/ DynamicMethod(string name, System.Type returnType, System.Type[] parameterTypes, bool restrictedSkipVisibility);
                /*0x20e54fc*/ DynamicMethod(string name, System.Type returnType, System.Type[] parameterTypes, System.Reflection.Module m);
                /*0x20e5544*/ DynamicMethod(string name, System.Type returnType, System.Type[] parameterTypes, System.Type owner);
                /*0x20e558c*/ DynamicMethod(string name, System.Type returnType, System.Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);
                /*0x20e55d4*/ DynamicMethod(string name, System.Type returnType, System.Type[] parameterTypes, System.Type owner, bool skipVisibility);
                /*0x20e561c*/ DynamicMethod(string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes, System.Reflection.Module m, bool skipVisibility);
                /*0x20e5664*/ DynamicMethod(string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes, System.Type owner, bool skipVisibility);
                /*0x20e56ac*/ System.Reflection.MethodAttributes get_Attributes();
                /*0x20e56ec*/ System.Reflection.CallingConventions get_CallingConvention();
                /*0x20e572c*/ System.Type get_DeclaringType();
                /*0x20e576c*/ bool get_InitLocals();
                /*0x20e5774*/ void set_InitLocals(bool value);
                /*0x20e5780*/ System.Reflection.Module get_Module();
                /*0x20e57c0*/ string get_Name();
                /*0x20e5800*/ System.Reflection.ParameterInfo get_ReturnParameter();
                /*0x20e5840*/ System.Type get_ReturnType();
                /*0x20e5880*/ System.Reflection.Emit.ILGenerator GetILGenerator();
                /*0x20e58c0*/ System.Reflection.Emit.ILGenerator GetILGenerator(int streamSize);
                /*0x20e5900*/ System.Reflection.ParameterInfo[] GetParameters();
                /*0x20e5940*/ System.RuntimeMethodHandle get_MethodHandle();
                /*0x20e5980*/ System.Type get_ReflectedType();
                /*0x20e59c0*/ System.Reflection.ICustomAttributeProvider get_ReturnTypeCustomAttributes();
                /*0x20e5a00*/ System.Delegate CreateDelegate(System.Type delegateType);
                /*0x20e5a40*/ System.Delegate CreateDelegate(System.Type delegateType, object target);
                /*0x20e5a80*/ object[] GetCustomAttributes(bool inherit);
                /*0x20e5ac0*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20e5b00*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
                /*0x20e5b40*/ System.Reflection.MethodInfo GetBaseDefinition();
                /*0x20e5b80*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                /*0x20e5bc0*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20e5c00*/ System.Reflection.Emit.ParameterBuilder DefineParameter(int position, System.Reflection.ParameterAttributes attributes, string parameterName);
                /*0x20e5c40*/ System.Reflection.Emit.DynamicILInfo GetDynamicILInfo();
                /*0x20e5c80*/ string ToString();
            }

            class EnumBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._EnumBuilder
            {
                /*0x20e5cc0*/ EnumBuilder();
                /*0x20e5d08*/ System.Reflection.Assembly get_Assembly();
                /*0x20e5d48*/ string get_AssemblyQualifiedName();
                /*0x20e5d88*/ System.Type get_BaseType();
                /*0x20e5dc8*/ System.Type get_DeclaringType();
                /*0x20e5e08*/ string get_FullName();
                /*0x20e5e48*/ System.Guid get_GUID();
                /*0x20e5e88*/ bool get_IsConstructedGenericType();
                /*0x20e5ec8*/ bool get_IsTypeDefinition();
                /*0x20e5f08*/ System.Reflection.Module get_Module();
                /*0x20e5f48*/ string get_Name();
                /*0x20e5f88*/ string get_Namespace();
                /*0x20e5fc8*/ System.Type get_ReflectedType();
                /*0x20e6008*/ System.RuntimeTypeHandle get_TypeHandle();
                /*0x20e6048*/ System.Reflection.Emit.TypeToken get_TypeToken();
                /*0x20e6088*/ System.Reflection.Emit.FieldBuilder get_UnderlyingField();
                /*0x20e60c8*/ System.Type get_UnderlyingSystemType();
                /*0x20e6108*/ System.Type CreateType();
                /*0x20e6148*/ System.Reflection.TypeInfo CreateTypeInfo();
                /*0x20e6188*/ System.Reflection.Emit.FieldBuilder DefineLiteral(string literalName, object literalValue);
                /*0x20e61c8*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
                /*0x20e6208*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20e6248*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
                /*0x20e6288*/ object[] GetCustomAttributes(bool inherit);
                /*0x20e62c8*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20e6308*/ System.Type GetElementType();
                /*0x20e6348*/ System.Type GetEnumUnderlyingType();
                /*0x20e6388*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20e63c8*/ System.Reflection.EventInfo[] GetEvents();
                /*0x20e6408*/ System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
                /*0x20e6448*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20e6488*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
                /*0x20e64c8*/ System.Type GetInterface(string name, bool ignoreCase);
                /*0x20e6508*/ System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType);
                /*0x20e6548*/ System.Type[] GetInterfaces();
                /*0x20e6588*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
                /*0x20e65c8*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
                /*0x20e6608*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20e6648*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
                /*0x20e6688*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20e66c8*/ System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
                /*0x20e6708*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
                /*0x20e6748*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20e6788*/ bool HasElementTypeImpl();
                /*0x20e67c8*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
                /*0x20e6808*/ bool IsArrayImpl();
                /*0x20e6848*/ bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo);
                /*0x20e6888*/ bool IsByRefImpl();
                /*0x20e68c8*/ bool IsCOMObjectImpl();
                /*0x20e6908*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20e6948*/ bool IsPointerImpl();
                /*0x20e6988*/ bool IsPrimitiveImpl();
                /*0x20e69c8*/ bool IsValueTypeImpl();
                /*0x20e6a08*/ System.Type MakeArrayType();
                /*0x20e6a48*/ System.Type MakeArrayType(int rank);
                /*0x20e6a88*/ System.Type MakeByRefType();
                /*0x20e6ac8*/ System.Type MakePointerType();
                /*0x20e6b08*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20e6b48*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20e6b88*/ void System.Runtime.InteropServices._EnumBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e6bc0*/ void System.Runtime.InteropServices._EnumBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e6bf8*/ void System.Runtime.InteropServices._EnumBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e6c30*/ void System.Runtime.InteropServices._EnumBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class EventBuilder : System.Runtime.InteropServices._EventBuilder
            {
                /*0x20e6c68*/ EventBuilder();
                /*0x20e6c70*/ void AddOtherMethod(System.Reflection.Emit.MethodBuilder mdBuilder);
                /*0x20e6cb0*/ void SetAddOnMethod(System.Reflection.Emit.MethodBuilder mdBuilder);
                /*0x20e6cf0*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20e6d30*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20e6d70*/ void SetRaiseMethod(System.Reflection.Emit.MethodBuilder mdBuilder);
                /*0x20e6db0*/ void SetRemoveOnMethod(System.Reflection.Emit.MethodBuilder mdBuilder);
                /*0x20e6df0*/ System.Reflection.Emit.EventToken GetEventToken();
                /*0x20e6e30*/ void System.Runtime.InteropServices._EventBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e6e68*/ void System.Runtime.InteropServices._EventBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e6ea0*/ void System.Runtime.InteropServices._EventBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e6ed8*/ void System.Runtime.InteropServices._EventBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class FieldBuilder : System.Reflection.FieldInfo, System.Runtime.InteropServices._FieldBuilder
            {
                /*0x20e6f10*/ FieldBuilder();
                /*0x20e6f58*/ System.Reflection.FieldAttributes get_Attributes();
                /*0x20e6f60*/ System.Type get_DeclaringType();
                /*0x20e6f68*/ System.RuntimeFieldHandle get_FieldHandle();
                /*0x20e6f70*/ System.Type get_FieldType();
                /*0x20e6f78*/ string get_Name();
                /*0x20e6f80*/ System.Type get_ReflectedType();
                /*0x20e6f88*/ object[] GetCustomAttributes(bool inherit);
                /*0x20e6f90*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20e6f98*/ System.Reflection.Emit.FieldToken GetToken();
                /*0x20e6fa0*/ object GetValue(object obj);
                /*0x20e6fa8*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20e6fb0*/ int get_MetadataToken();
                /*0x20e6ff0*/ System.Reflection.Module get_Module();
                /*0x20e7030*/ void SetConstant(object defaultValue);
                /*0x20e7070*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20e70b0*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20e70f0*/ void SetMarshal(System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);
                /*0x20e7130*/ void SetOffset(int iOffset);
                /*0x20e7170*/ void SetValue(object obj, object val, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, System.Globalization.CultureInfo culture);
                /*0x20e71b0*/ void System.Runtime.InteropServices._FieldBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e71e8*/ void System.Runtime.InteropServices._FieldBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e7220*/ void System.Runtime.InteropServices._FieldBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e7258*/ void System.Runtime.InteropServices._FieldBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            enum FlowControl
            {
                Branch = 0,
                Break = 1,
                Call = 2,
                Cond_Branch = 3,
                Meta = 4,
                Next = 5,
                Phi = 6,
                Return = 7,
                Throw = 8,
            }

            class GenericTypeParameterBuilder : System.Reflection.TypeInfo
            {
                /*0x20e7290*/ GenericTypeParameterBuilder();
                /*0x20e72d8*/ System.Reflection.Assembly get_Assembly();
                /*0x20e7318*/ string get_AssemblyQualifiedName();
                /*0x20e7358*/ System.Type get_BaseType();
                /*0x20e7398*/ bool get_ContainsGenericParameters();
                /*0x20e73d8*/ System.Reflection.MethodBase get_DeclaringMethod();
                /*0x20e7418*/ System.Type get_DeclaringType();
                /*0x20e7458*/ string get_FullName();
                /*0x20e7498*/ System.Reflection.GenericParameterAttributes get_GenericParameterAttributes();
                /*0x20e74d8*/ int get_GenericParameterPosition();
                /*0x20e7518*/ System.Guid get_GUID();
                /*0x20e7558*/ bool get_IsGenericParameter();
                /*0x20e7598*/ bool get_IsGenericType();
                /*0x20e75d8*/ bool get_IsGenericTypeDefinition();
                /*0x20e7618*/ System.Reflection.Module get_Module();
                /*0x20e7658*/ string get_Name();
                /*0x20e7698*/ string get_Namespace();
                /*0x20e76d8*/ System.Type get_ReflectedType();
                /*0x20e7718*/ System.RuntimeTypeHandle get_TypeHandle();
                /*0x20e7758*/ System.Type get_UnderlyingSystemType();
                /*0x20e7798*/ bool Equals(object o);
                /*0x20e77d8*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
                /*0x20e7818*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20e7858*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
                /*0x20e7898*/ object[] GetCustomAttributes(bool inherit);
                /*0x20e78d8*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20e7918*/ System.Type GetElementType();
                /*0x20e7958*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20e7998*/ System.Reflection.EventInfo[] GetEvents();
                /*0x20e79d8*/ System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
                /*0x20e7a18*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20e7a58*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
                /*0x20e7a98*/ System.Type[] GetGenericArguments();
                /*0x20e7ad8*/ System.Type[] GetGenericParameterConstraints();
                /*0x20e7b18*/ System.Type GetGenericTypeDefinition();
                /*0x20e7b58*/ int GetHashCode();
                /*0x20e7b98*/ System.Type GetInterface(string name, bool ignoreCase);
                /*0x20e7bd8*/ System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType);
                /*0x20e7c18*/ System.Type[] GetInterfaces();
                /*0x20e7c58*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
                /*0x20e7c98*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
                /*0x20e7cd8*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20e7d18*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
                /*0x20e7d58*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20e7d98*/ System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
                /*0x20e7dd8*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
                /*0x20e7e18*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20e7e58*/ bool HasElementTypeImpl();
                /*0x20e7e98*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
                /*0x20e7ed8*/ bool IsArrayImpl();
                /*0x20e7f18*/ bool IsAssignableFrom(System.Type c);
                /*0x20e7f58*/ bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo);
                /*0x20e7f98*/ bool IsByRefImpl();
                /*0x20e7fd8*/ bool IsCOMObjectImpl();
                /*0x20e8018*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20e8058*/ bool IsInstanceOfType(object o);
                /*0x20e8098*/ bool IsPointerImpl();
                /*0x20e80d8*/ bool IsPrimitiveImpl();
                /*0x20e8118*/ bool IsSubclassOf(System.Type c);
                /*0x20e8158*/ bool IsValueTypeImpl();
                /*0x20e8198*/ System.Type MakeArrayType();
                /*0x20e81d8*/ System.Type MakeArrayType(int rank);
                /*0x20e8218*/ System.Type MakeByRefType();
                /*0x20e8258*/ System.Type MakeGenericType(System.Type[] typeArguments);
                /*0x20e8298*/ System.Type MakePointerType();
                /*0x20e82d8*/ void SetBaseTypeConstraint(System.Type baseTypeConstraint);
                /*0x20e8318*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20e8358*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20e8398*/ void SetGenericParameterAttributes(System.Reflection.GenericParameterAttributes genericParameterAttributes);
                /*0x20e83d8*/ void SetInterfaceConstraints(System.Type[] interfaceConstraints);
                /*0x20e8418*/ string ToString();
            }

            class ILGenerator : System.Runtime.InteropServices._ILGenerator
            {
                /*0x20e8458*/ ILGenerator();
                /*0x20e8460*/ int get_ILOffset();
                /*0x20e84a0*/ void BeginCatchBlock(System.Type exceptionType);
                /*0x20e84e0*/ void BeginExceptFilterBlock();
                /*0x20e8520*/ System.Reflection.Emit.Label BeginExceptionBlock();
                /*0x20e8560*/ void BeginFaultBlock();
                /*0x20e85a0*/ void BeginFinallyBlock();
                /*0x20e85e0*/ void BeginScope();
                /*0x20e8620*/ System.Reflection.Emit.LocalBuilder DeclareLocal(System.Type localType);
                /*0x20e8660*/ System.Reflection.Emit.LocalBuilder DeclareLocal(System.Type localType, bool pinned);
                /*0x20e86a0*/ System.Reflection.Emit.Label DefineLabel();
                /*0x20e86e0*/ void Emit(System.Reflection.Emit.OpCode opcode);
                /*0x20e8720*/ void Emit(System.Reflection.Emit.OpCode opcode, byte arg);
                /*0x20e8760*/ void Emit(System.Reflection.Emit.OpCode opcode, double arg);
                /*0x20e87a0*/ void Emit(System.Reflection.Emit.OpCode opcode, short arg);
                /*0x20e87e0*/ void Emit(System.Reflection.Emit.OpCode opcode, int arg);
                /*0x20e8820*/ void Emit(System.Reflection.Emit.OpCode opcode, long arg);
                /*0x20e8860*/ void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.ConstructorInfo con);
                /*0x20e88a0*/ void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);
                /*0x20e88e0*/ void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);
                /*0x20e8920*/ void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);
                /*0x20e8960*/ void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);
                /*0x20e89a0*/ void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.FieldInfo field);
                /*0x20e89e0*/ void Emit(System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo meth);
                /*0x20e8a20*/ void Emit(System.Reflection.Emit.OpCode opcode, sbyte arg);
                /*0x20e8a60*/ void Emit(System.Reflection.Emit.OpCode opcode, float arg);
                /*0x20e8aa0*/ void Emit(System.Reflection.Emit.OpCode opcode, string str);
                /*0x20e8ae0*/ void Emit(System.Reflection.Emit.OpCode opcode, System.Type cls);
                /*0x20e8b20*/ void EmitCall(System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, System.Type[] optionalParameterTypes);
                /*0x20e8b60*/ void EmitCalli(System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes, System.Type[] optionalParameterTypes);
                /*0x20e8ba0*/ void EmitCalli(System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, System.Type returnType, System.Type[] parameterTypes);
                /*0x20e8be0*/ void EmitWriteLine(System.Reflection.Emit.LocalBuilder localBuilder);
                /*0x20e8c20*/ void EmitWriteLine(System.Reflection.FieldInfo fld);
                /*0x20e8c60*/ void EmitWriteLine(string value);
                /*0x20e8ca0*/ void EndExceptionBlock();
                /*0x20e8ce0*/ void EndScope();
                /*0x20e8d20*/ void MarkLabel(System.Reflection.Emit.Label loc);
                /*0x20e8d60*/ void MarkSequencePoint(System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
                /*0x20e8da0*/ void ThrowException(System.Type excType);
                /*0x20e8de0*/ void UsingNamespace(string usingNamespace);
                /*0x20e8e20*/ void System.Runtime.InteropServices._ILGenerator.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e8e58*/ void System.Runtime.InteropServices._ILGenerator.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e8e90*/ void System.Runtime.InteropServices._ILGenerator.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e8ec8*/ void System.Runtime.InteropServices._ILGenerator.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            struct Label : System.IEquatable<System.Reflection.Emit.Label>
            {
                /*0x10*/ int label;

                static /*0x20e8f90*/ bool op_Equality(System.Reflection.Emit.Label a, System.Reflection.Emit.Label b);
                static /*0x20e8f9c*/ bool op_Inequality(System.Reflection.Emit.Label a, System.Reflection.Emit.Label b);
                /*0x20e8f00*/ Label(int val);
                /*0x20e8f08*/ bool Equals(object obj);
                /*0x20e8f80*/ bool Equals(System.Reflection.Emit.Label obj);
                /*0x20e8fa8*/ int GetHashCode();
            }

            class LocalBuilder : System.Reflection.LocalVariableInfo, System.Runtime.InteropServices._LocalBuilder
            {
                /*0x20*/ string name;
                /*0x28*/ System.Reflection.Emit.ILGenerator ilgen;
                /*0x30*/ int startOffset;
                /*0x34*/ int endOffset;

                /*0x20e8fb0*/ LocalBuilder(System.Type t, System.Reflection.Emit.ILGenerator ilgen);
                /*0x20e9028*/ LocalBuilder();
                /*0x20e8fe0*/ void SetLocalSymInfo(string name, int startOffset, int endOffset);
                /*0x20e8fec*/ void SetLocalSymInfo(string name);
                /*0x20e8ff8*/ System.Type get_LocalType();
                /*0x20e9000*/ bool get_IsPinned();
                /*0x20e9008*/ int get_LocalIndex();
                /*0x20e9010*/ string get_Name();
                /*0x20e9018*/ int get_StartOffset();
                /*0x20e9020*/ int get_EndOffset();
                /*0x20e9060*/ void System.Runtime.InteropServices._LocalBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e9098*/ void System.Runtime.InteropServices._LocalBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e90d0*/ void System.Runtime.InteropServices._LocalBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e9108*/ void System.Runtime.InteropServices._LocalBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder
            {
                /*0x20e9140*/ MethodBuilder();
                /*0x20e9188*/ System.Reflection.MethodAttributes get_Attributes();
                /*0x20e91c8*/ System.Reflection.CallingConventions get_CallingConvention();
                /*0x20e9208*/ bool get_ContainsGenericParameters();
                /*0x20e9248*/ System.Type get_DeclaringType();
                /*0x20e9288*/ bool get_InitLocals();
                /*0x20e92c8*/ void set_InitLocals(bool value);
                /*0x20e9308*/ bool get_IsGenericMethod();
                /*0x20e9348*/ bool get_IsGenericMethodDefinition();
                /*0x20e9388*/ System.RuntimeMethodHandle get_MethodHandle();
                /*0x20e93c8*/ System.Reflection.Module get_Module();
                /*0x20e9408*/ string get_Name();
                /*0x20e9448*/ System.Type get_ReflectedType();
                /*0x20e9488*/ System.Reflection.ParameterInfo get_ReturnParameter();
                /*0x20e94c8*/ System.Type get_ReturnType();
                /*0x20e9508*/ System.Reflection.ICustomAttributeProvider get_ReturnTypeCustomAttributes();
                /*0x20e9548*/ string get_Signature();
                /*0x20e9588*/ void AddDeclarativeSecurity(System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);
                /*0x20e95c8*/ void CreateMethodBody(byte[] il, int count);
                /*0x20e9608*/ System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names);
                /*0x20e9648*/ System.Reflection.Emit.ParameterBuilder DefineParameter(int position, System.Reflection.ParameterAttributes attributes, string strParamName);
                /*0x20e9688*/ bool Equals(object obj);
                /*0x20e96c8*/ System.Reflection.MethodInfo GetBaseDefinition();
                /*0x20e9708*/ object[] GetCustomAttributes(bool inherit);
                /*0x20e9748*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20e9788*/ System.Type[] GetGenericArguments();
                /*0x20e97c8*/ System.Reflection.MethodInfo GetGenericMethodDefinition();
                /*0x20e9808*/ int GetHashCode();
                /*0x20e9848*/ System.Reflection.Emit.ILGenerator GetILGenerator();
                /*0x20e9888*/ System.Reflection.Emit.ILGenerator GetILGenerator(int size);
                /*0x20e98c8*/ System.Reflection.MethodImplAttributes GetMethodImplementationFlags();
                /*0x20e9908*/ System.Reflection.Module GetModule();
                /*0x20e9948*/ System.Reflection.ParameterInfo[] GetParameters();
                /*0x20e9988*/ System.Reflection.Emit.MethodToken GetToken();
                /*0x20e99c8*/ object Invoke(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);
                /*0x20e9a08*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20e9a48*/ System.Reflection.MethodInfo MakeGenericMethod(System.Type[] typeArguments);
                /*0x20e9a88*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20e9ac8*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20e9b08*/ void SetImplementationFlags(System.Reflection.MethodImplAttributes attributes);
                /*0x20e9b48*/ void SetMarshal(System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);
                /*0x20e9b88*/ void SetMethodBody(byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable<System.Reflection.Emit.ExceptionHandler> exceptionHandlers, System.Collections.Generic.IEnumerable<int> tokenFixups);
                /*0x20e9bc8*/ void SetParameters(System.Type[] parameterTypes);
                /*0x20e9c08*/ void SetReturnType(System.Type returnType);
                /*0x20e9c48*/ void SetSignature(System.Type returnType, System.Type[] returnTypeRequiredCustomModifiers, System.Type[] returnTypeOptionalCustomModifiers, System.Type[] parameterTypes, System.Type[][] parameterTypeRequiredCustomModifiers, System.Type[][] parameterTypeOptionalCustomModifiers);
                /*0x20e9c88*/ void SetSymCustomAttribute(string name, byte[] data);
                /*0x20e9cc8*/ string ToString();
                /*0x20e9d08*/ void System.Runtime.InteropServices._MethodBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e9d40*/ void System.Runtime.InteropServices._MethodBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e9d78*/ void System.Runtime.InteropServices._MethodBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e9db0*/ void System.Runtime.InteropServices._MethodBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class MethodRental : System.Runtime.InteropServices._MethodRental
            {
                static int JitImmediate = 1;
                static int JitOnDemand = 0;

                static /*0x20e9df0*/ void SwapMethodBody(System.Type cls, int methodtoken, nint rgIL, int methodSize, int flags);
                /*0x20e9de8*/ MethodRental();
                /*0x20e9e30*/ void System.Runtime.InteropServices._MethodRental.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20e9e70*/ void System.Runtime.InteropServices._MethodRental.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20e9eb0*/ void System.Runtime.InteropServices._MethodRental.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20e9ef0*/ void System.Runtime.InteropServices._MethodRental.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class ModuleBuilder : System.Reflection.Module, System.Runtime.InteropServices._ModuleBuilder
            {
                /*0x20e9f30*/ ModuleBuilder();
                /*0x20e9f90*/ System.Reflection.Assembly get_Assembly();
                /*0x20e9fd0*/ string get_FullyQualifiedName();
                /*0x20ea010*/ int get_MetadataToken();
                /*0x20ea050*/ System.Guid get_ModuleVersionId();
                /*0x20ea090*/ string get_Name();
                /*0x20ea0d0*/ string get_ScopeName();
                /*0x20ea110*/ void CreateGlobalFunctions();
                /*0x20ea150*/ System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, System.Guid language, System.Guid languageVendor, System.Guid documentType);
                /*0x20ea190*/ System.Reflection.Emit.EnumBuilder DefineEnum(string name, System.Reflection.TypeAttributes visibility, System.Type underlyingType);
                /*0x20ea1d0*/ System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes);
                /*0x20ea210*/ System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] requiredReturnTypeCustomModifiers, System.Type[] optionalReturnTypeCustomModifiers, System.Type[] parameterTypes, System.Type[][] requiredParameterTypeCustomModifiers, System.Type[][] optionalParameterTypeCustomModifiers);
                /*0x20ea250*/ System.Reflection.Emit.MethodBuilder DefineGlobalMethod(string name, System.Reflection.MethodAttributes attributes, System.Type returnType, System.Type[] parameterTypes);
                /*0x20ea290*/ System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, byte[] data, System.Reflection.FieldAttributes attributes);
                /*0x20ea2d0*/ void DefineManifestResource(string name, System.IO.Stream stream, System.Reflection.ResourceAttributes attribute);
                /*0x20ea310*/ System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);
                /*0x20ea350*/ System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);
                /*0x20ea390*/ System.Resources.IResourceWriter DefineResource(string name, string description);
                /*0x20ea3d0*/ System.Resources.IResourceWriter DefineResource(string name, string description, System.Reflection.ResourceAttributes attribute);
                /*0x20ea410*/ void DefineUnmanagedResource(byte[] resource);
                /*0x20ea450*/ void DefineUnmanagedResource(string resourceFileName);
                /*0x20ea490*/ System.Reflection.Emit.TypeBuilder DefineType(string name);
                /*0x20ea4d0*/ System.Reflection.Emit.TypeBuilder DefineType(string name, System.Reflection.TypeAttributes attr);
                /*0x20ea510*/ System.Reflection.Emit.TypeBuilder DefineType(string name, System.Reflection.TypeAttributes attr, System.Type parent);
                /*0x20ea550*/ System.Reflection.Emit.TypeBuilder DefineType(string name, System.Reflection.TypeAttributes attr, System.Type parent, int typesize);
                /*0x20ea590*/ System.Reflection.Emit.TypeBuilder DefineType(string name, System.Reflection.TypeAttributes attr, System.Type parent, System.Reflection.Emit.PackingSize packsize);
                /*0x20ea5d0*/ System.Reflection.Emit.TypeBuilder DefineType(string name, System.Reflection.TypeAttributes attr, System.Type parent, System.Reflection.Emit.PackingSize packingSize, int typesize);
                /*0x20ea610*/ System.Reflection.Emit.TypeBuilder DefineType(string name, System.Reflection.TypeAttributes attr, System.Type parent, System.Type[] interfaces);
                /*0x20ea650*/ System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int size, System.Reflection.FieldAttributes attributes);
                /*0x20ea690*/ bool Equals(object obj);
                /*0x20ea6d0*/ System.Reflection.MethodInfo GetArrayMethod(System.Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes);
                /*0x20ea710*/ System.Reflection.Emit.MethodToken GetArrayMethodToken(System.Type arrayClass, string methodName, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes);
                /*0x20ea750*/ System.Reflection.Emit.MethodToken GetConstructorToken(System.Reflection.ConstructorInfo con);
                /*0x20ea790*/ System.Reflection.Emit.MethodToken GetConstructorToken(System.Reflection.ConstructorInfo constructor, System.Collections.Generic.IEnumerable<System.Type> optionalParameterTypes);
                /*0x20ea7d0*/ object[] GetCustomAttributes(bool inherit);
                /*0x20ea810*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20ea850*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20ea890*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingFlags);
                /*0x20ea8d0*/ System.Reflection.Emit.FieldToken GetFieldToken(System.Reflection.FieldInfo field);
                /*0x20ea910*/ int GetHashCode();
                /*0x20ea950*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20ea990*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingFlags);
                /*0x20ea9d0*/ System.Reflection.Emit.MethodToken GetMethodToken(System.Reflection.MethodInfo method);
                /*0x20eaa10*/ System.Reflection.Emit.MethodToken GetMethodToken(System.Reflection.MethodInfo method, System.Collections.Generic.IEnumerable<System.Type> optionalParameterTypes);
                /*0x20eaa50*/ System.Reflection.Emit.SignatureToken GetSignatureToken(byte[] sigBytes, int sigLength);
                /*0x20eaa90*/ System.Reflection.Emit.SignatureToken GetSignatureToken(System.Reflection.Emit.SignatureHelper sigHelper);
                /*0x20eaad0*/ System.Reflection.Emit.StringToken GetStringConstant(string str);
                /*0x20eab10*/ System.Diagnostics.SymbolStore.ISymbolWriter GetSymWriter();
                /*0x20eab50*/ System.Type GetType(string className);
                /*0x20eab90*/ System.Type GetType(string className, bool ignoreCase);
                /*0x20eabd0*/ System.Type GetType(string className, bool throwOnError, bool ignoreCase);
                /*0x20eac10*/ System.Type[] GetTypes();
                /*0x20eac50*/ System.Reflection.Emit.TypeToken GetTypeToken(string name);
                /*0x20eac90*/ System.Reflection.Emit.TypeToken GetTypeToken(System.Type type);
                /*0x20eacd0*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20ead10*/ bool IsResource();
                /*0x20ead50*/ bool IsTransient();
                /*0x20ead90*/ System.Reflection.FieldInfo ResolveField(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
                /*0x20eadd0*/ System.Reflection.MemberInfo ResolveMember(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
                /*0x20eae10*/ System.Reflection.MethodBase ResolveMethod(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
                /*0x20eae50*/ byte[] ResolveSignature(int metadataToken);
                /*0x20eae90*/ string ResolveString(int metadataToken);
                /*0x20eaed0*/ System.Type ResolveType(int metadataToken, System.Type[] genericTypeArguments, System.Type[] genericMethodArguments);
                /*0x20eaf10*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20eaf50*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20eaf90*/ void SetSymCustomAttribute(string name, byte[] data);
                /*0x20eafd0*/ void SetUserEntryPoint(System.Reflection.MethodInfo entryPoint);
                /*0x20eb010*/ void System.Runtime.InteropServices._ModuleBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20eb048*/ void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20eb080*/ void System.Runtime.InteropServices._ModuleBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20eb0b8*/ void System.Runtime.InteropServices._ModuleBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            struct MethodToken : System.IEquatable<System.Reflection.Emit.MethodToken>
            {
                static /*0x0*/ System.Reflection.Emit.MethodToken Empty;

                static /*0x20eb1f0*/ bool op_Equality(System.Reflection.Emit.MethodToken a, System.Reflection.Emit.MethodToken b);
                static /*0x20eb230*/ bool op_Inequality(System.Reflection.Emit.MethodToken a, System.Reflection.Emit.MethodToken b);
                /*0x20eb0f0*/ int get_Token();
                /*0x20eb130*/ bool Equals(object obj);
                /*0x20eb170*/ bool Equals(System.Reflection.Emit.MethodToken obj);
                /*0x20eb1b0*/ int GetHashCode();
            }

            struct SignatureToken : System.IEquatable<System.Reflection.Emit.SignatureToken>
            {
                static /*0x0*/ System.Reflection.Emit.SignatureToken Empty;

                static /*0x20eb370*/ bool op_Equality(System.Reflection.Emit.SignatureToken a, System.Reflection.Emit.SignatureToken b);
                static /*0x20eb3b0*/ bool op_Inequality(System.Reflection.Emit.SignatureToken a, System.Reflection.Emit.SignatureToken b);
                /*0x20eb270*/ int get_Token();
                /*0x20eb2b0*/ bool Equals(object obj);
                /*0x20eb2f0*/ bool Equals(System.Reflection.Emit.SignatureToken obj);
                /*0x20eb330*/ int GetHashCode();
            }

            struct FieldToken : System.IEquatable<System.Reflection.Emit.FieldToken>
            {
                static /*0x0*/ System.Reflection.Emit.FieldToken Empty;

                static /*0x20eb4f0*/ bool op_Equality(System.Reflection.Emit.FieldToken a, System.Reflection.Emit.FieldToken b);
                static /*0x20eb530*/ bool op_Inequality(System.Reflection.Emit.FieldToken a, System.Reflection.Emit.FieldToken b);
                /*0x20eb3f0*/ int get_Token();
                /*0x20eb430*/ bool Equals(object obj);
                /*0x20eb470*/ bool Equals(System.Reflection.Emit.FieldToken obj);
                /*0x20eb4b0*/ int GetHashCode();
            }

            struct StringToken : System.IEquatable<System.Reflection.Emit.StringToken>
            {
                /*0x10*/ int DummyAddedByUnityProfileStubber;

                static /*0x20eb670*/ bool op_Equality(System.Reflection.Emit.StringToken a, System.Reflection.Emit.StringToken b);
                static /*0x20eb6b0*/ bool op_Inequality(System.Reflection.Emit.StringToken a, System.Reflection.Emit.StringToken b);
                /*0x20eb570*/ int get_Token();
                /*0x20eb5b0*/ bool Equals(object obj);
                /*0x20eb5f0*/ bool Equals(System.Reflection.Emit.StringToken obj);
                /*0x20eb630*/ int GetHashCode();
            }

            struct TypeToken : System.IEquatable<System.Reflection.Emit.TypeToken>
            {
                static /*0x0*/ System.Reflection.Emit.TypeToken Empty;

                static /*0x20eb7f0*/ bool op_Equality(System.Reflection.Emit.TypeToken a, System.Reflection.Emit.TypeToken b);
                static /*0x20eb830*/ bool op_Inequality(System.Reflection.Emit.TypeToken a, System.Reflection.Emit.TypeToken b);
                /*0x20eb6f0*/ int get_Token();
                /*0x20eb730*/ bool Equals(object obj);
                /*0x20eb770*/ bool Equals(System.Reflection.Emit.TypeToken obj);
                /*0x20eb7b0*/ int GetHashCode();
            }

            class DynamicILInfo
            {
                /*0x20eb870*/ DynamicILInfo();
                /*0x20eb8b8*/ System.Reflection.Emit.DynamicMethod get_DynamicMethod();
                /*0x20eb8f8*/ int GetTokenFor(byte[] signature);
                /*0x20eb938*/ int GetTokenFor(System.Reflection.Emit.DynamicMethod method);
                /*0x20eb978*/ int GetTokenFor(System.RuntimeFieldHandle field);
                /*0x20eb9b8*/ int GetTokenFor(System.RuntimeFieldHandle field, System.RuntimeTypeHandle contextType);
                /*0x20eb9f8*/ int GetTokenFor(System.RuntimeMethodHandle method);
                /*0x20eba38*/ int GetTokenFor(System.RuntimeMethodHandle method, System.RuntimeTypeHandle contextType);
                /*0x20eba78*/ int GetTokenFor(System.RuntimeTypeHandle type);
                /*0x20ebab8*/ int GetTokenFor(string literal);
                /*0x20ebaf8*/ void SetCode(byte* code, int codeSize, int maxStackSize);
                /*0x20ebb38*/ void SetCode(byte[] code, int maxStackSize);
                /*0x20ebb78*/ void SetExceptions(byte* exceptions, int exceptionsSize);
                /*0x20ebbb8*/ void SetExceptions(byte[] exceptions);
                /*0x20ebbf8*/ void SetLocalSignature(byte* localSignature, int signatureSize);
                /*0x20ebc38*/ void SetLocalSignature(byte[] localSignature);
            }

            struct EventToken : System.IEquatable<System.Reflection.Emit.EventToken>
            {
                static /*0x0*/ System.Reflection.Emit.EventToken Empty;

                static /*0x20ebd78*/ bool op_Equality(System.Reflection.Emit.EventToken a, System.Reflection.Emit.EventToken b);
                static /*0x20ebdb8*/ bool op_Inequality(System.Reflection.Emit.EventToken a, System.Reflection.Emit.EventToken b);
                /*0x20ebc78*/ int get_Token();
                /*0x20ebcb8*/ bool Equals(object obj);
                /*0x20ebcf8*/ bool Equals(System.Reflection.Emit.EventToken obj);
                /*0x20ebd38*/ int GetHashCode();
            }

            struct ParameterToken : System.IEquatable<System.Reflection.Emit.ParameterToken>
            {
                static /*0x0*/ System.Reflection.Emit.ParameterToken Empty;

                static /*0x20ebef8*/ bool op_Equality(System.Reflection.Emit.ParameterToken a, System.Reflection.Emit.ParameterToken b);
                static /*0x20ebf38*/ bool op_Inequality(System.Reflection.Emit.ParameterToken a, System.Reflection.Emit.ParameterToken b);
                /*0x20ebdf8*/ int get_Token();
                /*0x20ebe38*/ bool Equals(object obj);
                /*0x20ebe78*/ bool Equals(System.Reflection.Emit.ParameterToken obj);
                /*0x20ebeb8*/ int GetHashCode();
            }

            struct PropertyToken : System.IEquatable<System.Reflection.Emit.PropertyToken>
            {
                static /*0x0*/ System.Reflection.Emit.PropertyToken Empty;

                static /*0x20ec078*/ bool op_Equality(System.Reflection.Emit.PropertyToken a, System.Reflection.Emit.PropertyToken b);
                static /*0x20ec0b8*/ bool op_Inequality(System.Reflection.Emit.PropertyToken a, System.Reflection.Emit.PropertyToken b);
                /*0x20ebf78*/ int get_Token();
                /*0x20ebfb8*/ bool Equals(object obj);
                /*0x20ebff8*/ bool Equals(System.Reflection.Emit.PropertyToken obj);
                /*0x20ec038*/ int GetHashCode();
            }

            struct OpCode : System.IEquatable<System.Reflection.Emit.OpCode>
            {
                /*0x10*/ byte op1;
                /*0x11*/ byte op2;
                /*0x12*/ byte push;
                /*0x13*/ byte pop;
                /*0x14*/ byte size;
                /*0x15*/ byte type;
                /*0x16*/ byte args;
                /*0x17*/ byte flow;

                static /*0x20ec2f4*/ bool op_Equality(System.Reflection.Emit.OpCode a, System.Reflection.Emit.OpCode b);
                static /*0x20ec304*/ bool op_Inequality(System.Reflection.Emit.OpCode a, System.Reflection.Emit.OpCode b);
                /*0x20ec0f8*/ OpCode(int p, int q);
                /*0x20ec134*/ int GetHashCode();
                /*0x20ec1ec*/ bool Equals(object obj);
                /*0x20ec274*/ bool Equals(System.Reflection.Emit.OpCode obj);
                /*0x20ec29c*/ string ToString();
                /*0x20ec154*/ string get_Name();
                /*0x20ec2a0*/ int get_Size();
                /*0x20ec2a8*/ System.Reflection.Emit.OpCodeType get_OpCodeType();
                /*0x20ec2b0*/ System.Reflection.Emit.OperandType get_OperandType();
                /*0x20ec2b8*/ System.Reflection.Emit.FlowControl get_FlowControl();
                /*0x20ec2c0*/ System.Reflection.Emit.StackBehaviour get_StackBehaviourPop();
                /*0x20ec2c8*/ System.Reflection.Emit.StackBehaviour get_StackBehaviourPush();
                /*0x20ec2d0*/ short get_Value();
            }

            class OpCodeNames
            {
                static /*0x0*/ string[] names;

                static /*0x20ec314*/ OpCodeNames();
            }

            class OpCodes
            {
                static /*0x0*/ System.Reflection.Emit.OpCode Nop;
                static /*0x8*/ System.Reflection.Emit.OpCode Break;
                static /*0x10*/ System.Reflection.Emit.OpCode Ldarg_0;
                static /*0x18*/ System.Reflection.Emit.OpCode Ldarg_1;
                static /*0x20*/ System.Reflection.Emit.OpCode Ldarg_2;
                static /*0x28*/ System.Reflection.Emit.OpCode Ldarg_3;
                static /*0x30*/ System.Reflection.Emit.OpCode Ldloc_0;
                static /*0x38*/ System.Reflection.Emit.OpCode Ldloc_1;
                static /*0x40*/ System.Reflection.Emit.OpCode Ldloc_2;
                static /*0x48*/ System.Reflection.Emit.OpCode Ldloc_3;
                static /*0x50*/ System.Reflection.Emit.OpCode Stloc_0;
                static /*0x58*/ System.Reflection.Emit.OpCode Stloc_1;
                static /*0x60*/ System.Reflection.Emit.OpCode Stloc_2;
                static /*0x68*/ System.Reflection.Emit.OpCode Stloc_3;
                static /*0x70*/ System.Reflection.Emit.OpCode Ldarg_S;
                static /*0x78*/ System.Reflection.Emit.OpCode Ldarga_S;
                static /*0x80*/ System.Reflection.Emit.OpCode Starg_S;
                static /*0x88*/ System.Reflection.Emit.OpCode Ldloc_S;
                static /*0x90*/ System.Reflection.Emit.OpCode Ldloca_S;
                static /*0x98*/ System.Reflection.Emit.OpCode Stloc_S;
                static /*0xa0*/ System.Reflection.Emit.OpCode Ldnull;
                static /*0xa8*/ System.Reflection.Emit.OpCode Ldc_I4_M1;
                static /*0xb0*/ System.Reflection.Emit.OpCode Ldc_I4_0;
                static /*0xb8*/ System.Reflection.Emit.OpCode Ldc_I4_1;
                static /*0xc0*/ System.Reflection.Emit.OpCode Ldc_I4_2;
                static /*0xc8*/ System.Reflection.Emit.OpCode Ldc_I4_3;
                static /*0xd0*/ System.Reflection.Emit.OpCode Ldc_I4_4;
                static /*0xd8*/ System.Reflection.Emit.OpCode Ldc_I4_5;
                static /*0xe0*/ System.Reflection.Emit.OpCode Ldc_I4_6;
                static /*0xe8*/ System.Reflection.Emit.OpCode Ldc_I4_7;
                static /*0xf0*/ System.Reflection.Emit.OpCode Ldc_I4_8;
                static /*0xf8*/ System.Reflection.Emit.OpCode Ldc_I4_S;
                static /*0x100*/ System.Reflection.Emit.OpCode Ldc_I4;
                static /*0x108*/ System.Reflection.Emit.OpCode Ldc_I8;
                static /*0x110*/ System.Reflection.Emit.OpCode Ldc_R4;
                static /*0x118*/ System.Reflection.Emit.OpCode Ldc_R8;
                static /*0x120*/ System.Reflection.Emit.OpCode Dup;
                static /*0x128*/ System.Reflection.Emit.OpCode Pop;
                static /*0x130*/ System.Reflection.Emit.OpCode Jmp;
                static /*0x138*/ System.Reflection.Emit.OpCode Call;
                static /*0x140*/ System.Reflection.Emit.OpCode Calli;
                static /*0x148*/ System.Reflection.Emit.OpCode Ret;
                static /*0x150*/ System.Reflection.Emit.OpCode Br_S;
                static /*0x158*/ System.Reflection.Emit.OpCode Brfalse_S;
                static /*0x160*/ System.Reflection.Emit.OpCode Brtrue_S;
                static /*0x168*/ System.Reflection.Emit.OpCode Beq_S;
                static /*0x170*/ System.Reflection.Emit.OpCode Bge_S;
                static /*0x178*/ System.Reflection.Emit.OpCode Bgt_S;
                static /*0x180*/ System.Reflection.Emit.OpCode Ble_S;
                static /*0x188*/ System.Reflection.Emit.OpCode Blt_S;
                static /*0x190*/ System.Reflection.Emit.OpCode Bne_Un_S;
                static /*0x198*/ System.Reflection.Emit.OpCode Bge_Un_S;
                static /*0x1a0*/ System.Reflection.Emit.OpCode Bgt_Un_S;
                static /*0x1a8*/ System.Reflection.Emit.OpCode Ble_Un_S;
                static /*0x1b0*/ System.Reflection.Emit.OpCode Blt_Un_S;
                static /*0x1b8*/ System.Reflection.Emit.OpCode Br;
                static /*0x1c0*/ System.Reflection.Emit.OpCode Brfalse;
                static /*0x1c8*/ System.Reflection.Emit.OpCode Brtrue;
                static /*0x1d0*/ System.Reflection.Emit.OpCode Beq;
                static /*0x1d8*/ System.Reflection.Emit.OpCode Bge;
                static /*0x1e0*/ System.Reflection.Emit.OpCode Bgt;
                static /*0x1e8*/ System.Reflection.Emit.OpCode Ble;
                static /*0x1f0*/ System.Reflection.Emit.OpCode Blt;
                static /*0x1f8*/ System.Reflection.Emit.OpCode Bne_Un;
                static /*0x200*/ System.Reflection.Emit.OpCode Bge_Un;
                static /*0x208*/ System.Reflection.Emit.OpCode Bgt_Un;
                static /*0x210*/ System.Reflection.Emit.OpCode Ble_Un;
                static /*0x218*/ System.Reflection.Emit.OpCode Blt_Un;
                static /*0x220*/ System.Reflection.Emit.OpCode Switch;
                static /*0x228*/ System.Reflection.Emit.OpCode Ldind_I1;
                static /*0x230*/ System.Reflection.Emit.OpCode Ldind_U1;
                static /*0x238*/ System.Reflection.Emit.OpCode Ldind_I2;
                static /*0x240*/ System.Reflection.Emit.OpCode Ldind_U2;
                static /*0x248*/ System.Reflection.Emit.OpCode Ldind_I4;
                static /*0x250*/ System.Reflection.Emit.OpCode Ldind_U4;
                static /*0x258*/ System.Reflection.Emit.OpCode Ldind_I8;
                static /*0x260*/ System.Reflection.Emit.OpCode Ldind_I;
                static /*0x268*/ System.Reflection.Emit.OpCode Ldind_R4;
                static /*0x270*/ System.Reflection.Emit.OpCode Ldind_R8;
                static /*0x278*/ System.Reflection.Emit.OpCode Ldind_Ref;
                static /*0x280*/ System.Reflection.Emit.OpCode Stind_Ref;
                static /*0x288*/ System.Reflection.Emit.OpCode Stind_I1;
                static /*0x290*/ System.Reflection.Emit.OpCode Stind_I2;
                static /*0x298*/ System.Reflection.Emit.OpCode Stind_I4;
                static /*0x2a0*/ System.Reflection.Emit.OpCode Stind_I8;
                static /*0x2a8*/ System.Reflection.Emit.OpCode Stind_R4;
                static /*0x2b0*/ System.Reflection.Emit.OpCode Stind_R8;
                static /*0x2b8*/ System.Reflection.Emit.OpCode Add;
                static /*0x2c0*/ System.Reflection.Emit.OpCode Sub;
                static /*0x2c8*/ System.Reflection.Emit.OpCode Mul;
                static /*0x2d0*/ System.Reflection.Emit.OpCode Div;
                static /*0x2d8*/ System.Reflection.Emit.OpCode Div_Un;
                static /*0x2e0*/ System.Reflection.Emit.OpCode Rem;
                static /*0x2e8*/ System.Reflection.Emit.OpCode Rem_Un;
                static /*0x2f0*/ System.Reflection.Emit.OpCode And;
                static /*0x2f8*/ System.Reflection.Emit.OpCode Or;
                static /*0x300*/ System.Reflection.Emit.OpCode Xor;
                static /*0x308*/ System.Reflection.Emit.OpCode Shl;
                static /*0x310*/ System.Reflection.Emit.OpCode Shr;
                static /*0x318*/ System.Reflection.Emit.OpCode Shr_Un;
                static /*0x320*/ System.Reflection.Emit.OpCode Neg;
                static /*0x328*/ System.Reflection.Emit.OpCode Not;
                static /*0x330*/ System.Reflection.Emit.OpCode Conv_I1;
                static /*0x338*/ System.Reflection.Emit.OpCode Conv_I2;
                static /*0x340*/ System.Reflection.Emit.OpCode Conv_I4;
                static /*0x348*/ System.Reflection.Emit.OpCode Conv_I8;
                static /*0x350*/ System.Reflection.Emit.OpCode Conv_R4;
                static /*0x358*/ System.Reflection.Emit.OpCode Conv_R8;
                static /*0x360*/ System.Reflection.Emit.OpCode Conv_U4;
                static /*0x368*/ System.Reflection.Emit.OpCode Conv_U8;
                static /*0x370*/ System.Reflection.Emit.OpCode Callvirt;
                static /*0x378*/ System.Reflection.Emit.OpCode Cpobj;
                static /*0x380*/ System.Reflection.Emit.OpCode Ldobj;
                static /*0x388*/ System.Reflection.Emit.OpCode Ldstr;
                static /*0x390*/ System.Reflection.Emit.OpCode Newobj;
                static /*0x398*/ System.Reflection.Emit.OpCode Castclass;
                static /*0x3a0*/ System.Reflection.Emit.OpCode Isinst;
                static /*0x3a8*/ System.Reflection.Emit.OpCode Conv_R_Un;
                static /*0x3b0*/ System.Reflection.Emit.OpCode Unbox;
                static /*0x3b8*/ System.Reflection.Emit.OpCode Throw;
                static /*0x3c0*/ System.Reflection.Emit.OpCode Ldfld;
                static /*0x3c8*/ System.Reflection.Emit.OpCode Ldflda;
                static /*0x3d0*/ System.Reflection.Emit.OpCode Stfld;
                static /*0x3d8*/ System.Reflection.Emit.OpCode Ldsfld;
                static /*0x3e0*/ System.Reflection.Emit.OpCode Ldsflda;
                static /*0x3e8*/ System.Reflection.Emit.OpCode Stsfld;
                static /*0x3f0*/ System.Reflection.Emit.OpCode Stobj;
                static /*0x3f8*/ System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;
                static /*0x400*/ System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;
                static /*0x408*/ System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;
                static /*0x410*/ System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;
                static /*0x418*/ System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;
                static /*0x420*/ System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;
                static /*0x428*/ System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;
                static /*0x430*/ System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;
                static /*0x438*/ System.Reflection.Emit.OpCode Conv_Ovf_I_Un;
                static /*0x440*/ System.Reflection.Emit.OpCode Conv_Ovf_U_Un;
                static /*0x448*/ System.Reflection.Emit.OpCode Box;
                static /*0x450*/ System.Reflection.Emit.OpCode Newarr;
                static /*0x458*/ System.Reflection.Emit.OpCode Ldlen;
                static /*0x460*/ System.Reflection.Emit.OpCode Ldelema;
                static /*0x468*/ System.Reflection.Emit.OpCode Ldelem_I1;
                static /*0x470*/ System.Reflection.Emit.OpCode Ldelem_U1;
                static /*0x478*/ System.Reflection.Emit.OpCode Ldelem_I2;
                static /*0x480*/ System.Reflection.Emit.OpCode Ldelem_U2;
                static /*0x488*/ System.Reflection.Emit.OpCode Ldelem_I4;
                static /*0x490*/ System.Reflection.Emit.OpCode Ldelem_U4;
                static /*0x498*/ System.Reflection.Emit.OpCode Ldelem_I8;
                static /*0x4a0*/ System.Reflection.Emit.OpCode Ldelem_I;
                static /*0x4a8*/ System.Reflection.Emit.OpCode Ldelem_R4;
                static /*0x4b0*/ System.Reflection.Emit.OpCode Ldelem_R8;
                static /*0x4b8*/ System.Reflection.Emit.OpCode Ldelem_Ref;
                static /*0x4c0*/ System.Reflection.Emit.OpCode Stelem_I;
                static /*0x4c8*/ System.Reflection.Emit.OpCode Stelem_I1;
                static /*0x4d0*/ System.Reflection.Emit.OpCode Stelem_I2;
                static /*0x4d8*/ System.Reflection.Emit.OpCode Stelem_I4;
                static /*0x4e0*/ System.Reflection.Emit.OpCode Stelem_I8;
                static /*0x4e8*/ System.Reflection.Emit.OpCode Stelem_R4;
                static /*0x4f0*/ System.Reflection.Emit.OpCode Stelem_R8;
                static /*0x4f8*/ System.Reflection.Emit.OpCode Stelem_Ref;
                static /*0x500*/ System.Reflection.Emit.OpCode Ldelem;
                static /*0x508*/ System.Reflection.Emit.OpCode Stelem;
                static /*0x510*/ System.Reflection.Emit.OpCode Unbox_Any;
                static /*0x518*/ System.Reflection.Emit.OpCode Conv_Ovf_I1;
                static /*0x520*/ System.Reflection.Emit.OpCode Conv_Ovf_U1;
                static /*0x528*/ System.Reflection.Emit.OpCode Conv_Ovf_I2;
                static /*0x530*/ System.Reflection.Emit.OpCode Conv_Ovf_U2;
                static /*0x538*/ System.Reflection.Emit.OpCode Conv_Ovf_I4;
                static /*0x540*/ System.Reflection.Emit.OpCode Conv_Ovf_U4;
                static /*0x548*/ System.Reflection.Emit.OpCode Conv_Ovf_I8;
                static /*0x550*/ System.Reflection.Emit.OpCode Conv_Ovf_U8;
                static /*0x558*/ System.Reflection.Emit.OpCode Refanyval;
                static /*0x560*/ System.Reflection.Emit.OpCode Ckfinite;
                static /*0x568*/ System.Reflection.Emit.OpCode Mkrefany;
                static /*0x570*/ System.Reflection.Emit.OpCode Ldtoken;
                static /*0x578*/ System.Reflection.Emit.OpCode Conv_U2;
                static /*0x580*/ System.Reflection.Emit.OpCode Conv_U1;
                static /*0x588*/ System.Reflection.Emit.OpCode Conv_I;
                static /*0x590*/ System.Reflection.Emit.OpCode Conv_Ovf_I;
                static /*0x598*/ System.Reflection.Emit.OpCode Conv_Ovf_U;
                static /*0x5a0*/ System.Reflection.Emit.OpCode Add_Ovf;
                static /*0x5a8*/ System.Reflection.Emit.OpCode Add_Ovf_Un;
                static /*0x5b0*/ System.Reflection.Emit.OpCode Mul_Ovf;
                static /*0x5b8*/ System.Reflection.Emit.OpCode Mul_Ovf_Un;
                static /*0x5c0*/ System.Reflection.Emit.OpCode Sub_Ovf;
                static /*0x5c8*/ System.Reflection.Emit.OpCode Sub_Ovf_Un;
                static /*0x5d0*/ System.Reflection.Emit.OpCode Endfinally;
                static /*0x5d8*/ System.Reflection.Emit.OpCode Leave;
                static /*0x5e0*/ System.Reflection.Emit.OpCode Leave_S;
                static /*0x5e8*/ System.Reflection.Emit.OpCode Stind_I;
                static /*0x5f0*/ System.Reflection.Emit.OpCode Conv_U;
                static /*0x5f8*/ System.Reflection.Emit.OpCode Prefix7;
                static /*0x600*/ System.Reflection.Emit.OpCode Prefix6;
                static /*0x608*/ System.Reflection.Emit.OpCode Prefix5;
                static /*0x610*/ System.Reflection.Emit.OpCode Prefix4;
                static /*0x618*/ System.Reflection.Emit.OpCode Prefix3;
                static /*0x620*/ System.Reflection.Emit.OpCode Prefix2;
                static /*0x628*/ System.Reflection.Emit.OpCode Prefix1;
                static /*0x630*/ System.Reflection.Emit.OpCode Prefixref;
                static /*0x638*/ System.Reflection.Emit.OpCode Arglist;
                static /*0x640*/ System.Reflection.Emit.OpCode Ceq;
                static /*0x648*/ System.Reflection.Emit.OpCode Cgt;
                static /*0x650*/ System.Reflection.Emit.OpCode Cgt_Un;
                static /*0x658*/ System.Reflection.Emit.OpCode Clt;
                static /*0x660*/ System.Reflection.Emit.OpCode Clt_Un;
                static /*0x668*/ System.Reflection.Emit.OpCode Ldftn;
                static /*0x670*/ System.Reflection.Emit.OpCode Ldvirtftn;
                static /*0x678*/ System.Reflection.Emit.OpCode Ldarg;
                static /*0x680*/ System.Reflection.Emit.OpCode Ldarga;
                static /*0x688*/ System.Reflection.Emit.OpCode Starg;
                static /*0x690*/ System.Reflection.Emit.OpCode Ldloc;
                static /*0x698*/ System.Reflection.Emit.OpCode Ldloca;
                static /*0x6a0*/ System.Reflection.Emit.OpCode Stloc;
                static /*0x6a8*/ System.Reflection.Emit.OpCode Localloc;
                static /*0x6b0*/ System.Reflection.Emit.OpCode Endfilter;
                static /*0x6b8*/ System.Reflection.Emit.OpCode Unaligned;
                static /*0x6c0*/ System.Reflection.Emit.OpCode Volatile;
                static /*0x6c8*/ System.Reflection.Emit.OpCode Tailcall;
                static /*0x6d0*/ System.Reflection.Emit.OpCode Initobj;
                static /*0x6d8*/ System.Reflection.Emit.OpCode Constrained;
                static /*0x6e0*/ System.Reflection.Emit.OpCode Cpblk;
                static /*0x6e8*/ System.Reflection.Emit.OpCode Initblk;
                static /*0x6f0*/ System.Reflection.Emit.OpCode Rethrow;
                static /*0x6f8*/ System.Reflection.Emit.OpCode Sizeof;
                static /*0x700*/ System.Reflection.Emit.OpCode Refanytype;
                static /*0x708*/ System.Reflection.Emit.OpCode Readonly;

                static /*0x20efc48*/ OpCodes();
                static /*0x20efc20*/ bool TakesSingleByteArgument(System.Reflection.Emit.OpCode inst);
                /*0x20efc18*/ OpCodes();
            }

            enum PEFileKinds
            {
                Dll = 1,
                ConsoleApplication = 2,
                WindowApplication = 3,
            }

            class ParameterBuilder : System.Runtime.InteropServices._ParameterBuilder
            {
                /*0x20f0c10*/ ParameterBuilder();
                /*0x20f0c18*/ int get_Attributes();
                /*0x20f0c58*/ bool get_IsIn();
                /*0x20f0c98*/ bool get_IsOptional();
                /*0x20f0cd8*/ bool get_IsOut();
                /*0x20f0d18*/ string get_Name();
                /*0x20f0d58*/ int get_Position();
                /*0x20f0d98*/ void SetConstant(object defaultValue);
                /*0x20f0dd8*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20f0e18*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20f0e58*/ void SetMarshal(System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);
                /*0x20f0e98*/ System.Reflection.Emit.ParameterToken GetToken();
                /*0x20f0ed8*/ void System.Runtime.InteropServices._ParameterBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20f0f10*/ void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20f0f48*/ void System.Runtime.InteropServices._ParameterBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20f0f80*/ void System.Runtime.InteropServices._ParameterBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class PropertyBuilder : System.Reflection.PropertyInfo, System.Runtime.InteropServices._PropertyBuilder
            {
                /*0x20f0fb8*/ PropertyBuilder();
                /*0x20f1000*/ System.Reflection.PropertyAttributes get_Attributes();
                /*0x20f1040*/ bool get_CanRead();
                /*0x20f1080*/ bool get_CanWrite();
                /*0x20f10c0*/ System.Type get_DeclaringType();
                /*0x20f1100*/ System.Reflection.Module get_Module();
                /*0x20f1140*/ string get_Name();
                /*0x20f1180*/ System.Reflection.Emit.PropertyToken get_PropertyToken();
                /*0x20f11c0*/ System.Type get_PropertyType();
                /*0x20f1200*/ System.Type get_ReflectedType();
                /*0x20f1240*/ void AddOtherMethod(System.Reflection.Emit.MethodBuilder mdBuilder);
                /*0x20f1280*/ System.Reflection.MethodInfo[] GetAccessors(bool nonPublic);
                /*0x20f12c0*/ object[] GetCustomAttributes(bool inherit);
                /*0x20f1300*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20f1340*/ System.Reflection.MethodInfo GetGetMethod(bool nonPublic);
                /*0x20f1380*/ System.Reflection.ParameterInfo[] GetIndexParameters();
                /*0x20f13c0*/ System.Reflection.MethodInfo GetSetMethod(bool nonPublic);
                /*0x20f1400*/ object GetValue(object obj, object[] index);
                /*0x20f1440*/ object GetValue(object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
                /*0x20f1480*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20f14c0*/ void SetConstant(object defaultValue);
                /*0x20f1500*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20f1540*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20f1580*/ void SetGetMethod(System.Reflection.Emit.MethodBuilder mdBuilder);
                /*0x20f15c0*/ void SetSetMethod(System.Reflection.Emit.MethodBuilder mdBuilder);
                /*0x20f1600*/ void SetValue(object obj, object value, object[] index);
                /*0x20f1640*/ void SetValue(object obj, object value, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] index, System.Globalization.CultureInfo culture);
                /*0x20f1680*/ void System.Runtime.InteropServices._PropertyBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20f16b8*/ void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20f16f0*/ void System.Runtime.InteropServices._PropertyBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20f1728*/ void System.Runtime.InteropServices._PropertyBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class SignatureHelper : System.Runtime.InteropServices._SignatureHelper
            {
                static /*0x20f18a8*/ System.Reflection.Emit.SignatureHelper GetFieldSigHelper(System.Reflection.Module mod);
                static /*0x20f18e8*/ System.Reflection.Emit.SignatureHelper GetLocalVarSigHelper();
                static /*0x20f1928*/ System.Reflection.Emit.SignatureHelper GetLocalVarSigHelper(System.Reflection.Module mod);
                static /*0x20f1968*/ System.Reflection.Emit.SignatureHelper GetMethodSigHelper(System.Reflection.CallingConventions callingConvention, System.Type returnType);
                static /*0x20f19a8*/ System.Reflection.Emit.SignatureHelper GetMethodSigHelper(System.Reflection.Module mod, System.Reflection.CallingConventions callingConvention, System.Type returnType);
                static /*0x20f19e8*/ System.Reflection.Emit.SignatureHelper GetMethodSigHelper(System.Reflection.Module mod, System.Type returnType, System.Type[] parameterTypes);
                static /*0x20f1a28*/ System.Reflection.Emit.SignatureHelper GetPropertySigHelper(System.Reflection.Module mod, System.Type returnType, System.Type[] parameterTypes);
                static /*0x20f1a68*/ System.Reflection.Emit.SignatureHelper GetPropertySigHelper(System.Reflection.Module mod, System.Type returnType, System.Type[] requiredReturnTypeCustomModifiers, System.Type[] optionalReturnTypeCustomModifiers, System.Type[] parameterTypes, System.Type[][] requiredParameterTypeCustomModifiers, System.Type[][] optionalParameterTypeCustomModifiers);
                static /*0x20f1aa8*/ System.Reflection.Emit.SignatureHelper GetPropertySigHelper(System.Reflection.Module mod, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] requiredReturnTypeCustomModifiers, System.Type[] optionalReturnTypeCustomModifiers, System.Type[] parameterTypes, System.Type[][] requiredParameterTypeCustomModifiers, System.Type[][] optionalParameterTypeCustomModifiers);
                static /*0x20f1b28*/ System.Reflection.Emit.SignatureHelper GetMethodSigHelper(System.Reflection.Module mod, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, System.Type returnType);
                static /*0x20f1b68*/ System.Reflection.Emit.SignatureHelper GetMethodSigHelper(System.Runtime.InteropServices.CallingConvention unmanagedCallingConvention, System.Type returnType);
                /*0x20f1760*/ SignatureHelper();
                /*0x20f1768*/ void AddArgument(System.Type clsArgument);
                /*0x20f17a8*/ void AddArgument(System.Type argument, bool pinned);
                /*0x20f17e8*/ void AddArgument(System.Type argument, System.Type[] requiredCustomModifiers, System.Type[] optionalCustomModifiers);
                /*0x20f1828*/ void AddArguments(System.Type[] arguments, System.Type[][] requiredCustomModifiers, System.Type[][] optionalCustomModifiers);
                /*0x20f1868*/ void AddSentinel();
                /*0x20f1ae8*/ byte[] GetSignature();
                /*0x20f1ba8*/ bool Equals(object obj);
                /*0x20f1be8*/ int GetHashCode();
                /*0x20f1c28*/ string ToString();
                /*0x20f1c68*/ void System.Runtime.InteropServices._SignatureHelper.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20f1ca8*/ void System.Runtime.InteropServices._SignatureHelper.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20f1ce8*/ void System.Runtime.InteropServices._SignatureHelper.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20f1d28*/ void System.Runtime.InteropServices._SignatureHelper.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder
            {
                static int UnspecifiedTypeSize = 0;

                static /*0x20f2c70*/ System.Reflection.ConstructorInfo GetConstructor(System.Type type, System.Reflection.ConstructorInfo constructor);
                static /*0x20f2ef0*/ System.Reflection.FieldInfo GetField(System.Type type, System.Reflection.FieldInfo field);
                static /*0x20f3130*/ System.Reflection.MethodInfo GetMethod(System.Type type, System.Reflection.MethodInfo method);
                /*0x20f1d68*/ TypeBuilder();
                /*0x20f1db0*/ System.Reflection.Assembly get_Assembly();
                /*0x20f1df0*/ string get_AssemblyQualifiedName();
                /*0x20f1e30*/ System.Type get_BaseType();
                /*0x20f1e70*/ bool get_ContainsGenericParameters();
                /*0x20f1eb0*/ System.Reflection.MethodBase get_DeclaringMethod();
                /*0x20f1ef0*/ System.Type get_DeclaringType();
                /*0x20f1f30*/ string get_FullName();
                /*0x20f1f70*/ System.Reflection.GenericParameterAttributes get_GenericParameterAttributes();
                /*0x20f1fb0*/ int get_GenericParameterPosition();
                /*0x20f1ff0*/ System.Guid get_GUID();
                /*0x20f2030*/ bool get_IsConstructedGenericType();
                /*0x20f2070*/ bool get_IsGenericParameter();
                /*0x20f20b0*/ bool get_IsGenericType();
                /*0x20f20f0*/ bool get_IsGenericTypeDefinition();
                /*0x20f2130*/ bool get_IsTypeDefinition();
                /*0x20f2170*/ System.Reflection.Module get_Module();
                /*0x20f21b0*/ string get_Name();
                /*0x20f21f0*/ string get_Namespace();
                /*0x20f2230*/ System.Reflection.Emit.PackingSize get_PackingSize();
                /*0x20f2270*/ System.Type get_ReflectedType();
                /*0x20f22b0*/ int get_Size();
                /*0x20f22f0*/ System.RuntimeTypeHandle get_TypeHandle();
                /*0x20f2330*/ System.Reflection.Emit.TypeToken get_TypeToken();
                /*0x20f2370*/ System.Type get_UnderlyingSystemType();
                /*0x20f23b0*/ void AddDeclarativeSecurity(System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);
                /*0x20f23f0*/ void AddInterfaceImplementation(System.Type interfaceType);
                /*0x20f2430*/ System.Type CreateType();
                /*0x20f2470*/ System.Reflection.TypeInfo CreateTypeInfo();
                /*0x20f24b0*/ System.Reflection.Emit.ConstructorBuilder DefineConstructor(System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type[] parameterTypes);
                /*0x20f24f0*/ System.Reflection.Emit.ConstructorBuilder DefineConstructor(System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type[] parameterTypes, System.Type[][] requiredCustomModifiers, System.Type[][] optionalCustomModifiers);
                /*0x20f2530*/ System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(System.Reflection.MethodAttributes attributes);
                /*0x20f2570*/ System.Reflection.Emit.EventBuilder DefineEvent(string name, System.Reflection.EventAttributes attributes, System.Type eventtype);
                /*0x20f25b0*/ System.Reflection.Emit.FieldBuilder DefineField(string fieldName, System.Type type, System.Reflection.FieldAttributes attributes);
                /*0x20f25f0*/ System.Reflection.Emit.FieldBuilder DefineField(string fieldName, System.Type type, System.Type[] requiredCustomModifiers, System.Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);
                /*0x20f2630*/ System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names);
                /*0x20f2670*/ System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, byte[] data, System.Reflection.FieldAttributes attributes);
                /*0x20f26b0*/ System.Reflection.Emit.MethodBuilder DefineMethod(string name, System.Reflection.MethodAttributes attributes);
                /*0x20f26f0*/ System.Reflection.Emit.MethodBuilder DefineMethod(string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);
                /*0x20f2730*/ System.Reflection.Emit.MethodBuilder DefineMethod(string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes);
                /*0x20f2770*/ System.Reflection.Emit.MethodBuilder DefineMethod(string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] returnTypeRequiredCustomModifiers, System.Type[] returnTypeOptionalCustomModifiers, System.Type[] parameterTypes, System.Type[][] parameterTypeRequiredCustomModifiers, System.Type[][] parameterTypeOptionalCustomModifiers);
                /*0x20f27b0*/ System.Reflection.Emit.MethodBuilder DefineMethod(string name, System.Reflection.MethodAttributes attributes, System.Type returnType, System.Type[] parameterTypes);
                /*0x20f27f0*/ void DefineMethodOverride(System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);
                /*0x20f2830*/ System.Reflection.Emit.TypeBuilder DefineNestedType(string name);
                /*0x20f2870*/ System.Reflection.Emit.TypeBuilder DefineNestedType(string name, System.Reflection.TypeAttributes attr);
                /*0x20f28b0*/ System.Reflection.Emit.TypeBuilder DefineNestedType(string name, System.Reflection.TypeAttributes attr, System.Type parent);
                /*0x20f28f0*/ System.Reflection.Emit.TypeBuilder DefineNestedType(string name, System.Reflection.TypeAttributes attr, System.Type parent, int typeSize);
                /*0x20f2930*/ System.Reflection.Emit.TypeBuilder DefineNestedType(string name, System.Reflection.TypeAttributes attr, System.Type parent, System.Reflection.Emit.PackingSize packSize);
                /*0x20f2970*/ System.Reflection.Emit.TypeBuilder DefineNestedType(string name, System.Reflection.TypeAttributes attr, System.Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);
                /*0x20f29b0*/ System.Reflection.Emit.TypeBuilder DefineNestedType(string name, System.Reflection.TypeAttributes attr, System.Type parent, System.Type[] interfaces);
                /*0x20f29f0*/ System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);
                /*0x20f2a30*/ System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);
                /*0x20f2a70*/ System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] returnTypeRequiredCustomModifiers, System.Type[] returnTypeOptionalCustomModifiers, System.Type[] parameterTypes, System.Type[][] parameterTypeRequiredCustomModifiers, System.Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);
                /*0x20f2ab0*/ System.Reflection.Emit.PropertyBuilder DefineProperty(string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] parameterTypes);
                /*0x20f2af0*/ System.Reflection.Emit.PropertyBuilder DefineProperty(string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, System.Type returnType, System.Type[] returnTypeRequiredCustomModifiers, System.Type[] returnTypeOptionalCustomModifiers, System.Type[] parameterTypes, System.Type[][] parameterTypeRequiredCustomModifiers, System.Type[][] parameterTypeOptionalCustomModifiers);
                /*0x20f2b30*/ System.Reflection.Emit.PropertyBuilder DefineProperty(string name, System.Reflection.PropertyAttributes attributes, System.Type returnType, System.Type[] parameterTypes);
                /*0x20f2b70*/ System.Reflection.Emit.PropertyBuilder DefineProperty(string name, System.Reflection.PropertyAttributes attributes, System.Type returnType, System.Type[] returnTypeRequiredCustomModifiers, System.Type[] returnTypeOptionalCustomModifiers, System.Type[] parameterTypes, System.Type[][] parameterTypeRequiredCustomModifiers, System.Type[][] parameterTypeOptionalCustomModifiers);
                /*0x20f2bb0*/ System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer();
                /*0x20f2bf0*/ System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int size, System.Reflection.FieldAttributes attributes);
                /*0x20f2c30*/ System.Reflection.TypeAttributes GetAttributeFlagsImpl();
                /*0x20f2cb0*/ System.Reflection.ConstructorInfo GetConstructorImpl(System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20f2cf0*/ System.Reflection.ConstructorInfo[] GetConstructors(System.Reflection.BindingFlags bindingAttr);
                /*0x20f2d30*/ object[] GetCustomAttributes(bool inherit);
                /*0x20f2d70*/ object[] GetCustomAttributes(System.Type attributeType, bool inherit);
                /*0x20f2db0*/ System.Type GetElementType();
                /*0x20f2df0*/ System.Reflection.EventInfo GetEvent(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20f2e30*/ System.Reflection.EventInfo[] GetEvents();
                /*0x20f2e70*/ System.Reflection.EventInfo[] GetEvents(System.Reflection.BindingFlags bindingAttr);
                /*0x20f2eb0*/ System.Reflection.FieldInfo GetField(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20f2f30*/ System.Reflection.FieldInfo[] GetFields(System.Reflection.BindingFlags bindingAttr);
                /*0x20f2f70*/ System.Type[] GetGenericArguments();
                /*0x20f2fb0*/ System.Type GetGenericTypeDefinition();
                /*0x20f2ff0*/ System.Type GetInterface(string name, bool ignoreCase);
                /*0x20f3030*/ System.Reflection.InterfaceMapping GetInterfaceMap(System.Type interfaceType);
                /*0x20f3070*/ System.Type[] GetInterfaces();
                /*0x20f30b0*/ System.Reflection.MemberInfo[] GetMember(string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);
                /*0x20f30f0*/ System.Reflection.MemberInfo[] GetMembers(System.Reflection.BindingFlags bindingAttr);
                /*0x20f3170*/ System.Reflection.MethodInfo GetMethodImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20f31b0*/ System.Reflection.MethodInfo[] GetMethods(System.Reflection.BindingFlags bindingAttr);
                /*0x20f31f0*/ System.Type GetNestedType(string name, System.Reflection.BindingFlags bindingAttr);
                /*0x20f3230*/ System.Type[] GetNestedTypes(System.Reflection.BindingFlags bindingAttr);
                /*0x20f3270*/ System.Reflection.PropertyInfo[] GetProperties(System.Reflection.BindingFlags bindingAttr);
                /*0x20f32b0*/ System.Reflection.PropertyInfo GetPropertyImpl(string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Type returnType, System.Type[] types, System.Reflection.ParameterModifier[] modifiers);
                /*0x20f32f0*/ bool HasElementTypeImpl();
                /*0x20f3330*/ object InvokeMember(string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);
                /*0x20f3370*/ bool IsArrayImpl();
                /*0x20f33b0*/ bool IsAssignableFrom(System.Type c);
                /*0x20f33f0*/ bool IsAssignableFrom(System.Reflection.TypeInfo typeInfo);
                /*0x20f3430*/ bool IsByRefImpl();
                /*0x20f3470*/ bool IsCOMObjectImpl();
                /*0x20f34b0*/ bool IsCreated();
                /*0x20f34f0*/ bool IsDefined(System.Type attributeType, bool inherit);
                /*0x20f3530*/ bool IsPointerImpl();
                /*0x20f3570*/ bool IsPrimitiveImpl();
                /*0x20f35b0*/ bool IsSubclassOf(System.Type c);
                /*0x20f35f0*/ bool IsValueTypeImpl();
                /*0x20f3630*/ System.Type MakeArrayType();
                /*0x20f3670*/ System.Type MakeArrayType(int rank);
                /*0x20f36b0*/ System.Type MakeByRefType();
                /*0x20f36f0*/ System.Type MakeGenericType(System.Type[] typeArguments);
                /*0x20f3730*/ System.Type MakePointerType();
                /*0x20f3770*/ void SetCustomAttribute(System.Reflection.ConstructorInfo con, byte[] binaryAttribute);
                /*0x20f37b0*/ void SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder customBuilder);
                /*0x20f37f0*/ void SetParent(System.Type parent);
                /*0x20f3830*/ string ToString();
                /*0x20f3870*/ void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                /*0x20f38a8*/ void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                /*0x20f38e0*/ void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount(ref uint pcTInfo);
                /*0x20f3918*/ void System.Runtime.InteropServices._TypeBuilder.Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            class TypeBuilderInstantiation : System.Reflection.TypeInfo
            {
                static /*0x20f3950*/ System.Type MakeGenericType(System.Type type, System.Type[] typeArguments);
                /*0x20f39a0*/ TypeBuilderInstantiation();
            }

            class UnmanagedMarshal
            {
                static /*0x20f3ab0*/ System.Reflection.Emit.UnmanagedMarshal DefineByValArray(int elemCount);
                static /*0x20f3af0*/ System.Reflection.Emit.UnmanagedMarshal DefineByValTStr(int elemCount);
                static /*0x20f3b30*/ System.Reflection.Emit.UnmanagedMarshal DefineLPArray(System.Runtime.InteropServices.UnmanagedType elemType);
                static /*0x20f3b70*/ System.Reflection.Emit.UnmanagedMarshal DefineUnmanagedMarshal(System.Runtime.InteropServices.UnmanagedType unmanagedType);
                static /*0x20f3bb0*/ System.Reflection.Emit.UnmanagedMarshal DefineSafeArray(System.Runtime.InteropServices.UnmanagedType elemType);
                /*0x20f39a8*/ UnmanagedMarshal();
                /*0x20f39b0*/ System.Runtime.InteropServices.UnmanagedType get_BaseType();
                /*0x20f39f0*/ int get_ElementCount();
                /*0x20f3a30*/ System.Runtime.InteropServices.UnmanagedType get_GetUnmanagedType();
                /*0x20f3a70*/ System.Guid get_IIDGuid();
            }
        }
    }

    namespace Numerics
    {
        class ConstantHelper
        {
            static /*0x20f3be8*/ byte GetByteWithAllBitsSet();
            static /*0x20f3bf0*/ sbyte GetSByteWithAllBitsSet();
            static /*0x20f3bf8*/ ushort GetUInt16WithAllBitsSet();
            static /*0x20f3c00*/ short GetInt16WithAllBitsSet();
            static /*0x20f3c08*/ uint GetUInt32WithAllBitsSet();
            static /*0x20f3c10*/ int GetInt32WithAllBitsSet();
            static /*0x20f3c18*/ ulong GetUInt64WithAllBitsSet();
            static /*0x20f3c20*/ long GetInt64WithAllBitsSet();
            static /*0x20f3c28*/ float GetSingleWithAllBitsSet();
            static /*0x20f3c34*/ double GetDoubleWithAllBitsSet();
            /*0x20f3c3c*/ ConstantHelper();
        }

        struct Register
        {
            /*0x10*/ byte byte_0;
            /*0x11*/ byte byte_1;
            /*0x12*/ byte byte_2;
            /*0x13*/ byte byte_3;
            /*0x14*/ byte byte_4;
            /*0x15*/ byte byte_5;
            /*0x16*/ byte byte_6;
            /*0x17*/ byte byte_7;
            /*0x18*/ byte byte_8;
            /*0x19*/ byte byte_9;
            /*0x1a*/ byte byte_10;
            /*0x1b*/ byte byte_11;
            /*0x1c*/ byte byte_12;
            /*0x1d*/ byte byte_13;
            /*0x1e*/ byte byte_14;
            /*0x1f*/ byte byte_15;
            /*0x10*/ sbyte sbyte_0;
            /*0x11*/ sbyte sbyte_1;
            /*0x12*/ sbyte sbyte_2;
            /*0x13*/ sbyte sbyte_3;
            /*0x14*/ sbyte sbyte_4;
            /*0x15*/ sbyte sbyte_5;
            /*0x16*/ sbyte sbyte_6;
            /*0x17*/ sbyte sbyte_7;
            /*0x18*/ sbyte sbyte_8;
            /*0x19*/ sbyte sbyte_9;
            /*0x1a*/ sbyte sbyte_10;
            /*0x1b*/ sbyte sbyte_11;
            /*0x1c*/ sbyte sbyte_12;
            /*0x1d*/ sbyte sbyte_13;
            /*0x1e*/ sbyte sbyte_14;
            /*0x1f*/ sbyte sbyte_15;
            /*0x10*/ ushort uint16_0;
            /*0x12*/ ushort uint16_1;
            /*0x14*/ ushort uint16_2;
            /*0x16*/ ushort uint16_3;
            /*0x18*/ ushort uint16_4;
            /*0x1a*/ ushort uint16_5;
            /*0x1c*/ ushort uint16_6;
            /*0x1e*/ ushort uint16_7;
            /*0x10*/ short int16_0;
            /*0x12*/ short int16_1;
            /*0x14*/ short int16_2;
            /*0x16*/ short int16_3;
            /*0x18*/ short int16_4;
            /*0x1a*/ short int16_5;
            /*0x1c*/ short int16_6;
            /*0x1e*/ short int16_7;
            /*0x10*/ uint uint32_0;
            /*0x14*/ uint uint32_1;
            /*0x18*/ uint uint32_2;
            /*0x1c*/ uint uint32_3;
            /*0x10*/ int int32_0;
            /*0x14*/ int int32_1;
            /*0x18*/ int int32_2;
            /*0x1c*/ int int32_3;
            /*0x10*/ ulong uint64_0;
            /*0x18*/ ulong uint64_1;
            /*0x10*/ long int64_0;
            /*0x18*/ long int64_1;
            /*0x10*/ float single_0;
            /*0x14*/ float single_1;
            /*0x18*/ float single_2;
            /*0x1c*/ float single_3;
            /*0x10*/ double double_0;
            /*0x18*/ double double_1;
        }

        struct Vector<T> : System.IEquatable<System.Numerics.Vector<T>>, System.IFormattable
        {
            static /*0x0*/ int s_count;
            static /*0x0*/ System.Numerics.Vector<T> s_zero;
            static /*0x0*/ System.Numerics.Vector<T> s_one;
            static /*0x0*/ System.Numerics.Vector<T> s_allOnes;
            /*0x0*/ System.Numerics.Register register;

            static Vector();
            static int get_Count();
            static System.Numerics.Vector<T> get_Zero();
            static System.Numerics.Vector<T> get_One();
            static System.Numerics.Vector<T> get_AllOnes();
            static int InitializeCount();
            static System.Numerics.Vector<T> op_Addition(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> op_Subtraction(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> op_Multiply(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> op_Multiply(System.Numerics.Vector<T> value, T factor);
            static System.Numerics.Vector<T> op_Multiply(T factor, System.Numerics.Vector<T> value);
            static System.Numerics.Vector<T> op_Division(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> op_UnaryNegation(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<T> op_BitwiseAnd(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> op_BitwiseOr(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> op_ExclusiveOr(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> op_OnesComplement(System.Numerics.Vector<T> value);
            static bool op_Equality(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static bool op_Inequality(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<byte> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<sbyte> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<ushort> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<short> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<uint> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<int> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<ulong> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<long> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<float> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<double> op_Explicit(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<T> Equals(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> LessThan(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> GreaterThan(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> GreaterThanOrEqual(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> LessThanOrEqual(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> ConditionalSelect(System.Numerics.Vector<T> condition, System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> Abs(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<T> Min(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> Max(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static T DotProduct(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> SquareRoot(System.Numerics.Vector<T> value);
            static bool ScalarEquals(T left, T right);
            static bool ScalarLessThan(T left, T right);
            static bool ScalarGreaterThan(T left, T right);
            static T ScalarAdd(T left, T right);
            static T ScalarSubtract(T left, T right);
            static T ScalarMultiply(T left, T right);
            static T ScalarDivide(T left, T right);
            static T GetOneValue();
            static T GetAllBitsSetValue();
            Vector(T value);
            Vector(T[] values);
            Vector(System.Span<T> values);
            Vector(T[] values, int index);
            Vector(void* dataPointer);
            Vector(void* dataPointer, int offset);
            Vector(ref System.Numerics.Register existingRegister);
            void CopyTo(T[] destination);
            void CopyTo(T[] destination, int startIndex);
            T get_Item(int index);
            bool Equals(object obj);
            bool Equals(System.Numerics.Vector<T> other);
            int GetHashCode();
            string ToString();
            string ToString(string format);
            string ToString(string format, System.IFormatProvider formatProvider);

            struct VectorSizeHelper<T>
            {
                /*0x0*/ System.Numerics.Vector<T> _placeholder;
                /*0x0*/ byte _byte;
            }
        }

        class Vector
        {
            static /*0x20f3c44*/ void Widen(System.Numerics.Vector<byte> source, ref System.Numerics.Vector<ushort> low, ref System.Numerics.Vector<ushort> high);
            static /*0x20f3f14*/ void Widen(System.Numerics.Vector<ushort> source, ref System.Numerics.Vector<uint> low, ref System.Numerics.Vector<uint> high);
            static /*0x20f41e4*/ void Widen(System.Numerics.Vector<uint> source, ref System.Numerics.Vector<ulong> low, ref System.Numerics.Vector<ulong> high);
            static /*0x20f44b4*/ void Widen(System.Numerics.Vector<sbyte> source, ref System.Numerics.Vector<short> low, ref System.Numerics.Vector<short> high);
            static /*0x20f4784*/ void Widen(System.Numerics.Vector<short> source, ref System.Numerics.Vector<int> low, ref System.Numerics.Vector<int> high);
            static /*0x20f4a54*/ void Widen(System.Numerics.Vector<int> source, ref System.Numerics.Vector<long> low, ref System.Numerics.Vector<long> high);
            static /*0x20f4d24*/ void Widen(System.Numerics.Vector<float> source, ref System.Numerics.Vector<double> low, ref System.Numerics.Vector<double> high);
            static /*0x20f4ff4*/ System.Numerics.Vector<byte> Narrow(System.Numerics.Vector<ushort> low, System.Numerics.Vector<ushort> high);
            static /*0x20f51e8*/ System.Numerics.Vector<ushort> Narrow(System.Numerics.Vector<uint> low, System.Numerics.Vector<uint> high);
            static /*0x20f53e8*/ System.Numerics.Vector<uint> Narrow(System.Numerics.Vector<ulong> low, System.Numerics.Vector<ulong> high);
            static /*0x20f55e8*/ System.Numerics.Vector<sbyte> Narrow(System.Numerics.Vector<short> low, System.Numerics.Vector<short> high);
            static /*0x20f57dc*/ System.Numerics.Vector<short> Narrow(System.Numerics.Vector<int> low, System.Numerics.Vector<int> high);
            static /*0x20f59dc*/ System.Numerics.Vector<int> Narrow(System.Numerics.Vector<long> low, System.Numerics.Vector<long> high);
            static /*0x20f5bdc*/ System.Numerics.Vector<float> Narrow(System.Numerics.Vector<double> low, System.Numerics.Vector<double> high);
            static /*0x20f5de4*/ System.Numerics.Vector<float> ConvertToSingle(System.Numerics.Vector<int> value);
            static /*0x20f5fac*/ System.Numerics.Vector<float> ConvertToSingle(System.Numerics.Vector<uint> value);
            static /*0x20f6178*/ System.Numerics.Vector<double> ConvertToDouble(System.Numerics.Vector<long> value);
            static /*0x20f6340*/ System.Numerics.Vector<double> ConvertToDouble(System.Numerics.Vector<ulong> value);
            static /*0x20f6508*/ System.Numerics.Vector<int> ConvertToInt32(System.Numerics.Vector<float> value);
            static /*0x20f66ec*/ System.Numerics.Vector<uint> ConvertToUInt32(System.Numerics.Vector<float> value);
            static /*0x20f68c0*/ System.Numerics.Vector<long> ConvertToInt64(System.Numerics.Vector<double> value);
            static /*0x20f6aa4*/ System.Numerics.Vector<ulong> ConvertToUInt64(System.Numerics.Vector<double> value);
            static /*0x20f6c78*/ System.Numerics.Vector<float> ConditionalSelect(System.Numerics.Vector<int> condition, System.Numerics.Vector<float> left, System.Numerics.Vector<float> right);
            static /*0x20f6d74*/ System.Numerics.Vector<double> ConditionalSelect(System.Numerics.Vector<long> condition, System.Numerics.Vector<double> left, System.Numerics.Vector<double> right);
            static System.Numerics.Vector<T> ConditionalSelect<T>(System.Numerics.Vector<T> condition, System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> Equals<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x20f6e70*/ System.Numerics.Vector<int> Equals(System.Numerics.Vector<float> left, System.Numerics.Vector<float> right);
            static /*0x20f6f20*/ System.Numerics.Vector<int> Equals(System.Numerics.Vector<int> left, System.Numerics.Vector<int> right);
            static /*0x20f6fb4*/ System.Numerics.Vector<long> Equals(System.Numerics.Vector<double> left, System.Numerics.Vector<double> right);
            static /*0x20f7064*/ System.Numerics.Vector<long> Equals(System.Numerics.Vector<long> left, System.Numerics.Vector<long> right);
            static bool EqualsAll<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static bool EqualsAny<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> LessThan<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x20f70f8*/ System.Numerics.Vector<int> LessThan(System.Numerics.Vector<float> left, System.Numerics.Vector<float> right);
            static /*0x20f71a8*/ System.Numerics.Vector<int> LessThan(System.Numerics.Vector<int> left, System.Numerics.Vector<int> right);
            static /*0x20f723c*/ System.Numerics.Vector<long> LessThan(System.Numerics.Vector<double> left, System.Numerics.Vector<double> right);
            static /*0x20f72ec*/ System.Numerics.Vector<long> LessThan(System.Numerics.Vector<long> left, System.Numerics.Vector<long> right);
            static bool LessThanAll<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static bool LessThanAny<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> LessThanOrEqual<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x20f7380*/ System.Numerics.Vector<int> LessThanOrEqual(System.Numerics.Vector<float> left, System.Numerics.Vector<float> right);
            static /*0x20f7430*/ System.Numerics.Vector<int> LessThanOrEqual(System.Numerics.Vector<int> left, System.Numerics.Vector<int> right);
            static /*0x20f74c4*/ System.Numerics.Vector<long> LessThanOrEqual(System.Numerics.Vector<long> left, System.Numerics.Vector<long> right);
            static /*0x20f7558*/ System.Numerics.Vector<long> LessThanOrEqual(System.Numerics.Vector<double> left, System.Numerics.Vector<double> right);
            static bool LessThanOrEqualAll<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static bool LessThanOrEqualAny<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> GreaterThan<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x20f7608*/ System.Numerics.Vector<int> GreaterThan(System.Numerics.Vector<float> left, System.Numerics.Vector<float> right);
            static /*0x20f76b8*/ System.Numerics.Vector<int> GreaterThan(System.Numerics.Vector<int> left, System.Numerics.Vector<int> right);
            static /*0x20f774c*/ System.Numerics.Vector<long> GreaterThan(System.Numerics.Vector<double> left, System.Numerics.Vector<double> right);
            static /*0x20f77fc*/ System.Numerics.Vector<long> GreaterThan(System.Numerics.Vector<long> left, System.Numerics.Vector<long> right);
            static bool GreaterThanAll<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static bool GreaterThanAny<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> GreaterThanOrEqual<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x20f7890*/ System.Numerics.Vector<int> GreaterThanOrEqual(System.Numerics.Vector<float> left, System.Numerics.Vector<float> right);
            static /*0x20f7940*/ System.Numerics.Vector<int> GreaterThanOrEqual(System.Numerics.Vector<int> left, System.Numerics.Vector<int> right);
            static /*0x20f79d4*/ System.Numerics.Vector<long> GreaterThanOrEqual(System.Numerics.Vector<long> left, System.Numerics.Vector<long> right);
            static /*0x20f7a68*/ System.Numerics.Vector<long> GreaterThanOrEqual(System.Numerics.Vector<double> left, System.Numerics.Vector<double> right);
            static bool GreaterThanOrEqualAll<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static bool GreaterThanOrEqualAny<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static /*0x20f7b18*/ bool get_IsHardwareAccelerated();
            static System.Numerics.Vector<T> Abs<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<T> Min<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> Max<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static T Dot<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> SquareRoot<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<T> Add<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> Subtract<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> Multiply<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> Multiply<T>(System.Numerics.Vector<T> left, T right);
            static System.Numerics.Vector<T> Multiply<T>(T left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> Divide<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> Negate<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<T> BitwiseAnd<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> BitwiseOr<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> OnesComplement<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<T> Xor<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<T> AndNot<T>(System.Numerics.Vector<T> left, System.Numerics.Vector<T> right);
            static System.Numerics.Vector<byte> AsVectorByte<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<sbyte> AsVectorSByte<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<ushort> AsVectorUInt16<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<short> AsVectorInt16<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<uint> AsVectorUInt32<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<int> AsVectorInt32<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<ulong> AsVectorUInt64<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<long> AsVectorInt64<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<float> AsVectorSingle<T>(System.Numerics.Vector<T> value);
            static System.Numerics.Vector<double> AsVectorDouble<T>(System.Numerics.Vector<T> value);
        }

        namespace Hashing
        {
            class HashHelpers
            {
                static /*0x0*/ int RandomSeed;

                static /*0x20f7b30*/ HashHelpers();
                static /*0x20f7b20*/ int Combine(int h1, int h2);
            }
        }
    }

    namespace IO
    {
        class DirectoryNotFoundException : System.IO.IOException
        {
            /*0x20f7bc0*/ DirectoryNotFoundException();
            /*0x20f7c40*/ DirectoryNotFoundException(string message);
            /*0x20f7c64*/ DirectoryNotFoundException(string message, System.Exception innerException);
            /*0x20f7cac*/ DirectoryNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class EndOfStreamException : System.IO.IOException
        {
            /*0x20f7cbc*/ EndOfStreamException();
            /*0x20f7d18*/ EndOfStreamException(string message);
            /*0x20f7d3c*/ EndOfStreamException(string message, System.Exception innerException);
            /*0x20f7d60*/ EndOfStreamException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class Error
        {
            static /*0x20f7d68*/ System.Exception GetStreamIsClosed();
            static /*0x20f7de0*/ System.Exception GetEndOfFile();
            static /*0x20f7e60*/ System.Exception GetFileNotOpen();
            static /*0x20f7ed8*/ System.Exception GetReadNotSupported();
            static /*0x20f7f4c*/ System.Exception GetSeekNotSupported();
            static /*0x20f7fc0*/ System.Exception GetWriteNotSupported();
        }

        enum FileAccess
        {
            Read = 1,
            Write = 2,
            ReadWrite = 3,
        }

        class FileLoadException : System.IO.IOException
        {
            /*0x90*/ string <FileName>k__BackingField;
            /*0x98*/ string <FusionLog>k__BackingField;

            static /*0x20f8168*/ string FormatFileLoadExceptionMessage(string fileName, int hResult);
            /*0x20f8034*/ FileLoadException();
            /*0x20f8090*/ FileLoadException(string message);
            /*0x20f80b4*/ FileLoadException(string message, System.Exception inner);
            /*0x20f80d8*/ FileLoadException(string message, string fileName);
            /*0x20f810c*/ FileLoadException(string message, string fileName, System.Exception inner);
            /*0x20f83dc*/ FileLoadException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20f8144*/ string get_Message();
            /*0x20f81dc*/ string get_FileName();
            /*0x20f81e4*/ string get_FusionLog();
            /*0x20f81ec*/ string ToString();
            /*0x20f848c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum FileMode
        {
            CreateNew = 1,
            Create = 2,
            Open = 3,
            OpenOrCreate = 4,
            Truncate = 5,
            Append = 6,
        }

        class FileNotFoundException : System.IO.IOException
        {
            /*0x90*/ string <FileName>k__BackingField;
            /*0x98*/ string <FusionLog>k__BackingField;

            /*0x20f85a4*/ FileNotFoundException();
            /*0x20f8600*/ FileNotFoundException(string message);
            /*0x20f8624*/ FileNotFoundException(string message, System.Exception innerException);
            /*0x20f8648*/ FileNotFoundException(string message, string fileName);
            /*0x20f867c*/ FileNotFoundException(string message, string fileName, System.Exception innerException);
            /*0x20f8944*/ FileNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x20f86b4*/ string get_Message();
            /*0x20f86cc*/ void SetMessageField();
            /*0x20f8744*/ string get_FileName();
            /*0x20f874c*/ string get_FusionLog();
            /*0x20f8754*/ string ToString();
            /*0x20f89f4*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum FileOptions
        {
            None = 0,
            WriteThrough = -2147483648,
            Asynchronous = 1073741824,
            RandomAccess = 268435456,
            DeleteOnClose = 67108864,
            SequentialScan = 134217728,
            Encrypted = 16384,
        }

        enum FileShare
        {
            None = 0,
            Read = 1,
            Write = 2,
            ReadWrite = 3,
            Delete = 4,
            Inheritable = 16,
        }

        class IOException : System.SystemException
        {
            /*0x20f8b0c*/ IOException();
            /*0x20f7c1c*/ IOException(string message);
            /*0x20f8b68*/ IOException(string message, int hresult);
            /*0x20f7c88*/ IOException(string message, System.Exception innerException);
            /*0x20f7cb4*/ IOException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class MemoryStream : System.IO.Stream
        {
            static int MemStreamMaxLength = 2147483647;
            /*0x28*/ byte[] _buffer;
            /*0x30*/ int _origin;
            /*0x34*/ int _position;
            /*0x38*/ int _length;
            /*0x3c*/ int _capacity;
            /*0x40*/ bool _expandable;
            /*0x41*/ bool _writable;
            /*0x42*/ bool _exposable;
            /*0x43*/ bool _isOpen;
            /*0x48*/ System.Threading.Tasks.Task<int> _lastReadTask;

            /*0x20f8b90*/ MemoryStream();
            /*0x20f8b98*/ MemoryStream(int capacity);
            /*0x20f8cf8*/ MemoryStream(byte[] buffer);
            /*0x20f8d00*/ MemoryStream(byte[] buffer, bool writable);
            /*0x20f8df0*/ MemoryStream(byte[] buffer, int index, int count);
            /*0x20f8fd4*/ MemoryStream(byte[] buffer, int index, int count, bool writable);
            /*0x20f8dfc*/ MemoryStream(byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
            /*0x20f8fe0*/ bool get_CanRead();
            /*0x20f8fe8*/ bool get_CanSeek();
            /*0x20f8ff0*/ bool get_CanWrite();
            /*0x20f8ff8*/ void EnsureNotClosed();
            /*0x20f902c*/ void EnsureWriteable();
            /*0x20f9068*/ void Dispose(bool disposing);
            /*0x20f9084*/ bool EnsureCapacity(int value);
            /*0x20f9134*/ void Flush();
            /*0x20f9138*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x20f92ac*/ byte[] GetBuffer();
            /*0x20f9310*/ bool TryGetBuffer(ref System.ArraySegment<byte> buffer);
            /*0x20f939c*/ byte[] InternalGetBuffer();
            /*0x20f93a4*/ void InternalGetOriginAndLength(ref int origin, ref int length);
            /*0x20f93e4*/ int InternalGetPosition();
            /*0x20f93ec*/ int InternalReadInt32();
            /*0x20f94a4*/ int InternalEmulateRead(int count);
            /*0x20f94e0*/ int get_Capacity();
            /*0x20f9500*/ void set_Capacity(int value);
            /*0x20f9684*/ long get_Length();
            /*0x20f96a8*/ long get_Position();
            /*0x20f96c8*/ void set_Position(long value);
            /*0x20f9798*/ int Read(byte[] buffer, int offset, int count);
            /*0x20f998c*/ int Read(System.Span<byte> buffer);
            /*0x20f9b88*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x20f9ef0*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x20fa1cc*/ int ReadByte();
            /*0x20fa224*/ void CopyTo(System.IO.Stream destination, int bufferSize);
            /*0x20fa378*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
            /*0x20fa6a4*/ long Seek(long offset, System.IO.SeekOrigin loc);
            /*0x20fa7fc*/ void SetLength(long value);
            /*0x20fa8dc*/ byte[] ToArray();
            /*0x20fa9b8*/ void Write(byte[] buffer, int offset, int count);
            /*0x20fac50*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x20faea4*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x20fb1ac*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x20fb408*/ void WriteByte(byte value);
            /*0x20fb4c4*/ void WriteTo(System.IO.Stream stream);
        }

        class PathInternal
        {
            static char DirectorySeparatorChar = 47;
            static char AltDirectorySeparatorChar = 47;
            static char VolumeSeparatorChar = 47;
            static char PathSeparator = 58;
            static string DirectorySeparatorCharAsString = "/";
            static char InvalidPathChar = 0;
            static string ParentDirectoryPrefix = "../";
            static /*0x0*/ bool s_isCaseSensitive;

            static /*0x2118074*/ PathInternal();
            static /*0x2116b28*/ int GetRootLength(System.ReadOnlySpan<char> path);
            static /*0x2116ba4*/ bool IsDirectorySeparator(char c);
            static /*0x2116bb4*/ string NormalizeDirectorySeparators(string path);
            static /*0x2116dbc*/ bool IsPartiallyQualified(System.ReadOnlySpan<char> path);
            static /*0x2116e30*/ bool IsEffectivelyEmpty(string path);
            static /*0x2116e38*/ bool IsEffectivelyEmpty(System.ReadOnlySpan<char> path);
            static /*0x2116e90*/ bool EndsInDirectorySeparator(System.ReadOnlySpan<char> path);
            static /*0x2116f18*/ bool StartsWithDirectorySeparator(System.ReadOnlySpan<char> path);
            static /*0x2116f94*/ string EnsureTrailingSeparator(string path);
            static /*0x2117074*/ string TrimEndingDirectorySeparator(string path);
            static /*0x2117230*/ System.ReadOnlySpan<char> TrimEndingDirectorySeparator(System.ReadOnlySpan<char> path);
            static /*0x21171b4*/ bool IsRoot(System.ReadOnlySpan<char> path);
            static /*0x2117310*/ int GetCommonPathLength(string first, string second, bool ignoreCase);
            static /*0x211747c*/ int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
            static /*0x21175cc*/ bool AreRootsEqual(string first, string second, System.StringComparison comparisonType);
            static /*0x2117704*/ string RemoveRelativeSegments(string path, int rootLength);
            static /*0x2117c0c*/ System.StringComparison get_StringComparison();
            static /*0x2117c70*/ bool get_IsCaseSensitive();
            static /*0x2117cc8*/ bool GetIsCaseSensitive();
            static /*0x2117ff4*/ bool IsPartiallyQualified(string path);
            static /*0x2117ffc*/ bool HasIllegalCharacters(string path, bool checkAdditional);
        }

        class PathTooLongException : System.IO.IOException
        {
            /*0x21180c4*/ PathTooLongException();
            /*0x2118120*/ PathTooLongException(string message);
            /*0x2118144*/ PathTooLongException(string message, System.Exception innerException);
            /*0x2118168*/ PathTooLongException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        class PinnedBufferMemoryStream : System.IO.UnmanagedMemoryStream
        {
            /*0x68*/ byte[] _array;
            /*0x70*/ System.Runtime.InteropServices.GCHandle _pinningHandle;

            /*0x2118170*/ PinnedBufferMemoryStream(byte[] array);
            /*0x2118490*/ int Read(System.Span<byte> buffer);
            /*0x21186c0*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x21189c4*/ void Finalize();
            /*0x2118a68*/ void Dispose(bool disposing);
        }

        enum SeekOrigin
        {
            Begin = 0,
            Current = 1,
            End = 2,
        }

        class StreamHelpers
        {
            static /*0x2118acc*/ void ValidateCopyToArgs(System.IO.Stream source, System.IO.Stream destination, int bufferSize);
        }

        class StreamReader : System.IO.TextReader
        {
            static int DefaultBufferSize = 1024;
            static int DefaultFileStreamBufferSize = 4096;
            static int MinBufferSize = 128;
            static /*0x0*/ System.IO.StreamReader Null;
            /*0x18*/ System.IO.Stream _stream;
            /*0x20*/ System.Text.Encoding _encoding;
            /*0x28*/ System.Text.Decoder _decoder;
            /*0x30*/ byte[] _byteBuffer;
            /*0x38*/ char[] _charBuffer;
            /*0x40*/ int _charPos;
            /*0x44*/ int _charLen;
            /*0x48*/ int _byteLen;
            /*0x4c*/ int _bytePos;
            /*0x50*/ int _maxCharsPerBuffer;
            /*0x54*/ bool _detectEncoding;
            /*0x55*/ bool _checkPreamble;
            /*0x56*/ bool _isBlocked;
            /*0x57*/ bool _closable;
            /*0x58*/ System.Threading.Tasks.Task _asyncReadTask;

            static /*0x211cf14*/ StreamReader();
            static /*0x2118d70*/ void ThrowAsyncIOInProgress();
            /*0x2118dc0*/ StreamReader();
            /*0x2118e84*/ StreamReader(System.IO.Stream stream);
            /*0x2118ec0*/ StreamReader(System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);
            /*0x2119128*/ StreamReader(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x2119138*/ StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);
            /*0x2119148*/ StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
            /*0x2118f00*/ StreamReader(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
            /*0x211927c*/ StreamReader(string path);
            /*0x21192b4*/ StreamReader(string path, bool detectEncodingFromByteOrderMarks);
            /*0x211953c*/ StreamReader(string path, System.Text.Encoding encoding);
            /*0x2119548*/ StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);
            /*0x21192f0*/ StreamReader(string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
            /*0x2118d0c*/ void CheckAsyncTaskInProgress();
            /*0x2119154*/ void Init(System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
            /*0x2119554*/ void Init(System.IO.Stream stream);
            /*0x2119564*/ void Close();
            /*0x2119574*/ void Dispose(bool disposing);
            /*0x2119654*/ System.Text.Encoding get_CurrentEncoding();
            /*0x211965c*/ System.IO.Stream get_BaseStream();
            /*0x2119644*/ bool get_LeaveOpen();
            /*0x2119664*/ void DiscardBufferedData();
            /*0x21196a0*/ bool get_EndOfStream();
            /*0x211973c*/ int Peek();
            /*0x2119804*/ int Read();
            /*0x21198cc*/ int Read(char[] buffer, int index, int count);
            /*0x2119cf4*/ int Read(System.Span<char> buffer);
            /*0x2119a8c*/ int ReadSpan(System.Span<char> buffer);
            /*0x211a368*/ string ReadToEnd();
            /*0x211a484*/ int ReadBlock(char[] buffer, int index, int count);
            /*0x211a6bc*/ int ReadBlock(System.Span<char> buffer);
            /*0x211aa90*/ void CompressBuffer(int n);
            /*0x211aad4*/ void DetectEncoding();
            /*0x211ad8c*/ bool IsPreamble();
            /*0x211aebc*/ int ReadBuffer();
            /*0x211a058*/ int ReadBuffer(System.Span<char> userBuffer, ref bool readToUserBuffer);
            /*0x211b028*/ string ReadLine();
            /*0x211b288*/ System.Threading.Tasks.Task<string> ReadLineAsync();
            /*0x211b578*/ System.Threading.Tasks.Task<string> ReadLineAsyncInternal();
            /*0x211b668*/ System.Threading.Tasks.Task<string> ReadToEndAsync();
            /*0x211b87c*/ System.Threading.Tasks.Task<string> ReadToEndAsyncInternal();
            /*0x211b968*/ System.Threading.Tasks.Task<int> ReadAsync(char[] buffer, int index, int count);
            /*0x211be54*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x211c2d8*/ System.Threading.Tasks.ValueTask<int> ReadAsyncInternal(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x211c3d4*/ System.Threading.Tasks.Task<int> ReadBlockAsync(char[] buffer, int index, int count);
            /*0x211c834*/ System.Threading.Tasks.ValueTask<int> ReadBlockAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x211ce0c*/ System.Threading.Tasks.Task<int> ReadBufferAsync();
            /*0x211cf04*/ bool DataAvailable();

            class NullStreamReader : System.IO.StreamReader
            {
                /*0x211cf88*/ NullStreamReader();
                /*0x211d01c*/ System.IO.Stream get_BaseStream();
                /*0x211d074*/ System.Text.Encoding get_CurrentEncoding();
                /*0x211d07c*/ void Dispose(bool disposing);
                /*0x211d080*/ int Peek();
                /*0x211d088*/ int Read();
                /*0x211d090*/ int Read(char[] buffer, int index, int count);
                /*0x211d098*/ string ReadLine();
                /*0x211d0a0*/ string ReadToEnd();
                /*0x211d0e8*/ int ReadBuffer();
            }

            struct <ReadLineAsyncInternal>d__61 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<string> <>t__builder;
                /*0x30*/ System.IO.StreamReader <>4__this;
                /*0x38*/ System.Text.StringBuilder <sb>5__2;
                /*0x40*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<int> <>u__1;
                /*0x50*/ string <s>5__3;

                /*0x211d0f0*/ void MoveNext();
                /*0x211d638*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <ReadToEndAsyncInternal>d__63 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<string> <>t__builder;
                /*0x30*/ System.IO.StreamReader <>4__this;
                /*0x38*/ System.Text.StringBuilder <sb>5__2;
                /*0x40*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<int> <>u__1;

                /*0x211d690*/ void MoveNext();
                /*0x211d94c*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <ReadAsyncInternal>d__66 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<int> <>t__builder;
                /*0x38*/ System.IO.StreamReader <>4__this;
                /*0x40*/ System.Memory<char> buffer;
                /*0x50*/ System.Threading.CancellationToken cancellationToken;
                /*0x58*/ int <charsRead>5__2;
                /*0x5c*/ bool <readToUserBuffer>5__3;
                /*0x60*/ byte[] <tmpByteBuffer>5__4;
                /*0x68*/ System.IO.Stream <tmpStream>5__5;
                /*0x70*/ int <count>5__6;
                /*0x78*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<int> <>u__1;
                /*0x88*/ int <n>5__7;
                /*0x90*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__2;

                /*0x211d9a4*/ void MoveNext();
                /*0x211e4c4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <ReadBufferAsync>d__69 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<int> <>t__builder;
                /*0x30*/ System.IO.StreamReader <>4__this;
                /*0x38*/ byte[] <tmpByteBuffer>5__2;
                /*0x40*/ System.IO.Stream <tmpStream>5__3;
                /*0x48*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__1;

                /*0x211e51c*/ void MoveNext();
                /*0x211eb14*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        class StreamWriter : System.IO.TextWriter
        {
            static int DefaultBufferSize = 1024;
            static int DefaultFileStreamBufferSize = 4096;
            static int MinBufferSize = 128;
            static int DontCopyOnWriteLineThreshold = 512;
            static /*0x0*/ System.IO.StreamWriter Null;
            /*0x30*/ System.IO.Stream _stream;
            /*0x38*/ System.Text.Encoding _encoding;
            /*0x40*/ System.Text.Encoder _encoder;
            /*0x48*/ byte[] _byteBuffer;
            /*0x50*/ char[] _charBuffer;
            /*0x58*/ int _charPos;
            /*0x5c*/ int _charLen;
            /*0x60*/ bool _autoFlush;
            /*0x61*/ bool _haveWrittenPreamble;
            /*0x62*/ bool _closable;
            /*0x68*/ System.Threading.Tasks.Task _asyncWriteTask;

            static /*0x2124388*/ StreamWriter();
            static /*0x211ebd0*/ void ThrowAsyncIOInProgress();
            static /*0x211ec20*/ System.Text.Encoding get_UTF8NoBOM();
            static /*0x212183c*/ System.Threading.Tasks.Task WriteAsyncInternal(System.IO.StreamWriter _this, char value, char[] charBuffer, int charPos, int charLen, char[] coreNewLine, bool autoFlush, bool appendNewLine);
            static /*0x2121da0*/ System.Threading.Tasks.Task WriteAsyncInternal(System.IO.StreamWriter _this, string value, char[] charBuffer, int charPos, int charLen, char[] coreNewLine, bool autoFlush, bool appendNewLine);
            static /*0x2122418*/ System.Threading.Tasks.Task WriteAsyncInternal(System.IO.StreamWriter _this, System.ReadOnlyMemory<char> source, char[] charBuffer, int charPos, int charLen, char[] coreNewLine, bool autoFlush, bool appendNewLine, System.Threading.CancellationToken cancellationToken);
            static /*0x2124254*/ System.Threading.Tasks.Task FlushAsyncInternal(System.IO.StreamWriter _this, bool flushStream, bool flushEncoder, char[] charBuffer, int charPos, bool haveWrittenPreamble, System.Text.Encoding encoding, System.Text.Encoder encoder, byte[] byteBuffer, System.IO.Stream stream, System.Threading.CancellationToken cancellationToken);
            /*0x211ec70*/ StreamWriter();
            /*0x211edb4*/ StreamWriter(System.IO.Stream stream);
            /*0x211f040*/ StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x211f04c*/ StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize);
            /*0x211ee28*/ StreamWriter(System.IO.Stream stream, System.Text.Encoding encoding, int bufferSize, bool leaveOpen);
            /*0x211f190*/ StreamWriter(string path);
            /*0x211f454*/ StreamWriter(string path, bool append);
            /*0x211f4cc*/ StreamWriter(string path, bool append, System.Text.Encoding encoding);
            /*0x211f204*/ StreamWriter(string path, bool append, System.Text.Encoding encoding, int bufferSize);
            /*0x211eb6c*/ void CheckAsyncTaskInProgress();
            /*0x211f054*/ void Init(System.IO.Stream streamArg, System.Text.Encoding encodingArg, int bufferSize, bool shouldLeaveOpen);
            /*0x211f554*/ void Close();
            /*0x211f5c0*/ void Dispose(bool disposing);
            /*0x211f7d4*/ System.Threading.Tasks.ValueTask DisposeAsync();
            /*0x211f890*/ System.Threading.Tasks.ValueTask DisposeAsyncCore();
            /*0x211fa04*/ void CloseStreamFromDispose(bool disposing);
            /*0x211fadc*/ void Flush();
            /*0x211f654*/ void Flush(bool flushStream, bool flushEncoder);
            /*0x211fafc*/ bool get_AutoFlush();
            /*0x211fb04*/ void set_AutoFlush(bool value);
            /*0x211fb48*/ System.IO.Stream get_BaseStream();
            /*0x211facc*/ bool get_LeaveOpen();
            /*0x211fb50*/ void set_HaveWrittenPreamble(bool value);
            /*0x211fb5c*/ System.Text.Encoding get_Encoding();
            /*0x211fb64*/ void Write(char value);
            /*0x211fbf0*/ void Write(char[] buffer);
            /*0x211fe58*/ void Write(char[] buffer, int index, int count);
            /*0x2120230*/ void Write(System.ReadOnlySpan<char> buffer);
            /*0x21206e8*/ void WriteSpan(System.ReadOnlySpan<char> buffer, bool appendNewLine);
            /*0x21209b0*/ void Write(string value);
            /*0x2120c1c*/ void WriteLine(string value);
            /*0x2120f18*/ void WriteLine(System.ReadOnlySpan<char> value);
            /*0x2121464*/ System.Threading.Tasks.Task WriteAsync(char value);
            /*0x2121960*/ System.Threading.Tasks.Task WriteAsync(string value);
            /*0x2121ecc*/ System.Threading.Tasks.Task WriteAsync(char[] buffer, int index, int count);
            /*0x2122578*/ System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x2122a08*/ System.Threading.Tasks.Task WriteLineAsync();
            /*0x2122be0*/ System.Threading.Tasks.Task WriteLineAsync(char value);
            /*0x2122fb8*/ System.Threading.Tasks.Task WriteLineAsync(string value);
            /*0x21233bc*/ System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int index, int count);
            /*0x212390c*/ System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x2123da0*/ System.Threading.Tasks.Task FlushAsync();
            /*0x2124240*/ void set_CharPos_Prop(int value);
            /*0x2124248*/ void set_HaveWrittenPreamble_Prop(bool value);
            /*0x21240cc*/ System.Threading.Tasks.Task FlushAsyncInternal(bool flushStream, bool flushEncoder, char[] sCharBuffer, int sCharPos, System.Threading.CancellationToken cancellationToken);

            struct <DisposeAsyncCore>d__33 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder <>t__builder;
                /*0x38*/ System.IO.StreamWriter <>4__this;
                /*0x40*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;

                /*0x212443c*/ void MoveNext();
                /*0x21246c8*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <WriteAsyncInternal>d__57 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ int charPos;
                /*0x34*/ int charLen;
                /*0x38*/ System.IO.StreamWriter _this;
                /*0x40*/ char[] charBuffer;
                /*0x48*/ char value;
                /*0x4a*/ bool appendNewLine;
                /*0x50*/ char[] coreNewLine;
                /*0x58*/ bool autoFlush;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x70*/ int <i>5__2;

                /*0x21246d4*/ void MoveNext();
                /*0x2124adc*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <WriteAsyncInternal>d__59 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ string value;
                /*0x38*/ int charPos;
                /*0x3c*/ int charLen;
                /*0x40*/ System.IO.StreamWriter _this;
                /*0x48*/ char[] charBuffer;
                /*0x50*/ bool appendNewLine;
                /*0x58*/ char[] coreNewLine;
                /*0x60*/ bool autoFlush;
                /*0x64*/ int <count>5__2;
                /*0x68*/ int <index>5__3;
                /*0x70*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x80*/ int <i>5__4;

                /*0x2124ae8*/ void MoveNext();
                /*0x2124f48*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <WriteAsyncInternal>d__62 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ int charPos;
                /*0x34*/ int charLen;
                /*0x38*/ System.IO.StreamWriter _this;
                /*0x40*/ char[] charBuffer;
                /*0x48*/ System.Threading.CancellationToken cancellationToken;
                /*0x50*/ System.ReadOnlyMemory<char> source;
                /*0x60*/ bool appendNewLine;
                /*0x68*/ char[] coreNewLine;
                /*0x70*/ bool autoFlush;
                /*0x74*/ int <copied>5__2;
                /*0x78*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x88*/ int <i>5__3;

                /*0x2124f54*/ void MoveNext();
                /*0x2125534*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <FlushAsyncInternal>d__74 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ bool haveWrittenPreamble;
                /*0x38*/ System.IO.StreamWriter _this;
                /*0x40*/ System.Text.Encoding encoding;
                /*0x48*/ System.IO.Stream stream;
                /*0x50*/ System.Threading.CancellationToken cancellationToken;
                /*0x58*/ System.Text.Encoder encoder;
                /*0x60*/ char[] charBuffer;
                /*0x68*/ int charPos;
                /*0x70*/ byte[] byteBuffer;
                /*0x78*/ bool flushEncoder;
                /*0x79*/ bool flushStream;
                /*0x80*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__1;
                /*0x90*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__2;

                /*0x2125540*/ void MoveNext();
                /*0x2125c64*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        class TextReader : System.MarshalByRefObject, System.IDisposable
        {
            static /*0x0*/ System.IO.TextReader Null;

            static /*0x212644c*/ TextReader();
            static /*0x2126320*/ System.IO.TextReader Synchronized(System.IO.TextReader reader);
            /*0x2118e7c*/ TextReader();
            /*0x2125c70*/ void Close();
            /*0x2125cdc*/ void Dispose();
            /*0x2125d48*/ void Dispose(bool disposing);
            /*0x2125d4c*/ int Peek();
            /*0x2125d54*/ int Read();
            /*0x2125d5c*/ int Read(char[] buffer, int index, int count);
            /*0x2119dd4*/ int Read(System.Span<char> buffer);
            /*0x2125f18*/ string ReadToEnd();
            /*0x211a658*/ int ReadBlock(char[] buffer, int index, int count);
            /*0x211a808*/ int ReadBlock(System.Span<char> buffer);
            /*0x2126014*/ string ReadLine();
            /*0x211b3ac*/ System.Threading.Tasks.Task<string> ReadLineAsync();
            /*0x211b78c*/ System.Threading.Tasks.Task<string> ReadToEndAsync();
            /*0x211bc4c*/ System.Threading.Tasks.Task<int> ReadAsync(char[] buffer, int index, int count);
            /*0x211c038*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x2126104*/ System.Threading.Tasks.ValueTask<int> ReadAsyncInternal(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x211c638*/ System.Threading.Tasks.Task<int> ReadBlockAsync(char[] buffer, int index, int count);
            /*0x211ca70*/ System.Threading.Tasks.ValueTask<int> ReadBlockAsync(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x211cd10*/ System.Threading.Tasks.ValueTask<int> ReadBlockAsyncInternal(System.Memory<char> buffer, System.Threading.CancellationToken cancellationToken);

            class NullTextReader : System.IO.TextReader
            {
                /*0x21264c0*/ NullTextReader();
                /*0x2126518*/ int Read(char[] buffer, int index, int count);
                /*0x2126520*/ string ReadLine();
            }

            class SyncTextReader : System.IO.TextReader
            {
                /*0x18*/ System.IO.TextReader _in;

                /*0x21263e0*/ SyncTextReader(System.IO.TextReader t);
                /*0x2126528*/ void Close();
                /*0x2126548*/ void Dispose(bool disposing);
                /*0x21265fc*/ int Peek();
                /*0x212661c*/ int Read();
                /*0x212663c*/ int Read(char[] buffer, int index, int count);
                /*0x212665c*/ int ReadBlock(char[] buffer, int index, int count);
                /*0x2126680*/ string ReadLine();
                /*0x21266a4*/ string ReadToEnd();
                /*0x21266c8*/ System.Threading.Tasks.Task<string> ReadLineAsync();
                /*0x2126750*/ System.Threading.Tasks.Task<string> ReadToEndAsync();
                /*0x21267d8*/ System.Threading.Tasks.Task<int> ReadBlockAsync(char[] buffer, int index, int count);
                /*0x21269ac*/ System.Threading.Tasks.Task<int> ReadAsync(char[] buffer, int index, int count);
            }

            class <>c
            {
                static /*0x0*/ System.IO.TextReader.<> <>9;
                static /*0x8*/ System.Func<object, string> <>9__13_0;
                static /*0x10*/ System.Func<object, int> <>9__16_0;
                static /*0x18*/ System.Func<object, int> <>9__17_0;
                static /*0x20*/ System.Func<object, int> <>9__19_0;

                static /*0x2126b7c*/ <>c();
                /*0x2126be0*/ <>c();
                /*0x2126be8*/ string <ReadLineAsync>b__13_0(object state);
                /*0x2126c98*/ int <ReadAsync>b__16_0(object state);
                /*0x2126d8c*/ int <ReadAsyncInternal>b__17_0(object state);
                /*0x2126e80*/ int <ReadBlockAsync>b__19_0(object state);
            }

            struct <ReadToEndAsync>d__14 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<string> <>t__builder;
                /*0x30*/ System.IO.TextReader <>4__this;
                /*0x38*/ System.Text.StringBuilder <sb>5__2;
                /*0x40*/ char[] <chars>5__3;
                /*0x48*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__1;

                /*0x2126f74*/ void MoveNext();
                /*0x212741c*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <ReadBlockAsyncInternal>d__20 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<int> <>t__builder;
                /*0x38*/ System.IO.TextReader <>4__this;
                /*0x40*/ System.Memory<char> buffer;
                /*0x50*/ System.Threading.CancellationToken cancellationToken;
                /*0x58*/ int <n>5__2;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__1;

                /*0x2127474*/ void MoveNext();
                /*0x21277c4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        class TextWriter : System.MarshalByRefObject, System.IDisposable, System.IAsyncDisposable
        {
            static /*0x0*/ System.IO.TextWriter Null;
            static /*0x8*/ char[] s_coreNewLine;
            /*0x18*/ char[] CoreNewLine;
            /*0x20*/ string CoreNewLineStr;
            /*0x28*/ System.IFormatProvider _internalFormatProvider;

            static /*0x212883c*/ TextWriter();
            static /*0x2128700*/ System.IO.TextWriter Synchronized(System.IO.TextWriter writer);
            /*0x211f4d8*/ TextWriter();
            /*0x211ed2c*/ TextWriter(System.IFormatProvider formatProvider);
            /*0x212781c*/ System.IFormatProvider get_FormatProvider();
            /*0x2127884*/ void Close();
            /*0x21278f0*/ void Dispose(bool disposing);
            /*0x21278f4*/ void Dispose();
            /*0x211f938*/ System.Threading.Tasks.ValueTask DisposeAsync();
            /*0x2127960*/ void Flush();
            System.Text.Encoding get_Encoding();
            /*0x2127964*/ string get_NewLine();
            /*0x212796c*/ void set_NewLine(string value);
            /*0x21279b0*/ void Write(char value);
            /*0x21279b4*/ void Write(char[] buffer);
            /*0x21279d4*/ void Write(char[] buffer, int index, int count);
            /*0x2120508*/ void Write(System.ReadOnlySpan<char> buffer);
            /*0x2127b88*/ void Write(bool value);
            /*0x2127c04*/ void Write(int value);
            /*0x2127c54*/ void Write(uint value);
            /*0x2127ca4*/ void Write(long value);
            /*0x2127cf4*/ void Write(ulong value);
            /*0x2127d44*/ void Write(float value);
            /*0x2127d94*/ void Write(double value);
            /*0x2127de4*/ void Write(decimal value);
            /*0x2127e5c*/ void Write(string value);
            /*0x2127e94*/ void Write(object value);
            /*0x2127fa4*/ void Write(string format, object arg0);
            /*0x2127ff8*/ void Write(string format, object arg0, object arg1);
            /*0x212805c*/ void Write(string format, object arg0, object arg1, object arg2);
            /*0x21280c8*/ void Write(string format, object[] arg);
            /*0x212811c*/ void WriteLine();
            /*0x2128130*/ void WriteLine(char value);
            /*0x2128160*/ void WriteLine(char[] buffer);
            /*0x2128190*/ void WriteLine(char[] buffer, int index, int count);
            /*0x2121284*/ void WriteLine(System.ReadOnlySpan<char> buffer);
            /*0x21281c0*/ void WriteLine(bool value);
            /*0x21281f4*/ void WriteLine(int value);
            /*0x2128224*/ void WriteLine(uint value);
            /*0x2128254*/ void WriteLine(long value);
            /*0x2128284*/ void WriteLine(ulong value);
            /*0x21282b4*/ void WriteLine(float value);
            /*0x21282e4*/ void WriteLine(double value);
            /*0x2128314*/ void WriteLine(decimal value);
            /*0x2128344*/ void WriteLine(string value);
            /*0x2128380*/ void WriteLine(object value);
            /*0x21284a0*/ void WriteLine(string format, object arg0);
            /*0x21284f4*/ void WriteLine(string format, object arg0, object arg1);
            /*0x2128558*/ void WriteLine(string format, object arg0, object arg1, object arg2);
            /*0x21285c4*/ void WriteLine(string format, object[] arg);
            /*0x21215fc*/ System.Threading.Tasks.Task WriteAsync(char value);
            /*0x2121b60*/ System.Threading.Tasks.Task WriteAsync(string value);
            /*0x2128618*/ System.Threading.Tasks.Task WriteAsync(char[] buffer);
            /*0x21221c8*/ System.Threading.Tasks.Task WriteAsync(char[] buffer, int index, int count);
            /*0x2122784*/ System.Threading.Tasks.Task WriteAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x2122d78*/ System.Threading.Tasks.Task WriteLineAsync(char value);
            /*0x212317c*/ System.Threading.Tasks.Task WriteLineAsync(string value);
            /*0x21286d4*/ System.Threading.Tasks.Task WriteLineAsync(char[] buffer);
            /*0x21236bc*/ System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int index, int count);
            /*0x2123b1c*/ System.Threading.Tasks.Task WriteLineAsync(System.ReadOnlyMemory<char> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x2122bd8*/ System.Threading.Tasks.Task WriteLineAsync();
            /*0x2123ed8*/ System.Threading.Tasks.Task FlushAsync();

            class NullTextWriter : System.IO.TextWriter
            {
                /*0x21288d0*/ NullTextWriter();
                /*0x212895c*/ System.Text.Encoding get_Encoding();
                /*0x2128964*/ void Write(char[] buffer, int index, int count);
                /*0x2128968*/ void Write(string value);
                /*0x212896c*/ void WriteLine();
                /*0x2128970*/ void WriteLine(string value);
                /*0x2128974*/ void WriteLine(object value);
                /*0x2128978*/ void Write(char value);
            }

            class SyncTextWriter : System.IO.TextWriter, System.IDisposable
            {
                /*0x30*/ System.IO.TextWriter _out;

                /*0x21287c0*/ SyncTextWriter(System.IO.TextWriter t);
                /*0x212897c*/ System.Text.Encoding get_Encoding();
                /*0x21289a0*/ System.IFormatProvider get_FormatProvider();
                /*0x21289c0*/ string get_NewLine();
                /*0x21289e4*/ void set_NewLine(string value);
                /*0x2128a08*/ void Close();
                /*0x2128a28*/ void Dispose(bool disposing);
                /*0x2128adc*/ void Flush();
                /*0x2128b00*/ void Write(char value);
                /*0x2128b24*/ void Write(char[] buffer);
                /*0x2128b48*/ void Write(char[] buffer, int index, int count);
                /*0x2128b6c*/ void Write(bool value);
                /*0x2128b94*/ void Write(int value);
                /*0x2128bb8*/ void Write(uint value);
                /*0x2128bdc*/ void Write(long value);
                /*0x2128c00*/ void Write(ulong value);
                /*0x2128c24*/ void Write(float value);
                /*0x2128c48*/ void Write(double value);
                /*0x2128c6c*/ void Write(decimal value);
                /*0x2128c90*/ void Write(string value);
                /*0x2128cb4*/ void Write(object value);
                /*0x2128cd8*/ void Write(string format, object arg0);
                /*0x2128cfc*/ void Write(string format, object arg0, object arg1);
                /*0x2128d20*/ void Write(string format, object arg0, object arg1, object arg2);
                /*0x2128d44*/ void Write(string format, object[] arg);
                /*0x2128d68*/ void WriteLine();
                /*0x2128d8c*/ void WriteLine(char value);
                /*0x2128db0*/ void WriteLine(decimal value);
                /*0x2128dd4*/ void WriteLine(char[] buffer);
                /*0x2128df8*/ void WriteLine(char[] buffer, int index, int count);
                /*0x2128e1c*/ void WriteLine(bool value);
                /*0x2128e44*/ void WriteLine(int value);
                /*0x2128e68*/ void WriteLine(uint value);
                /*0x2128e8c*/ void WriteLine(long value);
                /*0x2128eb0*/ void WriteLine(ulong value);
                /*0x2128ed4*/ void WriteLine(float value);
                /*0x2128ef8*/ void WriteLine(double value);
                /*0x2128f1c*/ void WriteLine(string value);
                /*0x2128f40*/ void WriteLine(object value);
                /*0x2128f64*/ void WriteLine(string format, object arg0);
                /*0x2128f88*/ void WriteLine(string format, object arg0, object arg1);
                /*0x2128fac*/ void WriteLine(string format, object arg0, object arg1, object arg2);
                /*0x2128fd0*/ void WriteLine(string format, object[] arg);
                /*0x2128ff4*/ System.Threading.Tasks.Task WriteAsync(char value);
                /*0x21290a4*/ System.Threading.Tasks.Task WriteAsync(string value);
                /*0x2129154*/ System.Threading.Tasks.Task WriteAsync(char[] buffer, int index, int count);
                /*0x212921c*/ System.Threading.Tasks.Task WriteLineAsync(char value);
                /*0x21292cc*/ System.Threading.Tasks.Task WriteLineAsync(string value);
                /*0x212937c*/ System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int index, int count);
                /*0x2129444*/ System.Threading.Tasks.Task FlushAsync();
            }

            class <>c
            {
                static /*0x0*/ System.IO.TextWriter.<> <>9;
                static /*0x8*/ System.Action<object> <>9__56_0;
                static /*0x10*/ System.Action<object> <>9__57_0;
                static /*0x18*/ System.Action<object> <>9__59_0;
                static /*0x20*/ System.Action<object> <>9__60_0;
                static /*0x28*/ System.Action<object> <>9__61_0;
                static /*0x30*/ System.Action<object> <>9__62_0;
                static /*0x38*/ System.Action<object> <>9__64_0;
                static /*0x40*/ System.Action<object> <>9__65_0;
                static /*0x48*/ System.Action<object> <>9__67_0;

                static /*0x21294e4*/ <>c();
                /*0x2129548*/ <>c();
                /*0x2129550*/ void <WriteAsync>b__56_0(object state);
                /*0x21295fc*/ void <WriteAsync>b__57_0(object state);
                /*0x21296a8*/ void <WriteAsync>b__59_0(object state);
                /*0x2129770*/ void <WriteAsync>b__60_0(object state);
                /*0x2129864*/ void <WriteLineAsync>b__61_0(object state);
                /*0x2129910*/ void <WriteLineAsync>b__62_0(object state);
                /*0x21299bc*/ void <WriteLineAsync>b__64_0(object state);
                /*0x2129a84*/ void <WriteLineAsync>b__65_0(object state);
                /*0x2129b78*/ void <FlushAsync>b__67_0(object state);
            }
        }

        class UnmanagedMemoryAccessor : System.IDisposable
        {
            /*0x10*/ System.Runtime.InteropServices.SafeBuffer _buffer;
            /*0x18*/ long _offset;
            /*0x20*/ long _capacity;
            /*0x28*/ System.IO.FileAccess _access;
            /*0x2c*/ bool _isOpen;
            /*0x2d*/ bool _canRead;
            /*0x2e*/ bool _canWrite;

            /*0x2129c28*/ UnmanagedMemoryAccessor();
            /*0x2129c44*/ UnmanagedMemoryAccessor(System.Runtime.InteropServices.SafeBuffer buffer, long offset, long capacity);
            /*0x2129f9c*/ UnmanagedMemoryAccessor(System.Runtime.InteropServices.SafeBuffer buffer, long offset, long capacity, System.IO.FileAccess access);
            /*0x2129c8c*/ void Initialize(System.Runtime.InteropServices.SafeBuffer buffer, long offset, long capacity, System.IO.FileAccess access);
            /*0x2129fe8*/ long get_Capacity();
            /*0x2129ff0*/ bool get_CanRead();
            /*0x212a010*/ bool get_CanWrite();
            /*0x212a030*/ void Dispose(bool disposing);
            /*0x212a038*/ void Dispose();
            /*0x212a0a4*/ bool get_IsOpen();
            /*0x212a0ac*/ bool ReadBoolean(long position);
            /*0x212a0c4*/ byte ReadByte(long position);
            /*0x212a358*/ char ReadChar(long position);
            /*0x212a35c*/ short ReadInt16(long position);
            /*0x212a44c*/ int ReadInt32(long position);
            /*0x212a53c*/ long ReadInt64(long position);
            /*0x212a62c*/ decimal ReadDecimal(long position);
            /*0x212a7ec*/ float ReadSingle(long position);
            /*0x212a860*/ double ReadDouble(long position);
            /*0x212a8d4*/ sbyte ReadSByte(long position);
            /*0x212a8d8*/ ushort ReadUInt16(long position);
            /*0x212a8dc*/ uint ReadUInt32(long position);
            /*0x212a8e0*/ ulong ReadUInt64(long position);
            void Read<T>(long position, ref T structure);
            int ReadArray<T>(long position, T[] array, int offset, int count);
            /*0x212a8e4*/ void Write(long position, bool value);
            /*0x212a8f8*/ void Write(long position, byte value);
            /*0x212ab84*/ void Write(long position, char value);
            /*0x212ab88*/ void Write(long position, short value);
            /*0x212ac74*/ void Write(long position, int value);
            /*0x212ad60*/ void Write(long position, long value);
            /*0x212ae4c*/ void Write(long position, decimal value);
            /*0x212af88*/ void Write(long position, float value);
            /*0x212affc*/ void Write(long position, double value);
            /*0x212b070*/ void Write(long position, sbyte value);
            /*0x212b074*/ void Write(long position, ushort value);
            /*0x212b078*/ void Write(long position, uint value);
            /*0x212b07c*/ void Write(long position, ulong value);
            void Write<T>(long position, ref T structure);
            void WriteArray<T>(long position, T[] array, int offset, int count);
            /*0x212a1b4*/ void EnsureSafeToRead(long position, int sizeOfType);
            /*0x212a9e0*/ void EnsureSafeToWrite(long position, int sizeOfType);
        }

        class UnmanagedMemoryStream : System.IO.Stream
        {
            /*0x28*/ System.Runtime.InteropServices.SafeBuffer _buffer;
            /*0x30*/ byte* _mem;
            /*0x38*/ long _length;
            /*0x40*/ long _capacity;
            /*0x48*/ long _position;
            /*0x50*/ long _offset;
            /*0x58*/ System.IO.FileAccess _access;
            /*0x5c*/ bool _isOpen;
            /*0x60*/ System.Threading.Tasks.Task<int> _lastReadTask;

            /*0x2118224*/ UnmanagedMemoryStream();
            /*0x212b080*/ UnmanagedMemoryStream(System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length);
            /*0x212b418*/ UnmanagedMemoryStream(System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
            /*0x212b4a8*/ UnmanagedMemoryStream(byte* pointer, long length);
            /*0x212b528*/ UnmanagedMemoryStream(byte* pointer, long length, long capacity, System.IO.FileAccess access);
            /*0x212b10c*/ void Initialize(System.Runtime.InteropServices.SafeBuffer buffer, long offset, long length, System.IO.FileAccess access);
            /*0x2118288*/ void Initialize(byte* pointer, long length, long capacity, System.IO.FileAccess access);
            /*0x212b5b8*/ bool get_CanRead();
            /*0x212b5d4*/ bool get_CanSeek();
            /*0x212b5dc*/ bool get_CanWrite();
            /*0x2118ab8*/ void Dispose(bool disposing);
            /*0x212b5f8*/ void EnsureNotClosed();
            /*0x212b630*/ void EnsureReadable();
            /*0x212b670*/ void EnsureWriteable();
            /*0x212b6b0*/ void Flush();
            /*0x212b6b4*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x212b828*/ long get_Length();
            /*0x212b844*/ long get_Capacity();
            /*0x212b85c*/ long get_Position();
            /*0x212b8a8*/ void set_Position(long value);
            /*0x212b954*/ byte* get_PositionPointer();
            /*0x212ba14*/ void set_PositionPointer(byte* value);
            /*0x212bb28*/ int Read(byte[] buffer, int offset, int count);
            /*0x212bce8*/ int Read(System.Span<byte> buffer);
            /*0x2118494*/ int ReadCore(System.Span<byte> buffer);
            /*0x212bdcc*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x212c0dc*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x212c370*/ int ReadByte();
            /*0x212c4d0*/ long Seek(long offset, System.IO.SeekOrigin loc);
            /*0x212c5e4*/ void SetLength(long value);
            /*0x212c778*/ void Write(byte[] buffer, int offset, int count);
            /*0x212c964*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x21186c4*/ void WriteCore(System.ReadOnlySpan<byte> buffer);
            /*0x212ca48*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x212cd08*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x212cf1c*/ void WriteByte(byte value);
        }

        class UnmanagedMemoryStreamWrapper : System.IO.MemoryStream
        {
            /*0x50*/ System.IO.UnmanagedMemoryStream _unmanagedStream;

            /*0x212d148*/ UnmanagedMemoryStreamWrapper(System.IO.UnmanagedMemoryStream stream);
            /*0x212d170*/ bool get_CanRead();
            /*0x212d190*/ bool get_CanSeek();
            /*0x212d1b0*/ bool get_CanWrite();
            /*0x212d1d0*/ void Dispose(bool disposing);
            /*0x212d288*/ void Flush();
            /*0x212d2ac*/ byte[] GetBuffer();
            /*0x212d2fc*/ bool TryGetBuffer(ref System.ArraySegment<byte> buffer);
            /*0x212d308*/ int get_Capacity();
            /*0x212d32c*/ void set_Capacity(int value);
            /*0x212d37c*/ long get_Length();
            /*0x212d3a0*/ long get_Position();
            /*0x212d3c4*/ void set_Position(long value);
            /*0x212d3e8*/ int Read(byte[] buffer, int offset, int count);
            /*0x212d40c*/ int Read(System.Span<byte> buffer);
            /*0x212d430*/ int ReadByte();
            /*0x212d454*/ long Seek(long offset, System.IO.SeekOrigin loc);
            /*0x212d478*/ byte[] ToArray();
            /*0x212d534*/ void Write(byte[] buffer, int offset, int count);
            /*0x212d558*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x212d57c*/ void WriteByte(byte value);
            /*0x212d5a0*/ void WriteTo(System.IO.Stream stream);
            /*0x212d650*/ void SetLength(long value);
            /*0x212d658*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
            /*0x212d89c*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x212d8c0*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x212d8e4*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x212d908*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x212d92c*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
        }

        class DriveNotFoundException : System.IO.IOException
        {
            /*0x212d950*/ DriveNotFoundException();
            /*0x212d9ac*/ DriveNotFoundException(string message);
            /*0x212d9d0*/ DriveNotFoundException(string message, System.Exception innerException);
            /*0x212d9f4*/ DriveNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
        }

        enum DriveType
        {
            Unknown = 0,
            NoRootDirectory = 1,
            Removable = 2,
            Fixed = 3,
            Network = 4,
            CDRom = 5,
            Ram = 6,
        }

        class Directory
        {
            static /*0x212d9fc*/ System.IO.DirectoryInfo GetParent(string path);
            static /*0x212db4c*/ System.IO.DirectoryInfo CreateDirectory(string path);
            static /*0x212dc9c*/ bool Exists(string path);
            static /*0x212de10*/ void SetCreationTime(string path, System.DateTime creationTime);
            static /*0x212decc*/ void SetCreationTimeUtc(string path, System.DateTime creationTimeUtc);
            static /*0x212df60*/ System.DateTime GetCreationTime(string path);
            static /*0x212df68*/ System.DateTime GetCreationTimeUtc(string path);
            static /*0x212df70*/ void SetLastWriteTime(string path, System.DateTime lastWriteTime);
            static /*0x212e02c*/ void SetLastWriteTimeUtc(string path, System.DateTime lastWriteTimeUtc);
            static /*0x212e0c0*/ System.DateTime GetLastWriteTime(string path);
            static /*0x212e0c8*/ System.DateTime GetLastWriteTimeUtc(string path);
            static /*0x212e0d0*/ void SetLastAccessTime(string path, System.DateTime lastAccessTime);
            static /*0x212e18c*/ void SetLastAccessTimeUtc(string path, System.DateTime lastAccessTimeUtc);
            static /*0x212e220*/ System.DateTime GetLastAccessTime(string path);
            static /*0x212e228*/ System.DateTime GetLastAccessTimeUtc(string path);
            static /*0x212e230*/ string[] GetFiles(string path);
            static /*0x212e340*/ string[] GetFiles(string path, string searchPattern);
            static /*0x212e3e0*/ string[] GetFiles(string path, string searchPattern, System.IO.SearchOption searchOption);
            static /*0x212e2d8*/ string[] GetFiles(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            static /*0x212e624*/ string[] GetDirectories(string path);
            static /*0x212e734*/ string[] GetDirectories(string path, string searchPattern);
            static /*0x212e7d4*/ string[] GetDirectories(string path, string searchPattern, System.IO.SearchOption searchOption);
            static /*0x212e6cc*/ string[] GetDirectories(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            static /*0x212e84c*/ string[] GetFileSystemEntries(string path);
            static /*0x212e95c*/ string[] GetFileSystemEntries(string path, string searchPattern);
            static /*0x212e9fc*/ string[] GetFileSystemEntries(string path, string searchPattern, System.IO.SearchOption searchOption);
            static /*0x212e8f4*/ string[] GetFileSystemEntries(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            static /*0x212e458*/ System.Collections.Generic.IEnumerable<string> InternalEnumeratePaths(string path, string searchPattern, System.IO.SearchTarget searchTarget, System.IO.EnumerationOptions options);
            static /*0x212ea74*/ System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path);
            static /*0x212eb2c*/ System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern);
            static /*0x212ebd0*/ System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern, System.IO.SearchOption searchOption);
            static /*0x212eb20*/ System.Collections.Generic.IEnumerable<string> EnumerateDirectories(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            static /*0x212ec4c*/ System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path);
            static /*0x212ed04*/ System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern);
            static /*0x212eda8*/ System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern, System.IO.SearchOption searchOption);
            static /*0x212ecf8*/ System.Collections.Generic.IEnumerable<string> EnumerateFiles(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            static /*0x212ee24*/ System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path);
            static /*0x212eedc*/ System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern);
            static /*0x212ef80*/ System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, System.IO.SearchOption searchOption);
            static /*0x212eed0*/ System.Collections.Generic.IEnumerable<string> EnumerateFileSystemEntries(string path, string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            static /*0x212effc*/ string GetDirectoryRoot(string path);
            static /*0x212f140*/ string InternalGetDirectoryRoot(string path);
            static /*0x212f1f8*/ string GetCurrentDirectory();
            static /*0x212f200*/ void SetCurrentDirectory(string path);
            static /*0x212f304*/ void Move(string sourceDirName, string destDirName);
            static /*0x212f72c*/ void Delete(string path);
            static /*0x212f790*/ void Delete(string path, bool recursive);
            static /*0x212f800*/ string[] GetLogicalDrives();
            static /*0x212f808*/ System.IO.DirectoryInfo CreateDirectory(string path, System.Security.AccessControl.DirectorySecurity directorySecurity);
            static /*0x212f80c*/ System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, System.Security.AccessControl.AccessControlSections includeSections);
            static /*0x212f880*/ System.Security.AccessControl.DirectorySecurity GetAccessControl(string path);
            static /*0x212f888*/ void SetAccessControl(string path, System.Security.AccessControl.DirectorySecurity directorySecurity);
            static /*0x212f944*/ string InsecureGetCurrentDirectory();
            static /*0x212f9e0*/ void InsecureSetCurrentDirectory(string path);
        }

        class DirectoryInfo : System.IO.FileSystemInfo
        {
            static /*0x2130e14*/ System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> InternalEnumerateInfos(string path, string searchPattern, System.IO.SearchTarget searchTarget, System.IO.EnumerationOptions options);
            /*0x212fb98*/ DirectoryInfo(string path);
            /*0x212ff28*/ DirectoryInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
            /*0x21323bc*/ DirectoryInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x212fc90*/ void Init(string originalPath, string fullPath, string fileName, bool isNormalized);
            /*0x212ff70*/ System.IO.DirectoryInfo get_Parent();
            /*0x21300cc*/ System.IO.DirectoryInfo CreateSubdirectory(string path);
            /*0x2130a50*/ void Create();
            /*0x2130a7c*/ System.IO.FileInfo[] GetFiles();
            /*0x2130bc4*/ System.IO.FileInfo[] GetFiles(string searchPattern);
            /*0x2130c64*/ System.IO.FileInfo[] GetFiles(string searchPattern, System.IO.SearchOption searchOption);
            /*0x2130b24*/ System.IO.FileInfo[] GetFiles(string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            /*0x2130fd4*/ System.IO.FileSystemInfo[] GetFileSystemInfos();
            /*0x21310e4*/ System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern);
            /*0x2131184*/ System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, System.IO.SearchOption searchOption);
            /*0x213107c*/ System.IO.FileSystemInfo[] GetFileSystemInfos(string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            /*0x21311f8*/ System.IO.DirectoryInfo[] GetDirectories();
            /*0x2131340*/ System.IO.DirectoryInfo[] GetDirectories(string searchPattern);
            /*0x21313e0*/ System.IO.DirectoryInfo[] GetDirectories(string searchPattern, System.IO.SearchOption searchOption);
            /*0x21312a0*/ System.IO.DirectoryInfo[] GetDirectories(string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            /*0x2131454*/ System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories();
            /*0x2131584*/ System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories(string searchPattern);
            /*0x2131624*/ System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories(string searchPattern, System.IO.SearchOption searchOption);
            /*0x21314fc*/ System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> EnumerateDirectories(string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            /*0x2131698*/ System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles();
            /*0x21317c8*/ System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles(string searchPattern);
            /*0x2131868*/ System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles(string searchPattern, System.IO.SearchOption searchOption);
            /*0x2131740*/ System.Collections.Generic.IEnumerable<System.IO.FileInfo> EnumerateFiles(string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            /*0x21318dc*/ System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos();
            /*0x2131998*/ System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
            /*0x2131a3c*/ System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, System.IO.SearchOption searchOption);
            /*0x2131988*/ System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, System.IO.EnumerationOptions enumerationOptions);
            /*0x2131ab8*/ System.IO.DirectoryInfo get_Root();
            /*0x2131b54*/ void MoveTo(string destDirName);
            /*0x21322e0*/ void Delete();
            /*0x21323b0*/ void Delete(bool recursive);
            /*0x2132504*/ void Create(System.Security.AccessControl.DirectorySecurity directorySecurity);
            /*0x213250c*/ System.IO.DirectoryInfo CreateSubdirectory(string path, System.Security.AccessControl.DirectorySecurity directorySecurity);
            /*0x2132510*/ System.Security.AccessControl.DirectorySecurity GetAccessControl();
            /*0x2132520*/ System.Security.AccessControl.DirectorySecurity GetAccessControl(System.Security.AccessControl.AccessControlSections includeSections);
            /*0x213252c*/ void SetAccessControl(System.Security.AccessControl.DirectorySecurity directorySecurity);
        }

        class EnumerationOptions
        {
            static /*0x0*/ System.IO.EnumerationOptions <Compatible>k__BackingField;
            static /*0x8*/ System.IO.EnumerationOptions <CompatibleRecursive>k__BackingField;
            static /*0x10*/ System.IO.EnumerationOptions <Default>k__BackingField;
            /*0x10*/ bool <RecurseSubdirectories>k__BackingField;
            /*0x11*/ bool <IgnoreInaccessible>k__BackingField;
            /*0x14*/ int <BufferSize>k__BackingField;
            /*0x18*/ System.IO.FileAttributes <AttributesToSkip>k__BackingField;
            /*0x1c*/ System.IO.MatchType <MatchType>k__BackingField;
            /*0x20*/ System.IO.MatchCasing <MatchCasing>k__BackingField;
            /*0x24*/ bool <ReturnSpecialDirectories>k__BackingField;

            static /*0x21326e4*/ EnumerationOptions();
            static /*0x2132538*/ System.IO.EnumerationOptions get_Compatible();
            static /*0x2132590*/ System.IO.EnumerationOptions get_CompatibleRecursive();
            static /*0x21325e8*/ System.IO.EnumerationOptions get_Default();
            static /*0x2130cd8*/ System.IO.EnumerationOptions FromSearchOption(System.IO.SearchOption searchOption);
            /*0x2132640*/ EnumerationOptions();
            /*0x2132668*/ bool get_RecurseSubdirectories();
            /*0x2132670*/ void set_RecurseSubdirectories(bool value);
            /*0x213267c*/ bool get_IgnoreInaccessible();
            /*0x2132684*/ void set_IgnoreInaccessible(bool value);
            /*0x2132690*/ int get_BufferSize();
            /*0x2132698*/ void set_BufferSize(int value);
            /*0x21326a0*/ System.IO.FileAttributes get_AttributesToSkip();
            /*0x21326a8*/ void set_AttributesToSkip(System.IO.FileAttributes value);
            /*0x21326b0*/ System.IO.MatchType get_MatchType();
            /*0x21326b8*/ void set_MatchType(System.IO.MatchType value);
            /*0x21326c0*/ System.IO.MatchCasing get_MatchCasing();
            /*0x21326c8*/ void set_MatchCasing(System.IO.MatchCasing value);
            /*0x21326d0*/ bool get_ReturnSpecialDirectories();
            /*0x21326d8*/ void set_ReturnSpecialDirectories(bool value);
        }

        class File
        {
            static int MaxByteArrayLength = 2147483591;
            static int DefaultBufferSize = 4096;
            static /*0x0*/ System.Text.Encoding s_UTF8NoBOM;

            static /*0x21327bc*/ System.IO.StreamReader OpenText(string path);
            static /*0x2132870*/ System.IO.StreamWriter CreateText(string path);
            static /*0x2132928*/ System.IO.StreamWriter AppendText(string path);
            static /*0x21329e0*/ void Copy(string sourceFileName, string destFileName);
            static /*0x21329e8*/ void Copy(string sourceFileName, string destFileName, bool overwrite);
            static /*0x2132fb4*/ System.IO.FileStream Create(string path);
            static /*0x2132fbc*/ System.IO.FileStream Create(string path, int bufferSize);
            static /*0x213303c*/ System.IO.FileStream Create(string path, int bufferSize, System.IO.FileOptions options);
            static /*0x21330c4*/ void Delete(string path);
            static /*0x2133320*/ bool Exists(string path);
            static /*0x21334e4*/ System.IO.FileStream Open(string path, System.IO.FileMode mode);
            static /*0x2133584*/ System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileAccess access);
            static /*0x21334f8*/ System.IO.FileStream Open(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
            static /*0x213358c*/ System.DateTimeOffset GetUtcDateTimeOffset(System.DateTime dateTime);
            static /*0x2133648*/ void SetCreationTime(string path, System.DateTime creationTime);
            static /*0x21337dc*/ void SetCreationTimeUtc(string path, System.DateTime creationTimeUtc);
            static /*0x2133868*/ System.DateTime GetCreationTime(string path);
            static /*0x2133988*/ System.DateTime GetCreationTimeUtc(string path);
            static /*0x2133a04*/ void SetLastAccessTime(string path, System.DateTime lastAccessTime);
            static /*0x2133b98*/ void SetLastAccessTimeUtc(string path, System.DateTime lastAccessTimeUtc);
            static /*0x2133c24*/ System.DateTime GetLastAccessTime(string path);
            static /*0x2133d44*/ System.DateTime GetLastAccessTimeUtc(string path);
            static /*0x2133dc0*/ void SetLastWriteTime(string path, System.DateTime lastWriteTime);
            static /*0x2133f54*/ void SetLastWriteTimeUtc(string path, System.DateTime lastWriteTimeUtc);
            static /*0x2133fe0*/ System.DateTime GetLastWriteTime(string path);
            static /*0x2134100*/ System.DateTime GetLastWriteTimeUtc(string path);
            static /*0x213417c*/ System.IO.FileAttributes GetAttributes(string path);
            static /*0x2134258*/ void SetAttributes(string path, System.IO.FileAttributes fileAttributes);
            static /*0x21343e0*/ System.IO.FileStream OpenRead(string path);
            static /*0x2134450*/ System.IO.FileStream OpenWrite(string path);
            static /*0x21344c0*/ string ReadAllText(string path);
            static /*0x2134738*/ string ReadAllText(string path, System.Text.Encoding encoding);
            static /*0x213458c*/ string InternalReadAllText(string path, System.Text.Encoding encoding);
            static /*0x2134818*/ void WriteAllText(string path, string contents);
            static /*0x2134a58*/ void WriteAllText(string path, string contents, System.Text.Encoding encoding);
            static /*0x2134ccc*/ byte[] ReadAllBytes(string path);
            static /*0x2134f88*/ byte[] ReadAllBytesUnknownLength(System.IO.FileStream fs);
            static /*0x21353f8*/ void WriteAllBytes(string path, byte[] bytes);
            static /*0x2135500*/ void InternalWriteAllBytes(string path, byte[] bytes);
            static /*0x21356b8*/ string[] ReadAllLines(string path);
            static /*0x2135a04*/ string[] ReadAllLines(string path, System.Text.Encoding encoding);
            static /*0x2135784*/ string[] InternalReadAllLines(string path, System.Text.Encoding encoding);
            static /*0x2135ae4*/ System.Collections.Generic.IEnumerable<string> ReadLines(string path);
            static /*0x2135bbc*/ System.Collections.Generic.IEnumerable<string> ReadLines(string path, System.Text.Encoding encoding);
            static /*0x2135ca0*/ void WriteAllLines(string path, string[] contents);
            static /*0x2135ca4*/ void WriteAllLines(string path, System.Collections.Generic.IEnumerable<string> contents);
            static /*0x21361e0*/ void WriteAllLines(string path, string[] contents, System.Text.Encoding encoding);
            static /*0x21361e4*/ void WriteAllLines(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding);
            static /*0x2135ddc*/ void InternalWriteAllLines(System.IO.TextWriter writer, System.Collections.Generic.IEnumerable<string> contents);
            static /*0x2136358*/ void AppendAllText(string path, string contents);
            static /*0x213659c*/ void AppendAllText(string path, string contents, System.Text.Encoding encoding);
            static /*0x2136810*/ void AppendAllLines(string path, System.Collections.Generic.IEnumerable<string> contents);
            static /*0x213694c*/ void AppendAllLines(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding);
            static /*0x2136ac0*/ void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
            static /*0x2136ac8*/ void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
            static /*0x2136d68*/ void Move(string sourceFileName, string destFileName);
            static /*0x21370c4*/ void Encrypt(string path);
            static /*0x2137150*/ void Decrypt(string path);
            static /*0x21371dc*/ System.Text.Encoding get_UTF8NoBOM();
            static /*0x2137270*/ System.IO.StreamReader AsyncStreamReader(string path, System.Text.Encoding encoding);
            static /*0x213732c*/ System.IO.StreamWriter AsyncStreamWriter(string path, System.Text.Encoding encoding, bool append);
            static /*0x21373f4*/ System.Threading.Tasks.Task<string> ReadAllTextAsync(string path, System.Threading.CancellationToken cancellationToken);
            static /*0x2137424*/ System.Threading.Tasks.Task<string> ReadAllTextAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken);
            static /*0x2137598*/ System.Threading.Tasks.Task<string> InternalReadAllTextAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken);
            static /*0x213769c*/ System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, System.Threading.CancellationToken cancellationToken);
            static /*0x21376d0*/ System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken);
            static /*0x21379e8*/ System.Threading.Tasks.Task<System.Byte[]> ReadAllBytesAsync(string path, System.Threading.CancellationToken cancellationToken);
            static /*0x2137d38*/ System.Threading.Tasks.Task<System.Byte[]> InternalReadAllBytesAsync(System.IO.FileStream fs, int count, System.Threading.CancellationToken cancellationToken);
            static /*0x2137c3c*/ System.Threading.Tasks.Task<System.Byte[]> InternalReadAllBytesUnknownLengthAsync(System.IO.FileStream fs, System.Threading.CancellationToken cancellationToken);
            static /*0x2137e40*/ System.Threading.Tasks.Task WriteAllBytesAsync(string path, byte[] bytes, System.Threading.CancellationToken cancellationToken);
            static /*0x2137fc8*/ System.Threading.Tasks.Task InternalWriteAllBytesAsync(string path, byte[] bytes, System.Threading.CancellationToken cancellationToken);
            static /*0x21380ac*/ System.Threading.Tasks.Task<System.String[]> ReadAllLinesAsync(string path, System.Threading.CancellationToken cancellationToken);
            static /*0x21380dc*/ System.Threading.Tasks.Task<System.String[]> ReadAllLinesAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken);
            static /*0x2138250*/ System.Threading.Tasks.Task<System.String[]> InternalReadAllLinesAsync(string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken);
            static /*0x2138358*/ System.Threading.Tasks.Task WriteAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Threading.CancellationToken cancellationToken);
            static /*0x213838c*/ System.Threading.Tasks.Task WriteAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken);
            static /*0x2138524*/ System.Threading.Tasks.Task InternalWriteAllLinesAsync(System.IO.TextWriter writer, System.Collections.Generic.IEnumerable<string> contents, System.Threading.CancellationToken cancellationToken);
            static /*0x2137904*/ System.Threading.Tasks.Task InternalWriteAllTextAsync(System.IO.StreamWriter sw, string contents, System.Threading.CancellationToken cancellationToken);
            static /*0x213860c*/ System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, System.Threading.CancellationToken cancellationToken);
            static /*0x2138640*/ System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken);
            static /*0x2138864*/ System.Threading.Tasks.Task AppendAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Threading.CancellationToken cancellationToken);
            static /*0x2138898*/ System.Threading.Tasks.Task AppendAllLinesAsync(string path, System.Collections.Generic.IEnumerable<string> contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken);
            static /*0x2138a30*/ System.IO.FileStream Create(string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
            static /*0x2138ab8*/ System.Security.AccessControl.FileSecurity GetAccessControl(string path);
            static /*0x2138ac0*/ System.Security.AccessControl.FileSecurity GetAccessControl(string path, System.Security.AccessControl.AccessControlSections includeSections);
            static /*0x2138b34*/ void SetAccessControl(string path, System.Security.AccessControl.FileSecurity fileSecurity);

            struct <InternalReadAllTextAsync>d__67 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<string> <>t__builder;
                /*0x30*/ string path;
                /*0x38*/ System.Text.Encoding encoding;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ char[] <buffer>5__2;
                /*0x50*/ System.IO.StreamReader <sr>5__3;
                /*0x58*/ System.Text.StringBuilder <sb>5__4;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__1;

                /*0x2138b9c*/ void MoveNext();
                /*0x2139104*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <InternalReadAllBytesAsync>d__71 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<System.Byte[]> <>t__builder;
                /*0x30*/ System.IO.FileStream fs;
                /*0x38*/ int count;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ System.IO.FileStream <>7__wrap1;
                /*0x50*/ int <index>5__3;
                /*0x58*/ byte[] <bytes>5__4;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__1;

                /*0x213915c*/ void MoveNext();
                /*0x213968c*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <InternalReadAllBytesUnknownLengthAsync>d__72 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<System.Byte[]> <>t__builder;
                /*0x30*/ System.IO.FileStream fs;
                /*0x38*/ System.Threading.CancellationToken cancellationToken;
                /*0x40*/ byte[] <rentedArray>5__2;
                /*0x48*/ int <bytesRead>5__3;
                /*0x50*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__1;

                /*0x21396e4*/ void MoveNext();
                /*0x2139dc4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <InternalWriteAllBytesAsync>d__74 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ string path;
                /*0x38*/ byte[] bytes;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ System.IO.FileStream <fs>5__2;
                /*0x50*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__1;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__2;

                /*0x2139e1c*/ void MoveNext();
                /*0x213a3f4*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <InternalReadAllLinesAsync>d__77 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder<System.String[]> <>t__builder;
                /*0x30*/ string path;
                /*0x38*/ System.Text.Encoding encoding;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ System.IO.StreamReader <sr>5__2;
                /*0x50*/ System.Collections.Generic.List<string> <lines>5__3;
                /*0x58*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<string> <>u__1;

                /*0x213a400*/ void MoveNext();
                /*0x213a8c8*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <InternalWriteAllLinesAsync>d__80 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.IO.TextWriter writer;
                /*0x38*/ System.Collections.Generic.IEnumerable<string> contents;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ System.IO.TextWriter <>7__wrap1;
                /*0x50*/ System.Collections.Generic.IEnumerator<string> <>7__wrap2;
                /*0x58*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;

                /*0x213a920*/ void MoveNext();
                /*0x213b014*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <InternalWriteAllTextAsync>d__81 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ string contents;
                /*0x38*/ System.IO.StreamWriter sw;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ char[] <buffer>5__2;
                /*0x50*/ int <count>5__3;
                /*0x54*/ int <index>5__4;
                /*0x58*/ int <batchSize>5__5;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;

                /*0x213b020*/ void MoveNext();
                /*0x213b4fc*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        class FileInfo : System.IO.FileSystemInfo
        {
            /*0x213b508*/ FileInfo();
            /*0x213b50c*/ FileInfo(string fileName);
            /*0x213b51c*/ FileInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
            /*0x213c210*/ FileInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x213c230*/ FileInfo(string fullPath, bool ignoreThis);
            /*0x213b644*/ long get_Length();
            /*0x213b820*/ string get_DirectoryName();
            /*0x213b87c*/ System.IO.DirectoryInfo get_Directory();
            /*0x213b8f4*/ bool get_IsReadOnly();
            /*0x213b908*/ void set_IsReadOnly(bool value);
            /*0x213b954*/ System.IO.StreamReader OpenText();
            /*0x213b9d4*/ System.IO.StreamWriter CreateText();
            /*0x213ba40*/ System.IO.StreamWriter AppendText();
            /*0x213baac*/ System.IO.FileInfo CopyTo(string destFileName);
            /*0x213bab4*/ System.IO.FileInfo CopyTo(string destFileName, bool overwrite);
            /*0x213bc30*/ System.IO.FileStream Create();
            /*0x213bc3c*/ void Delete();
            /*0x213bc44*/ System.IO.FileStream Open(System.IO.FileMode mode);
            /*0x213bcf4*/ System.IO.FileStream Open(System.IO.FileMode mode, System.IO.FileAccess access);
            /*0x213bc64*/ System.IO.FileStream Open(System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
            /*0x213bcfc*/ System.IO.FileStream OpenRead();
            /*0x213bd78*/ System.IO.FileStream OpenWrite();
            /*0x213bdec*/ void MoveTo(string destFileName);
            /*0x213c0a8*/ System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName);
            /*0x213c0b0*/ System.IO.FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
            /*0x213c1f8*/ void Decrypt();
            /*0x213c204*/ void Encrypt();
            /*0x213c214*/ System.Security.AccessControl.FileSecurity GetAccessControl();
            /*0x213c220*/ System.Security.AccessControl.FileSecurity GetAccessControl(System.Security.AccessControl.AccessControlSections includeSections);
            /*0x213c228*/ void SetAccessControl(System.Security.AccessControl.FileSecurity fileSecurity);
            /*0x213c2a8*/ string get_Name();
        }

        struct FileStatus
        {
            /*0x10*/ Interop.Sys.FileStatus _fileStatus;
            /*0x80*/ int _fileStatusInitialized;
            /*0x84*/ bool <InitiallyDirectory>k__BackingField;
            /*0x85*/ bool _isDirectory;
            /*0x86*/ bool _exists;

            static /*0x213c2c4*/ void Initialize(ref System.IO.FileStatus status, bool isDirectory);
            /*0x213c2b0*/ bool get_InitiallyDirectory();
            /*0x213c2b8*/ void set_InitiallyDirectory(bool value);
            /*0x213c2d8*/ void Invalidate();
            /*0x213c2e4*/ bool IsReadOnly(System.ReadOnlySpan<char> path, bool continueOnError);
            /*0x213c490*/ System.IO.FileAttributes GetAttributes(System.ReadOnlySpan<char> path, System.ReadOnlySpan<char> fileName);
            /*0x213c578*/ void SetAttributes(string path, System.IO.FileAttributes attributes);
            /*0x213c810*/ bool GetExists(System.ReadOnlySpan<char> path);
            /*0x213c9ec*/ System.DateTimeOffset GetCreationTime(System.ReadOnlySpan<char> path, bool continueOnError);
            /*0x213cb84*/ void SetCreationTime(string path, System.DateTimeOffset time);
            /*0x213cc90*/ System.DateTimeOffset GetLastAccessTime(System.ReadOnlySpan<char> path, bool continueOnError);
            /*0x213cb88*/ void SetLastAccessTime(string path, System.DateTimeOffset time);
            /*0x213cee0*/ System.DateTimeOffset GetLastWriteTime(System.ReadOnlySpan<char> path, bool continueOnError);
            /*0x213cf7c*/ void SetLastWriteTime(string path, System.DateTimeOffset time);
            /*0x213cad0*/ System.DateTimeOffset UnixTimeToDateTimeOffset(long seconds, long nanoseconds);
            /*0x213cd2c*/ void SetAccessWriteTimes(string path, System.Nullable<long> accessSec, System.Nullable<long> accessUSec, System.Nullable<long> writeSec, System.Nullable<long> writeUSec);
            /*0x213d08c*/ long GetLength(System.ReadOnlySpan<char> path, bool continueOnError);
            /*0x213c854*/ void Refresh(System.ReadOnlySpan<char> path);
            /*0x213c3d4*/ void EnsureStatInitialized(System.ReadOnlySpan<char> path, bool continueOnError);
        }

        class FileSystem
        {
            static int DefaultBufferSize = 4096;

            static /*0x213d0a8*/ bool CopyDanglingSymlink(string sourceFullPath, string destFullPath);
            static /*0x2132b8c*/ void CopyFile(string sourceFullPath, string destFullPath, bool overwrite);
            static /*0x213d210*/ void LinkOrCopyFile(string sourceFullPath, string destFullPath);
            static /*0x2136bf8*/ void ReplaceFile(string sourceFullPath, string destFullPath, string destBackupFullPath, bool ignoreMetadataErrors);
            static /*0x2136fac*/ void MoveFile(string sourceFullPath, string destFullPath);
            static /*0x2133170*/ void DeleteFile(string fullPath);
            static /*0x2130458*/ void CreateDirectory(string fullPath);
            static /*0x2131fd4*/ void MoveDirectory(string sourceFullPath, string destFullPath);
            static /*0x21322ec*/ void RemoveDirectory(string fullPath, bool recursive);
            static /*0x213d4ac*/ void RemoveDirectoryInternal(System.IO.DirectoryInfo directory, bool recursive, bool throwOnTopLevelDirectoryNotFound);
            static /*0x2131fb4*/ bool DirectoryExists(System.ReadOnlySpan<char> fullPath);
            static /*0x213d4a0*/ bool DirectoryExists(System.ReadOnlySpan<char> fullPath, ref Interop.ErrorInfo errorInfo);
            static /*0x2131f34*/ bool FileExists(System.ReadOnlySpan<char> fullPath);
            static /*0x213d390*/ bool FileExists(System.ReadOnlySpan<char> fullPath, int fileType, ref Interop.ErrorInfo errorInfo);
            static /*0x213db44*/ bool ShouldIgnoreDirectory(string name);
            static /*0x21341d8*/ System.IO.FileAttributes GetAttributes(string fullPath);
            static /*0x2134360*/ void SetAttributes(string fullPath, System.IO.FileAttributes attributes);
            static /*0x21338e4*/ System.DateTimeOffset GetCreationTime(string fullPath);
            static /*0x2133700*/ void SetCreationTime(string fullPath, System.DateTimeOffset time, bool asDirectory);
            static /*0x2133ca0*/ System.DateTimeOffset GetLastAccessTime(string fullPath);
            static /*0x2133abc*/ void SetLastAccessTime(string fullPath, System.DateTimeOffset time, bool asDirectory);
            static /*0x213405c*/ System.DateTimeOffset GetLastWriteTime(string fullPath);
            static /*0x2133e78*/ void SetLastWriteTime(string fullPath, System.DateTimeOffset time, bool asDirectory);
            static /*0x213dcb8*/ string[] GetLogicalDrives();
        }

        class FileSystemInfo : System.MarshalByRefObject, System.Runtime.Serialization.ISerializable
        {
            /*0x18*/ System.IO.FileStatus _fileStatus;
            /*0x90*/ string FullPath;
            /*0x98*/ string OriginalPath;
            /*0xa0*/ string _name;

            static /*0x213dcc0*/ System.IO.FileSystemInfo Create(string fullPath, string fileName, ref System.IO.FileStatus fileStatus);
            static /*0x213c774*/ void ThrowNotFound(string path);
            /*0x212fc1c*/ FileSystemInfo();
            /*0x21323c0*/ FileSystemInfo(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x2130a70*/ void Invalidate();
            /*0x213dd9c*/ void Init(ref System.IO.FileStatus fileStatus);
            /*0x213b6d0*/ System.IO.FileAttributes get_Attributes();
            /*0x213b940*/ void set_Attributes(System.IO.FileAttributes value);
            /*0x213de18*/ bool get_ExistsCore();
            /*0x213deb0*/ System.DateTimeOffset get_CreationTimeCore();
            /*0x213dc00*/ void set_CreationTimeCore(System.DateTimeOffset value);
            /*0x213df1c*/ System.DateTimeOffset get_LastAccessTimeCore();
            /*0x213dc50*/ void set_LastAccessTimeCore(System.DateTimeOffset value);
            /*0x213df88*/ System.DateTimeOffset get_LastWriteTimeCore();
            /*0x213dca0*/ void set_LastWriteTimeCore(System.DateTimeOffset value);
            /*0x213b7a0*/ long get_LengthCore();
            /*0x213dff4*/ void Refresh();
            /*0x213e05c*/ string get_NormalizedPath();
            /*0x213e064*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x213e1ac*/ string get_FullName();
            /*0x213e1b4*/ string get_Extension();
            /*0x213e2e4*/ string get_Name();
            /*0x213e2ec*/ bool get_Exists();
            void Delete();
            /*0x213dbc8*/ System.DateTime get_CreationTime();
            /*0x213e39c*/ void set_CreationTime(System.DateTime value);
            /*0x213e374*/ System.DateTime get_CreationTimeUtc();
            /*0x213e3dc*/ void set_CreationTimeUtc(System.DateTime value);
            /*0x213dc18*/ System.DateTime get_LastAccessTime();
            /*0x213e430*/ void set_LastAccessTime(System.DateTime value);
            /*0x213e408*/ System.DateTime get_LastAccessTimeUtc();
            /*0x213e470*/ void set_LastAccessTimeUtc(System.DateTime value);
            /*0x213dc68*/ System.DateTime get_LastWriteTime();
            /*0x213e4c4*/ void set_LastWriteTime(System.DateTime value);
            /*0x213e49c*/ System.DateTime get_LastWriteTimeUtc();
            /*0x213e504*/ void set_LastWriteTimeUtc(System.DateTime value);
            /*0x213e530*/ string ToString();
        }

        class Iterator<TSource> : System.Collections.Generic.IEnumerable<TSource>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<TSource>, System.IDisposable, System.Collections.IEnumerator
        {
            /*0x0*/ int _threadId;
            /*0x0*/ int state;
            /*0x0*/ TSource current;

            Iterator();
            TSource get_Current();
            System.IO.Iterator<TSource> Clone();
            void Dispose();
            void Dispose(bool disposing);
            System.Collections.Generic.IEnumerator<TSource> GetEnumerator();
            bool MoveNext();
            object System.Collections.IEnumerator.get_Current();
            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            void System.Collections.IEnumerator.Reset();
        }

        enum MatchCasing
        {
            PlatformDefault = 0,
            CaseSensitive = 1,
            CaseInsensitive = 2,
        }

        enum MatchType
        {
            Simple = 0,
            Win32 = 1,
        }

        class ReadLinesIterator : System.IO.Iterator<string>
        {
            /*0x20*/ string _path;
            /*0x28*/ System.Text.Encoding _encoding;
            /*0x30*/ System.IO.StreamReader _reader;

            static /*0x2135bb4*/ System.IO.ReadLinesIterator CreateIterator(string path, System.Text.Encoding encoding);
            static /*0x213e67c*/ System.IO.ReadLinesIterator CreateIterator(string path, System.Text.Encoding encoding, System.IO.StreamReader reader);
            /*0x213e584*/ ReadLinesIterator(string path, System.Text.Encoding encoding, System.IO.StreamReader reader);
            /*0x213e5f4*/ bool MoveNext();
            /*0x213e66c*/ System.IO.Iterator<string> Clone();
            /*0x213e72c*/ void Dispose(bool disposing);
        }

        enum SearchOption
        {
            TopDirectoryOnly = 0,
            AllDirectories = 1,
        }

        enum SearchTarget
        {
            Files = 1,
            Directories = 2,
            Both = 3,
        }

        class BufferedStream : System.IO.Stream
        {
            static int MaxShadowBufferSize = 81920;
            static int DefaultBufferSize = 4096;
            /*0x28*/ System.IO.Stream _stream;
            /*0x30*/ byte[] _buffer;
            /*0x38*/ int _bufferSize;
            /*0x3c*/ int _readPos;
            /*0x40*/ int _readLen;
            /*0x44*/ int _writePos;
            /*0x48*/ System.Threading.Tasks.Task<int> _lastSyncCompletedReadTask;
            /*0x50*/ System.Threading.SemaphoreSlim _asyncActiveSemaphore;

            /*0x213e908*/ BufferedStream(System.IO.Stream stream);
            /*0x213e910*/ BufferedStream(System.IO.Stream stream, int bufferSize);
            /*0x213e810*/ System.Threading.SemaphoreSlim LazyEnsureAsyncActiveSemaphoreInitialized();
            /*0x213eaf4*/ void EnsureNotClosed();
            /*0x213eb58*/ void EnsureCanSeek();
            /*0x213ebcc*/ void EnsureCanRead();
            /*0x213ec40*/ void EnsureCanWrite();
            /*0x213ecb4*/ void EnsureShadowBufferAllocated();
            /*0x213ed88*/ void EnsureBufferAllocated();
            /*0x213ede0*/ System.IO.Stream get_UnderlyingStream();
            /*0x213ede8*/ int get_BufferSize();
            /*0x213edf0*/ bool get_CanRead();
            /*0x213ee08*/ bool get_CanWrite();
            /*0x213ee20*/ bool get_CanSeek();
            /*0x213ee38*/ long get_Length();
            /*0x213eec8*/ long get_Position();
            /*0x213ef14*/ void set_Position(long value);
            /*0x213efd8*/ System.Threading.Tasks.ValueTask DisposeAsync();
            /*0x213f084*/ void Dispose(bool disposing);
            /*0x213f1c0*/ void Flush();
            /*0x213f2c0*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x213f360*/ System.Threading.Tasks.Task FlushAsyncInternal(System.Threading.CancellationToken cancellationToken);
            /*0x213f27c*/ void FlushRead();
            /*0x213f43c*/ void ClearReadBufferBeforeWrite();
            /*0x213ee78*/ void FlushWrite();
            /*0x213f4d0*/ System.Threading.Tasks.Task FlushWriteAsync(System.Threading.CancellationToken cancellationToken);
            /*0x213f5ac*/ int ReadFromBuffer(byte[] array, int offset, int count);
            /*0x213f610*/ int ReadFromBuffer(System.Span<byte> destination);
            /*0x213f750*/ int ReadFromBuffer(byte[] array, int offset, int count, ref System.Exception error);
            /*0x213f7ec*/ int Read(byte[] array, int offset, int count);
            /*0x213fa10*/ int Read(System.Span<byte> destination);
            /*0x213fb74*/ System.Threading.Tasks.Task<int> LastSyncCompletedReadTask(int val);
            /*0x213fc24*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x2140108*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x213ffec*/ System.Threading.Tasks.ValueTask<int> ReadFromUnderlyingStreamAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken, int bytesAlreadySatisfied, System.Threading.Tasks.Task semaphoreLockTask);
            /*0x21403a4*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x2140458*/ int EndRead(System.IAsyncResult asyncResult);
            /*0x21404a0*/ int ReadByte();
            /*0x21404f0*/ int ReadByteSlow();
            /*0x2140580*/ void WriteToBuffer(byte[] array, ref int offset, ref int count);
            /*0x214065c*/ int WriteToBuffer(System.ReadOnlySpan<byte> buffer);
            /*0x21407f8*/ void WriteToBuffer(byte[] array, ref int offset, ref int count, ref System.Exception error);
            /*0x2140890*/ void Write(byte[] array, int offset, int count);
            /*0x2140b9c*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x2140e6c*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x2141040*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x2141254*/ System.Threading.Tasks.Task WriteToUnderlyingStreamAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken, System.Threading.Tasks.Task semaphoreLockTask);
            /*0x2141350*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x2141404*/ void EndWrite(System.IAsyncResult asyncResult);
            /*0x2141410*/ void WriteByte(byte value);
            /*0x214149c*/ long Seek(long offset, System.IO.SeekOrigin origin);
            /*0x21415c4*/ void SetLength(long value);
            /*0x2141688*/ void CopyTo(System.IO.Stream destination, int bufferSize);
            /*0x2141718*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
            /*0x21417dc*/ System.Threading.Tasks.Task CopyToAsyncCore(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);

            class <>c
            {
                static /*0x0*/ System.IO.BufferedStream.<> <>9;
                static /*0x8*/ System.Func<System.Threading.SemaphoreSlim> <>9__10_0;

                static /*0x21418d0*/ <>c();
                /*0x2141934*/ <>c();
                /*0x214193c*/ System.Threading.SemaphoreSlim <LazyEnsureAsyncActiveSemaphoreInitialized>b__10_0();
            }

            struct <DisposeAsync>d__34 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder <>t__builder;
                /*0x38*/ System.IO.BufferedStream <>4__this;
                /*0x40*/ object <>7__wrap1;
                /*0x48*/ int <>7__wrap2;
                /*0x50*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__2;

                /*0x21419a0*/ void MoveNext();
                /*0x2141fdc*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <FlushAsyncInternal>d__38 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.IO.BufferedStream <>4__this;
                /*0x38*/ System.Threading.CancellationToken cancellationToken;
                /*0x40*/ System.Threading.SemaphoreSlim <sem>5__2;
                /*0x48*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;

                /*0x2141fe8*/ void MoveNext();
                /*0x2142524*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <FlushWriteAsync>d__42 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.IO.BufferedStream <>4__this;
                /*0x38*/ System.Threading.CancellationToken cancellationToken;
                /*0x40*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__1;
                /*0x50*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__2;

                /*0x2142530*/ void MoveNext();
                /*0x21429ac*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <ReadFromUnderlyingStreamAsync>d__51 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<int> <>t__builder;
                /*0x38*/ System.Threading.Tasks.Task semaphoreLockTask;
                /*0x40*/ System.IO.BufferedStream <>4__this;
                /*0x48*/ System.Memory<byte> buffer;
                /*0x58*/ int bytesAlreadySatisfied;
                /*0x60*/ System.Threading.CancellationToken cancellationToken;
                /*0x68*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x78*/ int <>7__wrap1;
                /*0x80*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__2;

                /*0x21429b8*/ void MoveNext();
                /*0x21431fc*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <WriteToUnderlyingStreamAsync>d__63 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.Threading.Tasks.Task semaphoreLockTask;
                /*0x38*/ System.IO.BufferedStream <>4__this;
                /*0x40*/ System.ReadOnlyMemory<byte> buffer;
                /*0x50*/ System.Threading.CancellationToken cancellationToken;
                /*0x58*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x68*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__2;

                /*0x2143254*/ void MoveNext();
                /*0x2144228*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <CopyToAsyncCore>d__71 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.IO.BufferedStream <>4__this;
                /*0x38*/ System.IO.Stream destination;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ int bufferSize;
                /*0x50*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;
                /*0x60*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__2;

                /*0x2144234*/ void MoveNext();
                /*0x2144924*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        enum FileAttributes
        {
            ReadOnly = 1,
            Hidden = 2,
            System = 4,
            Directory = 16,
            Archive = 32,
            Device = 64,
            Normal = 128,
            Temporary = 256,
            SparseFile = 512,
            ReparsePoint = 1024,
            Compressed = 2048,
            Offline = 4096,
            NotContentIndexed = 8192,
            Encrypted = 16384,
            IntegrityStream = 32768,
            NoScrubData = 131072,
        }

        class Stream : System.MarshalByRefObject, System.IDisposable, System.IAsyncDisposable
        {
            static int DefaultCopyBufferSize = 81920;
            static /*0x0*/ System.IO.Stream Null;
            /*0x18*/ System.IO.Stream.ReadWriteTask _activeReadWriteTask;
            /*0x20*/ System.Threading.SemaphoreSlim _asyncActiveSemaphore;

            static /*0x2147840*/ Stream();
            static /*0x2147054*/ System.IO.Stream Synchronized(System.IO.Stream stream);
            static /*0x21473d4*/ int BlockingEndRead(System.IAsyncResult asyncResult);
            static /*0x2147670*/ void BlockingEndWrite(System.IAsyncResult asyncResult);
            static /*0x2145fac*/ System.Threading.Tasks.ValueTask<int> <ReadAsync>g__FinishReadAsync|44_0(System.Threading.Tasks.Task<int> readTask, byte[] localBuffer, System.Memory<byte> localDestination);
            /*0x213eaec*/ Stream();
            /*0x2144930*/ System.Threading.SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
            bool get_CanRead();
            bool get_CanSeek();
            /*0x2144a28*/ bool get_CanTimeout();
            bool get_CanWrite();
            long get_Length();
            long get_Position();
            void set_Position(long value);
            /*0x2144a30*/ int get_ReadTimeout();
            /*0x2144a80*/ void set_ReadTimeout(int value);
            /*0x2144ad0*/ int get_WriteTimeout();
            /*0x2144b20*/ void set_WriteTimeout(int value);
            /*0x2144b70*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination);
            /*0x2144c68*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize);
            /*0x2144cec*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, System.Threading.CancellationToken cancellationToken);
            /*0x2144d2c*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
            /*0x2144d70*/ System.Threading.Tasks.Task CopyToAsyncInternal(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
            /*0x2144e68*/ void CopyTo(System.IO.Stream destination);
            /*0x2144ea0*/ void CopyTo(System.IO.Stream destination, int bufferSize);
            /*0x2144b9c*/ int GetCopyBufferSize();
            /*0x2145060*/ void Close();
            /*0x21378f4*/ void Dispose();
            /*0x21450d0*/ void Dispose(bool disposing);
            void Flush();
            /*0x2141f70*/ System.Threading.Tasks.Task FlushAsync();
            /*0x21450d4*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x2145298*/ System.Threading.WaitHandle CreateWaitHandle();
            /*0x21452f8*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x2145318*/ System.IAsyncResult BeginReadInternal(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
            /*0x2145878*/ int EndRead(System.IAsyncResult asyncResult);
            /*0x2145a44*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count);
            /*0x2145ad8*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x2145d4c*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x2145b94*/ System.Threading.Tasks.Task<int> BeginEndReadAsync(byte[] buffer, int offset, int count);
            /*0x21460b4*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x21460d4*/ System.IAsyncResult BeginWriteInternal(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
            /*0x2145640*/ void RunReadWriteTaskWhenReady(System.Threading.Tasks.Task asyncWaiter, System.IO.Stream.ReadWriteTask readWriteTask);
            /*0x21457c4*/ void RunReadWriteTask(System.IO.Stream.ReadWriteTask readWriteTask);
            /*0x21462b8*/ void FinishTrackingAsyncOperation();
            /*0x21462dc*/ void EndWrite(System.IAsyncResult asyncResult);
            /*0x2146498*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count);
            /*0x214652c*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x214678c*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
            /*0x2146a04*/ System.Threading.Tasks.Task FinishWriteAsync(System.Threading.Tasks.Task writeTask, byte[] localBuffer);
            /*0x21465d4*/ System.Threading.Tasks.Task BeginEndWriteAsync(byte[] buffer, int offset, int count);
            long Seek(long offset, System.IO.SeekOrigin origin);
            void SetLength(long value);
            int Read(byte[] buffer, int offset, int count);
            /*0x2146ae4*/ int Read(System.Span<byte> buffer);
            /*0x2146d6c*/ int ReadByte();
            void Write(byte[] buffer, int offset, int count);
            /*0x2146e00*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x2146fc8*/ void WriteByte(byte value);
            /*0x21471d0*/ void ObjectInvariant();
            /*0x21471d4*/ System.IAsyncResult BlockingBeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x21474c8*/ System.IAsyncResult BlockingBeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
            /*0x21460ac*/ bool HasOverriddenBeginEndRead();
            /*0x2146adc*/ bool HasOverriddenBeginEndWrite();
            /*0x2147768*/ System.Threading.Tasks.ValueTask DisposeAsync();

            struct ReadWriteParameters
            {
                /*0x10*/ byte[] Buffer;
                /*0x18*/ int Offset;
                /*0x1c*/ int Count;
            }

            class ReadWriteTask : System.Threading.Tasks.Task<int>, System.Threading.Tasks.ITaskCompletionAction
            {
                static /*0x0*/ System.Threading.ContextCallback s_invokeAsyncCallback;
                /*0x54*/ bool _isRead;
                /*0x55*/ bool _apm;
                /*0x58*/ System.IO.Stream _stream;
                /*0x60*/ byte[] _buffer;
                /*0x68*/ int _offset;
                /*0x6c*/ int _count;
                /*0x70*/ System.AsyncCallback _callback;
                /*0x78*/ System.Threading.ExecutionContext _context;

                static /*0x2147914*/ void InvokeAsyncCallback(object completedTask);
                /*0x21454fc*/ ReadWriteTask(bool isRead, bool apm, System.Func<object, int> function, object state, System.IO.Stream stream, byte[] buffer, int offset, int count, System.AsyncCallback callback);
                /*0x214790c*/ void ClearBeginState();
                /*0x2147990*/ void System.Threading.Tasks.ITaskCompletionAction.Invoke(System.Threading.Tasks.Task completingTask);
                /*0x2147ab0*/ bool System.Threading.Tasks.ITaskCompletionAction.get_InvokeMayRunArbitraryCode();
            }

            class NullStream : System.IO.Stream
            {
                static /*0x0*/ System.Threading.Tasks.Task<int> s_zeroTask;

                static /*0x214810c*/ NullStream();
                /*0x21478b4*/ NullStream();
                /*0x2147ab8*/ bool get_CanRead();
                /*0x2147ac0*/ bool get_CanWrite();
                /*0x2147ac8*/ bool get_CanSeek();
                /*0x2147ad0*/ long get_Length();
                /*0x2147ad8*/ long get_Position();
                /*0x2147ae0*/ void set_Position(long value);
                /*0x2147ae4*/ void CopyTo(System.IO.Stream destination, int bufferSize);
                /*0x2147aec*/ System.Threading.Tasks.Task CopyToAsync(System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);
                /*0x2147bd4*/ void Dispose(bool disposing);
                /*0x2147bd8*/ void Flush();
                /*0x2147bdc*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
                /*0x2147c9c*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x2147d28*/ int EndRead(System.IAsyncResult asyncResult);
                /*0x2147dcc*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x2147e58*/ void EndWrite(System.IAsyncResult asyncResult);
                /*0x2147efc*/ int Read(byte[] buffer, int offset, int count);
                /*0x2147f04*/ int Read(System.Span<byte> buffer);
                /*0x2147f0c*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x2147f64*/ System.Threading.Tasks.ValueTask<int> ReadAsync(System.Memory<byte> buffer, System.Threading.CancellationToken cancellationToken);
                /*0x2147f98*/ int ReadByte();
                /*0x2147fa0*/ void Write(byte[] buffer, int offset, int count);
                /*0x2147fa4*/ void Write(System.ReadOnlySpan<byte> buffer);
                /*0x2147fa8*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
                /*0x2148068*/ System.Threading.Tasks.ValueTask WriteAsync(System.ReadOnlyMemory<byte> buffer, System.Threading.CancellationToken cancellationToken);
                /*0x21480fc*/ void WriteByte(byte value);
                /*0x2148100*/ long Seek(long offset, System.IO.SeekOrigin origin);
                /*0x2148108*/ void SetLength(long length);
            }

            class SynchronousAsyncResult : System.IAsyncResult
            {
                /*0x10*/ object _stateObject;
                /*0x18*/ bool _isWrite;
                /*0x20*/ System.Threading.ManualResetEvent _waitHandle;
                /*0x28*/ System.Runtime.ExceptionServices.ExceptionDispatchInfo _exceptionInfo;
                /*0x30*/ bool _endXxxCalled;
                /*0x34*/ int _bytesRead;

                static /*0x21473d8*/ int EndRead(System.IAsyncResult asyncResult);
                static /*0x2147674*/ void EndWrite(System.IAsyncResult asyncResult);
                /*0x2147358*/ SynchronousAsyncResult(int bytesRead, object asyncStateObject);
                /*0x2147640*/ SynchronousAsyncResult(object asyncStateObject);
                /*0x2147388*/ SynchronousAsyncResult(System.Exception ex, object asyncStateObject, bool isWrite);
                /*0x2148198*/ bool get_IsCompleted();
                /*0x21481a0*/ System.Threading.WaitHandle get_AsyncWaitHandle();
                /*0x2148298*/ object get_AsyncState();
                /*0x21482a0*/ bool get_CompletedSynchronously();
                /*0x21482a8*/ void ThrowIfError();

                class <>c
                {
                    static /*0x0*/ System.IO.Stream.SynchronousAsyncResult.<> <>9;
                    static /*0x8*/ System.Func<System.Threading.ManualResetEvent> <>9__12_0;

                    static /*0x21482bc*/ <>c();
                    /*0x2148320*/ <>c();
                    /*0x2148328*/ System.Threading.ManualResetEvent <get_AsyncWaitHandle>b__12_0();
                }
            }

            class SyncStream : System.IO.Stream, System.IDisposable
            {
                /*0x28*/ System.IO.Stream _stream;

                /*0x2147114*/ SyncStream(System.IO.Stream stream);
                /*0x2148388*/ bool get_CanRead();
                /*0x21483a8*/ bool get_CanWrite();
                /*0x21483c8*/ bool get_CanSeek();
                /*0x21483e8*/ bool get_CanTimeout();
                /*0x2148408*/ long get_Length();
                /*0x21484ec*/ long get_Position();
                /*0x21485d0*/ void set_Position(long value);
                /*0x21486ac*/ int get_ReadTimeout();
                /*0x21486d0*/ void set_ReadTimeout(int value);
                /*0x21486f4*/ int get_WriteTimeout();
                /*0x2148718*/ void set_WriteTimeout(int value);
                /*0x214873c*/ void Close();
                /*0x2148854*/ void Dispose(bool disposing);
                /*0x21489e4*/ void Flush();
                /*0x2148ab8*/ int Read(byte[] bytes, int offset, int count);
                /*0x2148bbc*/ int Read(System.Span<byte> buffer);
                /*0x2148cb0*/ int ReadByte();
                /*0x2148d94*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x2148ebc*/ int EndRead(System.IAsyncResult asyncResult);
                /*0x2148ffc*/ long Seek(long offset, System.IO.SeekOrigin origin);
                /*0x21490f0*/ void SetLength(long length);
                /*0x21491cc*/ void Write(byte[] bytes, int offset, int count);
                /*0x21492c0*/ void Write(System.ReadOnlySpan<byte> buffer);
                /*0x21493a4*/ void WriteByte(byte b);
                /*0x2149480*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int count, System.AsyncCallback callback, object state);
                /*0x21495a8*/ void EndWrite(System.IAsyncResult asyncResult);
            }

            class <>c
            {
                static /*0x0*/ System.IO.Stream.<> <>9;
                static /*0x8*/ System.Func<System.Threading.SemaphoreSlim> <>9__4_0;
                static /*0x10*/ System.Action<object> <>9__37_0;
                static /*0x18*/ System.Func<object, int> <>9__40_0;
                static /*0x20*/ System.Func<System.IO.Stream, System.IO.Stream.ReadWriteParameters, System.AsyncCallback, object, System.IAsyncResult> <>9__45_0;
                static /*0x28*/ System.Func<System.IO.Stream, System.IAsyncResult, int> <>9__45_1;
                static /*0x30*/ System.Func<object, int> <>9__48_0;
                static /*0x38*/ System.Action<System.Threading.Tasks.Task, object> <>9__49_0;
                static /*0x40*/ System.Func<System.IO.Stream, System.IO.Stream.ReadWriteParameters, System.AsyncCallback, object, System.IAsyncResult> <>9__58_0;
                static /*0x48*/ System.Func<System.IO.Stream, System.IAsyncResult, System.Threading.Tasks.VoidTaskResult> <>9__58_1;

                static /*0x21496d8*/ <>c();
                /*0x214973c*/ <>c();
                /*0x2149744*/ System.Threading.SemaphoreSlim <EnsureAsyncActiveSemaphoreInitialized>b__4_0();
                /*0x21497a8*/ void <FlushAsync>b__37_0(object state);
                /*0x2149858*/ int <BeginReadInternal>b__40_0(object <p0>);
                /*0x21499e8*/ System.IAsyncResult <BeginEndReadAsync>b__45_0(System.IO.Stream stream, System.IO.Stream.ReadWriteParameters args, System.AsyncCallback callback, object state);
                /*0x2149a1c*/ int <BeginEndReadAsync>b__45_1(System.IO.Stream stream, System.IAsyncResult asyncResult);
                /*0x2149a48*/ int <BeginWriteInternal>b__48_0(object <p0>);
                /*0x2149bc8*/ void <RunReadWriteTaskWhenReady>b__49_0(System.Threading.Tasks.Task t, object state);
                /*0x2149c34*/ System.IAsyncResult <BeginEndWriteAsync>b__58_0(System.IO.Stream stream, System.IO.Stream.ReadWriteParameters args, System.AsyncCallback callback, object state);
                /*0x2149c68*/ System.Threading.Tasks.VoidTaskResult <BeginEndWriteAsync>b__58_1(System.IO.Stream stream, System.IAsyncResult asyncResult);
            }

            struct <CopyToAsyncInternal>d__28 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ int bufferSize;
                /*0x38*/ System.IO.Stream <>4__this;
                /*0x40*/ System.Threading.CancellationToken cancellationToken;
                /*0x48*/ System.IO.Stream destination;
                /*0x50*/ byte[] <buffer>5__2;
                /*0x58*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter<int> <>u__1;
                /*0x68*/ System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable.ConfiguredValueTaskAwaiter <>u__2;

                /*0x2149c9c*/ void MoveNext();
                /*0x214a378*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <FinishWriteAsync>d__57 : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncTaskMethodBuilder <>t__builder;
                /*0x30*/ System.Threading.Tasks.Task writeTask;
                /*0x38*/ byte[] localBuffer;
                /*0x40*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter <>u__1;

                /*0x214a384*/ void MoveNext();
                /*0x214a590*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }

            struct <<ReadAsync>g__FinishReadAsync|44_0>d : System.Runtime.CompilerServices.IAsyncStateMachine
            {
                /*0x10*/ int <>1__state;
                /*0x18*/ System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder<int> <>t__builder;
                /*0x38*/ System.Threading.Tasks.Task<int> readTask;
                /*0x40*/ byte[] localBuffer;
                /*0x48*/ System.Memory<byte> localDestination;
                /*0x58*/ System.Runtime.CompilerServices.ConfiguredTaskAwaitable.ConfiguredTaskAwaiter<int> <>u__1;

                /*0x214a59c*/ void MoveNext();
                /*0x214a930*/ void SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine stateMachine);
            }
        }

        class __Error
        {
            static /*0x214a988*/ void EndOfFile();
            static /*0x214a9e8*/ void FileNotOpen();
            static /*0x214aa4c*/ void StreamIsClosed();
            static /*0x214aab0*/ void MemoryStreamNotExpandable();
            static /*0x214ab10*/ void ReaderClosed();
            static /*0x214ab74*/ void ReadNotSupported();
            static /*0x214abd4*/ void SeekNotSupported();
            static /*0x214ac34*/ void WrongAsyncResult();
            static /*0x214ac94*/ void EndReadCalledTwice();
            static /*0x214acf4*/ void EndWriteCalledTwice();
            static /*0x214ad54*/ string GetDisplayablePath(string path, bool isInvalidPath);
            static /*0x214b034*/ void WinIOError(int errorCode, string maybeFullPath);
            static /*0x214b5d4*/ void WriteNotSupported();
            static /*0x214b634*/ void WriterClosed();
        }

        class __HResults
        {
            static int COR_E_ENDOFSTREAM = -2147024858;
            static int COR_E_FILELOAD = -2146232799;
            static int COR_E_FILENOTFOUND = -2147024894;
            static int COR_E_DIRECTORYNOTFOUND = -2147024893;
            static int COR_E_PATHTOOLONG = -2147024690;
            static int COR_E_IO = -2146232800;
        }

        class BinaryReader : System.IDisposable
        {
            static int MaxCharBytesSize = 128;
            /*0x10*/ System.IO.Stream m_stream;
            /*0x18*/ byte[] m_buffer;
            /*0x20*/ System.Text.Decoder m_decoder;
            /*0x28*/ byte[] m_charBytes;
            /*0x30*/ char[] m_singleChar;
            /*0x38*/ char[] m_charBuffer;
            /*0x40*/ int m_maxCharsSize;
            /*0x44*/ bool m_2BytesPerChar;
            /*0x45*/ bool m_isMemoryStream;
            /*0x46*/ bool m_leaveOpen;

            /*0x214b698*/ BinaryReader(System.IO.Stream input);
            /*0x214b990*/ BinaryReader(System.IO.Stream input, System.Text.Encoding encoding);
            /*0x214b710*/ BinaryReader(System.IO.Stream input, System.Text.Encoding encoding, bool leaveOpen);
            /*0x214b998*/ System.IO.Stream get_BaseStream();
            /*0x214b9a0*/ void Close();
            /*0x214b9b0*/ void Dispose(bool disposing);
            /*0x214b9f4*/ void Dispose();
            /*0x214ba04*/ int PeekChar();
            /*0x214ba98*/ int Read();
            /*0x214bd20*/ bool ReadBoolean();
            /*0x214bd68*/ byte ReadByte();
            /*0x214bd9c*/ sbyte ReadSByte();
            /*0x214bddc*/ char ReadChar();
            /*0x214be00*/ short ReadInt16();
            /*0x214be48*/ ushort ReadUInt16();
            /*0x214be90*/ int ReadInt32();
            /*0x214bf84*/ uint ReadUInt32();
            /*0x214bff4*/ long ReadInt64();
            /*0x214c0a4*/ ulong ReadUInt64();
            /*0x214c154*/ float ReadSingle();
            /*0x214c184*/ double ReadDouble();
            /*0x214c1b4*/ decimal ReadDecimal();
            /*0x214c3c8*/ string ReadString();
            /*0x214c708*/ int Read(char[] buffer, int index, int count);
            /*0x214c880*/ int InternalReadChars(char[] buffer, int index, int count);
            /*0x214bab0*/ int InternalReadOneChar();
            /*0x214cb78*/ char[] ReadChars(int count);
            /*0x214ccd8*/ int Read(System.Span<char> buffer);
            /*0x214cf2c*/ int Read(System.Span<byte> buffer);
            /*0x214cf50*/ int Read(byte[] buffer, int index, int count);
            /*0x214d0d4*/ byte[] ReadBytes(int count);
            /*0x214d264*/ void FillBuffer(int numBytes);
            /*0x214c660*/ int Read7BitEncodedInt();
        }

        class BinaryWriter : System.IDisposable, System.IAsyncDisposable
        {
            static int LargeByteBufferSize = 256;
            static /*0x0*/ System.IO.BinaryWriter Null;
            /*0x10*/ System.IO.Stream OutStream;
            /*0x18*/ byte[] _buffer;
            /*0x20*/ System.Text.Encoding _encoding;
            /*0x28*/ System.Text.Encoder _encoder;
            /*0x30*/ bool _leaveOpen;
            /*0x38*/ char[] _tmpOneCharBuffer;
            /*0x40*/ byte[] _largeByteBuffer;
            /*0x48*/ int _maxChars;

            static /*0x214e5e4*/ BinaryWriter();
            /*0x214d388*/ BinaryWriter();
            /*0x214d474*/ BinaryWriter(System.IO.Stream output);
            /*0x214d66c*/ BinaryWriter(System.IO.Stream output, System.Text.Encoding encoding);
            /*0x214d4f4*/ BinaryWriter(System.IO.Stream output, System.Text.Encoding encoding, bool leaveOpen);
            /*0x214d674*/ void Close();
            /*0x214d684*/ void Dispose(bool disposing);
            /*0x214d6cc*/ void Dispose();
            /*0x214d6dc*/ System.IO.Stream get_BaseStream();
            /*0x214d6fc*/ void Flush();
            /*0x214d720*/ long Seek(int offset, System.IO.SeekOrigin origin);
            /*0x214d748*/ void Write(System.ReadOnlySpan<byte> buffer);
            /*0x214d7b8*/ void Write(System.ReadOnlySpan<char> buffer);
            /*0x214d828*/ System.Threading.Tasks.ValueTask DisposeAsync();
            /*0x214da00*/ void Write(bool value);
            /*0x214da50*/ void Write(byte value);
            /*0x214da74*/ void Write(sbyte value);
            /*0x214da98*/ void Write(byte[] buffer);
            /*0x214db14*/ void Write(byte[] buffer, int index, int count);
            /*0x214db38*/ void Write(char ch);
            /*0x214dc64*/ void Write(char[] chars);
            /*0x214dd0c*/ void Write(char[] chars, int index, int count);
            /*0x214dd5c*/ void Write(double value);
            /*0x214dd98*/ void Write(decimal value);
            /*0x214de58*/ void Write(short value);
            /*0x214dec0*/ void Write(ushort value);
            /*0x214df28*/ void Write(int value);
            /*0x214dfc8*/ void Write(uint value);
            /*0x214e068*/ void Write(long value);
            /*0x214e178*/ void Write(ulong value);
            /*0x214e288*/ void Write(float value);
            /*0x214e2c4*/ void Write(string value);
            /*0x214e57c*/ void Write7BitEncodedInt(int value);
        }

        class StringReader : System.IO.TextReader
        {
            /*0x18*/ string _s;
            /*0x20*/ int _pos;
            /*0x24*/ int _length;

            /*0x214e644*/ StringReader(string s);
            /*0x214e710*/ void Close();
            /*0x214e720*/ void Dispose(bool disposing);
            /*0x214e730*/ int Peek();
            /*0x214e76c*/ int Read();
            /*0x214e7b0*/ int Read(char[] buffer, int index, int count);
            /*0x214e96c*/ string ReadToEnd();
            /*0x214e9a8*/ string ReadLine();
            /*0x214eabc*/ System.Threading.Tasks.Task<string> ReadLineAsync();
            /*0x214eb44*/ System.Threading.Tasks.Task<string> ReadToEndAsync();
            /*0x214ebcc*/ System.Threading.Tasks.Task<int> ReadBlockAsync(char[] buffer, int index, int count);
            /*0x214edc0*/ System.Threading.Tasks.Task<int> ReadAsync(char[] buffer, int index, int count);
        }

        class StringWriter : System.IO.TextWriter
        {
            static /*0x0*/ System.Text.UnicodeEncoding m_encoding;
            /*0x30*/ System.Text.StringBuilder _sb;
            /*0x38*/ bool _isOpen;

            /*0x214efb0*/ StringWriter();
            /*0x214f12c*/ StringWriter(System.IFormatProvider formatProvider);
            /*0x214f1a0*/ StringWriter(System.Text.StringBuilder sb);
            /*0x214f044*/ StringWriter(System.Text.StringBuilder sb, System.IFormatProvider formatProvider);
            /*0x214f210*/ void Close();
            /*0x214f220*/ void Dispose(bool disposing);
            /*0x214f230*/ System.Text.Encoding get_Encoding();
            /*0x214f2dc*/ System.Text.StringBuilder GetStringBuilder();
            /*0x214f2e4*/ void Write(char value);
            /*0x214f30c*/ void Write(char[] buffer, int index, int count);
            /*0x214f494*/ void Write(string value);
            /*0x214f4c8*/ System.Threading.Tasks.Task WriteAsync(char value);
            /*0x214f578*/ System.Threading.Tasks.Task WriteAsync(string value);
            /*0x214f628*/ System.Threading.Tasks.Task WriteAsync(char[] buffer, int index, int count);
            /*0x214f6f0*/ System.Threading.Tasks.Task WriteLineAsync(char value);
            /*0x214f7a0*/ System.Threading.Tasks.Task WriteLineAsync(string value);
            /*0x214f850*/ System.Threading.Tasks.Task WriteLineAsync(char[] buffer, int index, int count);
            /*0x214f918*/ System.Threading.Tasks.Task FlushAsync();
            /*0x214f9a0*/ string ToString();
        }

        class __ConsoleStream
        {
            /*0x214f9c0*/ __ConsoleStream();
        }

        class DriveInfo : System.Runtime.Serialization.ISerializable
        {
            /*0x10*/ string drive_format;
            /*0x18*/ string path;

            static /*0x214fe08*/ void GetDiskFreeSpace(string path, ref ulong availableFreeSpace, ref ulong totalSize, ref ulong totalFreeSpace);
            static /*0x214fcdc*/ System.IO.DriveInfo[] GetDrives();
            static /*0x2150810*/ bool GetDiskFreeSpaceInternal(char* pathName, int pathName_length, ref ulong freeBytesAvail, ref ulong totalNumberOfBytes, ref ulong totalNumberOfFreeBytes, ref System.IO.MonoIOError error);
            static /*0x214fe6c*/ bool GetDiskFreeSpaceInternal(string pathName, ref ulong freeBytesAvail, ref ulong totalNumberOfBytes, ref ulong totalNumberOfFreeBytes, ref System.IO.MonoIOError error);
            static /*0x2150814*/ uint GetDriveTypeInternal(char* rootPathName, int rootPathName_length);
            static /*0x21506ec*/ uint GetDriveTypeInternal(string rootPathName);
            static /*0x2150818*/ string GetDriveFormatInternal(char* rootPathName, int rootPathName_length);
            static /*0x2150798*/ string GetDriveFormat(string rootPathName);
            /*0x214f9c8*/ DriveInfo(string path, string fstype);
            /*0x214f9f4*/ DriveInfo(string driveName);
            /*0x21505e8*/ long get_AvailableFreeSpace();
            /*0x2150620*/ long get_TotalFreeSpace();
            /*0x215065c*/ long get_TotalSize();
            /*0x2150694*/ string get_VolumeLabel();
            /*0x215069c*/ void set_VolumeLabel(string value);
            /*0x21506dc*/ string get_DriveFormat();
            /*0x21506e4*/ System.IO.DriveType get_DriveType();
            /*0x215071c*/ string get_Name();
            /*0x2150724*/ System.IO.DirectoryInfo get_RootDirectory();
            /*0x215078c*/ bool get_IsReady();
            /*0x21507c8*/ void System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x2150808*/ string ToString();

            class <>c
            {
                static /*0x0*/ System.IO.DriveInfo.<> <>9;
                static /*0x8*/ System.Comparison<System.IO.DriveInfo> <>9__3_0;

                static /*0x215081c*/ <>c();
                /*0x2150880*/ <>c();
                /*0x2150888*/ int <.ctor>b__3_0(System.IO.DriveInfo di1, System.IO.DriveInfo di2);
            }
        }

        class FileStream : System.IO.Stream
        {
            static int DefaultBufferSize = 4096;
            static /*0x0*/ byte[] buf_recycle;
            static /*0x8*/ object buf_recycle_lock;
            /*0x28*/ byte[] buf;
            /*0x30*/ string name;
            /*0x38*/ Microsoft.Win32.SafeHandles.SafeFileHandle safeHandle;
            /*0x40*/ bool isExposed;
            /*0x48*/ long append_startpos;
            /*0x50*/ System.IO.FileAccess access;
            /*0x54*/ bool owner;
            /*0x55*/ bool async;
            /*0x56*/ bool canseek;
            /*0x57*/ bool anonymous;
            /*0x58*/ bool buf_dirty;
            /*0x5c*/ int buf_size;
            /*0x60*/ int buf_length;
            /*0x64*/ int buf_offset;
            /*0x68*/ long buf_start;

            static /*0x2155d80*/ FileStream();
            /*0x21508b0*/ FileStream(nint handle, System.IO.FileAccess access);
            /*0x2150a70*/ FileStream(nint handle, System.IO.FileAccess access, bool ownsHandle);
            /*0x2150a84*/ FileStream(nint handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);
            /*0x2150a94*/ FileStream(nint handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
            /*0x21508c4*/ FileStream(nint handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper);
            /*0x2150d8c*/ FileStream(string path, System.IO.FileMode mode);
            /*0x21514f0*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access);
            /*0x2151534*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
            /*0x2151558*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
            /*0x2151578*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);
            /*0x21515a0*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
            /*0x21515c0*/ FileStream(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);
            /*0x2151688*/ FileStream(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);
            /*0x21515cc*/ FileStream(Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);
            /*0x2151690*/ FileStream(string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);
            /*0x21516bc*/ FileStream(string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);
            /*0x21516d4*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, string msgPath, bool bFromProxy, bool useLongPath, bool checkHost);
            /*0x215151c*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool isAsync, bool anonymous);
            /*0x2150dc0*/ FileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool anonymous, System.IO.FileOptions options);
            /*0x2150aa4*/ void Init(Microsoft.Win32.SafeHandles.SafeFileHandle safeHandle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync, bool isConsoleWrapper);
            /*0x21527d4*/ bool get_CanRead();
            /*0x21527e8*/ bool get_CanWrite();
            /*0x21527fc*/ bool get_CanSeek();
            /*0x2152804*/ bool get_IsAsync();
            /*0x215280c*/ string get_Name();
            /*0x2152814*/ long get_Length();
            /*0x2152ab0*/ long get_Position();
            /*0x2152c20*/ void set_Position(long value);
            /*0x2152cb0*/ nint get_Handle();
            /*0x2152d04*/ Microsoft.Win32.SafeHandles.SafeFileHandle get_SafeFileHandle();
            /*0x215266c*/ void ExposeHandle();
            /*0x2152eb8*/ int ReadByte();
            /*0x2153158*/ void WriteByte(byte value);
            /*0x21532b4*/ int Read(byte[] array, int offset, int count);
            /*0x215351c*/ int ReadInternal(byte[] dest, int offset, int count);
            /*0x2153670*/ System.IAsyncResult BeginRead(byte[] array, int offset, int numBytes, System.AsyncCallback userCallback, object stateObject);
            /*0x2153a80*/ int EndRead(System.IAsyncResult asyncResult);
            /*0x2153c10*/ void Write(byte[] array, int offset, int count);
            /*0x2153e4c*/ void WriteInternal(byte[] src, int offset, int count);
            /*0x21541c0*/ System.IAsyncResult BeginWrite(byte[] array, int offset, int numBytes, System.AsyncCallback userCallback, object stateObject);
            /*0x21546f0*/ void EndWrite(System.IAsyncResult asyncResult);
            /*0x2154868*/ long Seek(long offset, System.IO.SeekOrigin origin);
            /*0x2154ad4*/ void SetLength(long value);
            /*0x2154e18*/ void Flush();
            /*0x2154e90*/ void Flush(bool flushToDisk);
            /*0x2155098*/ void Lock(long position, long length);
            /*0x215534c*/ void Unlock(long position, long length);
            /*0x2155600*/ void Finalize();
            /*0x21556a4*/ void Dispose(bool disposing);
            /*0x21559dc*/ System.Security.AccessControl.FileSecurity GetAccessControl();
            /*0x2155ac0*/ void SetAccessControl(System.Security.AccessControl.FileSecurity fileSecurity);
            /*0x2155b9c*/ System.Threading.Tasks.Task FlushAsync(System.Threading.CancellationToken cancellationToken);
            /*0x2155c28*/ System.Threading.Tasks.Task<int> ReadAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x2155c30*/ System.Threading.Tasks.Task WriteAsync(byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);
            /*0x21535b8*/ int ReadSegment(byte[] dest, int dest_offset, int count);
            /*0x2154148*/ int WriteSegment(byte[] src, int src_offset, int count);
            /*0x2152d40*/ void FlushBuffer();
            /*0x2152978*/ void FlushBufferIfDirty();
            /*0x2153128*/ void RefillBuffer();
            /*0x2153000*/ int ReadData(System.Runtime.InteropServices.SafeHandle safeHandle, byte[] buf, int offset, int count);
            /*0x21523e0*/ void InitBuffer(int size, bool isZeroSize);
            /*0x2152240*/ string GetSecureFileName(string filename);
            /*0x2151d34*/ string GetSecureFileName(string filename, bool full);

            class ReadDelegate : System.MulticastDelegate
            {
                /*0x2153900*/ ReadDelegate(object object, nint method);
                /*0x2155df8*/ int Invoke(byte[] buffer, int offset, int count);
                /*0x21539d8*/ System.IAsyncResult BeginInvoke(byte[] buffer, int offset, int count, System.AsyncCallback callback, object object);
                /*0x2153be8*/ int EndInvoke(System.IAsyncResult result);
            }

            class WriteDelegate : System.MulticastDelegate
            {
                /*0x2154570*/ WriteDelegate(object object, nint method);
                /*0x2155e0c*/ void Invoke(byte[] buffer, int offset, int count);
                /*0x2154648*/ System.IAsyncResult BeginInvoke(byte[] buffer, int offset, int count, System.AsyncCallback callback, object object);
                /*0x215485c*/ void EndInvoke(System.IAsyncResult result);
            }
        }

        class FileStreamAsyncResult : System.IAsyncResult
        {
            /*0x10*/ object state;
            /*0x18*/ bool completed;
            /*0x19*/ bool done;
            /*0x20*/ System.Exception exc;
            /*0x28*/ System.Threading.ManualResetEvent wh;
            /*0x30*/ System.AsyncCallback cb;
            /*0x38*/ bool completedSynch;
            /*0x40*/ byte[] Buffer;
            /*0x48*/ int Offset;
            /*0x4c*/ int Count;
            /*0x50*/ int OriginalCount;
            /*0x54*/ int BytesRead;
            /*0x58*/ System.AsyncCallback realcb;

            static /*0x2155e20*/ void CBWrapper(System.IAsyncResult ares);
            /*0x2154498*/ FileStreamAsyncResult(System.AsyncCallback cb, object state);
            /*0x2155eb4*/ void SetComplete(System.Exception e);
            /*0x2155f04*/ void SetComplete(System.Exception e, int nbytes);
            /*0x2155f0c*/ void SetComplete(System.Exception e, int nbytes, bool synch);
            /*0x2155f1c*/ object get_AsyncState();
            /*0x2155f24*/ bool get_CompletedSynchronously();
            /*0x2155f2c*/ System.Threading.WaitHandle get_AsyncWaitHandle();
            /*0x2155f34*/ bool get_IsCompleted();
            /*0x2155f3c*/ System.Exception get_Exception();
            /*0x2155f44*/ bool get_Done();
            /*0x2155f4c*/ void set_Done(bool value);
        }

        class HGlobalUnmanagedMemoryStream : System.IO.UnmanagedMemoryStream
        {
            /*0x68*/ nint ptr;

            /*0x2155f58*/ HGlobalUnmanagedMemoryStream(byte* pointer, long length, nint ptr);
            /*0x2155f88*/ void Dispose(bool disposing);
        }

        enum MonoFileType
        {
            Unknown = 0,
            Disk = 1,
            Char = 2,
            Pipe = 3,
            Remote = 32768,
        }

        class MonoIO
        {
            static int FileAlreadyExistsHResult = -2147024816;
            static System.IO.FileAttributes InvalidFileAttributes = -1;
            static /*0x0*/ nint InvalidHandle;
            static /*0x8*/ bool dump_handles;

            static /*0x2156f60*/ MonoIO();
            static /*0x2156000*/ System.Exception GetException(System.IO.MonoIOError error);
            static /*0x214fecc*/ System.Exception GetException(string path, System.IO.MonoIOError error);
            static /*0x2156134*/ bool CreateDirectory(char* path, ref System.IO.MonoIOError error);
            static /*0x2156138*/ bool CreateDirectory(string path, ref System.IO.MonoIOError error);
            static /*0x21561a4*/ bool RemoveDirectory(char* path, ref System.IO.MonoIOError error);
            static /*0x21561a8*/ bool RemoveDirectory(string path, ref System.IO.MonoIOError error);
            static /*0x2156214*/ string GetCurrentDirectory(ref System.IO.MonoIOError error);
            static /*0x2156218*/ bool SetCurrentDirectory(char* path, ref System.IO.MonoIOError error);
            static /*0x215621c*/ bool SetCurrentDirectory(string path, ref System.IO.MonoIOError error);
            static /*0x2156288*/ bool MoveFile(char* path, char* dest, ref System.IO.MonoIOError error);
            static /*0x215628c*/ bool MoveFile(string path, string dest, ref System.IO.MonoIOError error);
            static /*0x2156318*/ bool CopyFile(char* path, char* dest, bool overwrite, ref System.IO.MonoIOError error);
            static /*0x2156320*/ bool CopyFile(string path, string dest, bool overwrite, ref System.IO.MonoIOError error);
            static /*0x21563b4*/ bool DeleteFile(char* path, ref System.IO.MonoIOError error);
            static /*0x21563b8*/ bool DeleteFile(string path, ref System.IO.MonoIOError error);
            static /*0x2156424*/ bool ReplaceFile(char* sourceFileName, char* destinationFileName, char* destinationBackupFileName, bool ignoreMetadataErrors, ref System.IO.MonoIOError error);
            static /*0x215642c*/ bool ReplaceFile(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors, ref System.IO.MonoIOError error);
            static /*0x21564e0*/ System.IO.FileAttributes GetFileAttributes(char* path, ref System.IO.MonoIOError error);
            static /*0x21564e4*/ System.IO.FileAttributes GetFileAttributes(string path, ref System.IO.MonoIOError error);
            static /*0x2156550*/ bool SetFileAttributes(char* path, System.IO.FileAttributes attrs, ref System.IO.MonoIOError error);
            static /*0x2156554*/ bool SetFileAttributes(string path, System.IO.FileAttributes attrs, ref System.IO.MonoIOError error);
            static /*0x21565d0*/ System.IO.MonoFileType GetFileType(nint handle, ref System.IO.MonoIOError error);
            static /*0x21522b8*/ System.IO.MonoFileType GetFileType(System.Runtime.InteropServices.SafeHandle safeHandle, ref System.IO.MonoIOError error);
            static /*0x21565d4*/ nint FindFirstFile(char* pathWithPattern, ref string fileName, ref int fileAttr, ref int error);
            static /*0x21565d8*/ nint FindFirstFile(string pathWithPattern, ref string fileName, ref int fileAttr, ref int error);
            static /*0x215665c*/ bool FindNextFile(nint hnd, ref string fileName, ref int fileAttr, ref int error);
            static /*0x2156660*/ bool FindCloseFile(nint hnd);
            static /*0x2156664*/ bool Exists(string path, ref System.IO.MonoIOError error);
            static /*0x21566d4*/ bool ExistsFile(string path, ref System.IO.MonoIOError error);
            static /*0x2156754*/ bool ExistsDirectory(string path, ref System.IO.MonoIOError error);
            static /*0x21567e4*/ bool ExistsSymlink(string path, ref System.IO.MonoIOError error);
            static /*0x2156860*/ bool GetFileStat(char* path, ref System.IO.MonoIOStat stat, ref System.IO.MonoIOError error);
            static /*0x2156864*/ bool GetFileStat(string path, ref System.IO.MonoIOStat stat, ref System.IO.MonoIOError error);
            static /*0x21568e0*/ nint Open(char* filename, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.FileOptions options, ref System.IO.MonoIOError error);
            static /*0x21521a4*/ nint Open(string filename, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.FileOptions options, ref System.IO.MonoIOError error);
            static /*0x21568e4*/ bool Cancel_internal(nint handle, ref System.IO.MonoIOError error);
            static /*0x21568e8*/ bool Cancel(System.Runtime.InteropServices.SafeHandle safeHandle, ref System.IO.MonoIOError error);
            static /*0x21559d8*/ bool Close(nint handle, ref System.IO.MonoIOError error);
            static /*0x2156a10*/ int Read(nint handle, byte[] dest, int dest_offset, int count, ref System.IO.MonoIOError error);
            static /*0x2155c38*/ int Read(System.Runtime.InteropServices.SafeHandle safeHandle, byte[] dest, int dest_offset, int count, ref System.IO.MonoIOError error);
            static /*0x2156a14*/ int Write(nint handle, byte[] src, int src_offset, int count, ref System.IO.MonoIOError error);
            static /*0x2154000*/ int Write(System.Runtime.InteropServices.SafeHandle safeHandle, byte[] src, int src_offset, int count, ref System.IO.MonoIOError error);
            static /*0x2156a18*/ long Seek(nint handle, long offset, System.IO.SeekOrigin origin, ref System.IO.MonoIOError error);
            static /*0x2152694*/ long Seek(System.Runtime.InteropServices.SafeHandle safeHandle, long offset, System.IO.SeekOrigin origin, ref System.IO.MonoIOError error);
            static /*0x2156a1c*/ bool Flush(nint handle, ref System.IO.MonoIOError error);
            static /*0x2154f70*/ bool Flush(System.Runtime.InteropServices.SafeHandle safeHandle, ref System.IO.MonoIOError error);
            static /*0x2156a20*/ long GetLength(nint handle, ref System.IO.MonoIOError error);
            static /*0x2152988*/ long GetLength(System.Runtime.InteropServices.SafeHandle safeHandle, ref System.IO.MonoIOError error);
            static /*0x2156a24*/ bool SetLength(nint handle, long length, ref System.IO.MonoIOError error);
            static /*0x2154ce8*/ bool SetLength(System.Runtime.InteropServices.SafeHandle safeHandle, long length, ref System.IO.MonoIOError error);
            static /*0x2156a28*/ bool SetFileTime(nint handle, long creation_time, long last_access_time, long last_write_time, ref System.IO.MonoIOError error);
            static /*0x2156a2c*/ bool SetFileTime(System.Runtime.InteropServices.SafeHandle safeHandle, long creation_time, long last_access_time, long last_write_time, ref System.IO.MonoIOError error);
            static /*0x2156b74*/ bool SetFileTime(string path, long creation_time, long last_access_time, long last_write_time, ref System.IO.MonoIOError error);
            static /*0x2156dbc*/ bool SetCreationTime(string path, System.DateTime dateTime, ref System.IO.MonoIOError error);
            static /*0x2156e38*/ bool SetLastAccessTime(string path, System.DateTime dateTime, ref System.IO.MonoIOError error);
            static /*0x2156eb4*/ bool SetLastWriteTime(string path, System.DateTime dateTime, ref System.IO.MonoIOError error);
            static /*0x2156c34*/ bool SetFileTime(string path, int type, long creation_time, long last_access_time, long last_write_time, System.DateTime dateTime, ref System.IO.MonoIOError error);
            static /*0x2156f30*/ void Lock(nint handle, long position, long length, ref System.IO.MonoIOError error);
            static /*0x215521c*/ void Lock(System.Runtime.InteropServices.SafeHandle safeHandle, long position, long length, ref System.IO.MonoIOError error);
            static /*0x2156f34*/ void Unlock(nint handle, long position, long length, ref System.IO.MonoIOError error);
            static /*0x21554d0*/ void Unlock(System.Runtime.InteropServices.SafeHandle safeHandle, long position, long length, ref System.IO.MonoIOError error);
            static /*0x2156f38*/ nint get_ConsoleOutput();
            static /*0x2156f3c*/ nint get_ConsoleInput();
            static /*0x2156f40*/ nint get_ConsoleError();
            static /*0x2156f44*/ bool CreatePipe(ref nint read_handle, ref nint write_handle, ref System.IO.MonoIOError error);
            static /*0x2156f48*/ bool DuplicateHandle(nint source_process_handle, nint source_handle, nint target_process_handle, ref nint target_handle, int access, int inherit, int options, ref System.IO.MonoIOError error);
            static /*0x2156f4c*/ char get_VolumeSeparatorChar();
            static /*0x2156f50*/ char get_DirectorySeparatorChar();
            static /*0x2156f54*/ char get_AltDirectorySeparatorChar();
            static /*0x2156f58*/ char get_PathSeparator();
            static /*0x2156130*/ void DumpHandles();
            static /*0x2156f5c*/ bool RemapPath(string path, ref string newPath);
        }

        enum MonoIOError
        {
            ERROR_SUCCESS = 0,
            ERROR_FILE_NOT_FOUND = 2,
            ERROR_PATH_NOT_FOUND = 3,
            ERROR_TOO_MANY_OPEN_FILES = 4,
            ERROR_ACCESS_DENIED = 5,
            ERROR_INVALID_HANDLE = 6,
            ERROR_INVALID_DRIVE = 15,
            ERROR_NOT_SAME_DEVICE = 17,
            ERROR_NO_MORE_FILES = 18,
            ERROR_NOT_READY = 21,
            ERROR_WRITE_FAULT = 29,
            ERROR_READ_FAULT = 30,
            ERROR_GEN_FAILURE = 31,
            ERROR_SHARING_VIOLATION = 32,
            ERROR_LOCK_VIOLATION = 33,
            ERROR_HANDLE_DISK_FULL = 39,
            ERROR_NOT_SUPPORTED = 50,
            ERROR_FILE_EXISTS = 80,
            ERROR_CANNOT_MAKE = 82,
            ERROR_INVALID_PARAMETER = 87,
            ERROR_BROKEN_PIPE = 109,
            ERROR_INVALID_NAME = 123,
            ERROR_DIR_NOT_EMPTY = 145,
            ERROR_ALREADY_EXISTS = 183,
            ERROR_FILENAME_EXCED_RANGE = 206,
            ERROR_DIRECTORY = 267,
            ERROR_ENCRYPTION_FAILED = 6000,
        }

        struct MonoIOStat
        {
            /*0x10*/ System.IO.FileAttributes fileAttributes;
            /*0x18*/ long Length;
            /*0x20*/ long CreationTime;
            /*0x28*/ long LastAccessTime;
            /*0x30*/ long LastWriteTime;
        }

        class Path
        {
            static int MAX_PATH = 260;
            static /*0x0*/ char[] InvalidPathChars;
            static /*0x8*/ char AltDirectorySeparatorChar;
            static /*0xa*/ char DirectorySeparatorChar;
            static /*0xc*/ char PathSeparator;
            static /*0x10*/ string DirectorySeparatorStr;
            static /*0x18*/ char VolumeSeparatorChar;
            static /*0x20*/ char[] PathSeparatorChars;
            static /*0x28*/ bool dirEqualsVolume;
            static /*0x30*/ char[] trimEndCharsWindows;
            static /*0x38*/ char[] trimEndCharsUnix;

            static /*0x2158e38*/ Path();
            static /*0x2156fe8*/ string ChangeExtension(string path, string extension);
            static /*0x2157278*/ string Combine(string path1, string path2);
            static /*0x215760c*/ string CleanPath(string s);
            static /*0x2151ddc*/ string GetDirectoryName(string path);
            static /*0x2157e7c*/ System.ReadOnlySpan<char> GetDirectoryName(System.ReadOnlySpan<char> path);
            static /*0x2157f4c*/ string GetExtension(string path);
            static /*0x214af24*/ string GetFileName(string path);
            static /*0x2158078*/ string GetFileNameWithoutExtension(string path);
            static /*0x215213c*/ string GetFullPath(string path);
            static /*0x21580d4*/ string GetFullPathInternal(string path);
            static /*0x21516e0*/ string InsecureGetFullPath(string path);
            static /*0x214ae98*/ bool IsDirectorySeparator(char c);
            static /*0x2157a4c*/ string GetPathRoot(string path);
            static /*0x2158548*/ string GetTempFileName();
            static /*0x215888c*/ string GetTempPath();
            static /*0x2158974*/ string get_temp_path();
            static /*0x2158978*/ bool HasExtension(string path);
            static /*0x2158a88*/ bool IsPathRooted(System.ReadOnlySpan<char> path);
            static /*0x21574e4*/ bool IsPathRooted(string path);
            static /*0x2158b8c*/ char[] GetInvalidFileNameChars();
            static /*0x2158c40*/ char[] GetInvalidPathChars();
            static /*0x2158cd4*/ string GetRandomFileName();
            static /*0x21571e4*/ int findExtension(string path);
            static /*0x2158fe0*/ string GetServerAndShare(string path);
            static /*0x2159124*/ bool SameRoot(string root, string path);
            static /*0x2158128*/ string CanonicalizePath(string path);
            static /*0x21593f0*/ bool IsPathSubsetOf(string subset, string path);
            static /*0x215952c*/ string Combine(string[] paths);
            static /*0x2159818*/ string Combine(string path1, string path2, string path3);
            static /*0x21599c0*/ string Combine(string path1, string path2, string path3, string path4);
            static /*0x2159bb8*/ void Validate(string path);
            static /*0x2159c24*/ void Validate(string path, string parameterName);
            static /*0x2159d50*/ string get_DirectorySeparatorCharAsString();
            static /*0x2159da8*/ char[] get_TrimEndChars();
            static /*0x2159e20*/ void CheckSearchPattern(string searchPattern);
            static /*0x2159f98*/ void CheckInvalidPathChars(string path, bool checkAdditional);
            static /*0x215a0a8*/ string InternalCombine(string path1, string path2);
            static /*0x215a324*/ System.ReadOnlySpan<char> GetFileName(System.ReadOnlySpan<char> path);
            static /*0x215a470*/ string Join(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2);
            static /*0x215a7a4*/ string Join(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2, System.ReadOnlySpan<char> path3);
            static /*0x215ac1c*/ bool TryJoin(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2, System.Span<char> destination, ref int charsWritten);
            static /*0x215ae50*/ bool TryJoin(System.ReadOnlySpan<char> path1, System.ReadOnlySpan<char> path2, System.ReadOnlySpan<char> path3, System.Span<char> destination, ref int charsWritten);
            static /*0x215a528*/ string JoinInternal(System.ReadOnlySpan<char> first, System.ReadOnlySpan<char> second);
            static /*0x215a8b4*/ string JoinInternal(System.ReadOnlySpan<char> first, System.ReadOnlySpan<char> second, System.ReadOnlySpan<char> third);
            static /*0x215b168*/ string JoinInternal(System.ReadOnlySpan<char> first, System.ReadOnlySpan<char> second, System.ReadOnlySpan<char> third, System.ReadOnlySpan<char> fourth);
            static /*0x215b5cc*/ System.ReadOnlySpan<char> GetExtension(System.ReadOnlySpan<char> path);
            static /*0x215b69c*/ System.ReadOnlySpan<char> GetFileNameWithoutExtension(System.ReadOnlySpan<char> path);
            static /*0x215b76c*/ System.ReadOnlySpan<char> GetPathRoot(System.ReadOnlySpan<char> path);
            static /*0x215b83c*/ bool HasExtension(System.ReadOnlySpan<char> path);
            static /*0x215b8c8*/ string GetRelativePath(string relativeTo, string path);
            static /*0x215b990*/ string GetRelativePath(string relativeTo, string path, System.StringComparison comparisonType);
            static /*0x215b934*/ System.StringComparison get_StringComparison();
            static /*0x215be54*/ bool get_IsCaseSensitive();
            static /*0x215beac*/ bool get_IsWindows();
            static /*0x215bee0*/ bool IsPathFullyQualified(string path);
            static /*0x215bfc0*/ bool IsPathFullyQualified(System.ReadOnlySpan<char> path);
            static /*0x215c034*/ string GetFullPath(string path, string basePath);
            static /*0x215c204*/ string CombineInternal(string first, string second);

            class <>c
            {
                static /*0x0*/ System.IO.Path.<> <>9;
                static /*0x8*/ System.Buffers.SpanAction<char, System.ValueTuple<nint, int, nint, int, bool>> <>9__56_0;
                static /*0x10*/ System.Buffers.SpanAction<char, System.ValueTuple<nint, int, nint, int, nint, int, bool, System.ValueTuple<bool>>> <>9__57_0;
                static /*0x18*/ System.Buffers.SpanAction<char, System.ValueTuple<nint, int, nint, int, nint, int, nint, System.ValueTuple<int, bool, bool, bool>>> <>9__58_0;

                static /*0x215c39c*/ <>c();
                /*0x215c400*/ <>c();
                /*0x215c408*/ void <JoinInternal>b__56_0(System.Span<char> destination, System.ValueTuple<nint, int, nint, int, bool> state);
                /*0x215c5a8*/ void <JoinInternal>b__57_0(System.Span<char> destination, System.ValueTuple<nint, int, nint, int, nint, int, bool, System.ValueTuple<bool>> state);
                /*0x215c80c*/ void <JoinInternal>b__58_0(System.Span<char> destination, System.ValueTuple<nint, int, nint, int, nint, int, nint, System.ValueTuple<int, bool, bool, bool>> state);
            }
        }

        class SearchPattern
        {
            static /*0x0*/ char[] WildcardChars;

            static /*0x215cb70*/ SearchPattern();
            /*0x215cb68*/ SearchPattern();
        }

        class UnexceptionalStreamReader : System.IO.StreamReader
        {
            static /*0x0*/ bool[] newline;
            static /*0x8*/ char newlineChar;

            static /*0x215cc04*/ UnexceptionalStreamReader();
            /*0x215cca4*/ UnexceptionalStreamReader(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x215cd14*/ int Peek();
            /*0x215cd9c*/ int Read();
            /*0x215ce24*/ int Read(char[] dest_buffer, int index, int count);
            /*0x215d0bc*/ bool CheckEOL(char current);
            /*0x215d254*/ string ReadLine();
            /*0x215d2dc*/ string ReadToEnd();
        }

        class UnexceptionalStreamWriter : System.IO.StreamWriter
        {
            /*0x215d364*/ UnexceptionalStreamWriter(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x215d3dc*/ void Flush();
            /*0x215d460*/ void Write(char[] buffer, int index, int count);
            /*0x215d4e4*/ void Write(char value);
            /*0x215d568*/ void Write(char[] value);
            /*0x215d5ec*/ void Write(string value);
        }

        class CStreamReader : System.IO.StreamReader
        {
            /*0x60*/ System.TermInfoDriver driver;

            /*0x215d670*/ CStreamReader(System.IO.Stream stream, System.Text.Encoding encoding);
            /*0x215d784*/ int Peek();
            /*0x215d80c*/ int Read();
            /*0x215d8dc*/ int Read(char[] dest, int index, int count);
            /*0x215da8c*/ string ReadLine();
            /*0x215db24*/ string ReadToEnd();
        }

        class CStreamWriter : System.IO.StreamWriter
        {
            /*0x70*/ System.TermInfoDriver driver;

            /*0x215dbbc*/ CStreamWriter(System.IO.Stream stream, System.Text.Encoding encoding, bool leaveOpen);
            /*0x215dce4*/ void Write(char[] buffer, int index, int count);
            /*0x215e02c*/ void Write(char val);
            /*0x215e23c*/ void InternalWriteString(string val);
            /*0x215e1b8*/ void InternalWriteChar(char val);
            /*0x215e2c0*/ void InternalWriteChars(char[] buffer, int n);
            /*0x215e34c*/ void Write(char[] val);
            /*0x215e374*/ void Write(string val);
            /*0x215e440*/ void WriteLine(string val);
        }

        class DriveInfoInternal
        {
            static /*0x215e488*/ string[] GetLogicalDrives();
        }

        class MonoLinqHelper
        {
            static T[] ToArray<T>(System.Collections.Generic.IEnumerable<T> source);
        }

        namespace IsolatedStorage
        {
            interface INormalizeForIsolatedStorage
            {
                object Normalize();
            }

            enum IsolatedStorageScope
            {
                None = 0,
                User = 1,
                Domain = 2,
                Assembly = 4,
                Roaming = 8,
                Machine = 16,
                Application = 32,
            }

            class IsolatedStorage : System.MarshalByRefObject
            {
                /*0x18*/ System.IO.IsolatedStorage.IsolatedStorageScope storage_scope;
                /*0x20*/ object _assemblyIdentity;
                /*0x28*/ object _domainIdentity;
                /*0x30*/ object _applicationIdentity;

                /*0x215e490*/ IsolatedStorage();
                /*0x215e498*/ object get_ApplicationIdentity();
                /*0x215e558*/ object get_AssemblyIdentity();
                /*0x215e5e0*/ ulong get_CurrentSize();
                /*0x215e640*/ object get_DomainIdentity();
                /*0x215e6c8*/ ulong get_MaximumSize();
                /*0x215e728*/ System.IO.IsolatedStorage.IsolatedStorageScope get_Scope();
                /*0x215e730*/ long get_AvailableFreeSpace();
                /*0x215e780*/ long get_Quota();
                /*0x215e7d0*/ long get_UsedSize();
                /*0x215e820*/ char get_SeparatorExternal();
                /*0x215e878*/ char get_SeparatorInternal();
                /*0x215e880*/ System.Security.Permissions.IsolatedStoragePermission GetPermission(System.Security.PermissionSet ps);
                /*0x215e888*/ void InitStore(System.IO.IsolatedStorage.IsolatedStorageScope scope, System.Type domainEvidenceType, System.Type assemblyEvidenceType);
                /*0x215e958*/ void InitStore(System.IO.IsolatedStorage.IsolatedStorageScope scope, System.Type appEvidenceType);
                void Remove();
                /*0x215e960*/ bool IncreaseQuotaTo(long newQuotaSize);
            }

            class IsolatedStorageException : System.Exception
            {
                /*0x215e968*/ IsolatedStorageException();
                /*0x215e9f4*/ IsolatedStorageException(string message);
                /*0x215ea5c*/ IsolatedStorageException(string message, System.Exception inner);
                /*0x215eacc*/ IsolatedStorageException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class IsolatedStorageFile : System.IO.IsolatedStorage.IsolatedStorage, System.IDisposable
            {
                /*0x38*/ bool closed;
                /*0x39*/ bool disposed;
                /*0x40*/ System.IO.DirectoryInfo directory;

                static /*0x215eb4c*/ System.Collections.IEnumerator GetEnumerator(System.IO.IsolatedStorage.IsolatedStorageScope scope);
                static /*0x215ed60*/ System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope scope, System.Security.Policy.Evidence domainEvidence, System.Type domainEvidenceType, System.Security.Policy.Evidence assemblyEvidence, System.Type assemblyEvidenceType);
                static /*0x215eff0*/ System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope scope, object domainIdentity, object assemblyIdentity);
                static /*0x215f0f0*/ System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope scope, System.Type domainEvidenceType, System.Type assemblyEvidenceType);
                static /*0x215f15c*/ System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope scope, object applicationIdentity);
                static /*0x215f220*/ System.IO.IsolatedStorage.IsolatedStorageFile GetStore(System.IO.IsolatedStorage.IsolatedStorageScope scope, System.Type applicationEvidenceType);
                static /*0x215f28c*/ System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForApplication();
                static /*0x215f2f8*/ System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForAssembly();
                static /*0x215f364*/ System.IO.IsolatedStorage.IsolatedStorageFile GetMachineStoreForDomain();
                static /*0x215f3d0*/ System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForApplication();
                static /*0x215f43c*/ System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForAssembly();
                static /*0x215f4a8*/ System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForDomain();
                static /*0x215f514*/ System.IO.IsolatedStorage.IsolatedStorageFile GetUserStoreForSite();
                static /*0x215f554*/ void Remove(System.IO.IsolatedStorage.IsolatedStorageScope scope);
                static /*0x215ec40*/ string GetIsolatedStorageRoot(System.IO.IsolatedStorage.IsolatedStorageScope scope);
                static /*0x215ec3c*/ void Demand(System.IO.IsolatedStorage.IsolatedStorageScope scope);
                static /*0x215f638*/ System.Security.Permissions.IsolatedStorageContainment ScopeToContainment(System.IO.IsolatedStorage.IsolatedStorageScope scope);
                static /*0x215f6d8*/ ulong GetDirectorySize(System.IO.DirectoryInfo di);
                static /*0x215f938*/ bool get_IsEnabled();
                /*0x215ee5c*/ IsolatedStorageFile(System.IO.IsolatedStorage.IsolatedStorageScope scope);
                /*0x215f7b4*/ IsolatedStorageFile(System.IO.IsolatedStorage.IsolatedStorageScope scope, string location);
                /*0x2161ec0*/ IsolatedStorageFile();
                /*0x215f8a0*/ void Finalize();
                /*0x215ee84*/ void PostInit();
                /*0x215f8a8*/ ulong get_CurrentSize();
                /*0x215f8b0*/ ulong get_MaximumSize();
                /*0x215f8b8*/ string get_Root();
                /*0x215f8d8*/ long get_AvailableFreeSpace();
                /*0x215f8f8*/ long get_Quota();
                /*0x215f91c*/ long get_UsedSize();
                /*0x215f940*/ bool get_IsClosed();
                /*0x215f948*/ bool get_IsDisposed();
                /*0x215f950*/ void Close();
                /*0x215f95c*/ void CreateDirectory(string dir);
                /*0x215fb48*/ void CopyFile(string sourceFileName, string destinationFileName);
                /*0x215fb50*/ void CopyFile(string sourceFileName, string destinationFileName, bool overwrite);
                /*0x2160020*/ System.IO.IsolatedStorage.IsolatedStorageFileStream CreateFile(string path);
                /*0x21600a0*/ void DeleteDirectory(string dir);
                /*0x2160268*/ void DeleteFile(string file);
                /*0x2160494*/ void Dispose();
                /*0x21604f4*/ bool DirectoryExists(string path);
                /*0x21605fc*/ bool FileExists(string path);
                /*0x2160704*/ System.DateTimeOffset GetCreationTime(string path);
                /*0x2160890*/ System.DateTimeOffset GetLastAccessTime(string path);
                /*0x2160a1c*/ System.DateTimeOffset GetLastWriteTime(string path);
                /*0x2160ba8*/ string[] GetDirectoryNames(string searchPattern);
                /*0x2160f78*/ string[] GetDirectoryNames();
                /*0x2160e90*/ string[] GetNames(System.IO.FileSystemInfo[] afsi);
                /*0x2160fc0*/ string[] GetFileNames(string searchPattern);
                /*0x2161258*/ string[] GetFileNames();
                /*0x21612a0*/ bool IncreaseQuotaTo(long newQuotaSize);
                /*0x2161320*/ void MoveDirectory(string sourceDirectoryName, string destinationDirectoryName);
                /*0x21616e8*/ void MoveFile(string sourceFileName, string destinationFileName);
                /*0x2161a60*/ System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(string path, System.IO.FileMode mode);
                /*0x2161adc*/ System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(string path, System.IO.FileMode mode, System.IO.FileAccess access);
                /*0x2161b68*/ System.IO.IsolatedStorage.IsolatedStorageFileStream OpenFile(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
                /*0x2161bfc*/ void Remove();
                /*0x2161dec*/ System.Security.Permissions.IsolatedStoragePermission GetPermission(System.Security.PermissionSet ps);
                /*0x215f8f0*/ void CheckOpen();
                /*0x2161cf0*/ void CheckOpen(bool checkDirExists);
                /*0x215ff8c*/ bool IsPathInStorage(string path);
            }

            class IsolatedStorageFileEnumerator : System.Collections.IEnumerator
            {
                /*0x10*/ System.IO.IsolatedStorage.IsolatedStorageScope _scope;
                /*0x18*/ string[] _storages;
                /*0x20*/ int _pos;

                /*0x2161ef8*/ IsolatedStorageFileEnumerator(System.IO.IsolatedStorage.IsolatedStorageScope scope, string root);
                /*0x2161f84*/ object get_Current();
                /*0x2162028*/ bool MoveNext();
                /*0x2162054*/ void Reset();
            }

            class IsolatedStorageFileStream : System.IO.FileStream
            {
                static /*0x2162060*/ string CreateIsolatedPath(System.IO.IsolatedStorage.IsolatedStorageFile isf, string path, System.IO.FileMode mode);
                /*0x21624b0*/ IsolatedStorageFileStream(string path, System.IO.FileMode mode);
                /*0x2162594*/ IsolatedStorageFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access);
                /*0x21625a8*/ IsolatedStorageFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);
                /*0x21625b4*/ IsolatedStorageFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);
                /*0x21624cc*/ IsolatedStorageFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.IsolatedStorage.IsolatedStorageFile isf);
                /*0x21625bc*/ IsolatedStorageFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, System.IO.IsolatedStorage.IsolatedStorageFile isf);
                /*0x21625c8*/ IsolatedStorageFileStream(string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.IsolatedStorage.IsolatedStorageFile isf);
                /*0x21625dc*/ IsolatedStorageFileStream(string path, System.IO.FileMode mode, System.IO.IsolatedStorage.IsolatedStorageFile isf);
                /*0x21625f8*/ bool get_CanRead();
                /*0x2162600*/ bool get_CanSeek();
                /*0x2162608*/ bool get_CanWrite();
                /*0x2162610*/ Microsoft.Win32.SafeHandles.SafeFileHandle get_SafeFileHandle();
                /*0x2162670*/ nint get_Handle();
                /*0x21626d0*/ bool get_IsAsync();
                /*0x21626d8*/ long get_Length();
                /*0x21626e0*/ long get_Position();
                /*0x21626e8*/ void set_Position(long value);
                /*0x21626f0*/ System.IAsyncResult BeginRead(byte[] buffer, int offset, int numBytes, System.AsyncCallback userCallback, object stateObject);
                /*0x21626f8*/ System.IAsyncResult BeginWrite(byte[] buffer, int offset, int numBytes, System.AsyncCallback userCallback, object stateObject);
                /*0x2162700*/ int EndRead(System.IAsyncResult asyncResult);
                /*0x2162708*/ void EndWrite(System.IAsyncResult asyncResult);
                /*0x2162710*/ void Flush();
                /*0x2162718*/ void Flush(bool flushToDisk);
                /*0x2162724*/ int Read(byte[] buffer, int offset, int count);
                /*0x216272c*/ int ReadByte();
                /*0x2162734*/ long Seek(long offset, System.IO.SeekOrigin origin);
                /*0x216273c*/ void SetLength(long value);
                /*0x2162744*/ void Write(byte[] buffer, int offset, int count);
                /*0x216274c*/ void WriteByte(byte value);
                /*0x2162754*/ void Dispose(bool disposing);
            }

            enum IsolatedStorageSecurityOptions
            {
                IncreaseQuotaForApplication = 4,
            }

            class IsolatedStorageSecurityState : System.Security.SecurityState
            {
                /*0x2162760*/ IsolatedStorageSecurityState();
                /*0x2162768*/ System.IO.IsolatedStorage.IsolatedStorageSecurityOptions get_Options();
                /*0x2162770*/ long get_Quota();
                /*0x21627b0*/ void set_Quota(long value);
                /*0x21627b4*/ long get_UsedSize();
                /*0x21627f4*/ void EnsureState();
            }
        }

        namespace Enumeration
        {
            struct FileSystemEntry
            {
                /*0x10*/ Interop.Sys.DirectoryEntry _directoryEntry;
                /*0x20*/ System.IO.FileStatus _status;
                /*0x98*/ System.Span<char> _pathBuffer;
                /*0xa8*/ System.ReadOnlySpan<char> _fullPath;
                /*0xb8*/ System.ReadOnlySpan<char> _fileName;
                /*0xc8*/ System.IO.Enumeration.FileSystemEntry.<_fileNameBuffer> _fileNameBuffer;
                /*0x2c8*/ System.IO.FileAttributes _initialAttributes;
                /*0x2d0*/ System.ReadOnlySpan<char> <Directory>k__BackingField;
                /*0x2e0*/ System.ReadOnlySpan<char> <RootDirectory>k__BackingField;
                /*0x2f0*/ System.ReadOnlySpan<char> <OriginalRootDirectory>k__BackingField;

                static /*0x2162834*/ System.IO.FileAttributes Initialize(ref System.IO.Enumeration.FileSystemEntry entry, Interop.Sys.DirectoryEntry directoryEntry, System.ReadOnlySpan<char> directory, System.ReadOnlySpan<char> rootDirectory, System.ReadOnlySpan<char> originalRootDirectory, System.Span<char> pathBuffer);
                /*0x2162ab4*/ System.ReadOnlySpan<char> get_FullPath();
                /*0x2162be8*/ System.ReadOnlySpan<char> get_FileName();
                /*0x2162c7c*/ System.ReadOnlySpan<char> get_Directory();
                /*0x2162c8c*/ void set_Directory(System.ReadOnlySpan<char> value);
                /*0x2162c98*/ System.ReadOnlySpan<char> get_RootDirectory();
                /*0x2162ca8*/ void set_RootDirectory(System.ReadOnlySpan<char> value);
                /*0x2162cb4*/ System.ReadOnlySpan<char> get_OriginalRootDirectory();
                /*0x2162cc4*/ void set_OriginalRootDirectory(System.ReadOnlySpan<char> value);
                /*0x2162cd0*/ System.IO.FileAttributes get_Attributes();
                /*0x2162d18*/ long get_Length();
                /*0x2162d48*/ System.DateTimeOffset get_CreationTimeUtc();
                /*0x2162d78*/ System.DateTimeOffset get_LastAccessTimeUtc();
                /*0x2162da8*/ System.DateTimeOffset get_LastWriteTimeUtc();
                /*0x2162dd8*/ bool get_IsDirectory();
                /*0x2162de0*/ bool get_IsHidden();
                /*0x2162df4*/ System.IO.FileSystemInfo ToFileSystemInfo();
                /*0x2162e64*/ string ToFullPath();
                /*0x2162e8c*/ string ToSpecifiedFullPath();

                struct <_fileNameBuffer>e__FixedBuffer
                {
                    /*0x10*/ char FixedElementField;
                }
            }

            class FileSystemEnumerable<TResult> : System.Collections.Generic.IEnumerable<TResult>, System.Collections.IEnumerable
            {
                /*0x0*/ System.IO.Enumeration.FileSystemEnumerable.DelegateEnumerator<TResult> _enumerator;
                /*0x0*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<TResult> _transform;
                /*0x0*/ System.IO.EnumerationOptions _options;
                /*0x0*/ string _directory;
                /*0x0*/ System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> <ShouldIncludePredicate>k__BackingField;
                /*0x0*/ System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> <ShouldRecursePredicate>k__BackingField;

                FileSystemEnumerable(string directory, System.IO.Enumeration.FileSystemEnumerable.FindTransform<TResult> transform, System.IO.EnumerationOptions options);
                System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> get_ShouldIncludePredicate();
                void set_ShouldIncludePredicate(System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> value);
                System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> get_ShouldRecursePredicate();
                void set_ShouldRecursePredicate(System.IO.Enumeration.FileSystemEnumerable.FindPredicate<TResult> value);
                System.Collections.Generic.IEnumerator<TResult> GetEnumerator();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();

                class FindPredicate<TResult> : System.MulticastDelegate
                {
                    FindPredicate(object object, nint method);
                    bool Invoke(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class FindTransform<TResult> : System.MulticastDelegate
                {
                    FindTransform(object object, nint method);
                    TResult Invoke(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class DelegateEnumerator<TResult> : System.IO.Enumeration.FileSystemEnumerator<TResult>
                {
                    /*0x0*/ System.IO.Enumeration.FileSystemEnumerable<TResult> _enumerable;

                    DelegateEnumerator(System.IO.Enumeration.FileSystemEnumerable<TResult> enumerable);
                    TResult TransformEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                    bool ShouldRecurseIntoEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                    bool ShouldIncludeEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                }
            }

            class FileSystemEnumerableFactory
            {
                static /*0x0*/ char[] s_unixEscapeChars;

                static /*0x2164614*/ FileSystemEnumerableFactory();
                static /*0x2163014*/ void NormalizeInputs(ref string directory, ref string expression, System.IO.EnumerationOptions options);
                static /*0x2163818*/ bool MatchesPattern(string expression, System.ReadOnlySpan<char> name, System.IO.EnumerationOptions options);
                static /*0x2163b4c*/ System.Collections.Generic.IEnumerable<string> UserFiles(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x2163d18*/ System.Collections.Generic.IEnumerable<string> UserDirectories(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x2163ee4*/ System.Collections.Generic.IEnumerable<string> UserEntries(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x21640b0*/ System.Collections.Generic.IEnumerable<System.IO.FileInfo> FileInfos(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x216427c*/ System.Collections.Generic.IEnumerable<System.IO.DirectoryInfo> DirectoryInfos(string directory, string expression, System.IO.EnumerationOptions options);
                static /*0x2164448*/ System.Collections.Generic.IEnumerable<System.IO.FileSystemInfo> FileSystemInfos(string directory, string expression, System.IO.EnumerationOptions options);

                class <>c__DisplayClass3_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x2163d10*/ <>c__DisplayClass3_0();
                    /*0x21646a8*/ bool <UserFiles>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c
                {
                    static /*0x0*/ System.IO.Enumeration.FileSystemEnumerableFactory.<> <>9;
                    static /*0x8*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<string> <>9__3_0;
                    static /*0x10*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<string> <>9__4_0;
                    static /*0x18*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<string> <>9__5_0;
                    static /*0x20*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<System.IO.FileInfo> <>9__6_0;
                    static /*0x28*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<System.IO.DirectoryInfo> <>9__7_0;
                    static /*0x30*/ System.IO.Enumeration.FileSystemEnumerable.FindTransform<System.IO.FileSystemInfo> <>9__8_0;

                    static /*0x2164748*/ <>c();
                    /*0x21647ac*/ <>c();
                    /*0x21647b4*/ string <UserFiles>b__3_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x21647bc*/ string <UserDirectories>b__4_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x21647c4*/ string <UserEntries>b__5_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x21647cc*/ System.IO.FileInfo <FileInfos>b__6_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x216482c*/ System.IO.DirectoryInfo <DirectoryInfos>b__7_0(ref System.IO.Enumeration.FileSystemEntry entry);
                    /*0x216488c*/ System.IO.FileSystemInfo <FileSystemInfos>b__8_0(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass4_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x2163edc*/ <>c__DisplayClass4_0();
                    /*0x2164894*/ bool <UserDirectories>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass5_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x21640a8*/ <>c__DisplayClass5_0();
                    /*0x2164934*/ bool <UserEntries>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass6_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x2164274*/ <>c__DisplayClass6_0();
                    /*0x21649b8*/ bool <FileInfos>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass7_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x2164440*/ <>c__DisplayClass7_0();
                    /*0x2164a58*/ bool <DirectoryInfos>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }

                class <>c__DisplayClass8_0
                {
                    /*0x10*/ string expression;
                    /*0x18*/ System.IO.EnumerationOptions options;

                    /*0x216460c*/ <>c__DisplayClass8_0();
                    /*0x2164af8*/ bool <FileSystemInfos>b__1(ref System.IO.Enumeration.FileSystemEntry entry);
                }
            }

            class FileSystemEnumerator<TResult> : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Collections.Generic.IEnumerator<TResult>, System.IDisposable, System.Collections.IEnumerator
            {
                static int StandardBufferSize = 4096;
                /*0x0*/ string _originalRootDirectory;
                /*0x0*/ string _rootDirectory;
                /*0x0*/ System.IO.EnumerationOptions _options;
                /*0x0*/ object _lock;
                /*0x0*/ string _currentPath;
                /*0x0*/ nint _directoryHandle;
                /*0x0*/ bool _lastEntryFound;
                /*0x0*/ System.Collections.Generic.Queue<string> _pending;
                /*0x0*/ Interop.Sys.DirectoryEntry _entry;
                /*0x0*/ TResult _current;
                /*0x0*/ char[] _pathBuffer;
                /*0x0*/ byte[] _entryBuffer;

                static bool IsDirectoryNotFound(Interop.ErrorInfo info);
                static bool IsAccessError(Interop.ErrorInfo info);
                FileSystemEnumerator(string directory, System.IO.EnumerationOptions options);
                bool InternalContinueOnError(Interop.ErrorInfo info, bool ignoreNotFound);
                nint CreateDirectoryHandle(string path, bool ignoreNotFound);
                void CloseDirectoryHandle();
                bool MoveNext();
                void FindNextEntry();
                void FindNextEntry(byte* entryBufferPtr, int bufferLength);
                bool DequeueNextDirectory();
                void InternalDispose(bool disposing);
                bool ShouldIncludeEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                bool ShouldRecurseIntoEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                TResult TransformEntry(ref System.IO.Enumeration.FileSystemEntry entry);
                void OnDirectoryFinished(System.ReadOnlySpan<char> directory);
                bool ContinueOnError(int error);
                TResult get_Current();
                object System.Collections.IEnumerator.get_Current();
                void DirectoryFinished();
                void Reset();
                void Dispose();
                void Dispose(bool disposing);
                void Finalize();
            }

            class FileSystemName
            {
                static /*0x0*/ char[] s_wildcardChars;
                static /*0x8*/ char[] s_simpleWildcardChars;

                static /*0x21652d0*/ FileSystemName();
                static /*0x216347c*/ string TranslateWin32Expression(string expression);
                static /*0x2163ac4*/ bool MatchesWin32Expression(System.ReadOnlySpan<char> expression, System.ReadOnlySpan<char> name, bool ignoreCase);
                static /*0x2163a3c*/ bool MatchesSimpleExpression(System.ReadOnlySpan<char> expression, System.ReadOnlySpan<char> name, bool ignoreCase);
                static /*0x2164b7c*/ bool MatchPattern(System.ReadOnlySpan<char> expression, System.ReadOnlySpan<char> name, bool ignoreCase, bool useExtendedWildcards);
            }
        }
    }

    namespace Globalization
    {
        enum BidiCategory
        {
            LeftToRight = 0,
            LeftToRightEmbedding = 1,
            LeftToRightOverride = 2,
            RightToLeft = 3,
            RightToLeftArabic = 4,
            RightToLeftEmbedding = 5,
            RightToLeftOverride = 6,
            PopDirectionalFormat = 7,
            EuropeanNumber = 8,
            EuropeanNumberSeparator = 9,
            EuropeanNumberTerminator = 10,
            ArabicNumber = 11,
            CommonNumberSeparator = 12,
            NonSpacingMark = 13,
            BoundaryNeutral = 14,
            ParagraphSeparator = 15,
            SegmentSeparator = 16,
            Whitespace = 17,
            OtherNeutrals = 18,
            LeftToRightIsolate = 19,
            RightToLeftIsolate = 20,
            FirstStrongIsolate = 21,
            PopDirectionIsolate = 22,
        }

        enum CalendarAlgorithmType
        {
            Unknown = 0,
            SolarCalendar = 1,
            LunarCalendar = 2,
            LunisolarCalendar = 3,
        }

        enum CalendarWeekRule
        {
            FirstDay = 0,
            FirstFullWeek = 1,
            FirstFourDayWeek = 2,
        }

        class CharUnicodeInfo
        {
            static char HIGH_SURROGATE_START = 55296;
            static char HIGH_SURROGATE_END = 56319;
            static char LOW_SURROGATE_START = 56320;
            static char LOW_SURROGATE_END = 57343;
            static int HIGH_SURROGATE_RANGE = 1023;
            static int UNICODE_CATEGORY_OFFSET = 0;
            static int BIDI_CATEGORY_OFFSET = 1;
            static int UNICODE_PLANE01_START = 65536;

            static /*0x21653a8*/ int InternalConvertToUtf32(string s, int index);
            static /*0x216543c*/ int InternalConvertToUtf32(System.Text.StringBuilder s, int index);
            static /*0x21654c8*/ int InternalConvertToUtf32(string s, int index, ref int charLength);
            static /*0x216557c*/ double InternalGetNumericValue(int ch);
            static /*0x2165878*/ byte InternalGetDigitValues(int ch, int offset);
            static /*0x2165998*/ double GetNumericValue(char ch);
            static /*0x21659a0*/ double GetNumericValue(string s, int index);
            static /*0x2165a64*/ int GetDecimalDigitValue(char ch);
            static /*0x2165a80*/ int GetDecimalDigitValue(string s, int index);
            static /*0x2165b50*/ int GetDigitValue(char ch);
            static /*0x2165b6c*/ int GetDigitValue(string s, int index);
            static /*0x2165c3c*/ System.Globalization.UnicodeCategory GetUnicodeCategory(char ch);
            static /*0x2165c70*/ System.Globalization.UnicodeCategory GetUnicodeCategory(string s, int index);
            static /*0x2165c58*/ System.Globalization.UnicodeCategory GetUnicodeCategory(int codePoint);
            static /*0x2165d3c*/ byte InternalGetCategoryValue(int ch, int offset);
            static /*0x2165d20*/ System.Globalization.UnicodeCategory InternalGetUnicodeCategory(string value, int index);
            static /*0x2166000*/ System.Globalization.BidiCategory GetBidiCategory(string s, int index);
            static /*0x21660b0*/ System.Globalization.BidiCategory GetBidiCategory(System.Text.StringBuilder s, int index);
            static /*0x21660cc*/ System.Globalization.UnicodeCategory InternalGetUnicodeCategory(string str, int index, ref int charLength);
            static /*0x21660e8*/ bool IsCombiningCategory(System.Globalization.UnicodeCategory uc);
            static /*0x2166108*/ bool IsWhiteSpace(string s, int index);
            static /*0x2166124*/ bool IsWhiteSpace(char c);
            static /*0x2165e30*/ System.ReadOnlySpan<byte> get_CategoryLevel1Index();
            static /*0x2165ea4*/ System.ReadOnlySpan<byte> get_CategoryLevel2Index();
            static /*0x2165f18*/ System.ReadOnlySpan<byte> get_CategoryLevel3Index();
            static /*0x2165f8c*/ System.ReadOnlySpan<byte> get_CategoriesValue();
            static /*0x21656a8*/ System.ReadOnlySpan<byte> get_NumericLevel1Index();
            static /*0x216571c*/ System.ReadOnlySpan<byte> get_NumericLevel2Index();
            static /*0x2165790*/ System.ReadOnlySpan<byte> get_NumericLevel3Index();
            static /*0x2165804*/ System.ReadOnlySpan<byte> get_NumericValues();
            static /*0x2165924*/ System.ReadOnlySpan<byte> get_DigitValues();
        }

        class CompareInfo : System.Runtime.Serialization.IDeserializationCallback
        {
            static System.Globalization.CompareOptions ValidIndexMaskOffFlags = -32;
            static System.Globalization.CompareOptions ValidCompareMaskOffFlags = -536870944;
            static System.Globalization.CompareOptions ValidHashCodeOfStringMaskOffFlags = -32;
            static System.Globalization.CompareOptions ValidSortkeyCtorMaskOffFlags = -536870944;
            static /*0x0*/ System.Globalization.CompareInfo Invariant;
            static /*0x8*/ System.Collections.Generic.Dictionary<string, System.Globalization.ISimpleCollator> collators;
            static /*0x10*/ bool managedCollation;
            static /*0x11*/ bool managedCollationChecked;
            /*0x10*/ string m_name;
            /*0x18*/ string _sortName;
            /*0x20*/ System.Globalization.SortVersion m_SortVersion;
            /*0x28*/ int culture;
            /*0x30*/ System.Globalization.ISimpleCollator collator;

            static /*0x216c278*/ CompareInfo();
            static /*0x216614c*/ int InvariantIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
            static /*0x216653c*/ int InvariantIndexOf(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, bool ignoreCase);
            static /*0x2166618*/ int InvariantLastIndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
            static /*0x2166210*/ int InvariantFindString(char* source, int sourceCount, char* value, int valueCount, bool ignoreCase, bool start);
            static /*0x21666e4*/ char InvariantToUpper(char c);
            static /*0x21669e8*/ System.Globalization.CompareInfo GetCompareInfo(int culture, System.Reflection.Assembly assembly);
            static /*0x2166c3c*/ System.Globalization.CompareInfo GetCompareInfo(string name, System.Reflection.Assembly assembly);
            static /*0x2166b5c*/ System.Globalization.CompareInfo GetCompareInfo(int culture);
            static /*0x2166dd8*/ System.Globalization.CompareInfo GetCompareInfo(string name);
            static /*0x2166e98*/ bool IsSortable(char ch);
            static /*0x2166fe8*/ bool IsSortable(string text);
            static /*0x2168638*/ int CompareOrdinalIgnoreCase(string strA, int indexA, int lengthA, string strB, int indexB, int lengthB);
            static /*0x21675ac*/ int CompareOrdinalIgnoreCase(System.ReadOnlySpan<char> strA, System.ReadOnlySpan<char> strB);
            static /*0x216abf4*/ int GetIgnoreCaseHash(string source);
            static /*0x216b6bc*/ bool get_UseManagedCollation();
            static /*0x216c26c*/ int internal_compare_icall(char* str1, int length1, char* str2, int length2, System.Globalization.CompareOptions options);
            static /*0x216bf8c*/ int internal_compare(string str1, int offset1, int length1, string str2, int offset2, int length2, System.Globalization.CompareOptions options);
            static /*0x216c270*/ int internal_index_icall(char* source, int sindex, int count, char* value, int value_length, bool first);
            static /*0x216bdac*/ int internal_index(string source, int sindex, int count, string value, bool first);
            static /*0x21687ac*/ int CompareStringOrdinalIgnoreCase(char* pString1, int length1, char* pString2, int length2);
            static /*0x2169e90*/ int IndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
            static /*0x216a8a0*/ int LastIndexOfOrdinalCore(string source, string value, int startIndex, int count, bool ignoreCase);
            static /*0x2166f64*/ bool IsSortable(char* text, int length);
            /*0x2166998*/ CompareInfo(System.Globalization.CultureInfo culture);
            /*0x216c304*/ CompareInfo();
            /*0x21666fc*/ System.Globalization.SortKey InvariantCreateSortKey(string source, System.Globalization.CompareOptions options);
            /*0x2167128*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x2167130*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x21671d8*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x2167134*/ void OnDeserialized();
            /*0x21671dc*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x2167268*/ string get_Name();
            /*0x21672f4*/ int Compare(string string1, string string2);
            /*0x2167304*/ int Compare(string string1, string string2, System.Globalization.CompareOptions options);
            /*0x216789c*/ int Compare(System.ReadOnlySpan<char> string1, string string2, System.Globalization.CompareOptions options);
            /*0x2167ca0*/ int CompareOptionNone(System.ReadOnlySpan<char> string1, System.ReadOnlySpan<char> string2);
            /*0x2167f04*/ int CompareOptionIgnoreCase(System.ReadOnlySpan<char> string1, System.ReadOnlySpan<char> string2);
            /*0x2168040*/ int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
            /*0x2168068*/ int Compare(string string1, int offset1, string string2, int offset2, System.Globalization.CompareOptions options);
            /*0x21680c8*/ int Compare(string string1, int offset1, string string2, int offset2);
            /*0x21680d8*/ int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, System.Globalization.CompareOptions options);
            /*0x2168920*/ bool IsPrefix(string source, string prefix, System.Globalization.CompareOptions options);
            /*0x2168cb8*/ bool IsPrefix(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> prefix, System.Globalization.CompareOptions options);
            /*0x2168d1c*/ bool IsPrefix(string source, string prefix);
            /*0x2168d2c*/ bool IsSuffix(string source, string suffix, System.Globalization.CompareOptions options);
            /*0x21690c0*/ bool IsSuffix(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> suffix, System.Globalization.CompareOptions options);
            /*0x2169124*/ bool IsSuffix(string source, string suffix);
            /*0x2169138*/ int IndexOf(string source, char value);
            /*0x21691ac*/ int IndexOf(string source, string value);
            /*0x2169220*/ int IndexOf(string source, char value, System.Globalization.CompareOptions options);
            /*0x2169294*/ int IndexOf(string source, string value, System.Globalization.CompareOptions options);
            /*0x2169308*/ int IndexOf(string source, char value, int startIndex);
            /*0x216937c*/ int IndexOf(string source, string value, int startIndex);
            /*0x21693f0*/ int IndexOf(string source, char value, int startIndex, System.Globalization.CompareOptions options);
            /*0x2169464*/ int IndexOf(string source, string value, int startIndex, System.Globalization.CompareOptions options);
            /*0x21694d8*/ int IndexOf(string source, char value, int startIndex, int count);
            /*0x21694ec*/ int IndexOf(string source, string value, int startIndex, int count);
            /*0x2169500*/ int IndexOf(string source, char value, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x216992c*/ int IndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x2169bf0*/ int IndexOfOrdinal(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, bool ignoreCase);
            /*0x2169c74*/ int IndexOf(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, System.Globalization.CompareOptions options);
            /*0x2169cfc*/ int IndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options, int* matchLengthPtr);
            /*0x21697d0*/ int IndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
            /*0x2169eb0*/ int LastIndexOf(string source, char value);
            /*0x2169f24*/ int LastIndexOf(string source, string value);
            /*0x2169f98*/ int LastIndexOf(string source, char value, System.Globalization.CompareOptions options);
            /*0x216a00c*/ int LastIndexOf(string source, string value, System.Globalization.CompareOptions options);
            /*0x216a080*/ int LastIndexOf(string source, char value, int startIndex);
            /*0x216a098*/ int LastIndexOf(string source, string value, int startIndex);
            /*0x216a0b0*/ int LastIndexOf(string source, char value, int startIndex, System.Globalization.CompareOptions options);
            /*0x216a0c8*/ int LastIndexOf(string source, string value, int startIndex, System.Globalization.CompareOptions options);
            /*0x216a0e0*/ int LastIndexOf(string source, char value, int startIndex, int count);
            /*0x216a0f4*/ int LastIndexOf(string source, string value, int startIndex, int count);
            /*0x216a108*/ int LastIndexOf(string source, char value, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x216a444*/ int LastIndexOf(string source, string value, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x216a7a0*/ int LastIndexOfOrdinal(string source, string value, int startIndex, int count, bool ignoreCase);
            /*0x216a8c0*/ System.Globalization.SortKey GetSortKey(string source, System.Globalization.CompareOptions options);
            /*0x216aa48*/ System.Globalization.SortKey GetSortKey(string source);
            /*0x216ab0c*/ bool Equals(object value);
            /*0x216abcc*/ int GetHashCode();
            /*0x216b070*/ int GetHashCodeOfString(string source, System.Globalization.CompareOptions options);
            /*0x216b244*/ int GetHashCode(string source, System.Globalization.CompareOptions options);
            /*0x216b348*/ string ToString();
            /*0x216b3a8*/ System.Globalization.SortVersion get_Version();
            /*0x216b638*/ int get_LCID();
            /*0x216b800*/ System.Globalization.ISimpleCollator GetCollator();
            /*0x216bb34*/ System.Globalization.SortKey CreateSortKeyCore(string source, System.Globalization.CompareOptions options);
            /*0x216bc70*/ int internal_index_switch(string s1, int sindex, int count, string s2, System.Globalization.CompareOptions opt, bool first);
            /*0x21677a0*/ int internal_compare_switch(string str1, int offset1, int length1, string str2, int offset2, int length2, System.Globalization.CompareOptions options);
            /*0x216c040*/ int internal_compare_managed(string str1, int offset1, int length1, string str2, int offset2, int length2, System.Globalization.CompareOptions options);
            /*0x216c140*/ int internal_index_managed(string s, int sindex, int count, char c, System.Globalization.CompareOptions opt, bool first);
            /*0x216be60*/ int internal_index_managed(string s1, int sindex, int count, string s2, System.Globalization.CompareOptions opt, bool first);
            /*0x21669cc*/ void InitSort(System.Globalization.CultureInfo culture);
            /*0x216a42c*/ int LastIndexOfCore(string source, string target, int startIndex, int count, System.Globalization.CompareOptions options);
            /*0x21698d0*/ int IndexOfCore(string source, string target, int startIndex, int count, System.Globalization.CompareOptions options, int* matchLengthPtr);
            /*0x2169c7c*/ int IndexOfCore(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> target, System.Globalization.CompareOptions options, int* matchLengthPtr);
            /*0x2169bf8*/ int IndexOfOrdinalCore(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> value, bool ignoreCase);
            /*0x2167c3c*/ int CompareString(System.ReadOnlySpan<char> string1, string string2, System.Globalization.CompareOptions options);
            /*0x2167e14*/ int CompareString(System.ReadOnlySpan<char> string1, System.ReadOnlySpan<char> string2, System.Globalization.CompareOptions options);
            /*0x216a988*/ System.Globalization.SortKey CreateSortKey(string source, System.Globalization.CompareOptions options);
            /*0x2168b44*/ bool StartsWith(string source, string prefix, System.Globalization.CompareOptions options);
            /*0x2168cbc*/ bool StartsWith(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> prefix, System.Globalization.CompareOptions options);
            /*0x2168f50*/ bool EndsWith(string source, string suffix, System.Globalization.CompareOptions options);
            /*0x21690c4*/ bool EndsWith(System.ReadOnlySpan<char> source, System.ReadOnlySpan<char> suffix, System.Globalization.CompareOptions options);
            /*0x216b218*/ int GetHashCodeOfStringCore(string source, System.Globalization.CompareOptions options);
            /*0x216b5f8*/ System.Globalization.SortVersion GetSortVersion();
        }

        enum CompareOptions
        {
            None = 0,
            IgnoreCase = 1,
            IgnoreNonSpace = 2,
            IgnoreSymbols = 4,
            IgnoreKanaType = 8,
            IgnoreWidth = 16,
            OrdinalIgnoreCase = 268435456,
            StringSort = 536870912,
            Ordinal = 1073741824,
        }

        class CultureNotFoundException : System.ArgumentException
        {
            /*0x98*/ string _invalidCultureName;
            /*0xa0*/ System.Nullable<int> _invalidCultureId;

            static /*0x216c388*/ string get_DefaultMessage();
            /*0x216c33c*/ CultureNotFoundException();
            /*0x216c3c8*/ CultureNotFoundException(string message);
            /*0x216c3d0*/ CultureNotFoundException(string paramName, string message);
            /*0x216c3e4*/ CultureNotFoundException(string message, System.Exception innerException);
            /*0x216c3ec*/ CultureNotFoundException(string paramName, string invalidCultureName, string message);
            /*0x216c41c*/ CultureNotFoundException(string message, string invalidCultureName, System.Exception innerException);
            /*0x216c448*/ CultureNotFoundException(string message, int invalidCultureId, System.Exception innerException);
            /*0x216c4d4*/ CultureNotFoundException(string paramName, int invalidCultureId, string message);
            /*0x216c560*/ CultureNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x216c71c*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x216c880*/ System.Nullable<int> get_InvalidCultureId();
            /*0x216c888*/ string get_InvalidCultureName();
            /*0x216c890*/ string get_FormatedInvalidCultureId();
            /*0x216c9cc*/ string get_Message();
        }

        enum CultureTypes
        {
            NeutralCultures = 1,
            SpecificCultures = 2,
            InstalledWin32Cultures = 4,
            AllCultures = 7,
            UserCustomCulture = 8,
            ReplacementCultures = 16,
            WindowsOnlyCultures = 32,
            FrameworkCultures = 64,
        }

        enum MonthNameStyles
        {
            Regular = 0,
            Genitive = 1,
            LeapYear = 2,
        }

        enum DateTimeFormatFlags
        {
            None = 0,
            UseGenitiveMonth = 1,
            UseLeapYearMonth = 2,
            UseSpacesInMonthNames = 4,
            UseHebrewRule = 8,
            UseSpacesInDayNames = 16,
            UseDigitPrefixInTokens = 32,
            NotInitialized = -1,
        }

        class DateTimeFormatInfo : System.IFormatProvider, System.ICloneable
        {
            static string rfc1123Pattern = "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'";
            static string sortableDateTimePattern = "yyyy'-'MM'-'dd'T'HH':'mm':'ss";
            static string universalSortableDateTimePattern = "yyyy'-'MM'-'dd HH':'mm':'ss'Z'";
            static int DEFAULT_ALL_DATETIMES_SIZE = 132;
            static string RoundtripFormat = "yyyy'-'MM'-'dd'T'HH':'mm':'ss.fffffffK";
            static string RoundtripDateTimeUnfixed = "yyyy'-'MM'-'ddTHH':'mm':'ss zzz";
            static System.Globalization.DateTimeStyles InvalidDateTimeStyles = -256;
            static int TOKEN_HASH_SIZE = 199;
            static int SECOND_PRIME = 197;
            static string dateSeparatorOrTimeZoneOffset = "-";
            static string invariantDateSeparator = "/";
            static string invariantTimeSeparator = ":";
            static string IgnorablePeriod = ".";
            static string IgnorableComma = ",";
            static string CJKYearSuff = "";
            static string CJKMonthSuff = "";
            static string CJKDaySuff = "";
            static string KoreanYearSuff = "";
            static string KoreanMonthSuff = "";
            static string KoreanDaySuff = "";
            static string KoreanHourSuff = "";
            static string KoreanMinuteSuff = "";
            static string KoreanSecondSuff = "";
            static string CJKHourSuff = "";
            static string ChineseHourSuff = "";
            static string CJKMinuteSuff = "";
            static string CJKSecondSuff = "";
            static string JapaneseEraStart = "";
            static string LocalTimeMark = "T";
            static string GMTName = "GMT";
            static string ZuluName = "Z";
            static string KoreanLangName = "ko";
            static string JapaneseLangName = "ja";
            static string EnglishLangName = "en";
            static /*0x0*/ System.Globalization.DateTimeFormatInfo s_invariantInfo;
            static /*0x8*/ char[] s_monthSpaces;
            static /*0x10*/ System.Globalization.DateTimeFormatInfo s_jajpDTFI;
            static /*0x18*/ System.Globalization.DateTimeFormatInfo s_zhtwDTFI;
            /*0x10*/ System.Globalization.CultureData _cultureData;
            /*0x18*/ string _name;
            /*0x20*/ string _langName;
            /*0x28*/ System.Globalization.CompareInfo _compareInfo;
            /*0x30*/ System.Globalization.CultureInfo _cultureInfo;
            /*0x38*/ string amDesignator;
            /*0x40*/ string pmDesignator;
            /*0x48*/ string dateSeparator;
            /*0x50*/ string generalShortTimePattern;
            /*0x58*/ string generalLongTimePattern;
            /*0x60*/ string timeSeparator;
            /*0x68*/ string monthDayPattern;
            /*0x70*/ string dateTimeOffsetPattern;
            /*0x78*/ System.Globalization.Calendar calendar;
            /*0x80*/ int firstDayOfWeek;
            /*0x84*/ int calendarWeekRule;
            /*0x88*/ string fullDateTimePattern;
            /*0x90*/ string[] abbreviatedDayNames;
            /*0x98*/ string[] m_superShortDayNames;
            /*0xa0*/ string[] dayNames;
            /*0xa8*/ string[] abbreviatedMonthNames;
            /*0xb0*/ string[] monthNames;
            /*0xb8*/ string[] genitiveMonthNames;
            /*0xc0*/ string[] m_genitiveAbbreviatedMonthNames;
            /*0xc8*/ string[] leapYearMonthNames;
            /*0xd0*/ string longDatePattern;
            /*0xd8*/ string shortDatePattern;
            /*0xe0*/ string yearMonthPattern;
            /*0xe8*/ string longTimePattern;
            /*0xf0*/ string shortTimePattern;
            /*0xf8*/ string[] allYearMonthPatterns;
            /*0x100*/ string[] allShortDatePatterns;
            /*0x108*/ string[] allLongDatePatterns;
            /*0x110*/ string[] allShortTimePatterns;
            /*0x118*/ string[] allLongTimePatterns;
            /*0x120*/ string[] m_eraNames;
            /*0x128*/ string[] m_abbrevEraNames;
            /*0x130*/ string[] m_abbrevEnglishEraNames;
            /*0x138*/ System.Globalization.CalendarId[] optionalCalendars;
            /*0x140*/ bool _isReadOnly;
            /*0x144*/ System.Globalization.DateTimeFormatFlags formatFlags;
            /*0x148*/ string _fullTimeSpanPositivePattern;
            /*0x150*/ string _fullTimeSpanNegativePattern;
            /*0x158*/ System.Globalization.DateTimeFormatInfo.TokenHashValue[] _dtfiTokenHash;

            static /*0x2174930*/ DateTimeFormatInfo();
            static /*0x216d224*/ System.Globalization.DateTimeFormatInfo get_InvariantInfo();
            static /*0x216d2f4*/ System.Globalization.DateTimeFormatInfo get_CurrentInfo();
            static /*0x216d400*/ System.Globalization.DateTimeFormatInfo GetInstance(System.IFormatProvider provider);
            static /*0x216f090*/ void CheckNullValue(string[] values, int length);
            static /*0x217014c*/ string[] GetCombinedPatterns(string[] patterns1, string[] patterns2, string connectString);
            static /*0x2170d54*/ string[] GetMergedPatterns(string[] patterns, string defaultPattern);
            static /*0x2170f38*/ System.Globalization.DateTimeFormatInfo ReadOnly(System.Globalization.DateTimeFormatInfo dtfi);
            static /*0x21719c0*/ void ValidateStyles(System.Globalization.DateTimeStyles style, string parameterName);
            static /*0x2171e88*/ System.Globalization.DateTimeFormatInfo GetJapaneseCalendarDTFI();
            static /*0x217201c*/ System.Globalization.DateTimeFormatInfo GetTaiwanCalendarDTFI();
            static /*0x2173a68*/ bool IsJapaneseCalendar(System.Globalization.Calendar calendar);
            static /*0x2173ba4*/ bool TryParseHebrewNumber(ref System.__DTString str, ref bool badFormat, ref int number);
            static /*0x2173f44*/ bool IsHebrewChar(char ch);
            /*0x216cd44*/ DateTimeFormatInfo();
            /*0x216cf34*/ DateTimeFormatInfo(System.Globalization.CultureData cultureData, System.Globalization.Calendar cal);
            /*0x216ca88*/ string get_CultureName();
            /*0x216cab4*/ System.Globalization.CultureInfo get_Culture();
            /*0x216cb38*/ string get_LanguageName();
            /*0x216cb64*/ string[] internalGetAbbreviatedDayOfWeekNames();
            /*0x216cb78*/ string[] internalGetAbbreviatedDayOfWeekNamesCore();
            /*0x216cbc4*/ string[] internalGetSuperShortDayNames();
            /*0x216cbd8*/ string[] internalGetSuperShortDayNamesCore();
            /*0x216cc24*/ string[] internalGetDayOfWeekNames();
            /*0x216cc38*/ string[] internalGetDayOfWeekNamesCore();
            /*0x216cc84*/ string[] internalGetAbbreviatedMonthNames();
            /*0x216cc98*/ string[] internalGetAbbreviatedMonthNamesCore();
            /*0x216cce4*/ string[] internalGetMonthNames();
            /*0x216ccf8*/ string[] internalGetMonthNamesCore();
            /*0x216ce18*/ void InitializeOverridableProperties(System.Globalization.CultureData cultureData, int calendarId);
            /*0x216d5c0*/ object GetFormat(System.Type formatType);
            /*0x216d658*/ object Clone();
            /*0x216d758*/ string get_AMDesignator();
            /*0x216d784*/ void set_AMDesignator(string value);
            /*0x216d908*/ System.Globalization.Calendar get_Calendar();
            /*0x216cf78*/ void set_Calendar(System.Globalization.Calendar value);
            /*0x216d910*/ System.Globalization.CalendarId[] get_OptionalCalendars();
            /*0x216d940*/ int GetEra(string eraName);
            /*0x216dbb8*/ string[] get_EraNames();
            /*0x216dcb4*/ string GetEraName(int era);
            /*0x216dc0c*/ string[] get_AbbreviatedEraNames();
            /*0x216dd90*/ string GetAbbreviatedEraName(int era);
            /*0x216dc60*/ string[] get_AbbreviatedEnglishEraNames();
            /*0x216de7c*/ string get_DateSeparator();
            /*0x216ded0*/ void set_DateSeparator(string value);
            /*0x216dfa0*/ System.DayOfWeek get_FirstDayOfWeek();
            /*0x216dfd0*/ void set_FirstDayOfWeek(System.DayOfWeek value);
            /*0x216e0f8*/ System.Globalization.CalendarWeekRule get_CalendarWeekRule();
            /*0x216e128*/ void set_CalendarWeekRule(System.Globalization.CalendarWeekRule value);
            /*0x216e250*/ string get_FullDateTimePattern();
            /*0x216e33c*/ void set_FullDateTimePattern(string value);
            /*0x216e2c4*/ string get_LongDatePattern();
            /*0x216e454*/ void set_LongDatePattern(string value);
            /*0x216e300*/ string get_LongTimePattern();
            /*0x216e558*/ void set_LongTimePattern(string value);
            /*0x216e634*/ string get_MonthDayPattern();
            /*0x216e688*/ void set_MonthDayPattern(string value);
            /*0x216e74c*/ string get_PMDesignator();
            /*0x216e778*/ void set_PMDesignator(string value);
            /*0x216e848*/ string get_RFC1123Pattern();
            /*0x216e888*/ string get_ShortDatePattern();
            /*0x216e918*/ void set_ShortDatePattern(string value);
            /*0x216e9f0*/ string get_ShortTimePattern();
            /*0x216ea5c*/ void set_ShortTimePattern(string value);
            /*0x216eb30*/ string get_SortableDateTimePattern();
            /*0x216eb70*/ string get_GeneralShortTimePattern();
            /*0x216ebe4*/ string get_GeneralLongTimePattern();
            /*0x216ec58*/ string get_DateTimeOffsetPattern();
            /*0x216edf4*/ string get_TimeSeparator();
            /*0x216ee20*/ void set_TimeSeparator(string value);
            /*0x216eef0*/ string get_UniversalSortableDateTimePattern();
            /*0x216ef30*/ string get_YearMonthPattern();
            /*0x216efc0*/ void set_YearMonthPattern(string value);
            /*0x216f140*/ string[] get_AbbreviatedDayNames();
            /*0x216f1c4*/ void set_AbbreviatedDayNames(string[] value);
            /*0x216f384*/ string[] get_ShortestDayNames();
            /*0x216f408*/ void set_ShortestDayNames(string[] value);
            /*0x216f5bc*/ string[] get_DayNames();
            /*0x216f640*/ void set_DayNames(string[] value);
            /*0x216f800*/ string[] get_AbbreviatedMonthNames();
            /*0x216f884*/ void set_AbbreviatedMonthNames(string[] value);
            /*0x216fa48*/ string[] get_MonthNames();
            /*0x216facc*/ void set_MonthNames(string[] value);
            /*0x216fc90*/ bool get_HasSpacesInMonthNames();
            /*0x216fcd0*/ bool get_HasSpacesInDayNames();
            /*0x216fcf8*/ string internalGetMonthName(int month, System.Globalization.MonthNameStyles style, bool abbreviated);
            /*0x216fe64*/ string[] internalGetGenitiveMonthNames(bool abbreviated);
            /*0x216fef8*/ string[] internalGetLeapYearMonthNames();
            /*0x216ff4c*/ string GetAbbreviatedDayName(System.DayOfWeek dayofweek);
            /*0x217004c*/ string GetShortestDayName(System.DayOfWeek dayOfWeek);
            /*0x21702b8*/ string[] GetAllDateTimePatterns();
            /*0x217048c*/ string[] GetAllDateTimePatterns(char format);
            /*0x2170a4c*/ string GetDayName(System.DayOfWeek dayofweek);
            /*0x2170b4c*/ string GetAbbreviatedMonthName(int month);
            /*0x2170c50*/ string GetMonthName(int month);
            /*0x21709d8*/ string[] get_AllYearMonthPatterns();
            /*0x2170808*/ string[] get_AllShortDatePatterns();
            /*0x21708f0*/ string[] get_AllShortTimePatterns();
            /*0x217087c*/ string[] get_AllLongDatePatterns();
            /*0x2170964*/ string[] get_AllLongTimePatterns();
            /*0x216ef6c*/ string[] get_UnclonedYearMonthPatterns();
            /*0x216e8c4*/ string[] get_UnclonedShortDatePatterns();
            /*0x216e400*/ string[] get_UnclonedLongDatePatterns();
            /*0x216ea2c*/ string[] get_UnclonedShortTimePatterns();
            /*0x216e528*/ string[] get_UnclonedLongTimePatterns();
            /*0x216d854*/ bool get_IsReadOnly();
            /*0x2171044*/ string get_NativeCalendarName();
            /*0x2171080*/ void SetAllDateTimePatterns(string[] patterns, char format);
            /*0x217137c*/ string[] get_AbbreviatedMonthGenitiveNames();
            /*0x21713fc*/ void set_AbbreviatedMonthGenitiveNames(string[] value);
            /*0x21715c0*/ string[] get_MonthGenitiveNames();
            /*0x2171640*/ void set_MonthGenitiveNames(string[] value);
            /*0x2171804*/ string get_FullTimeSpanPositivePattern();
            /*0x21718d8*/ string get_FullTimeSpanNegativePattern();
            /*0x2171940*/ System.Globalization.CompareInfo get_CompareInfo();
            /*0x216fcb8*/ System.Globalization.DateTimeFormatFlags get_FormatFlags();
            /*0x2171a98*/ System.Globalization.DateTimeFormatFlags InitializeFormatFlags();
            /*0x2171cf8*/ bool get_HasForceTwoDigitYears();
            /*0x2171d2c*/ bool get_HasYearMonthAdjustment();
            /*0x2171d54*/ bool YearMonthAdjustment(ref int year, ref int month, bool parsedMonthName);
            /*0x216d8f8*/ void ClearTokenHashTable();
            /*0x21721b0*/ System.Globalization.DateTimeFormatInfo.TokenHashValue[] CreateTokenHashTable();
            /*0x2172da4*/ void PopulateSpecialTokenHashTable(System.Globalization.DateTimeFormatInfo.TokenHashValue[] temp, ref bool useDateSepAsIgnorableSymbol);
            /*0x2173680*/ void AddMonthNames(System.Globalization.DateTimeFormatInfo.TokenHashValue[] temp, string monthPostfix);
            /*0x2173f58*/ bool IsAllowedJapaneseTokenFollowedByNonSpaceLetter(string tokenString, char nextCh);
            /*0x2174060*/ bool Tokenize(System.TokenType TokenMask, ref System.TokenType tokenType, ref int tokenValue, ref System.__DTString str);
            /*0x2174634*/ void InsertAtCurrentHashNode(System.Globalization.DateTimeFormatInfo.TokenHashValue[] hashTable, string str, char ch, System.TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe);
            /*0x2172aa0*/ void InsertHash(System.Globalization.DateTimeFormatInfo.TokenHashValue[] hashTable, string str, System.TokenType tokenType, int tokenValue);
            /*0x2174838*/ bool CompareStringIgnoreCaseOptimized(string string1, int offset1, int length1, string string2, int offset2, int length2);

            class TokenHashValue
            {
                /*0x10*/ string tokenString;
                /*0x18*/ System.TokenType tokenType;
                /*0x1c*/ int tokenValue;

                /*0x21747fc*/ TokenHashValue(string tokenString, System.TokenType tokenType, int tokenValue);
            }
        }

        enum FORMATFLAGS
        {
            None = 0,
            UseGenitiveMonth = 1,
            UseLeapYearMonth = 2,
            UseSpacesInMonthNames = 4,
            UseHebrewParsing = 8,
            UseSpacesInDayNames = 16,
            UseDigitPrefixInTokens = 32,
        }

        enum CalendarId
        {
            UNINITIALIZED_VALUE = 0,
            GREGORIAN = 1,
            GREGORIAN_US = 2,
            JAPAN = 3,
            TAIWAN = 4,
            KOREA = 5,
            HIJRI = 6,
            THAI = 7,
            HEBREW = 8,
            GREGORIAN_ME_FRENCH = 9,
            GREGORIAN_ARABIC = 10,
            GREGORIAN_XLIT_ENGLISH = 11,
            GREGORIAN_XLIT_FRENCH = 12,
            JULIAN = 13,
            JAPANESELUNISOLAR = 14,
            CHINESELUNISOLAR = 15,
            SAKA = 16,
            LUNAR_ETO_CHN = 17,
            LUNAR_ETO_KOR = 18,
            LUNAR_ETO_ROKUYOU = 19,
            KOREANLUNISOLAR = 20,
            TAIWANLUNISOLAR = 21,
            PERSIAN = 22,
            UMALQURA = 23,
            LAST_CALENDAR = 23,
        }

        class DateTimeFormatInfoScanner
        {
            static char MonthPostfixChar = 57344;
            static char IgnorableSymbolChar = 57345;
            static string CJKYearSuff = "";
            static string CJKMonthSuff = "";
            static string CJKDaySuff = "";
            static string KoreanYearSuff = "";
            static string KoreanMonthSuff = "";
            static string KoreanDaySuff = "";
            static string KoreanHourSuff = "";
            static string KoreanMinuteSuff = "";
            static string KoreanSecondSuff = "";
            static string CJKHourSuff = "";
            static string ChineseHourSuff = "";
            static string CJKMinuteSuff = "";
            static string CJKSecondSuff = "";
            static /*0x0*/ System.Collections.Generic.Dictionary<string, string> s_knownWords;
            /*0x10*/ System.Collections.Generic.List<string> m_dateWords;
            /*0x18*/ System.Globalization.DateTimeFormatInfoScanner.FoundDatePattern _ymdFlags;

            static /*0x21749c4*/ System.Collections.Generic.Dictionary<string, string> get_KnownWords();
            static /*0x2174dc4*/ int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
            static /*0x2175494*/ int ScanRepeatChar(string pattern, char ch, int index, ref int count);
            static /*0x2171bd4*/ System.Globalization.FORMATFLAGS GetFormatFlagGenitiveMonth(string[] monthNames, string[] genitveMonthNames, string[] abbrevMonthNames, string[] genetiveAbbrevMonthNames);
            static /*0x2171c14*/ System.Globalization.FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(string[] monthNames, string[] genitveMonthNames, string[] abbrevMonthNames, string[] genetiveAbbrevMonthNames);
            static /*0x2171cb8*/ System.Globalization.FORMATFLAGS GetFormatFlagUseSpaceInDayNames(string[] dayNames, string[] abbrevDayNames);
            static /*0x2171ce8*/ System.Globalization.FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
            static /*0x2175754*/ bool EqualStringArrays(string[] array1, string[] array2);
            static /*0x2175a58*/ bool ArrayElementsHaveSpace(string[] array);
            static /*0x21757fc*/ bool ArrayElementsBeginWithDigit(string[] array);
            /*0x217372c*/ DateTimeFormatInfoScanner();
            /*0x2174ec0*/ void AddDateWordOrPostfix(string formatPostfix, string str);
            /*0x21752bc*/ int AddDateWords(string pattern, int index, string formatPostfix);
            /*0x2175170*/ void AddIgnorableSymbols(string text);
            /*0x2175518*/ void ScanDateWord(string pattern);
            /*0x21737a8*/ string[] GetDateWordsOfDTFI(System.Globalization.DateTimeFormatInfo dtfi);

            enum FoundDatePattern
            {
                None = 0,
                FoundYearPatternFlag = 1,
                FoundMonthPatternFlag = 2,
                FoundDayPatternFlag = 4,
                FoundYMDPatternFlag = 7,
            }
        }

        enum DateTimeStyles
        {
            None = 0,
            AllowLeadingWhite = 1,
            AllowTrailingWhite = 2,
            AllowInnerWhite = 4,
            AllowWhiteSpaces = 7,
            NoCurrentDateDefault = 8,
            AdjustToUniversal = 16,
            AssumeLocal = 32,
            AssumeUniversal = 64,
            RoundtripKind = 128,
        }

        class DaylightTime
        {
            /*0x10*/ System.DateTime _start;
            /*0x18*/ System.DateTime _end;
            /*0x20*/ System.TimeSpan _delta;

            /*0x2175b4c*/ DaylightTime(System.DateTime start, System.DateTime end, System.TimeSpan delta);
            /*0x2175b88*/ System.DateTime get_Start();
            /*0x2175b90*/ System.DateTime get_End();
            /*0x2175b98*/ System.TimeSpan get_Delta();
        }

        struct DaylightTimeStruct
        {
            /*0x10*/ System.DateTime Start;
            /*0x18*/ System.DateTime End;
            /*0x20*/ System.TimeSpan Delta;

            /*0x2175ba0*/ DaylightTimeStruct(System.DateTime start, System.DateTime end, System.TimeSpan delta);
        }

        enum DigitShapes
        {
            Context = 0,
            None = 1,
            NativeNational = 2,
        }

        class GlobalizationExtensions
        {
            static /*0x2175bac*/ System.StringComparer GetStringComparer(System.Globalization.CompareInfo compareInfo, System.Globalization.CompareOptions options);
        }

        struct HebrewNumberParsingContext
        {
            /*0x10*/ System.Globalization.HebrewNumber.HS state;
            /*0x14*/ int result;

            /*0x2173da8*/ HebrewNumberParsingContext(int result);
        }

        enum HebrewNumberParsingState
        {
            InvalidHebrewNumber = 0,
            NotHebrewDigit = 1,
            FoundEndOfHebrewNumber = 2,
            ContinueParsing = 3,
        }

        class HebrewNumber
        {
            static int minHebrewNumberCh = 1488;
            static int HebrewTokenCount = 10;
            static /*0x0*/ System.Globalization.HebrewNumber.HebrewValue[] s_hebrewValues;
            static /*0x8*/ char s_maxHebrewNumberCh;
            static /*0x10*/ System.Globalization.HebrewNumber.HS[] s_numberPasingState;

            static /*0x2175f94*/ HebrewNumber();
            static /*0x2175d3c*/ string ToString(int Number);
            static /*0x2173db4*/ System.Globalization.HebrewNumberParsingState ParseByChar(char ch, ref System.Globalization.HebrewNumberParsingContext context);
            static /*0x2173cd8*/ bool IsDigit(char ch);
            /*0x2175d34*/ HebrewNumber();

            enum HebrewToken
            {
                Invalid = -1,
                Digit400 = 0,
                Digit200_300 = 1,
                Digit100 = 2,
                Digit10 = 3,
                Digit1 = 4,
                Digit6_7 = 5,
                Digit7 = 6,
                Digit9 = 7,
                SingleQuote = 8,
                DoubleQuote = 9,
            }

            struct HebrewValue
            {
                /*0x10*/ System.Globalization.HebrewNumber.HebrewToken token;
                /*0x12*/ short value;

                /*0x2176244*/ HebrewValue(System.Globalization.HebrewNumber.HebrewToken token, short value);
            }

            enum HS
            {
                _err = -1,
                Start = 0,
                S400 = 1,
                S400_400 = 2,
                S400_X00 = 3,
                S400_X0 = 4,
                X00_DQ = 5,
                S400_X00_X0 = 6,
                X0_DQ = 7,
                X = 8,
                X0 = 9,
                X00 = 10,
                S400_DQ = 11,
                S400_400_DQ = 12,
                S400_400_100 = 13,
                S9 = 14,
                X00_S9 = 15,
                S9_DQ = 16,
                END = 100,
            }
        }

        class InternalGlobalizationHelper
        {
            static long TicksPerMillisecond = 10000;
            static long TicksPerTenthSecond = 1000000;
            static long TicksPerSecond = 10000000;
            static long MaxSeconds = 922337203685;
            static long MinSeconds = -922337203685;
            static int DaysPerYear = 365;
            static int DaysPer4Years = 1461;
            static int DaysPer100Years = 36524;
            static int DaysPer400Years = 146097;
            static int DaysTo10000 = 3652059;
            static long TicksPerMinute = 600000000;
            static long TicksPerHour = 36000000000;
            static long TicksPerDay = 864000000000;
            static long MaxTicks = 3155378975999999999;
            static long MinTicks = 0;
            static long MaxMilliSeconds = 922337203685477;
            static long MinMilliSeconds = -922337203685477;
            static int StringBuilderDefaultCapacity = 16;
            static long MaxOffset = 504000000000;
            static long MinOffset = -504000000000;

            static /*0x2176250*/ long TimeToTicks(int hour, int minute, int second);
            /*0x21762ec*/ InternalGlobalizationHelper();
        }

        enum NumberStyles
        {
            None = 0,
            AllowLeadingWhite = 1,
            AllowTrailingWhite = 2,
            AllowLeadingSign = 4,
            AllowTrailingSign = 8,
            AllowParentheses = 16,
            AllowDecimalPoint = 32,
            AllowThousands = 64,
            AllowExponent = 128,
            AllowCurrencySymbol = 256,
            AllowHexSpecifier = 512,
            Integer = 7,
            HexNumber = 515,
            Number = 111,
            Float = 167,
            Currency = 383,
            Any = 511,
        }

        class SortVersion : System.IEquatable<System.Globalization.SortVersion>
        {
            /*0x10*/ int m_NlsVersion;
            /*0x14*/ System.Guid m_SortId;

            static /*0x216b4e0*/ bool op_Equality(System.Globalization.SortVersion left, System.Globalization.SortVersion right);
            static /*0x21763cc*/ bool op_Inequality(System.Globalization.SortVersion left, System.Globalization.SortVersion right);
            /*0x217630c*/ SortVersion(int fullVersion, System.Guid sortId);
            /*0x216b500*/ SortVersion(int nlsVersion, int effectiveId, System.Guid customVersion);
            /*0x21762f4*/ int get_FullVersion();
            /*0x21762fc*/ System.Guid get_SortId();
            /*0x217634c*/ bool Equals(object obj);
            /*0x21763e4*/ bool Equals(System.Globalization.SortVersion other);
            /*0x21764a0*/ int GetHashCode();
        }

        class TimeSpanFormat
        {
            static /*0x0*/ System.Globalization.TimeSpanFormat.FormatLiterals PositiveInvariantFormatLiterals;
            static /*0x28*/ System.Globalization.TimeSpanFormat.FormatLiterals NegativeInvariantFormatLiterals;

            static /*0x21775ec*/ TimeSpanFormat();
            static /*0x21764c8*/ void AppendNonNegativeInt32(System.Text.StringBuilder sb, int n, int digits);
            static /*0x21765c0*/ string Format(System.TimeSpan value, string format, System.IFormatProvider formatProvider);
            static /*0x2176920*/ bool TryFormat(System.TimeSpan value, System.Span<char> destination, ref int charsWritten, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider);
            static /*0x2176678*/ System.Text.StringBuilder FormatToBuilder(System.TimeSpan value, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider);
            static /*0x2176a3c*/ System.Text.StringBuilder FormatStandard(System.TimeSpan value, bool isInvariant, System.ReadOnlySpan<char> format, System.Globalization.TimeSpanFormat.Pattern pattern);
            static /*0x2176eec*/ System.Text.StringBuilder FormatCustomized(System.TimeSpan value, System.ReadOnlySpan<char> format, System.Globalization.DateTimeFormatInfo dtfi, System.Text.StringBuilder result);

            enum Pattern
            {
                None = 0,
                Minimum = 1,
                Full = 2,
            }

            struct FormatLiterals
            {
                /*0x10*/ string AppCompatLiteral;
                /*0x18*/ int dd;
                /*0x1c*/ int hh;
                /*0x20*/ int mm;
                /*0x24*/ int ss;
                /*0x28*/ int ff;
                /*0x30*/ string[] _literals;

                static /*0x217779c*/ System.Globalization.TimeSpanFormat.FormatLiterals InitInvariant(bool isNegative);
                /*0x2177698*/ string get_Start();
                /*0x21776c0*/ string get_DayHourSep();
                /*0x21776ec*/ string get_HourMinuteSep();
                /*0x2177718*/ string get_MinuteSecondSep();
                /*0x2177744*/ string get_SecondFractionSep();
                /*0x2177770*/ string get_End();
                /*0x21779ac*/ void Init(System.ReadOnlySpan<char> format, bool useInvariantFieldLengths);
            }
        }

        class TimeSpanParse
        {
            static int MaxFractionDigits = 7;
            static int MaxDays = 10675199;
            static int MaxHours = 23;
            static int MaxMinutes = 59;
            static int MaxSeconds = 59;
            static int MaxFraction = 9999999;

            static /*0x2177da4*/ long Pow10(int pow);
            static /*0x2177e34*/ bool TryTimeToTicks(bool positive, System.Globalization.TimeSpanParse.TimeSpanToken days, System.Globalization.TimeSpanParse.TimeSpanToken hours, System.Globalization.TimeSpanParse.TimeSpanToken minutes, System.Globalization.TimeSpanParse.TimeSpanToken seconds, System.Globalization.TimeSpanParse.TimeSpanToken fraction, ref long result);
            static /*0x2177ff0*/ System.TimeSpan Parse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider);
            static /*0x21781cc*/ bool TryParse(System.ReadOnlySpan<char> input, System.IFormatProvider formatProvider, ref System.TimeSpan result);
            static /*0x2178214*/ System.TimeSpan ParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles);
            static /*0x21783b0*/ bool TryParseExact(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.TimeSpan result);
            static /*0x21783f0*/ System.TimeSpan ParseExactMultiple(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles);
            static /*0x21785e0*/ bool TryParseExactMultiple(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.TimeSpan result);
            static /*0x2178030*/ bool TryParseTimeSpan(System.ReadOnlySpan<char> input, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, System.IFormatProvider formatProvider, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x2178b18*/ bool ProcessTerminalState(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x217ad6c*/ bool ProcessTerminal_DHMSF(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x217a194*/ bool ProcessTerminal_HMS_F_D(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x2179330*/ bool ProcessTerminal_HM_S_D(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x2178fdc*/ bool ProcessTerminal_HM(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x2178c50*/ bool ProcessTerminal_D(ref System.Globalization.TimeSpanParse.TimeSpanRawInfo raw, System.Globalization.TimeSpanParse.TimeSpanStandardStyles style, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x217823c*/ bool TryParseExactTimeSpan(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x217e388*/ bool TryParseByFormat(System.ReadOnlySpan<char> input, System.ReadOnlySpan<char> format, System.Globalization.TimeSpanStyles styles, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x217ea8c*/ bool ParseExactDigits(ref System.Globalization.TimeSpanParse.TimeSpanTokenizer tokenizer, int minDigitLength, ref int result);
            static /*0x217eabc*/ bool ParseExactDigits(ref System.Globalization.TimeSpanParse.TimeSpanTokenizer tokenizer, int minDigitLength, int maxDigitLength, ref int zeroes, ref int result);
            static /*0x217eb80*/ bool ParseExactLiteral(ref System.Globalization.TimeSpanParse.TimeSpanTokenizer tokenizer, System.Text.StringBuilder enquotedString);
            static /*0x217e354*/ bool TryParseTimeSpanConstant(System.ReadOnlySpan<char> input, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x2178418*/ bool TryParseExactMultipleTimeSpan(System.ReadOnlySpan<char> input, string[] formats, System.IFormatProvider formatProvider, System.Globalization.TimeSpanStyles styles, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            static /*0x217eecc*/ void ValidateStyles(System.Globalization.TimeSpanStyles style, string parameterName);

            enum ParseFailureKind
            {
                None = 0,
                ArgumentNull = 1,
                Format = 2,
                FormatWithParameter = 3,
                Overflow = 4,
            }

            enum TimeSpanStandardStyles
            {
                None = 0,
                Invariant = 1,
                Localized = 2,
                RequireFull = 4,
                Any = 3,
            }

            enum TTT
            {
                None = 0,
                End = 1,
                Num = 2,
                Sep = 3,
                NumOverflow = 4,
            }

            struct TimeSpanToken
            {
                /*0x10*/ System.Globalization.TimeSpanParse.TTT _ttt;
                /*0x14*/ int _num;
                /*0x18*/ int _zeroes;
                /*0x20*/ System.ReadOnlySpan<char> _sep;

                /*0x217ef40*/ TimeSpanToken(System.Globalization.TimeSpanParse.TTT type);
                /*0x217b8f0*/ TimeSpanToken(int number);
                /*0x217ecb8*/ TimeSpanToken(int number, int leadingZeroes);
                /*0x217ef50*/ TimeSpanToken(System.Globalization.TimeSpanParse.TTT type, int number, int leadingZeroes, System.ReadOnlySpan<char> separator);
                /*0x2177f94*/ bool IsInvalidFraction();
            }

            struct TimeSpanTokenizer
            {
                /*0x10*/ System.ReadOnlySpan<char> _value;
                /*0x20*/ int _pos;

                /*0x2178768*/ TimeSpanTokenizer(System.ReadOnlySpan<char> input);
                /*0x217ea80*/ TimeSpanTokenizer(System.ReadOnlySpan<char> input, int startPosition);
                /*0x21787c8*/ System.Globalization.TimeSpanParse.TimeSpanToken GetNextToken();
                /*0x217ec6c*/ bool get_EOL();
                /*0x217eccc*/ void BackOne();
                /*0x217ec0c*/ char get_NextChar();
            }

            struct TimeSpanRawInfo
            {
                /*0x10*/ System.Globalization.TimeSpanParse.TTT _lastSeenTTT;
                /*0x14*/ int _tokenCount;
                /*0x18*/ int _sepCount;
                /*0x1c*/ int _numCount;
                /*0x20*/ System.Globalization.TimeSpanFormat.FormatLiterals _posLoc;
                /*0x48*/ System.Globalization.TimeSpanFormat.FormatLiterals _negLoc;
                /*0x70*/ bool _posLocInit;
                /*0x71*/ bool _negLocInit;
                /*0x78*/ string _fullPosPattern;
                /*0x80*/ string _fullNegPattern;
                /*0x88*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers0;
                /*0xa8*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers1;
                /*0xc8*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers2;
                /*0xe8*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers3;
                /*0x108*/ System.Globalization.TimeSpanParse.TimeSpanToken _numbers4;
                /*0x128*/ System.ReadOnlySpan<char> _literals0;
                /*0x138*/ System.ReadOnlySpan<char> _literals1;
                /*0x148*/ System.ReadOnlySpan<char> _literals2;
                /*0x158*/ System.ReadOnlySpan<char> _literals3;
                /*0x168*/ System.ReadOnlySpan<char> _literals4;
                /*0x178*/ System.ReadOnlySpan<char> _literals5;

                /*0x217ef60*/ System.Globalization.TimeSpanFormat.FormatLiterals get_PositiveInvariant();
                /*0x217efc8*/ System.Globalization.TimeSpanFormat.FormatLiterals get_NegativeInvariant();
                /*0x217b78c*/ System.Globalization.TimeSpanFormat.FormatLiterals get_PositiveLocalized();
                /*0x217b83c*/ System.Globalization.TimeSpanFormat.FormatLiterals get_NegativeLocalized();
                /*0x217c604*/ bool FullAppCompatMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x217d714*/ bool PartialAppCompatMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x217afd8*/ bool FullMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x217e070*/ bool FullDMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x217dc58*/ bool FullHMMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x217d1c8*/ bool FullDHMMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x217cc7c*/ bool FullHMSMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x217bf84*/ bool FullDHMSMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x217b904*/ bool FullHMSFMatch(System.Globalization.TimeSpanFormat.FormatLiterals pattern);
                /*0x2178774*/ void Init(System.Globalization.DateTimeFormatInfo dtfi);
                /*0x2178a08*/ bool ProcessToken(ref System.Globalization.TimeSpanParse.TimeSpanToken tok, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x217f034*/ bool AddSep(System.ReadOnlySpan<char> sep, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x217f140*/ bool AddNum(System.Globalization.TimeSpanParse.TimeSpanToken num, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
            }

            struct TimeSpanResult
            {
                /*0x10*/ System.TimeSpan parsedTimeSpan;
                /*0x18*/ bool _throwOnFailure;

                /*0x2178020*/ TimeSpanResult(bool throwOnFailure);
                /*0x2178620*/ bool SetFailure(System.Globalization.TimeSpanParse.ParseFailureKind kind, string resourceKey, object messageArgument, string argumentName);
            }

            struct StringParser
            {
                /*0x10*/ System.ReadOnlySpan<char> _str;
                /*0x20*/ char _ch;
                /*0x24*/ int _pos;
                /*0x28*/ int _len;

                /*0x217f250*/ void NextChar();
                /*0x217f29c*/ char NextNonDigit();
                /*0x217ece0*/ bool TryParse(System.ReadOnlySpan<char> input, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x217f4e8*/ bool ParseInt(int max, ref int i, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x217f328*/ bool ParseTime(ref long time, ref System.Globalization.TimeSpanParse.TimeSpanResult result);
                /*0x217f2f8*/ void SkipBlanks();
            }
        }

        enum TimeSpanStyles
        {
            None = 0,
            AssumeNegative = 1,
        }

        enum UnicodeCategory
        {
            UppercaseLetter = 0,
            LowercaseLetter = 1,
            TitlecaseLetter = 2,
            ModifierLetter = 3,
            OtherLetter = 4,
            NonSpacingMark = 5,
            SpacingCombiningMark = 6,
            EnclosingMark = 7,
            DecimalDigitNumber = 8,
            LetterNumber = 9,
            OtherNumber = 10,
            SpaceSeparator = 11,
            LineSeparator = 12,
            ParagraphSeparator = 13,
            Control = 14,
            Format = 15,
            Surrogate = 16,
            PrivateUse = 17,
            ConnectorPunctuation = 18,
            DashPunctuation = 19,
            OpenPunctuation = 20,
            ClosePunctuation = 21,
            InitialQuotePunctuation = 22,
            FinalQuotePunctuation = 23,
            OtherPunctuation = 24,
            MathSymbol = 25,
            CurrencySymbol = 26,
            ModifierSymbol = 27,
            OtherSymbol = 28,
            OtherNotAssigned = 29,
        }

        class ISOWeek
        {
            static int WeeksInLongYear = 53;
            static int WeeksInShortYear = 52;
            static int MinWeek = 1;
            static int MaxWeek = 53;

            static /*0x217f600*/ int GetWeekOfYear(System.DateTime date);
            static /*0x217f7f0*/ int GetYear(System.DateTime date);
            static /*0x217f848*/ System.DateTime GetYearStart(int year);
            static /*0x217fa00*/ System.DateTime GetYearEnd(int year);
            static /*0x217f6b0*/ int GetWeeksInYear(int year);
            static /*0x217f854*/ System.DateTime ToDateTime(int year, int week, System.DayOfWeek dayOfWeek);
            static /*0x217f64c*/ int GetWeekNumber(System.DateTime date);
            static /*0x217fa90*/ int GetWeekday(System.DayOfWeek dayOfWeek);
            static /*0x217fa20*/ int <GetWeeksInYear>g__P|8_0(int y);
        }

        class GlobalizationMode
        {
            static string c_InvariantModeConfigSwitch = "System.Globalization.Invariant";
            static /*0x0*/ bool <Invariant>k__BackingField;

            static /*0x217fb00*/ GlobalizationMode();
            static /*0x217faa0*/ bool get_Invariant();
            static /*0x217faf8*/ bool GetGlobalizationInvariantMode();
        }

        class CalendricalCalculationsHelper
        {
            static double FullCircleOfArc = 360;
            static int HalfCircleOfArc = 180;
            static double TwelveHours = 0.5;
            static double Noon2000Jan01 = 730120.5;
            static double MeanTropicalYearInDays = 365.242189;
            static double MeanSpeedOfSun = 1.0145616361111112;
            static double LongitudeSpring = 0;
            static double TwoDegreesAfterSpring = 2;
            static int SecondsPerDay = 86400;
            static int DaysInUniformLengthCentury = 36525;
            static int SecondsPerMinute = 60;
            static int MinutesPerDegree = 60;
            static /*0x0*/ long StartOf1810;
            static /*0x8*/ long StartOf1900Century;
            static /*0x10*/ double[] Coefficients1900to1987;
            static /*0x18*/ double[] Coefficients1800to1899;
            static /*0x20*/ double[] Coefficients1700to1799;
            static /*0x28*/ double[] Coefficients1620to1699;
            static /*0x30*/ double[] LambdaCoefficients;
            static /*0x38*/ double[] AnomalyCoefficients;
            static /*0x40*/ double[] EccentricityCoefficients;
            static /*0x48*/ double[] Coefficients;
            static /*0x50*/ double[] CoefficientsA;
            static /*0x58*/ double[] CoefficientsB;
            static /*0x60*/ System.Globalization.CalendricalCalculationsHelper.EphemerisCorrectionAlgorithmMap[] EphemerisCorrectionTable;

            static /*0x2181758*/ CalendricalCalculationsHelper();
            static /*0x217fb48*/ double RadiansFromDegrees(double degree);
            static /*0x217fb64*/ double SinOfDegree(double degree);
            static /*0x217fbfc*/ double CosOfDegree(double degree);
            static /*0x217fc94*/ double TanOfDegree(double degree);
            static /*0x217fd2c*/ double Angle(int degrees, int minutes, double seconds);
            static /*0x217fd50*/ double Obliquity(double julianCenturies);
            static /*0x217fe10*/ long GetNumberOfDays(System.DateTime date);
            static /*0x217fe4c*/ int GetGregorianYear(double numberOfDays);
            static /*0x217ff44*/ double Reminder(double divisor, double dividend);
            static /*0x217ffb0*/ double NormalizeLongitude(double longitude);
            static /*0x2180028*/ double AsDayFraction(double longitude);
            static /*0x217fdb8*/ double PolynomialSum(double[] coefficients, double indeterminate);
            static /*0x2180038*/ double CenturiesFrom1900(int gregorianYear);
            static /*0x2180100*/ double DefaultEphemerisCorrection(int gregorianYear);
            static /*0x2180220*/ double EphemerisCorrection1988to2019(int gregorianYear);
            static /*0x2180238*/ double EphemerisCorrection1900to1987(int gregorianYear);
            static /*0x218029c*/ double EphemerisCorrection1800to1899(int gregorianYear);
            static /*0x2180300*/ double EphemerisCorrection1700to1799(int gregorianYear);
            static /*0x2180380*/ double EphemerisCorrection1620to1699(int gregorianYear);
            static /*0x2180400*/ double EphemerisCorrection(double time);
            static /*0x21805a0*/ double JulianCenturies(double moment);
            static /*0x218061c*/ bool IsNegative(double value);
            static /*0x2180688*/ double CopySign(double value, double sign);
            static /*0x2180708*/ double EquationOfTime(double time);
            static /*0x21808f0*/ double AsLocalTime(double apparentMidday, double longitude);
            static /*0x2180964*/ double Midday(double date, double longitude);
            static /*0x21809e0*/ double InitLongitude(double longitude);
            static /*0x2180a54*/ double MiddayAtPersianObservationSite(double date);
            static /*0x2180ac0*/ double PeriodicTerm(double julianCenturies, int x, double y, double z);
            static /*0x2180b40*/ double SumLongSequenceOfPeriodicTerms(double julianCenturies);
            static /*0x2181348*/ double Aberration(double julianCenturies);
            static /*0x21813d4*/ double Nutation(double julianCenturies);
            static /*0x218148c*/ double Compute(double time);
            static /*0x2181544*/ double AsSeason(double longitude);
            static /*0x218155c*/ double EstimatePrior(double longitude, double time);
            static /*0x218163c*/ long PersianNewYearOnOrBefore(long numberOfDays);
            /*0x2181750*/ CalendricalCalculationsHelper();

            enum CorrectionAlgorithm
            {
                Default = 0,
                Year1988to2019 = 1,
                Year1900to1987 = 2,
                Year1800to1899 = 3,
                Year1700to1799 = 4,
                Year1620to1699 = 5,
            }

            struct EphemerisCorrectionAlgorithmMap
            {
                /*0x10*/ int _lowestYear;
                /*0x14*/ System.Globalization.CalendricalCalculationsHelper.CorrectionAlgorithm _algorithm;

                /*0x2181bdc*/ EphemerisCorrectionAlgorithmMap(int year, System.Globalization.CalendricalCalculationsHelper.CorrectionAlgorithm algorithm);
            }
        }

        class PersianCalendar : System.Globalization.Calendar
        {
            static int ApproximateHalfYear = 180;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int MonthsPerYear = 12;
            static int MaxCalendarYear = 9378;
            static int MaxCalendarMonth = 10;
            static int MaxCalendarDay = 13;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 1410;
            static /*0x0*/ int PersianEra;
            static /*0x8*/ long PersianEpoch;
            static /*0x10*/ int[] DaysToMonth;
            static /*0x18*/ System.DateTime minDate;
            static /*0x20*/ System.DateTime maxDate;

            static /*0x2183ac0*/ PersianCalendar();
            static /*0x2181eb4*/ void CheckTicksRange(long ticks);
            static /*0x2182064*/ void CheckEraRange(int era);
            static /*0x2182134*/ void CheckYearRange(int year, int era);
            static /*0x218228c*/ void CheckYearMonthRange(int year, int month, int era);
            static /*0x2182414*/ int MonthFromOrdinalDay(int ordinalDay);
            static /*0x2181e34*/ int DaysInPreviousMonths(int month);
            /*0x2181c9c*/ PersianCalendar();
            /*0x2181be4*/ System.DateTime get_MinSupportedDateTime();
            /*0x2181c3c*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2181c94*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x2181cc4*/ int get_BaseCalendarID();
            /*0x2181ccc*/ int get_ID();
            /*0x2181cd4*/ long GetAbsoluteDatePersian(int year, int month, int day);
            /*0x21824a8*/ int GetDatePart(long ticks, int part);
            /*0x2182710*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x2182ae8*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x2182b00*/ int GetDayOfMonth(System.DateTime time);
            /*0x2182b38*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x2182ba0*/ int GetDayOfYear(System.DateTime time);
            /*0x2182bd8*/ int GetDaysInMonth(int year, int month, int era);
            /*0x2182cf4*/ int GetDaysInYear(int year, int era);
            /*0x2182dd4*/ int GetEra(System.DateTime time);
            /*0x2182e4c*/ int[] get_Eras();
            /*0x2182ee8*/ int GetMonth(System.DateTime time);
            /*0x2182f20*/ int GetMonthsInYear(int year, int era);
            /*0x2182f9c*/ int GetYear(System.DateTime time);
            /*0x2182fd4*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x2183148*/ int GetLeapMonth(int year, int era);
            /*0x21831b4*/ bool IsLeapMonth(int year, int month, int era);
            /*0x2183228*/ bool IsLeapYear(int year, int era);
            /*0x21832d4*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x2183664*/ int get_TwoDigitYearMax();
            /*0x21836fc*/ void set_TwoDigitYearMax(int value);
            /*0x2183888*/ int ToFourDigitYear(int year);
        }

        class Calendar : System.ICloneable
        {
            static long TicksPerMillisecond = 10000;
            static long TicksPerSecond = 10000000;
            static long TicksPerMinute = 600000000;
            static long TicksPerHour = 36000000000;
            static long TicksPerDay = 864000000000;
            static int MillisPerSecond = 1000;
            static int MillisPerMinute = 60000;
            static int MillisPerHour = 3600000;
            static int MillisPerDay = 86400000;
            static int DaysPerYear = 365;
            static int DaysPer4Years = 1461;
            static int DaysPer100Years = 36524;
            static int DaysPer400Years = 146097;
            static int DaysTo10000 = 3652059;
            static long MaxMillis = 315537897600000;
            static int CAL_GREGORIAN = 1;
            static int CAL_GREGORIAN_US = 2;
            static int CAL_JAPAN = 3;
            static int CAL_TAIWAN = 4;
            static int CAL_KOREA = 5;
            static int CAL_HIJRI = 6;
            static int CAL_THAI = 7;
            static int CAL_HEBREW = 8;
            static int CAL_GREGORIAN_ME_FRENCH = 9;
            static int CAL_GREGORIAN_ARABIC = 10;
            static int CAL_GREGORIAN_XLIT_ENGLISH = 11;
            static int CAL_GREGORIAN_XLIT_FRENCH = 12;
            static int CAL_JULIAN = 13;
            static int CAL_JAPANESELUNISOLAR = 14;
            static int CAL_CHINESELUNISOLAR = 15;
            static int CAL_SAKA = 16;
            static int CAL_LUNAR_ETO_CHN = 17;
            static int CAL_LUNAR_ETO_KOR = 18;
            static int CAL_LUNAR_ETO_ROKUYOU = 19;
            static int CAL_KOREANLUNISOLAR = 20;
            static int CAL_TAIWANLUNISOLAR = 21;
            static int CAL_PERSIAN = 22;
            static int CAL_UMALQURA = 23;
            static int CurrentEra = 0;
            /*0x10*/ int m_currentEraValue;
            /*0x14*/ bool m_isReadOnly;
            /*0x18*/ int twoDigitYearMax;

            static /*0x2183d8c*/ System.Globalization.Calendar ReadOnly(System.Globalization.Calendar calendar);
            static /*0x21829c8*/ void CheckAddResult(long ticks, System.DateTime minValue, System.DateTime maxValue);
            static /*0x21834a8*/ long TimeToTicks(int hour, int minute, int second, int millisecond);
            static /*0x21836a8*/ int GetSystemTwoDigitYearSetting(int CalID, int defaultYearValue);
            /*0x2181cb0*/ Calendar();
            /*0x2183c30*/ System.DateTime get_MinSupportedDateTime();
            /*0x2183c88*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2183ce0*/ int get_ID();
            /*0x2183ce8*/ int get_BaseCalendarID();
            /*0x2183cf4*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x2183cfc*/ bool get_IsReadOnly();
            /*0x2183d04*/ object Clone();
            /*0x2183814*/ void VerifyWritable();
            /*0x2183e7c*/ void SetReadOnlyState(bool readOnly);
            /*0x2183e88*/ int get_CurrentEraValue();
            /*0x2183fbc*/ System.DateTime Add(System.DateTime time, double value, int scale);
            /*0x2184104*/ System.DateTime AddMilliseconds(System.DateTime time, double milliseconds);
            /*0x218410c*/ System.DateTime AddDays(System.DateTime time, int days);
            /*0x218411c*/ System.DateTime AddHours(System.DateTime time, int hours);
            /*0x218412c*/ System.DateTime AddMinutes(System.DateTime time, int minutes);
            System.DateTime AddMonths(System.DateTime time, int months);
            /*0x2184138*/ System.DateTime AddSeconds(System.DateTime time, int seconds);
            /*0x2184144*/ System.DateTime AddWeeks(System.DateTime time, int weeks);
            System.DateTime AddYears(System.DateTime time, int years);
            int GetDayOfMonth(System.DateTime time);
            System.DayOfWeek GetDayOfWeek(System.DateTime time);
            int GetDayOfYear(System.DateTime time);
            /*0x218415c*/ int GetDaysInMonth(int year, int month);
            int GetDaysInMonth(int year, int month, int era);
            /*0x2184170*/ int GetDaysInYear(int year);
            int GetDaysInYear(int year, int era);
            int GetEra(System.DateTime time);
            int[] get_Eras();
            /*0x2184184*/ int GetHour(System.DateTime time);
            /*0x21841e0*/ double GetMilliseconds(System.DateTime time);
            /*0x2184240*/ int GetMinute(System.DateTime time);
            int GetMonth(System.DateTime time);
            /*0x218429c*/ int GetMonthsInYear(int year);
            int GetMonthsInYear(int year, int era);
            /*0x21842b0*/ int GetSecond(System.DateTime time);
            /*0x2184310*/ int GetFirstDayWeekOfYear(System.DateTime time, int firstDayOfWeek);
            /*0x21843cc*/ int GetWeekOfYearFullDays(System.DateTime time, int firstDayOfWeek, int fullDays);
            /*0x2184584*/ int GetWeekOfYearOfMinSupportedDateTime(int firstDayOfWeek, int minimumDaysInFirstWeek);
            /*0x21846e8*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x21846f0*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            int GetYear(System.DateTime time);
            /*0x21849dc*/ bool IsLeapDay(int year, int month, int day);
            bool IsLeapDay(int year, int month, int day, int era);
            /*0x21849f0*/ bool IsLeapMonth(int year, int month);
            bool IsLeapMonth(int year, int month, int era);
            /*0x2184a04*/ int GetLeapMonth(int year);
            /*0x2184a18*/ int GetLeapMonth(int year, int era);
            /*0x2184ab8*/ bool IsLeapYear(int year);
            bool IsLeapYear(int year, int era);
            /*0x2184acc*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
            System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x2184af4*/ bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, ref System.DateTime result);
            /*0x2184c54*/ bool IsValidYear(int year, int era);
            /*0x2184cd8*/ bool IsValidMonth(int year, int month, int era);
            /*0x2184d50*/ bool IsValidDay(int year, int month, int day, int era);
            /*0x2184dd0*/ int get_TwoDigitYearMax();
            /*0x2184dd8*/ void set_TwoDigitYearMax(int value);
            /*0x21839c4*/ int ToFourDigitYear(int year);
        }

        class CalendarData
        {
            static int MAX_CALENDARS = 23;
            static /*0x0*/ System.Globalization.CalendarData Invariant;
            static /*0x8*/ string[] HEBREW_MONTH_NAMES;
            static /*0x10*/ string[] HEBREW_LEAP_MONTH_NAMES;
            /*0x10*/ string sNativeName;
            /*0x18*/ string[] saShortDates;
            /*0x20*/ string[] saYearMonths;
            /*0x28*/ string[] saLongDates;
            /*0x30*/ string sMonthDay;
            /*0x38*/ string[] saEraNames;
            /*0x40*/ string[] saAbbrevEraNames;
            /*0x48*/ string[] saAbbrevEnglishEraNames;
            /*0x50*/ string[] saDayNames;
            /*0x58*/ string[] saAbbrevDayNames;
            /*0x60*/ string[] saSuperShortDayNames;
            /*0x68*/ string[] saMonthNames;
            /*0x70*/ string[] saAbbrevMonthNames;
            /*0x78*/ string[] saMonthGenitiveNames;
            /*0x80*/ string[] saAbbrevMonthGenitiveNames;
            /*0x88*/ string[] saLeapYearMonthNames;
            /*0x90*/ int iTwoDigitYearMax;
            /*0x94*/ int iCurrentEra;
            /*0x98*/ bool bUseUserOverrides;

            static /*0x2184e14*/ CalendarData();
            static /*0x2187108*/ string[] GetJapaneseEraNames();
            static /*0x2187018*/ string[] GetJapaneseEnglishEraNames();
            static /*0x2183f14*/ System.Globalization.CalendarData GetCalendarData(int calendarId);
            static /*0x21871f8*/ string CalendarIdToCultureName(int calendarId);
            static /*0x2184dfc*/ int nativeGetTwoDigitYearMax(int calID);
            static /*0x21868a4*/ bool nativeGetCalendarData(System.Globalization.CalendarData data, string localeName, int calendarId);
            /*0x2184e04*/ CalendarData();
            /*0x2186340*/ CalendarData(string localeName, int calendarId, bool bUseUserOverrides);
            /*0x2186960*/ void InitializeEraNames(string localeName, int calendarId);
            /*0x2186d1c*/ void InitializeAbbreviatedEraNames(string localeName, int calendarId);
            /*0x21872c4*/ bool fill_calendar_data(string localeName, int datetimeIndex);
        }

        class ChineseLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            static int ChineseEra = 1;
            static int MIN_LUNISOLAR_YEAR = 1901;
            static int MAX_LUNISOLAR_YEAR = 2100;
            static int MIN_GREGORIAN_YEAR = 1901;
            static int MIN_GREGORIAN_MONTH = 2;
            static int MIN_GREGORIAN_DAY = 19;
            static int MAX_GREGORIAN_YEAR = 2101;
            static int MAX_GREGORIAN_MONTH = 1;
            static int MAX_GREGORIAN_DAY = 28;
            static /*0x0*/ System.DateTime minDate;
            static /*0x8*/ System.DateTime maxDate;
            static /*0x10*/ int[,] yinfo;

            static /*0x21879c0*/ ChineseLunisolarCalendar();
            /*0x2187728*/ ChineseLunisolarCalendar();
            /*0x21872c8*/ System.DateTime get_MinSupportedDateTime();
            /*0x2187320*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2187378*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x2187380*/ int get_MinCalendarYear();
            /*0x2187388*/ int get_MaxCalendarYear();
            /*0x2187390*/ System.DateTime get_MinDate();
            /*0x21873e8*/ System.DateTime get_MaxDate();
            /*0x2187440*/ System.Globalization.EraInfo[] get_CalEraInfo();
            /*0x2187448*/ int GetYearInfo(int LunarYear, int Index);
            /*0x21875d4*/ int GetYear(int year, System.DateTime time);
            /*0x21875dc*/ int GetGregorianYear(int year, int era);
            /*0x21877a0*/ int GetEra(System.DateTime time);
            /*0x218794c*/ int get_ID();
            /*0x2187954*/ int get_BaseCalendarID();
            /*0x218795c*/ int[] get_Eras();
        }

        class EastAsianLunisolarCalendar : System.Globalization.Calendar
        {
            static int LeapMonth = 0;
            static int Jan1Month = 1;
            static int Jan1Date = 2;
            static int nDaysPerMonth = 3;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int MaxCalendarMonth = 13;
            static int MaxCalendarDay = 30;
            static int DEFAULT_GREGORIAN_TWO_DIGIT_YEAR_MAX = 2029;
            static /*0x0*/ int[] DaysToMonth365;
            static /*0x8*/ int[] DaysToMonth366;

            static /*0x2189da4*/ EastAsianLunisolarCalendar();
            static /*0x218865c*/ int GregorianIsLeapYear(int y);
            /*0x218778c*/ EastAsianLunisolarCalendar();
            /*0x2187b04*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x2187b0c*/ int GetSexagenaryYear(System.DateTime time);
            /*0x2187c80*/ int GetCelestialStem(int sexagenaryYear);
            /*0x2187dc8*/ int GetTerrestrialBranch(int sexagenaryYear);
            int GetYearInfo(int LunarYear, int Index);
            int GetYear(int year, System.DateTime time);
            int GetGregorianYear(int year, int era);
            int get_MinCalendarYear();
            int get_MaxCalendarYear();
            System.Globalization.EraInfo[] get_CalEraInfo();
            System.DateTime get_MinDate();
            System.DateTime get_MaxDate();
            /*0x2187f10*/ int MinEraCalendarYear(int era);
            /*0x21880b0*/ int MaxEraCalendarYear(int era);
            /*0x21877d8*/ void CheckTicksRange(long ticks);
            /*0x2188250*/ void CheckEraRange(int era);
            /*0x2188358*/ int CheckYearRange(int year, int era);
            /*0x2188508*/ int CheckYearMonthRange(int year, int month, int era);
            /*0x21885d0*/ int InternalGetDaysInMonth(int year, int month);
            /*0x2188608*/ int GetDaysInMonth(int year, int month, int era);
            /*0x21886b4*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x2188b88*/ void GregorianToLunar(int nSYear, int nSMonth, int nSDate, ref int nLYear, ref int nLMonth, ref int nLDate);
            /*0x21888f8*/ bool LunarToGregorian(int nLYear, int nLMonth, int nLDate, ref int nSolarYear, ref int nSolarMonth, ref int nSolarDay);
            /*0x2188e90*/ System.DateTime LunarToTime(System.DateTime time, int year, int month, int day);
            /*0x2187b90*/ void TimeToLunar(System.DateTime time, ref int year, ref int month, ref int day);
            /*0x2189088*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x21893c0*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x2189540*/ int GetDayOfYear(System.DateTime time);
            /*0x2189610*/ int GetDayOfMonth(System.DateTime time);
            /*0x2189668*/ int GetDaysInYear(int year, int era);
            /*0x2189708*/ int GetMonth(System.DateTime time);
            /*0x2189760*/ int GetYear(System.DateTime time);
            /*0x21897d0*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x218985c*/ int GetMonthsInYear(int year, int era);
            /*0x2189898*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x2189a54*/ bool IsLeapMonth(int year, int month, int era);
            /*0x2189aa8*/ int GetLeapMonth(int year, int era);
            /*0x2189398*/ bool InternalIsLeapYear(int year);
            /*0x2189ae0*/ bool IsLeapYear(int year, int era);
            /*0x2189b18*/ int get_TwoDigitYearMax();
            /*0x2189b94*/ void set_TwoDigitYearMax(int value);
            /*0x2189d04*/ int ToFourDigitYear(int year);
        }

        class GlobalizationAssembly
        {
            static /*0x2189e74*/ byte* GetGlobalizationResourceBytePtr(System.Reflection.Assembly assembly, string tableName);
            /*0x2189f50*/ GlobalizationAssembly();
        }

        class GregorianCalendar : System.Globalization.Calendar
        {
            static int ADEra = 1;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int MaxYear = 9999;
            static int MinYear = 1;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 2029;
            static /*0x0*/ int[] DaysToMonth365;
            static /*0x8*/ int[] DaysToMonth366;
            static /*0x10*/ System.Globalization.Calendar s_defaultInstance;
            /*0x1c*/ System.Globalization.GregorianCalendarTypes m_type;

            static /*0x218bfe0*/ GregorianCalendar();
            static /*0x2188fb8*/ System.Globalization.Calendar GetDefaultInstance();
            static /*0x218a51c*/ long GetAbsoluteDate(int year, int month, int day);
            /*0x218a0ec*/ GregorianCalendar();
            /*0x218a118*/ GregorianCalendar(System.Globalization.GregorianCalendarTypes type);
            /*0x2189f58*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x218a034*/ System.DateTime get_MinSupportedDateTime();
            /*0x218a08c*/ System.DateTime get_MaxSupportedDateTime();
            /*0x218a0e4*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x218a26c*/ System.Globalization.GregorianCalendarTypes get_CalendarType();
            /*0x218a274*/ void set_CalendarType(System.Globalization.GregorianCalendarTypes value);
            /*0x218a318*/ int get_ID();
            /*0x218a320*/ int GetDatePart(long ticks, int part);
            /*0x218a704*/ long DateToTicks(int year, int month, int day);
            /*0x218a784*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x218ab30*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x218ab48*/ int GetDayOfMonth(System.DateTime time);
            /*0x218ab8c*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x218abf4*/ int GetDayOfYear(System.DateTime time);
            /*0x218ac38*/ int GetDaysInMonth(int year, int month, int era);
            /*0x218aee8*/ int GetDaysInYear(int year, int era);
            /*0x218b07c*/ int GetEra(System.DateTime time);
            /*0x218b084*/ int[] get_Eras();
            /*0x218b0e8*/ int GetMonth(System.DateTime time);
            /*0x218b12c*/ int GetMonthsInYear(int year, int era);
            /*0x218b27c*/ int GetYear(System.DateTime time);
            /*0x218b2c0*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x218b698*/ int GetLeapMonth(int year, int era);
            /*0x218b7f0*/ bool IsLeapMonth(int year, int month, int era);
            /*0x218ba34*/ bool IsLeapYear(int year, int era);
            /*0x218bbd0*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x218bc70*/ bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, ref System.DateTime result);
            /*0x218bd64*/ int get_TwoDigitYearMax();
            /*0x218bda8*/ void set_TwoDigitYearMax(int value);
            /*0x218bec0*/ int ToFourDigitYear(int year);
        }

        class EraInfo
        {
            /*0x10*/ int era;
            /*0x18*/ long ticks;
            /*0x20*/ int yearOffset;
            /*0x24*/ int minEraYear;
            /*0x28*/ int maxEraYear;
            /*0x30*/ string eraName;
            /*0x38*/ string abbrevEraName;
            /*0x40*/ string englishEraName;

            /*0x218c0b0*/ EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
            /*0x218c14c*/ EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);
        }

        class GregorianCalendarHelper
        {
            static long TicksPerMillisecond = 10000;
            static long TicksPerSecond = 10000000;
            static long TicksPerMinute = 600000000;
            static long TicksPerHour = 36000000000;
            static long TicksPerDay = 864000000000;
            static int MillisPerSecond = 1000;
            static int MillisPerMinute = 60000;
            static int MillisPerHour = 3600000;
            static int MillisPerDay = 86400000;
            static int DaysPerYear = 365;
            static int DaysPer4Years = 1461;
            static int DaysPer100Years = 36524;
            static int DaysPer400Years = 146097;
            static int DaysTo10000 = 3652059;
            static long MaxMillis = 315537897600000;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static /*0x0*/ int[] DaysToMonth365;
            static /*0x8*/ int[] DaysToMonth366;
            /*0x10*/ int m_maxYear;
            /*0x14*/ int m_minYear;
            /*0x18*/ System.Globalization.Calendar m_Cal;
            /*0x20*/ System.Globalization.EraInfo[] m_EraInfo;
            /*0x28*/ int[] m_eras;
            /*0x30*/ System.DateTime m_minDate;

            static /*0x218de90*/ GregorianCalendarHelper();
            static /*0x218c950*/ long GetAbsoluteDate(int year, int month, int day);
            static /*0x218cb38*/ long DateToTicks(int year, int month, int day);
            static /*0x218cbb8*/ long TimeToTicks(int hour, int minute, int second, int millisecond);
            /*0x218c208*/ GregorianCalendarHelper(System.Globalization.Calendar cal, System.Globalization.EraInfo[] eraInfo);
            /*0x218c200*/ int get_MaxYear();
            /*0x218c280*/ int GetYearOffset(int year, int era, bool throwOnError);
            /*0x218c574*/ int GetGregorianYear(int year, int era);
            /*0x218c590*/ bool IsValidYear(int year, int era);
            /*0x218c5ac*/ int GetDatePart(long ticks, int part);
            /*0x218c7b8*/ void CheckTicksRange(long ticks);
            /*0x218cd74*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x218d140*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x218d14c*/ int GetDayOfMonth(System.DateTime time);
            /*0x218d18c*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x218d218*/ int GetDayOfYear(System.DateTime time);
            /*0x218d258*/ int GetDaysInMonth(int year, int month, int era);
            /*0x218d3e4*/ int GetDaysInYear(int year, int era);
            /*0x218d454*/ int GetEra(System.DateTime time);
            /*0x218d524*/ int[] get_Eras();
            /*0x218d614*/ int GetMonth(System.DateTime time);
            /*0x218d654*/ int GetMonthsInYear(int year, int era);
            /*0x218d66c*/ int GetYear(System.DateTime time);
            /*0x218d75c*/ int GetYear(int year, System.DateTime time);
            /*0x218d834*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x218da24*/ int GetLeapMonth(int year, int era);
            /*0x218da3c*/ bool IsLeapMonth(int year, int month, int era);
            /*0x218d9b4*/ bool IsLeapYear(int year, int era);
            /*0x218db58*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x218dc5c*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x218dd08*/ int ToFourDigitYear(int year, int twoDigitYearMax);
        }

        enum GregorianCalendarTypes
        {
            Localized = 1,
            USEnglish = 2,
            MiddleEastFrench = 9,
            Arabic = 10,
            TransliteratedEnglish = 11,
            TransliteratedFrench = 12,
        }

        class HebrewCalendar : System.Globalization.Calendar
        {
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int DatePartDayOfWeek = 4;
            static int HebrewYearOf1AD = 3760;
            static int FirstGregorianTableYear = 1583;
            static int LastGregorianTableYear = 2239;
            static int TABLESIZE = 656;
            static int MinHebrewYear = 5343;
            static int MaxHebrewYear = 5999;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 5790;
            static /*0x0*/ int HebrewEra;
            static /*0x8*/ int[] HebrewTable;
            static /*0x10*/ int[,] LunarMonthLen;
            static /*0x18*/ System.DateTime calendarMinValue;
            static /*0x20*/ System.DateTime calendarMaxValue;

            static /*0x2190030*/ HebrewCalendar();
            static /*0x218e028*/ void CheckHebrewYearValue(int y, int era, string varName);
            static /*0x218e178*/ void CheckEraRange(int era);
            static /*0x218e4a8*/ void CheckTicksRange(long ticks);
            static /*0x218e658*/ int GetResult(System.Globalization.HebrewCalendar.__DateBuffer result, int part);
            static /*0x218e700*/ int GetLunarMonthDay(int gregorianYear, System.Globalization.HebrewCalendar.__DateBuffer lunarDate);
            static /*0x218f2f4*/ int GetHebrewYearType(int year, int era);
            static /*0x218f9e4*/ int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2);
            static /*0x218fb38*/ System.DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond);
            /*0x218e018*/ HebrewCalendar();
            /*0x218df60*/ System.DateTime get_MinSupportedDateTime();
            /*0x218dfb8*/ System.DateTime get_MaxSupportedDateTime();
            /*0x218e010*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x218e020*/ int get_ID();
            /*0x218e248*/ void CheckHebrewMonthValue(int year, int month, int era);
            /*0x218e378*/ void CheckHebrewDayValue(int year, int month, int day, int era);
            /*0x218e868*/ int GetDatePart(long ticks, int part);
            /*0x218ecb8*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x218f00c*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x218f248*/ int GetDayOfMonth(System.DateTime time);
            /*0x218f28c*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x218f3a8*/ int GetDayOfYear(System.DateTime time);
            /*0x218f480*/ int GetDaysInMonth(int year, int month, int era);
            /*0x218f5cc*/ int GetDaysInYear(int year, int era);
            /*0x218f650*/ int GetEra(System.DateTime time);
            /*0x218f6a8*/ int[] get_Eras();
            /*0x218f744*/ int GetMonth(System.DateTime time);
            /*0x218f788*/ int GetMonthsInYear(int year, int era);
            /*0x218f7b0*/ int GetYear(System.DateTime time);
            /*0x218f7f4*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x218f8a0*/ int GetLeapMonth(int year, int era);
            /*0x218f8c8*/ bool IsLeapMonth(int year, int month, int era);
            /*0x218f92c*/ bool IsLeapYear(int year, int era);
            /*0x218fcec*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x218fe10*/ int get_TwoDigitYearMax();
            /*0x218fe4c*/ void set_TwoDigitYearMax(int value);
            /*0x218feec*/ int ToFourDigitYear(int year);

            class __DateBuffer
            {
                /*0x10*/ int year;
                /*0x14*/ int month;
                /*0x18*/ int day;

                /*0x218ecb0*/ __DateBuffer();
            }
        }

        class HijriCalendar : System.Globalization.Calendar
        {
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int MinAdvancedHijri = -2;
            static int MaxAdvancedHijri = 2;
            static string HijriAdvanceRegKeyEntry = "AddHijriDate";
            static int MaxCalendarYear = 9666;
            static int MaxCalendarMonth = 4;
            static int MaxCalendarDay = 3;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 1451;
            static /*0x0*/ int HijriEra;
            static /*0x8*/ int[] HijriMonthDays;
            static /*0x10*/ System.DateTime calendarMinValue;
            static /*0x18*/ System.DateTime calendarMaxValue;
            /*0x1c*/ int m_HijriAdvance;

            static /*0x2191c50*/ HijriCalendar();
            static /*0x219049c*/ int GetAdvanceHijriDate();
            static /*0x21905bc*/ void CheckTicksRange(long ticks);
            static /*0x219076c*/ void CheckEraRange(int era);
            static /*0x219083c*/ void CheckYearRange(int year, int era);
            static /*0x2190994*/ void CheckYearMonthRange(int year, int month, int era);
            /*0x2190290*/ HijriCalendar();
            /*0x21901d8*/ System.DateTime get_MinSupportedDateTime();
            /*0x2190230*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2190288*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x21902a0*/ int get_ID();
            /*0x21902a8*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x21902b0*/ long GetAbsoluteDateHijri(int y, int m, int d);
            /*0x2190378*/ long DaysUpToHijriYear(int HijriYear);
            /*0x2190434*/ int get_HijriAdjustment();
            /*0x21904a4*/ void set_HijriAdjustment(int value);
            /*0x2190b1c*/ int GetDatePart(long ticks, int part);
            /*0x2190d8c*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x2191070*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x2191088*/ int GetDayOfMonth(System.DateTime time);
            /*0x21910cc*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x2191134*/ int GetDayOfYear(System.DateTime time);
            /*0x2191178*/ int GetDaysInMonth(int year, int month, int era);
            /*0x2191244*/ int GetDaysInYear(int year, int era);
            /*0x21912d8*/ int GetEra(System.DateTime time);
            /*0x2191350*/ int[] get_Eras();
            /*0x21913ec*/ int GetMonth(System.DateTime time);
            /*0x2191430*/ int GetMonthsInYear(int year, int era);
            /*0x219149c*/ int GetYear(System.DateTime time);
            /*0x21914e0*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x2191654*/ int GetLeapMonth(int year, int era);
            /*0x21916c0*/ bool IsLeapMonth(int year, int month, int era);
            /*0x2191734*/ bool IsLeapYear(int year, int era);
            /*0x21917d4*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x21919b8*/ int get_TwoDigitYearMax();
            /*0x21919f4*/ void set_TwoDigitYearMax(int value);
            /*0x2191b10*/ int ToFourDigitYear(int year);
        }

        class JapaneseCalendar : System.Globalization.Calendar
        {
            static string c_japaneseErasHive = "System\CurrentControlSet\Control\Nls\Calendars\Japanese\Eras";
            static string c_japaneseErasHivePermissionList = "HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Nls\Calendars\Japanese\Eras";
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 99;
            static /*0x0*/ System.DateTime calendarMinValue;
            static /*0x8*/ System.Globalization.EraInfo[] japaneseEraInfo;
            static /*0x10*/ System.Globalization.Calendar s_defaultInstance;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x2193130*/ JapaneseCalendar();
            static /*0x2191e1c*/ System.Globalization.EraInfo[] GetEraInfo();
            static /*0x2192274*/ System.Globalization.EraInfo[] GetErasFromRegistry();
            static /*0x219227c*/ int CompareEraRanges(System.Globalization.EraInfo a, System.Globalization.EraInfo b);
            static /*0x21922a4*/ System.Globalization.EraInfo GetEraFromValue(string value, string data);
            static /*0x2192680*/ System.Globalization.Calendar GetDefaultInstance();
            static /*0x2192c5c*/ string[] EraNames();
            static /*0x2192d70*/ string[] AbbrevEraNames();
            static /*0x2192e84*/ string[] EnglishEraNames();
            /*0x2192738*/ JapaneseCalendar();
            /*0x2191d64*/ System.DateTime get_MinSupportedDateTime();
            /*0x2191dbc*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2191e14*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x2192900*/ int get_ID();
            /*0x2192908*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x2192924*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x2192940*/ int GetDaysInMonth(int year, int month, int era);
            /*0x219295c*/ int GetDaysInYear(int year, int era);
            /*0x2192978*/ int GetDayOfMonth(System.DateTime time);
            /*0x2192994*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x21929b0*/ int GetDayOfYear(System.DateTime time);
            /*0x21929cc*/ int GetMonthsInYear(int year, int era);
            /*0x21929e8*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x2192a08*/ int GetEra(System.DateTime time);
            /*0x2192a24*/ int GetMonth(System.DateTime time);
            /*0x2192a40*/ int GetYear(System.DateTime time);
            /*0x2192a5c*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x2192a78*/ bool IsLeapYear(int year, int era);
            /*0x2192a94*/ int GetLeapMonth(int year, int era);
            /*0x2192ab0*/ bool IsLeapMonth(int year, int month, int era);
            /*0x2192acc*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x2192af0*/ int ToFourDigitYear(int year);
            /*0x2192c40*/ int[] get_Eras();
            /*0x2192f98*/ bool IsValidYear(int year, int era);
            /*0x2192fb4*/ int get_TwoDigitYearMax();
            /*0x2192ff0*/ void set_TwoDigitYearMax(int value);
        }

        class JapaneseLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            static int JapaneseEra = 1;
            static int MIN_LUNISOLAR_YEAR = 1960;
            static int MAX_LUNISOLAR_YEAR = 2049;
            static int MIN_GREGORIAN_YEAR = 1960;
            static int MIN_GREGORIAN_MONTH = 1;
            static int MIN_GREGORIAN_DAY = 28;
            static int MAX_GREGORIAN_YEAR = 2050;
            static int MAX_GREGORIAN_MONTH = 1;
            static int MAX_GREGORIAN_DAY = 22;
            static /*0x0*/ System.DateTime minDate;
            static /*0x8*/ System.DateTime maxDate;
            static /*0x10*/ int[,] yinfo;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x21937a0*/ JapaneseLunisolarCalendar();
            static /*0x2193520*/ System.Globalization.EraInfo[] TrimEras(System.Globalization.EraInfo[] baseEras);
            /*0x219365c*/ JapaneseLunisolarCalendar();
            /*0x2193198*/ System.DateTime get_MinSupportedDateTime();
            /*0x21931f0*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2193248*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x2193250*/ int get_MinCalendarYear();
            /*0x2193258*/ int get_MaxCalendarYear();
            /*0x2193260*/ System.DateTime get_MinDate();
            /*0x21932b8*/ System.DateTime get_MaxDate();
            /*0x2193310*/ System.Globalization.EraInfo[] get_CalEraInfo();
            /*0x219335c*/ int GetYearInfo(int LunarYear, int Index);
            /*0x21934e8*/ int GetYear(int year, System.DateTime time);
            /*0x2193504*/ int GetGregorianYear(int year, int era);
            /*0x2193758*/ int GetEra(System.DateTime time);
            /*0x2193774*/ int get_BaseCalendarID();
            /*0x219377c*/ int get_ID();
            /*0x2193784*/ int[] get_Eras();
        }

        class JulianCalendar : System.Globalization.Calendar
        {
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int JulianDaysPerYear = 365;
            static int JulianDaysPer4Years = 1461;
            static /*0x0*/ int JulianEra;
            static /*0x8*/ int[] DaysToMonth365;
            static /*0x10*/ int[] DaysToMonth366;
            /*0x1c*/ int MaxYear;

            static /*0x2194f00*/ JulianCalendar();
            static /*0x21939cc*/ void CheckEraRange(int era);
            static /*0x2193bfc*/ void CheckMonthRange(int month);
            static /*0x2193c7c*/ void CheckDayRange(int year, int month, int day);
            static /*0x2193e78*/ int GetDatePart(long ticks, int part);
            static /*0x2193ff0*/ long DateToTicks(int year, int month, int day);
            /*0x219399c*/ JulianCalendar();
            /*0x21938e4*/ System.DateTime get_MinSupportedDateTime();
            /*0x219393c*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2193994*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x21939c4*/ int get_ID();
            /*0x2193a9c*/ void CheckYearEraRange(int year, int era);
            /*0x21940d0*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x2194458*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x2194470*/ int GetDayOfMonth(System.DateTime time);
            /*0x21944e0*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x2194548*/ int GetDayOfYear(System.DateTime time);
            /*0x21945b8*/ int GetDaysInMonth(int year, int month, int era);
            /*0x21946a0*/ int GetDaysInYear(int year, int era);
            /*0x21946c8*/ int GetEra(System.DateTime time);
            /*0x2194720*/ int GetMonth(System.DateTime time);
            /*0x2194790*/ int[] get_Eras();
            /*0x219482c*/ int GetMonthsInYear(int year, int era);
            /*0x2194840*/ int GetYear(System.DateTime time);
            /*0x21948b0*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x219498c*/ int GetLeapMonth(int year, int era);
            /*0x21949a0*/ bool IsLeapMonth(int year, int month, int era);
            /*0x2194a28*/ bool IsLeapYear(int year, int era);
            /*0x2194a44*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x2194c9c*/ int get_TwoDigitYearMax();
            /*0x2194ca4*/ void set_TwoDigitYearMax(int value);
            /*0x2194dcc*/ int ToFourDigitYear(int year);
        }

        class KoreanCalendar : System.Globalization.Calendar
        {
            static int KoreanEra = 1;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 4362;
            static /*0x0*/ System.Globalization.EraInfo[] koreanEraInfo;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x2195698*/ KoreanCalendar();
            /*0x2195098*/ KoreanCalendar();
            /*0x2194fe0*/ System.DateTime get_MinSupportedDateTime();
            /*0x2195038*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2195090*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x2195260*/ int get_ID();
            /*0x2195268*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x2195284*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x21952a0*/ int GetDaysInMonth(int year, int month, int era);
            /*0x21952bc*/ int GetDaysInYear(int year, int era);
            /*0x21952d8*/ int GetDayOfMonth(System.DateTime time);
            /*0x21952f4*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x2195310*/ int GetDayOfYear(System.DateTime time);
            /*0x219532c*/ int GetMonthsInYear(int year, int era);
            /*0x2195348*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x2195368*/ int GetEra(System.DateTime time);
            /*0x2195384*/ int GetMonth(System.DateTime time);
            /*0x21953a0*/ int GetYear(System.DateTime time);
            /*0x21953bc*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x21953d8*/ bool IsLeapYear(int year, int era);
            /*0x21953f4*/ int GetLeapMonth(int year, int era);
            /*0x2195410*/ bool IsLeapMonth(int year, int month, int era);
            /*0x219542c*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x2195450*/ int[] get_Eras();
            /*0x219546c*/ int get_TwoDigitYearMax();
            /*0x21954a8*/ void set_TwoDigitYearMax(int value);
            /*0x21955e8*/ int ToFourDigitYear(int year);
        }

        class KoreanLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            static int GregorianEra = 1;
            static int MIN_LUNISOLAR_YEAR = 918;
            static int MAX_LUNISOLAR_YEAR = 2050;
            static int MIN_GREGORIAN_YEAR = 918;
            static int MIN_GREGORIAN_MONTH = 2;
            static int MIN_GREGORIAN_DAY = 14;
            static int MAX_GREGORIAN_YEAR = 2051;
            static int MAX_GREGORIAN_MONTH = 2;
            static int MAX_GREGORIAN_DAY = 10;
            static /*0x0*/ System.DateTime minDate;
            static /*0x8*/ System.DateTime maxDate;
            static /*0x10*/ int[,] yinfo;

            static /*0x2195cf8*/ KoreanLunisolarCalendar();
            /*0x2195bf0*/ KoreanLunisolarCalendar();
            /*0x2195790*/ System.DateTime get_MinSupportedDateTime();
            /*0x21957e8*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2195840*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x2195848*/ int get_MinCalendarYear();
            /*0x2195850*/ int get_MaxCalendarYear();
            /*0x2195858*/ System.DateTime get_MinDate();
            /*0x21958b0*/ System.DateTime get_MaxDate();
            /*0x2195908*/ System.Globalization.EraInfo[] get_CalEraInfo();
            /*0x2195910*/ int GetYearInfo(int LunarYear, int Index);
            /*0x2195a9c*/ int GetYear(int year, System.DateTime time);
            /*0x2195aa4*/ int GetGregorianYear(int year, int era);
            /*0x2195c48*/ int GetEra(System.DateTime time);
            /*0x2195c84*/ int get_BaseCalendarID();
            /*0x2195c8c*/ int get_ID();
            /*0x2195c94*/ int[] get_Eras();
        }

        class NumberFormatInfo : System.ICloneable, System.IFormatProvider
        {
            static System.Globalization.NumberStyles InvalidNumberStyles = -1024;
            static /*0x0*/ System.Globalization.NumberFormatInfo invariantInfo;
            /*0x10*/ int[] numberGroupSizes;
            /*0x18*/ int[] currencyGroupSizes;
            /*0x20*/ int[] percentGroupSizes;
            /*0x28*/ string positiveSign;
            /*0x30*/ string negativeSign;
            /*0x38*/ string numberDecimalSeparator;
            /*0x40*/ string numberGroupSeparator;
            /*0x48*/ string currencyGroupSeparator;
            /*0x50*/ string currencyDecimalSeparator;
            /*0x58*/ string currencySymbol;
            /*0x60*/ string ansiCurrencySymbol;
            /*0x68*/ string nanSymbol;
            /*0x70*/ string positiveInfinitySymbol;
            /*0x78*/ string negativeInfinitySymbol;
            /*0x80*/ string percentDecimalSeparator;
            /*0x88*/ string percentGroupSeparator;
            /*0x90*/ string percentSymbol;
            /*0x98*/ string perMilleSymbol;
            /*0xa0*/ string[] nativeDigits;
            /*0xa8*/ int m_dataItem;
            /*0xac*/ int numberDecimalDigits;
            /*0xb0*/ int currencyDecimalDigits;
            /*0xb4*/ int currencyPositivePattern;
            /*0xb8*/ int currencyNegativePattern;
            /*0xbc*/ int numberNegativePattern;
            /*0xc0*/ int percentPositivePattern;
            /*0xc4*/ int percentNegativePattern;
            /*0xc8*/ int percentDecimalDigits;
            /*0xcc*/ int digitSubstitution;
            /*0xd0*/ bool isReadOnly;
            /*0xd1*/ bool m_useUserOverride;
            /*0xd2*/ bool m_isInvariant;
            /*0xd3*/ bool validForParseAsNumber;
            /*0xd4*/ bool validForParseAsCurrency;

            static /*0x2196424*/ void VerifyDecimalSeparator(string decSep, string propertyName);
            static /*0x21964fc*/ void VerifyGroupSeparator(string groupSep, string propertyName);
            static /*0x219656c*/ void VerifyNativeDigits(string[] nativeDig, string propertyName);
            static /*0x219677c*/ void VerifyDigitSubstitution(System.Globalization.DigitShapes digitSub, string propertyName);
            static /*0x21925dc*/ System.Globalization.NumberFormatInfo get_InvariantInfo();
            static /*0x2196adc*/ System.Globalization.NumberFormatInfo GetInstance(System.IFormatProvider formatProvider);
            static /*0x2196f80*/ void CheckGroupSize(string propName, int[] groupSize);
            static /*0x2196c98*/ System.Globalization.NumberFormatInfo get_CurrentInfo();
            static /*0x2196a08*/ System.Globalization.NumberFormatInfo ReadOnly(System.Globalization.NumberFormatInfo nfi);
            static /*0x2198548*/ void ValidateParseStyleInteger(System.Globalization.NumberStyles style);
            static /*0x2198620*/ void ValidateParseStyleFloatingPoint(System.Globalization.NumberStyles style);
            /*0x2195e3c*/ NumberFormatInfo();
            /*0x2195e44*/ NumberFormatInfo(System.Globalization.CultureData cultureData);
            /*0x2196398*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x219641c*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x2196420*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x2196994*/ void VerifyWritable();
            /*0x2196d8c*/ object Clone();
            /*0x2196df8*/ int get_CurrencyDecimalDigits();
            /*0x2196e00*/ void set_CurrencyDecimalDigits(int value);
            /*0x2196f0c*/ string get_CurrencyDecimalSeparator();
            /*0x2196f14*/ void set_CurrencyDecimalSeparator(string value);
            /*0x2196f78*/ bool get_IsReadOnly();
            /*0x2197044*/ int[] get_CurrencyGroupSizes();
            /*0x21970bc*/ void set_CurrencyGroupSizes(int[] value);
            /*0x21971d8*/ int[] get_NumberGroupSizes();
            /*0x2197250*/ void set_NumberGroupSizes(int[] value);
            /*0x219736c*/ int[] get_PercentGroupSizes();
            /*0x21973e4*/ void set_PercentGroupSizes(int[] value);
            /*0x2197500*/ string get_CurrencyGroupSeparator();
            /*0x2197508*/ void set_CurrencyGroupSeparator(string value);
            /*0x219756c*/ string get_CurrencySymbol();
            /*0x2197574*/ void set_CurrencySymbol(string value);
            /*0x2197604*/ string get_NaNSymbol();
            /*0x219760c*/ void set_NaNSymbol(string value);
            /*0x219769c*/ int get_CurrencyNegativePattern();
            /*0x21976a4*/ void set_CurrencyNegativePattern(int value);
            /*0x21977b0*/ int get_NumberNegativePattern();
            /*0x21977b8*/ void set_NumberNegativePattern(int value);
            /*0x21978c4*/ int get_PercentPositivePattern();
            /*0x21978cc*/ void set_PercentPositivePattern(int value);
            /*0x21979d8*/ int get_PercentNegativePattern();
            /*0x21979e0*/ void set_PercentNegativePattern(int value);
            /*0x2197aec*/ string get_NegativeInfinitySymbol();
            /*0x2197af4*/ void set_NegativeInfinitySymbol(string value);
            /*0x2197b84*/ string get_NegativeSign();
            /*0x2197b8c*/ void set_NegativeSign(string value);
            /*0x2197c1c*/ int get_NumberDecimalDigits();
            /*0x2197c24*/ void set_NumberDecimalDigits(int value);
            /*0x2197d30*/ string get_NumberDecimalSeparator();
            /*0x2197d38*/ void set_NumberDecimalSeparator(string value);
            /*0x2197d9c*/ string get_NumberGroupSeparator();
            /*0x2197da4*/ void set_NumberGroupSeparator(string value);
            /*0x2197e08*/ int get_CurrencyPositivePattern();
            /*0x2197e10*/ void set_CurrencyPositivePattern(int value);
            /*0x2197f1c*/ string get_PositiveInfinitySymbol();
            /*0x2197f24*/ void set_PositiveInfinitySymbol(string value);
            /*0x2197fb4*/ string get_PositiveSign();
            /*0x2197fbc*/ void set_PositiveSign(string value);
            /*0x219804c*/ int get_PercentDecimalDigits();
            /*0x2198054*/ void set_PercentDecimalDigits(int value);
            /*0x2198160*/ string get_PercentDecimalSeparator();
            /*0x2198168*/ void set_PercentDecimalSeparator(string value);
            /*0x21981cc*/ string get_PercentGroupSeparator();
            /*0x21981d4*/ void set_PercentGroupSeparator(string value);
            /*0x2198238*/ string get_PercentSymbol();
            /*0x2198240*/ void set_PercentSymbol(string value);
            /*0x21982d0*/ string get_PerMilleSymbol();
            /*0x21982d8*/ void set_PerMilleSymbol(string value);
            /*0x2198368*/ string[] get_NativeDigits();
            /*0x21983e0*/ void set_NativeDigits(string[] value);
            /*0x2198444*/ System.Globalization.DigitShapes get_DigitSubstitution();
            /*0x219844c*/ void set_DigitSubstitution(System.Globalization.DigitShapes value);
            /*0x21984b0*/ object GetFormat(System.Type formatType);
        }

        class StringInfo
        {
            /*0x10*/ string m_str;
            /*0x18*/ int[] m_indexes;

            static /*0x2198d90*/ string GetNextTextElement(string str);
            static /*0x2198f0c*/ int GetCurrentTextElementLen(string str, int index, int len, ref System.Globalization.UnicodeCategory ucCurrent, ref int currentCharCount);
            static /*0x2198d98*/ string GetNextTextElement(string str, int index);
            static /*0x2199020*/ System.Globalization.TextElementEnumerator GetTextElementEnumerator(string str);
            static /*0x2199028*/ System.Globalization.TextElementEnumerator GetTextElementEnumerator(string str, int index);
            static /*0x2198968*/ int[] ParseCombiningCharacters(string str);
            /*0x21986ec*/ StringInfo();
            /*0x2198744*/ StringInfo(string value);
            /*0x21987f4*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x2198844*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x2198868*/ bool Equals(object value);
            /*0x2198908*/ int GetHashCode();
            /*0x2198928*/ int[] get_Indexes();
            /*0x2198ad4*/ string get_String();
            /*0x2198770*/ void set_String(string value);
            /*0x2198adc*/ int get_LengthInTextElements();
            /*0x2198b08*/ string SubstringByTextElements(int startingTextElement);
            /*0x2198bc4*/ string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
        }

        class TaiwanCalendar : System.Globalization.Calendar
        {
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 99;
            static /*0x0*/ System.Globalization.EraInfo[] taiwanEraInfo;
            static /*0x8*/ System.Globalization.Calendar s_defaultInstance;
            static /*0x10*/ System.DateTime calendarMinValue;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x21999d4*/ TaiwanCalendar();
            static /*0x21991c4*/ System.Globalization.Calendar GetDefaultInstance();
            /*0x219927c*/ TaiwanCalendar();
            /*0x2199444*/ System.DateTime get_MinSupportedDateTime();
            /*0x219949c*/ System.DateTime get_MaxSupportedDateTime();
            /*0x21994f4*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x21994fc*/ int get_ID();
            /*0x2199504*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x2199520*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x219953c*/ int GetDaysInMonth(int year, int month, int era);
            /*0x2199558*/ int GetDaysInYear(int year, int era);
            /*0x2199574*/ int GetDayOfMonth(System.DateTime time);
            /*0x2199590*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x21995ac*/ int GetDayOfYear(System.DateTime time);
            /*0x21995c8*/ int GetMonthsInYear(int year, int era);
            /*0x21995e4*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x2199604*/ int GetEra(System.DateTime time);
            /*0x2199620*/ int GetMonth(System.DateTime time);
            /*0x219963c*/ int GetYear(System.DateTime time);
            /*0x2199658*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x2199674*/ bool IsLeapYear(int year, int era);
            /*0x2199690*/ int GetLeapMonth(int year, int era);
            /*0x21996ac*/ bool IsLeapMonth(int year, int month, int era);
            /*0x21996c8*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x21996ec*/ int[] get_Eras();
            /*0x2199708*/ int get_TwoDigitYearMax();
            /*0x2199744*/ void set_TwoDigitYearMax(int value);
            /*0x2199884*/ int ToFourDigitYear(int year);
        }

        class TaiwanLunisolarCalendar : System.Globalization.EastAsianLunisolarCalendar
        {
            static int MIN_LUNISOLAR_YEAR = 1912;
            static int MAX_LUNISOLAR_YEAR = 2050;
            static int MIN_GREGORIAN_YEAR = 1912;
            static int MIN_GREGORIAN_MONTH = 2;
            static int MIN_GREGORIAN_DAY = 18;
            static int MAX_GREGORIAN_YEAR = 2051;
            static int MAX_GREGORIAN_MONTH = 2;
            static int MAX_GREGORIAN_DAY = 10;
            static /*0x0*/ System.Globalization.EraInfo[] taiwanLunisolarEraInfo;
            static /*0x8*/ System.DateTime minDate;
            static /*0x10*/ System.DateTime maxDate;
            static /*0x18*/ int[,] yinfo;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x2199f9c*/ TaiwanLunisolarCalendar();
            /*0x2199e8c*/ TaiwanLunisolarCalendar();
            /*0x2199af8*/ System.DateTime get_MinSupportedDateTime();
            /*0x2199b50*/ System.DateTime get_MaxSupportedDateTime();
            /*0x2199ba8*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x2199bb0*/ int get_MinCalendarYear();
            /*0x2199bb8*/ int get_MaxCalendarYear();
            /*0x2199bc0*/ System.DateTime get_MinDate();
            /*0x2199c18*/ System.DateTime get_MaxDate();
            /*0x2199c70*/ System.Globalization.EraInfo[] get_CalEraInfo();
            /*0x2199cc8*/ int GetYearInfo(int LunarYear, int Index);
            /*0x2199e54*/ int GetYear(int year, System.DateTime time);
            /*0x2199e70*/ int GetGregorianYear(int year, int era);
            /*0x2199f54*/ int GetEra(System.DateTime time);
            /*0x2199f70*/ int get_BaseCalendarID();
            /*0x2199f78*/ int get_ID();
            /*0x2199f80*/ int[] get_Eras();
        }

        class TextElementEnumerator : System.Collections.IEnumerator
        {
            /*0x10*/ string str;
            /*0x18*/ int index;
            /*0x1c*/ int startIndex;
            /*0x20*/ int strLen;
            /*0x24*/ int currTextElementLen;
            /*0x28*/ System.Globalization.UnicodeCategory uc;
            /*0x2c*/ int charLen;
            /*0x30*/ int endIndex;
            /*0x34*/ int nextTextElementLen;

            /*0x2199164*/ TextElementEnumerator(string str, int startIndex, int strLen);
            /*0x219a3a4*/ TextElementEnumerator();
            /*0x219a1c8*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x219a1d4*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x219a214*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x219a224*/ bool MoveNext();
            /*0x219a274*/ object get_Current();
            /*0x219a278*/ string GetTextElement();
            /*0x219a324*/ int get_ElementIndex();
            /*0x219a194*/ void Reset();
        }

        class TextInfo : System.ICloneable, System.Runtime.Serialization.IDeserializationCallback
        {
            static int wordSeparatorMask = 536672256;
            static /*0x0*/ System.Globalization.TextInfo s_Invariant;
            /*0x10*/ string m_listSeparator;
            /*0x18*/ bool m_isReadOnly;
            /*0x20*/ string m_cultureName;
            /*0x28*/ System.Globalization.CultureData m_cultureData;
            /*0x30*/ string m_textInfoName;
            /*0x38*/ System.Nullable<bool> m_IsAsciiCasingSameAsInvariant;
            /*0x40*/ string customCultureName;
            /*0x48*/ int m_nDataItem;
            /*0x4c*/ bool m_useUserOverride;
            /*0x50*/ int m_win32LangID;

            static /*0x219a3dc*/ System.Globalization.TextInfo get_Invariant();
            static /*0x219a9c8*/ int GetHashCodeOrdinalIgnoreCase(string s);
            static /*0x219a9d4*/ int GetHashCodeOrdinalIgnoreCase(string s, bool forceRandomizedHashing, long additionalEntropy);
            static /*0x219aaf4*/ int CompareOrdinalIgnoreCaseEx(string strA, int indexA, string strB, int indexB, int lengthA, int lengthB);
            static /*0x219aca0*/ int IndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
            static /*0x219ad40*/ int LastIndexOfStringOrdinalIgnoreCase(string source, string value, int startIndex, int count);
            static /*0x219af44*/ System.Globalization.TextInfo ReadOnly(System.Globalization.TextInfo textInfo);
            static /*0x219b2e8*/ char ToLowerAsciiInvariant(char c);
            static /*0x219b8ec*/ char ToUpperAsciiInvariant(char c);
            static /*0x219b1d4*/ bool IsAscii(char c);
            static /*0x219c494*/ int AddNonLetter(ref System.Text.StringBuilder result, ref string input, int inputIndex, int charLen);
            static /*0x219c478*/ bool IsWordSeparator(System.Globalization.UnicodeCategory category);
            static /*0x219c45c*/ bool IsLetterCategory(System.Globalization.UnicodeCategory uc);
            static /*0x219aaf8*/ int InternalCompareStringOrdinalIgnoreCase(string strA, int indexA, string strB, int indexB, int lenA, int lenB);
            /*0x219a81c*/ TextInfo(System.Globalization.CultureData cultureData);
            /*0x219c8d0*/ TextInfo();
            /*0x219a858*/ void OnDeserializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x219a860*/ void OnDeserialized();
            /*0x219a944*/ void OnDeserialized(System.Runtime.Serialization.StreamingContext ctx);
            /*0x219a948*/ void OnSerializing(System.Runtime.Serialization.StreamingContext ctx);
            /*0x219adcc*/ int get_ANSICodePage();
            /*0x219ade8*/ int get_OEMCodePage();
            /*0x219ae04*/ int get_MacCodePage();
            /*0x219ae20*/ int get_EBCDICCodePage();
            /*0x219ae3c*/ int get_LCID();
            /*0x219aeac*/ string get_CultureName();
            /*0x219aeb4*/ bool get_IsReadOnly();
            /*0x219aebc*/ object Clone();
            /*0x219b034*/ void VerifyWritable();
            /*0x219b0a8*/ void SetReadOnlyState(bool readOnly);
            /*0x219b0b4*/ string get_ListSeparator();
            /*0x219b0e0*/ void set_ListSeparator(string value);
            /*0x219b170*/ char ToLower(char c);
            /*0x219b748*/ string ToLower(string str);
            /*0x219b888*/ char ToUpper(char c);
            /*0x219bd6c*/ string ToUpper(string str);
            /*0x219b1e4*/ bool get_IsAsciiCasingSameAsInvariant();
            /*0x219beac*/ bool Equals(object obj);
            /*0x219bf4c*/ int GetHashCode();
            /*0x219bf6c*/ string ToString();
            /*0x219bfc4*/ string ToTitleCase(string str);
            /*0x219c308*/ int AddTitlecaseLetter(ref System.Text.StringBuilder result, ref string input, int inputIndex, int charLen);
            /*0x219c530*/ bool get_IsRightToLeft();
            /*0x219c54c*/ void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
            /*0x219c550*/ int GetCaseInsensitiveHashCode(string str);
            /*0x219a9f8*/ int GetCaseInsensitiveHashCode(string str, bool forceRandomizedHashing, long additionalEntropy);
            /*0x219c558*/ int GetInvariantCaseInsensitiveHashCode(string str);
            /*0x219bdc4*/ string ToUpperInternal(string str);
            /*0x219b7a0*/ string ToLowerInternal(string str);
            /*0x219b908*/ char ToUpperInternal(char c);
            /*0x219b304*/ char ToLowerInternal(char c);
            /*0x219c668*/ void ToLowerAsciiInvariant(System.ReadOnlySpan<char> source, System.Span<char> destination);
            /*0x219c6f8*/ void ToUpperAsciiInvariant(System.ReadOnlySpan<char> source, System.Span<char> destination);
            /*0x219c788*/ void ChangeCase(System.ReadOnlySpan<char> source, System.Span<char> destination, bool toUpper);
        }

        class ThaiBuddhistCalendar : System.Globalization.Calendar
        {
            static int ThaiBuddhistEra = 1;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 2572;
            static /*0x0*/ System.Globalization.EraInfo[] thaiBuddhistEraInfo;
            /*0x20*/ System.Globalization.GregorianCalendarHelper helper;

            static /*0x219ce9c*/ ThaiBuddhistCalendar();
            /*0x219c9c0*/ ThaiBuddhistCalendar();
            /*0x219c908*/ System.DateTime get_MinSupportedDateTime();
            /*0x219c960*/ System.DateTime get_MaxSupportedDateTime();
            /*0x219c9b8*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x219ca64*/ int get_ID();
            /*0x219ca6c*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x219ca88*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x219caa4*/ int GetDaysInMonth(int year, int month, int era);
            /*0x219cac0*/ int GetDaysInYear(int year, int era);
            /*0x219cadc*/ int GetDayOfMonth(System.DateTime time);
            /*0x219caf8*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x219cb14*/ int GetDayOfYear(System.DateTime time);
            /*0x219cb30*/ int GetMonthsInYear(int year, int era);
            /*0x219cb4c*/ int GetWeekOfYear(System.DateTime time, System.Globalization.CalendarWeekRule rule, System.DayOfWeek firstDayOfWeek);
            /*0x219cb6c*/ int GetEra(System.DateTime time);
            /*0x219cb88*/ int GetMonth(System.DateTime time);
            /*0x219cba4*/ int GetYear(System.DateTime time);
            /*0x219cbc0*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x219cbdc*/ bool IsLeapYear(int year, int era);
            /*0x219cbf8*/ int GetLeapMonth(int year, int era);
            /*0x219cc14*/ bool IsLeapMonth(int year, int month, int era);
            /*0x219cc30*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x219cc54*/ int[] get_Eras();
            /*0x219cc70*/ int get_TwoDigitYearMax();
            /*0x219ccac*/ void set_TwoDigitYearMax(int value);
            /*0x219cdec*/ int ToFourDigitYear(int year);
        }

        class UmAlQuraCalendar : System.Globalization.Calendar
        {
            static int MinCalendarYear = 1318;
            static int MaxCalendarYear = 1500;
            static int UmAlQuraEra = 1;
            static int DateCycle = 30;
            static int DatePartYear = 0;
            static int DatePartDayOfYear = 1;
            static int DatePartMonth = 2;
            static int DatePartDay = 3;
            static int DEFAULT_TWO_DIGIT_YEAR_MAX = 1451;
            static /*0x0*/ System.Globalization.UmAlQuraCalendar.DateMapping[] HijriYearInfo;
            static /*0x8*/ System.DateTime minDate;
            static /*0x10*/ System.DateTime maxDate;

            static /*0x219eb04*/ UmAlQuraCalendar();
            static /*0x219cf94*/ System.Globalization.UmAlQuraCalendar.DateMapping[] InitDateMapping();
            static /*0x219d210*/ void ConvertHijriToGregorian(int HijriYear, int HijriMonth, int HijriDay, ref int yg, ref int mg, ref int dg);
            static /*0x219d350*/ long GetAbsoluteDateUmAlQura(int year, int month, int day);
            static /*0x219d418*/ void CheckTicksRange(long ticks);
            static /*0x219d5c8*/ void CheckEraRange(int era);
            static /*0x219d644*/ void CheckYearRange(int year, int era);
            static /*0x219d790*/ void CheckYearMonthRange(int year, int month, int era);
            static /*0x219d870*/ void ConvertGregorianToHijri(System.DateTime time, ref int HijriYear, ref int HijriMonth, ref int HijriDay);
            static /*0x219e0a8*/ int RealGetDaysInYear(int year);
            /*0x219d1f0*/ UmAlQuraCalendar();
            /*0x219d138*/ System.DateTime get_MinSupportedDateTime();
            /*0x219d190*/ System.DateTime get_MaxSupportedDateTime();
            /*0x219d1e8*/ System.Globalization.CalendarAlgorithmType get_AlgorithmType();
            /*0x219d1f8*/ int get_BaseCalendarID();
            /*0x219d200*/ int get_ID();
            /*0x219d208*/ int get_DaysInYearBeforeMinSupportedYear();
            /*0x219dac8*/ int GetDatePart(System.DateTime time, int part);
            /*0x219dc34*/ System.DateTime AddMonths(System.DateTime time, int months);
            /*0x219df48*/ System.DateTime AddYears(System.DateTime time, int years);
            /*0x219df60*/ int GetDayOfMonth(System.DateTime time);
            /*0x219df74*/ System.DayOfWeek GetDayOfWeek(System.DateTime time);
            /*0x219dfdc*/ int GetDayOfYear(System.DateTime time);
            /*0x219dff0*/ int GetDaysInMonth(int year, int month, int era);
            /*0x219e148*/ int GetDaysInYear(int year, int era);
            /*0x219e1b4*/ int GetEra(System.DateTime time);
            /*0x219e224*/ int[] get_Eras();
            /*0x219e288*/ int GetMonth(System.DateTime time);
            /*0x219e29c*/ int GetMonthsInYear(int year, int era);
            /*0x219e308*/ int GetYear(System.DateTime time);
            /*0x219e31c*/ bool IsLeapDay(int year, int month, int day, int era);
            /*0x219e4b4*/ int GetLeapMonth(int year, int era);
            /*0x219e520*/ bool IsLeapMonth(int year, int month, int era);
            /*0x219e594*/ bool IsLeapYear(int year, int era);
            /*0x219e60c*/ System.DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
            /*0x219e864*/ int get_TwoDigitYearMax();
            /*0x219e8a0*/ void set_TwoDigitYearMax(int value);
            /*0x219e9c4*/ int ToFourDigitYear(int year);

            struct DateMapping
            {
                /*0x10*/ int HijriMonthsLengthFlags;
                /*0x18*/ System.DateTime GregorianDate;

                /*0x219d0f8*/ DateMapping(int MonthsLengthFlags, int GYear, int GMonth, int GDay);
            }
        }

        class SortKey
        {
            /*0x10*/ string source;
            /*0x18*/ byte[] key;
            /*0x20*/ System.Globalization.CompareOptions options;
            /*0x24*/ int lcid;

            static /*0x219ebec*/ int Compare(System.Globalization.SortKey sortkey1, System.Globalization.SortKey sortkey2);
            /*0x219ed60*/ SortKey(int lcid, string source, System.Globalization.CompareOptions opt);
            /*0x219ee34*/ SortKey(int lcid, string source, byte[] buffer, System.Globalization.CompareOptions opt, int lv1Length, int lv2Length, int lv3Length, int kanaSmallLength, int markTypeLength, int katakanaLength, int kanaWidthLength, int identLength);
            /*0x219ee74*/ SortKey(string localeName, string str, System.Globalization.CompareOptions options, byte[] keyData);
            /*0x219f1d4*/ SortKey();
            /*0x219eebc*/ string get_OriginalString();
            /*0x219eec4*/ byte[] get_KeyData();
            /*0x219eecc*/ bool Equals(object value);
            /*0x219ef7c*/ int GetHashCode();
            /*0x219efe4*/ string ToString();
        }

        interface ISimpleCollator
        {
            System.Globalization.SortKey GetSortKey(string source, System.Globalization.CompareOptions options);
            int Compare(string s1, string s2);
            int Compare(string s1, int idx1, int len1, string s2, int idx2, int len2, System.Globalization.CompareOptions options);
            bool IsPrefix(string src, string target, System.Globalization.CompareOptions opt);
            bool IsSuffix(string src, string target, System.Globalization.CompareOptions opt);
            int IndexOf(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
            int IndexOf(string s, char target, int start, int length, System.Globalization.CompareOptions opt);
            int LastIndexOf(string s, string target, System.Globalization.CompareOptions opt);
            int LastIndexOf(string s, string target, int start, int length, System.Globalization.CompareOptions opt);
            int LastIndexOf(string s, char target, System.Globalization.CompareOptions opt);
            int LastIndexOf(string s, char target, int start, int length, System.Globalization.CompareOptions opt);
        }

        class CultureData
        {
            static /*0x0*/ System.Globalization.CultureData s_Invariant;
            /*0x10*/ string sAM1159;
            /*0x18*/ string sPM2359;
            /*0x20*/ string sTimeSeparator;
            /*0x28*/ string[] saLongTimes;
            /*0x30*/ string[] saShortTimes;
            /*0x38*/ int iFirstDayOfWeek;
            /*0x3c*/ int iFirstWeekOfYear;
            /*0x40*/ int[] waCalendars;
            /*0x48*/ System.Globalization.CalendarData[] calendars;
            /*0x50*/ string sISO639Language;
            /*0x58*/ string sRealName;
            /*0x60*/ bool bUseOverrides;
            /*0x64*/ int calendarId;
            /*0x68*/ int numberIndex;
            /*0x6c*/ int iDefaultAnsiCodePage;
            /*0x70*/ int iDefaultOemCodePage;
            /*0x74*/ int iDefaultMacCodePage;
            /*0x78*/ int iDefaultEbcdicCodePage;
            /*0x7c*/ bool isRightToLeft;
            /*0x80*/ string sListSeparator;

            static /*0x219a478*/ System.Globalization.CultureData get_Invariant();
            static /*0x219f234*/ System.Globalization.CultureData GetCultureData(string cultureName, bool useUserOverride);
            static /*0x219f320*/ System.Globalization.CultureData GetCultureData(string cultureName, bool useUserOverride, int datetimeIndex, int calendarId, int numberIndex, string iso2lang, int ansiCodePage, int oemCodePage, int macCodePage, int ebcdicCodePage, bool rightToLeft, string listSeparator);
            static /*0x219f444*/ System.Globalization.CultureData GetCultureData(int culture, bool bUseUserOverride);
            static /*0x219fb4c*/ string GetDateSeparator(string format);
            static /*0x219fb94*/ string GetSeparator(string format, string timeParts);
            static /*0x219fc98*/ int IndexOfTimePart(string format, int startIndex, string timeParts);
            static /*0x219fd84*/ string UnescapeNlsString(string str, int start, int end);
            static /*0x219ff28*/ string[] ReescapeWin32Strings(string[] array);
            static /*0x219ff2c*/ string ReescapeWin32String(string str);
            static /*0x219ff30*/ bool IsCustomCultureId(int cultureId);
            static /*0x219ff38*/ int strlen(byte* s);
            static /*0x219ff50*/ string idx2string(byte* data, int idx);
            static /*0x21a0048*/ byte* fill_number_data(int index, ref System.Globalization.CultureData.NumberFormatEntryManaged nfe);
            /*0x219f20c*/ CultureData(string name);
            /*0x219f440*/ void fill_culture_data(int datetimeIndex);
            /*0x219f44c*/ System.Globalization.CalendarData GetCalendar(int calendarId);
            /*0x219f568*/ string[] get_LongTimes();
            /*0x219f580*/ string[] get_ShortTimes();
            /*0x219f598*/ string get_SISO639LANGNAME();
            /*0x219f5a0*/ int get_IFIRSTDAYOFWEEK();
            /*0x219f5a8*/ int get_IFIRSTWEEKOFYEAR();
            /*0x219f5b0*/ string get_SAM1159();
            /*0x219f5b8*/ string get_SPM2359();
            /*0x219f5c0*/ string get_TimeSeparator();
            /*0x219f5c8*/ int[] get_CalendarIds();
            /*0x219f778*/ System.Globalization.CalendarId[] GetCalendarIds();
            /*0x2196988*/ bool get_IsInvariantCulture();
            /*0x219f850*/ string get_CultureName();
            /*0x219f858*/ string get_SCOMPAREINFO();
            /*0x219f898*/ string get_STEXTINFO();
            /*0x219f8a0*/ int get_ILANGUAGE();
            /*0x219f8a8*/ int get_IDEFAULTANSICODEPAGE();
            /*0x219f8b0*/ int get_IDEFAULTOEMCODEPAGE();
            /*0x219f8b8*/ int get_IDEFAULTMACCODEPAGE();
            /*0x219f8c0*/ int get_IDEFAULTEBCDICCODEPAGE();
            /*0x219f8c8*/ bool get_IsRightToLeft();
            /*0x219f8d0*/ string get_SLIST();
            /*0x219f8d8*/ bool get_UseUserOverride();
            /*0x219f8e0*/ string CalendarName(int calendarId);
            /*0x219f8fc*/ string[] EraNames(int calendarId);
            /*0x219f918*/ string[] AbbrevEraNames(int calendarId);
            /*0x219f934*/ string[] AbbreviatedEnglishEraNames(int calendarId);
            /*0x219f950*/ string[] ShortDates(int calendarId);
            /*0x219f96c*/ string[] LongDates(int calendarId);
            /*0x219f988*/ string[] YearMonths(int calendarId);
            /*0x219f9a4*/ string[] DayNames(int calendarId);
            /*0x219f9c0*/ string[] AbbreviatedDayNames(int calendarId);
            /*0x219f9dc*/ string[] SuperShortDayNames(int calendarId);
            /*0x219f9f8*/ string[] MonthNames(int calendarId);
            /*0x219fa14*/ string[] GenitiveMonthNames(int calendarId);
            /*0x219fa30*/ string[] AbbreviatedMonthNames(int calendarId);
            /*0x219fa4c*/ string[] AbbreviatedGenitiveMonthNames(int calendarId);
            /*0x219fa68*/ string[] LeapYearMonthNames(int calendarId);
            /*0x219fa84*/ string MonthDay(int calendarId);
            /*0x219faa0*/ string DateSeparator(int calendarId);
            /*0x219ff94*/ int[] create_group_sizes_array(int gs0, int gs1);
            /*0x21967f0*/ void GetNFIValues(System.Globalization.NumberFormatInfo nfi);

            struct NumberFormatEntryManaged
            {
                /*0x10*/ int currency_decimal_digits;
                /*0x14*/ int currency_decimal_separator;
                /*0x18*/ int currency_group_separator;
                /*0x1c*/ int currency_group_sizes0;
                /*0x20*/ int currency_group_sizes1;
                /*0x24*/ int currency_negative_pattern;
                /*0x28*/ int currency_positive_pattern;
                /*0x2c*/ int currency_symbol;
                /*0x30*/ int nan_symbol;
                /*0x34*/ int negative_infinity_symbol;
                /*0x38*/ int negative_sign;
                /*0x3c*/ int number_decimal_digits;
                /*0x40*/ int number_decimal_separator;
                /*0x44*/ int number_group_separator;
                /*0x48*/ int number_group_sizes0;
                /*0x4c*/ int number_group_sizes1;
                /*0x50*/ int number_negative_pattern;
                /*0x54*/ int per_mille_symbol;
                /*0x58*/ int percent_negative_pattern;
                /*0x5c*/ int percent_positive_pattern;
                /*0x60*/ int percent_symbol;
                /*0x64*/ int positive_infinity_symbol;
                /*0x68*/ int positive_sign;
            }
        }

        class CodePageDataItem
        {
            static /*0x0*/ char[] sep;
            /*0x10*/ int m_dataIndex;
            /*0x14*/ int m_uiFamilyCodePage;
            /*0x18*/ string m_webName;
            /*0x20*/ string m_headerName;
            /*0x28*/ string m_bodyName;
            /*0x30*/ uint m_flags;

            static /*0x21a03e8*/ CodePageDataItem();
            static /*0x21a00f0*/ string CreateString(string pStrings, uint index);
            /*0x21a004c*/ CodePageDataItem(int dataIndex);
            /*0x21a01a4*/ string get_WebName();
            /*0x21a0260*/ int get_UIFamilyCodePage();
            /*0x21a0268*/ string get_HeaderName();
            /*0x21a0324*/ string get_BodyName();
            /*0x21a03e0*/ uint get_Flags();
        }

        class EncodingTable
        {
            static int MIMECONTF_MAILNEWS = 1;
            static int MIMECONTF_BROWSER = 2;
            static int MIMECONTF_MINIMAL = 4;
            static int MIMECONTF_IMPORT = 8;
            static int MIMECONTF_SAVABLE_MAILNEWS = 256;
            static int MIMECONTF_SAVABLE_BROWSER = 512;
            static int MIMECONTF_EXPORT = 1024;
            static int MIMECONTF_PRIVCONVERTER = 65536;
            static int MIMECONTF_VALID = 131072;
            static int MIMECONTF_VALID_NLS = 262144;
            static int MIMECONTF_MIME_IE4 = 268435456;
            static int MIMECONTF_MIME_LATEST = 536870912;
            static int MIMECONTF_MIME_REGISTRY = 1073741824;
            static /*0x0*/ System.Globalization.InternalEncodingDataItem[] encodingDataPtr;
            static /*0x8*/ System.Globalization.InternalCodePageDataItem[] codePageDataPtr;
            static /*0x10*/ int lastEncodingItem;
            static /*0x14*/ int lastCodePageItem;
            static /*0x18*/ System.Collections.Generic.Dictionary<string, int> hashByName;
            static /*0x20*/ System.Collections.Generic.Dictionary<int, System.Globalization.CodePageDataItem> hashByCodePage;

            static /*0x21a04ec*/ EncodingTable();
            static /*0x21a046c*/ int GetNumEncodingItems();
            static /*0x21a04d0*/ System.Globalization.InternalEncodingDataItem ENC(string name, ushort cp);
            static /*0x21a04d8*/ System.Globalization.InternalCodePageDataItem MapCodePageDataItem(ushort cp, ushort fcp, string names, uint flags);
            static /*0x21a59a4*/ int internalGetCodePageFromName(string name);
            static /*0x21a5bfc*/ System.Text.EncodingInfo[] GetEncodings();
            static /*0x21a5ea0*/ int GetCodePageFromName(string name);
            static /*0x21a6124*/ System.Globalization.CodePageDataItem GetCodePageDataItem(int codepage);
        }

        struct InternalEncodingDataItem
        {
            /*0x10*/ string webName;
            /*0x18*/ ushort codePage;
        }

        struct InternalCodePageDataItem
        {
            /*0x10*/ ushort codePage;
            /*0x12*/ ushort uiFamilyCodePage;
            /*0x14*/ uint flags;
            /*0x18*/ string Names;
        }

        class TextInfoToUpperData
        {
            static /*0x0*/ char[] range_00e0_0586;
            static /*0x8*/ char[] range_1e01_1ff3;
            static /*0x10*/ char[] range_2170_2184;
            static /*0x18*/ char[] range_24d0_24e9;
            static /*0x20*/ char[] range_2c30_2ce3;
            static /*0x28*/ char[] range_2d00_2d25;
            static /*0x30*/ char[] range_a641_a697;
            static /*0x38*/ char[] range_a723_a78c;

            static /*0x21a740c*/ TextInfoToUpperData();
        }

        class TextInfoToLowerData
        {
            static /*0x0*/ char[] range_00c0_0556;
            static /*0x8*/ char[] range_10a0_10c5;
            static /*0x10*/ char[] range_1e00_1ffc;
            static /*0x18*/ char[] range_2160_216f;
            static /*0x20*/ char[] range_24b6_24cf;
            static /*0x28*/ char[] range_2c00_2c2e;
            static /*0x30*/ char[] range_2c60_2ce2;
            static /*0x38*/ char[] range_a640_a696;
            static /*0x40*/ char[] range_a722_a78b;

            static /*0x21a765c*/ TextInfoToLowerData();
        }

        class CultureInfo : System.ICloneable, System.IFormatProvider
        {
            static int InvariantCultureId = 127;
            static int CalendarTypeBits = 8;
            static int LOCALE_INVARIANT = 127;
            static string MSG_READONLY = "This instance is read only";
            static /*0x0*/ System.Globalization.CultureInfo invariant_culture_info;
            static /*0x8*/ object shared_table_lock;
            static /*0x10*/ System.Globalization.CultureInfo default_current_culture;
            static /*0x18*/ System.Globalization.CultureInfo s_DefaultThreadCurrentUICulture;
            static /*0x20*/ System.Globalization.CultureInfo s_DefaultThreadCurrentCulture;
            static /*0x28*/ System.Collections.Generic.Dictionary<int, System.Globalization.CultureInfo> shared_by_number;
            static /*0x30*/ System.Collections.Generic.Dictionary<string, System.Globalization.CultureInfo> shared_by_name;
            static /*0x38*/ System.Globalization.CultureInfo s_UserPreferredCultureInfoInAppX;
            static /*0x40*/ bool IsTaiwanSku;
            /*0x10*/ bool m_isReadOnly;
            /*0x14*/ int cultureID;
            /*0x18*/ int parent_lcid;
            /*0x1c*/ int datetime_index;
            /*0x20*/ int number_index;
            /*0x24*/ int default_calendar_type;
            /*0x28*/ bool m_useUserOverride;
            /*0x30*/ System.Globalization.NumberFormatInfo numInfo;
            /*0x38*/ System.Globalization.DateTimeFormatInfo dateTimeInfo;
            /*0x40*/ System.Globalization.TextInfo textInfo;
            /*0x48*/ string m_name;
            /*0x50*/ string englishname;
            /*0x58*/ string nativename;
            /*0x60*/ string iso3lang;
            /*0x68*/ string iso2lang;
            /*0x70*/ string win3lang;
            /*0x78*/ string territory;
            /*0x80*/ string[] native_calendar_names;
            /*0x88*/ System.Globalization.CompareInfo compareInfo;
            /*0x90*/ void* textinfo_data;
            /*0x98*/ int m_dataItem;
            /*0xa0*/ System.Globalization.Calendar calendar;
            /*0xa8*/ System.Globalization.CultureInfo parent_culture;
            /*0xb0*/ bool constructed;
            /*0xb8*/ byte[] cached_serialized_form;
            /*0xc0*/ System.Globalization.CultureData m_cultureData;
            /*0xc8*/ bool m_isInherited;

            static /*0x21ae580*/ CultureInfo();
            static /*0x21a7998*/ System.Globalization.CultureInfo get_InvariantCulture();
            static /*0x21a79f8*/ System.Globalization.CultureInfo get_CurrentCulture();
            static /*0x21a7a18*/ void set_CurrentCulture(System.Globalization.CultureInfo value);
            static /*0x21a7a40*/ System.Globalization.CultureInfo get_CurrentUICulture();
            static /*0x21a7a60*/ void set_CurrentUICulture(System.Globalization.CultureInfo value);
            static /*0x21a7a88*/ System.Globalization.CultureInfo ConstructCurrentCulture();
            static /*0x21a7e8c*/ System.Globalization.CultureInfo ConstructCurrentUICulture();
            static /*0x21a8294*/ System.Globalization.CultureInfo[] GetCultures(System.Globalization.CultureTypes types);
            static /*0x21a9f40*/ System.Globalization.CultureInfo ReadOnly(System.Globalization.CultureInfo ci);
            static /*0x21aa65c*/ System.Globalization.CultureInfo get_InstalledUICulture();
            static /*0x21a7c6c*/ string get_current_locale_name();
            static /*0x21a9e94*/ System.Globalization.CultureInfo[] internal_get_cultures(bool neutral, bool specific, bool installed);
            static /*0x21aaf40*/ void insert_into_shared_tables(System.Globalization.CultureInfo c);
            static /*0x21ab0c8*/ System.Globalization.CultureInfo GetCultureInfo(int culture);
            static /*0x21a8e2c*/ System.Globalization.CultureInfo GetCultureInfo(string name);
            static /*0x21ab30c*/ System.Globalization.CultureInfo GetCultureInfo(string name, string altName);
            static /*0x21ab3b8*/ System.Globalization.CultureInfo GetCultureInfoByIetfLanguageTag(string name);
            static /*0x21ab4a8*/ System.Globalization.CultureInfo CreateCulture(string name, bool reference);
            static /*0x21a7c70*/ System.Globalization.CultureInfo CreateSpecificCulture(string name);
            static /*0x21ab51c*/ System.Globalization.CultureInfo CreateSpecificCultureFromNeutral(string name);
            static /*0x21a9310*/ System.Globalization.Calendar CreateCalendar(int calendarType);
            static /*0x21aae58*/ System.Exception CreateNotFoundException(string name);
            static /*0x21adc70*/ System.Globalization.CultureInfo get_DefaultThreadCurrentCulture();
            static /*0x21adcd0*/ void set_DefaultThreadCurrentCulture(System.Globalization.CultureInfo value);
            static /*0x21add30*/ System.Globalization.CultureInfo get_DefaultThreadCurrentUICulture();
            static /*0x21add90*/ void set_DefaultThreadCurrentUICulture(System.Globalization.CultureInfo value);
            static /*0x21addf8*/ System.Globalization.CultureInfo get_UserDefaultUICulture();
            static /*0x21ade44*/ System.Globalization.CultureInfo get_UserDefaultCulture();
            static /*0x21ade90*/ void InitializeUserPreferredCultureInfoInAppX(System.Globalization.CultureInfo.OnCultureInfoChangedDelegate onCultureInfoChangedInAppX);
            static /*0x21adea0*/ void SetUserPreferredCultureInfoInAppX(string name);
            static /*0x21a78e8*/ void OnCultureInfoChangedInAppX(string language);
            static /*0x21adeb0*/ System.Globalization.CultureInfo GetCultureInfoForUserPreferredLanguageInAppX();
            static /*0x21ae060*/ void SetCultureInfoForUserPreferredLanguageInAppX(System.Globalization.CultureInfo cultureInfo);
            static /*0x21ae16c*/ void CheckDomainSafetyObject(object obj, object container);
            static /*0x21ae388*/ bool VerifyCultureName(string cultureName, bool throwException);
            static /*0x21ae4ec*/ bool VerifyCultureName(System.Globalization.CultureInfo culture, bool throwException);
            /*0x21a9834*/ CultureInfo(int culture);
            /*0x21aa920*/ CultureInfo(int culture, bool useUserOverride);
            /*0x21aa92c*/ CultureInfo(int culture, bool useUserOverride, bool read_only);
            /*0x21a9828*/ CultureInfo(string name);
            /*0x21aab90*/ CultureInfo(string name, bool useUserOverride);
            /*0x21aab9c*/ CultureInfo(string name, bool useUserOverride, bool read_only);
            /*0x21aaf20*/ CultureInfo();
            /*0x21a7988*/ System.Globalization.CultureData get__cultureData();
            /*0x21a7990*/ bool get__isInherited();
            /*0x21a7ed8*/ string get_Territory();
            /*0x21a7ee0*/ string get__name();
            /*0x21a7ee8*/ System.Globalization.CultureTypes get_CultureTypes();
            /*0x21a84c8*/ System.Globalization.CultureInfo GetConsoleFallbackUICulture();
            /*0x21a9058*/ string get_IetfLanguageTag();
            /*0x21a912c*/ int get_KeyboardLayoutId();
            /*0x21a91d0*/ int get_LCID();
            /*0x21a91d8*/ string get_Name();
            /*0x21a91e0*/ string get_NativeName();
            /*0x21a9230*/ string get_NativeCalendarName();
            /*0x21a928c*/ System.Globalization.Calendar get_Calendar();
            /*0x21a9548*/ System.Globalization.Calendar[] get_OptionalCalendars();
            /*0x21a95ec*/ System.Globalization.CultureInfo get_Parent();
            /*0x21a9840*/ System.Globalization.TextInfo get_TextInfo();
            /*0x21a99d8*/ string get_ThreeLetterISOLanguageName();
            /*0x21a9a08*/ string get_ThreeLetterWindowsLanguageName();
            /*0x21a9a38*/ string get_TwoLetterISOLanguageName();
            /*0x21a9a68*/ bool get_UseUserOverride();
            /*0x21a9a70*/ void ClearCachedData();
            /*0x21a9c4c*/ object Clone();
            /*0x21a9de8*/ bool Equals(object value);
            /*0x21a9ea4*/ System.Globalization.CultureInfo.Data GetTextInfoData();
            /*0x21a9f34*/ int GetHashCode();
            /*0x21aa0e0*/ string ToString();
            /*0x21aa0e8*/ System.Globalization.CompareInfo get_CompareInfo();
            /*0x21aa240*/ bool get_IsNeutralCulture();
            /*0x21aa288*/ void CheckNeutral();
            /*0x21aa28c*/ System.Globalization.NumberFormatInfo get_NumberFormat();
            /*0x21aa31c*/ void set_NumberFormat(System.Globalization.NumberFormatInfo value);
            /*0x21aa3ec*/ System.Globalization.DateTimeFormatInfo get_DateTimeFormat();
            /*0x21aa54c*/ void set_DateTimeFormat(System.Globalization.DateTimeFormatInfo value);
            /*0x21aa61c*/ string get_DisplayName();
            /*0x21aa62c*/ string get_EnglishName();
            /*0x21aa6a8*/ bool get_IsReadOnly();
            /*0x21aa6b0*/ object GetFormat(System.Type formatType);
            /*0x21a9210*/ void Construct();
            /*0x21aa7c0*/ bool construct_internal_locale_from_lcid(int lcid);
            /*0x21aa7c4*/ bool construct_internal_locale_from_name(string name);
            /*0x21aa7c8*/ void ConstructInvariant(bool read_only);
            /*0x21a995c*/ System.Globalization.TextInfo CreateTextInfo(bool readOnly);
            /*0x21aadcc*/ bool ConstructLocaleFromName(string name);
            /*0x21a9ebc*/ int get_CalendarType();
            /*0x21addf0*/ string get_SortName();
            /*0x21ae2fc*/ bool get_HasInvariantCultureName();

            struct Data
            {
                /*0x10*/ int ansi;
                /*0x14*/ int ebcdic;
                /*0x18*/ int mac;
                /*0x1c*/ int oem;
                /*0x20*/ bool right_to_left;
                /*0x21*/ byte list_sep;
            }

            class OnCultureInfoChangedDelegate : System.MulticastDelegate
            {
                /*0x21adf8c*/ OnCultureInfoChangedDelegate(object object, nint method);
                /*0x21ae628*/ void Invoke(string language);
            }
        }

        class IdnMapping
        {
            /*0x10*/ bool allow_unassigned;
            /*0x11*/ bool use_std3;
            /*0x18*/ System.Globalization.Punycode puny;

            /*0x21ae63c*/ IdnMapping();
            /*0x21ae70c*/ bool get_AllowUnassigned();
            /*0x21ae714*/ void set_AllowUnassigned(bool value);
            /*0x21ae720*/ bool get_UseStd3AsciiRules();
            /*0x21ae728*/ void set_UseStd3AsciiRules(bool value);
            /*0x21ae734*/ bool Equals(object obj);
            /*0x21ae7c0*/ int GetHashCode();
            /*0x21ae7d0*/ string GetAscii(string unicode);
            /*0x21ae908*/ string GetAscii(string unicode, int index);
            /*0x21ae834*/ string GetAscii(string unicode, int index, int count);
            /*0x21ae96c*/ string Convert(string input, int index, int count, bool toAscii);
            /*0x21aeb94*/ string ToAscii(string s, int offset);
            /*0x21af604*/ void VerifyLength(string s, int offset);
            /*0x21aefa4*/ string NamePrep(string s, int offset);
            /*0x21af6d0*/ void VerifyProhibitedCharacters(string s, int offset);
            /*0x21af0f0*/ void VerifyStd3AsciiRules(string s, int offset);
            /*0x21af910*/ string GetUnicode(string ascii);
            /*0x21afa48*/ string GetUnicode(string ascii, int index);
            /*0x21af974*/ string GetUnicode(string ascii, int index, int count);
            /*0x21aedd0*/ string ToUnicode(string s, int offset);
        }

        class Bootstring
        {
            /*0x10*/ char delimiter;
            /*0x14*/ int base_num;
            /*0x18*/ int tmin;
            /*0x1c*/ int tmax;
            /*0x20*/ int skew;
            /*0x24*/ int damp;
            /*0x28*/ int initial_bias;
            /*0x2c*/ int initial_n;

            /*0x21afd84*/ Bootstring(char delimiter, int baseNum, int tmin, int tmax, int skew, int damp, int initialBias, int initialN);
            /*0x21af2c0*/ string Encode(string s, int offset);
            /*0x21afdf0*/ char EncodeDigit(int d);
            /*0x21afe80*/ int DecodeDigit(char c);
            /*0x21afe08*/ int Adapt(int delta, int numPoints, bool firstTime);
            /*0x21afaac*/ string Decode(string s, int offset);
        }

        class Punycode : System.Globalization.Bootstring
        {
            /*0x21ae6cc*/ Punycode();
        }

        class RegionInfo
        {
            static /*0x0*/ System.Globalization.RegionInfo currentRegion;
            /*0x10*/ int regionId;
            /*0x18*/ string iso2Name;
            /*0x20*/ string iso3Name;
            /*0x28*/ string win3Name;
            /*0x30*/ string englishName;
            /*0x38*/ string nativeName;
            /*0x40*/ string currencySymbol;
            /*0x48*/ string isoCurrencySymbol;
            /*0x50*/ string currencyEnglishName;
            /*0x58*/ string currencyNativeName;

            static /*0x21afeb8*/ System.Globalization.RegionInfo get_CurrentRegion();
            static /*0x21a9c04*/ void ClearCachedData();
            /*0x21b0118*/ RegionInfo(int culture);
            /*0x21b02cc*/ RegionInfo(string name);
            /*0x21aff80*/ RegionInfo(System.Globalization.CultureInfo ci);
            /*0x21b0220*/ bool GetByTerritory(System.Globalization.CultureInfo ci);
            /*0x21b040c*/ bool construct_internal_region_from_name(string name);
            /*0x21b0410*/ string get_CurrencyEnglishName();
            /*0x21b0418*/ string get_CurrencySymbol();
            /*0x21b0420*/ string get_DisplayName();
            /*0x21b0428*/ string get_EnglishName();
            /*0x21b0430*/ int get_GeoId();
            /*0x21b0438*/ bool get_IsMetric();
            /*0x21b04c4*/ string get_ISOCurrencySymbol();
            /*0x21b04cc*/ string get_NativeName();
            /*0x21b04d4*/ string get_CurrencyNativeName();
            /*0x21b04dc*/ string get_Name();
            /*0x21b04e4*/ string get_ThreeLetterISORegionName();
            /*0x21b04ec*/ string get_ThreeLetterWindowsRegionName();
            /*0x21b04f4*/ string get_TwoLetterISORegionName();
            /*0x21b04fc*/ bool Equals(object value);
            /*0x21b05c4*/ int GetHashCode();
            /*0x21b05f0*/ string ToString();
        }
    }

    namespace Diagnostics
    {
        class ConditionalAttribute : System.Attribute
        {
            /*0x10*/ string <ConditionString>k__BackingField;

            /*0x21b0600*/ ConditionalAttribute(string conditionString);
            /*0x21b0628*/ string get_ConditionString();
        }

        class StackTraceHiddenAttribute : System.Attribute
        {
            /*0x21b0630*/ StackTraceHiddenAttribute();
        }

        class Assert
        {
            static int COR_E_FAILFAST = -2146232797;
            static /*0x0*/ System.Diagnostics.AssertFilter Filter;

            static /*0x21b0638*/ Assert();
            static /*0x21b06b8*/ void Check(bool condition, string conditionString, string message);
            static /*0x21b07c8*/ void Check(bool condition, string conditionString, string message, int exitCode);
            static /*0x21b0854*/ void Fail(string conditionString, string message);
            static /*0x21b0744*/ void Fail(string conditionString, string message, string windowTitle, int exitCode);
            static /*0x21b0a54*/ void Fail(string conditionString, string message, int exitCode, System.Diagnostics.StackTrace.TraceFormat stackTraceFormat);
            static /*0x21b08c4*/ void Fail(string conditionString, string message, string windowTitle, int exitCode, System.Diagnostics.StackTrace.TraceFormat stackTraceFormat, int numStackFramesToSkip);
            static /*0x21b0b98*/ int ShowDefaultAssertDialog(string conditionString, string message, string stackTrace, string windowTitle);
        }

        class AssertFilter
        {
            /*0x21b0bd8*/ AssertFilter();
            System.Diagnostics.AssertFilters AssertFailure(string condition, string message, System.Diagnostics.StackTrace location, System.Diagnostics.StackTrace.TraceFormat stackTraceFormat, string windowTitle);
        }

        class DefaultFilter : System.Diagnostics.AssertFilter
        {
            /*0x21b06b0*/ DefaultFilter();
            /*0x21b0be0*/ System.Diagnostics.AssertFilters AssertFailure(string condition, string message, System.Diagnostics.StackTrace location, System.Diagnostics.StackTrace.TraceFormat stackTraceFormat, string windowTitle);
        }

        enum AssertFilters
        {
            FailDebug = 0,
            FailIgnore = 1,
            FailTerminate = 2,
            FailContinueFilter = 3,
        }

        class DebuggerStepThroughAttribute : System.Attribute
        {
            /*0x21b0c44*/ DebuggerStepThroughAttribute();
        }

        class DebuggerStepperBoundaryAttribute : System.Attribute
        {
            /*0x21b0c4c*/ DebuggerStepperBoundaryAttribute();
        }

        class DebuggerHiddenAttribute : System.Attribute
        {
            /*0x21b0c54*/ DebuggerHiddenAttribute();
        }

        class DebuggerNonUserCodeAttribute : System.Attribute
        {
            /*0x21b0c5c*/ DebuggerNonUserCodeAttribute();
        }

        class DebuggableAttribute : System.Attribute
        {
            /*0x10*/ System.Diagnostics.DebuggableAttribute.DebuggingModes m_debuggingModes;

            /*0x21b0c64*/ DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
            /*0x21b0ca4*/ DebuggableAttribute(System.Diagnostics.DebuggableAttribute.DebuggingModes modes);
            /*0x21b0ccc*/ bool get_IsJITTrackingEnabled();
            /*0x21b0cd8*/ bool get_IsJITOptimizerDisabled();
            /*0x21b0ce4*/ System.Diagnostics.DebuggableAttribute.DebuggingModes get_DebuggingFlags();

            enum DebuggingModes
            {
                None = 0,
                Default = 1,
                DisableOptimizations = 256,
                IgnoreSymbolStoreSequencePoints = 2,
                EnableEditAndContinue = 4,
            }
        }

        enum DebuggerBrowsableState
        {
            Never = 0,
            Collapsed = 2,
            RootHidden = 3,
        }

        class DebuggerBrowsableAttribute : System.Attribute
        {
            /*0x10*/ System.Diagnostics.DebuggerBrowsableState state;

            /*0x21b0cec*/ DebuggerBrowsableAttribute(System.Diagnostics.DebuggerBrowsableState state);
            /*0x21b0d68*/ System.Diagnostics.DebuggerBrowsableState get_State();
        }

        class DebuggerTypeProxyAttribute : System.Attribute
        {
            /*0x10*/ string typeName;
            /*0x18*/ string targetName;
            /*0x20*/ System.Type target;

            /*0x21b0d70*/ DebuggerTypeProxyAttribute(System.Type type);
            /*0x21b0e58*/ DebuggerTypeProxyAttribute(string typeName);
            /*0x21b0e80*/ string get_ProxyTypeName();
            /*0x21b0e88*/ void set_Target(System.Type value);
            /*0x21b0f64*/ System.Type get_Target();
            /*0x21b0f6c*/ string get_TargetTypeName();
            /*0x21b0f74*/ void set_TargetTypeName(string value);
        }

        class DebuggerDisplayAttribute : System.Attribute
        {
            /*0x10*/ string name;
            /*0x18*/ string value;
            /*0x20*/ string type;
            /*0x28*/ string targetName;
            /*0x30*/ System.Type target;

            /*0x21b0f7c*/ DebuggerDisplayAttribute(string value);
            /*0x21b0fec*/ string get_Value();
            /*0x21b0ff4*/ string get_Name();
            /*0x21b0ffc*/ void set_Name(string value);
            /*0x21b1004*/ string get_Type();
            /*0x21b100c*/ void set_Type(string value);
            /*0x21b1014*/ void set_Target(System.Type value);
            /*0x21b10f0*/ System.Type get_Target();
            /*0x21b10f8*/ string get_TargetTypeName();
            /*0x21b1100*/ void set_TargetTypeName(string value);
        }

        class DebuggerVisualizerAttribute : System.Attribute
        {
            /*0x10*/ string visualizerObjectSourceName;
            /*0x18*/ string visualizerName;
            /*0x20*/ string description;
            /*0x28*/ string targetName;
            /*0x30*/ System.Type target;

            /*0x21b1108*/ DebuggerVisualizerAttribute(string visualizerTypeName);
            /*0x21b1130*/ DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
            /*0x21b115c*/ DebuggerVisualizerAttribute(string visualizerTypeName, System.Type visualizerObjectSource);
            /*0x21b124c*/ DebuggerVisualizerAttribute(System.Type visualizer);
            /*0x21b1334*/ DebuggerVisualizerAttribute(System.Type visualizer, System.Type visualizerObjectSource);
            /*0x21b1484*/ DebuggerVisualizerAttribute(System.Type visualizer, string visualizerObjectSourceTypeName);
            /*0x21b1570*/ string get_VisualizerObjectSourceTypeName();
            /*0x21b1578*/ string get_VisualizerTypeName();
            /*0x21b1580*/ string get_Description();
            /*0x21b1588*/ void set_Description(string value);
            /*0x21b1590*/ void set_Target(System.Type value);
            /*0x21b166c*/ System.Type get_Target();
            /*0x21b1674*/ void set_TargetTypeName(string value);
            /*0x21b167c*/ string get_TargetTypeName();
        }

        class DebugPrivate
        {
            static /*0x21b1684*/ void Assert(bool condition);
            static /*0x21b1688*/ void Assert(bool condition, string message);
            static /*0x21b168c*/ void Assert(bool condition, string message, string detailMessage);
            static /*0x21b1690*/ void Assert(bool condition, string message, string detailMessageFormat, object[] args);
            static /*0x21b1694*/ void Fail(string message);
            static /*0x21b1698*/ void Fail(string message, string detailMessage);
        }

        class Debugger
        {
            static /*0x0*/ string DefaultCategory;

            static /*0x21b1724*/ Debugger();
            static /*0x21b0b0c*/ bool get_IsAttached();
            static /*0x21b169c*/ bool IsAttached_internal();
            static /*0x21b16a0*/ void Break();
            static /*0x21b16a4*/ bool IsLogging();
            static /*0x21b0b58*/ bool Launch();
            static /*0x21b16a8*/ void Log_icall(int level, ref string category, ref string message);
            static /*0x21b16ac*/ void Log(int level, string category, string message);
            static /*0x21b1718*/ void NotifyOfCrossThreadDependency();
            /*0x21b171c*/ Debugger();
        }

        class StackFrame
        {
            static int OFFSET_UNKNOWN = -1;
            /*0x10*/ int ilOffset;
            /*0x14*/ int nativeOffset;
            /*0x18*/ long methodAddress;
            /*0x20*/ uint methodIndex;
            /*0x28*/ System.Reflection.MethodBase methodBase;
            /*0x30*/ string fileName;
            /*0x38*/ int lineNumber;
            /*0x3c*/ int columnNumber;
            /*0x40*/ string internalMethodName;

            static /*0x21b1784*/ bool get_frame_info(int skip, bool needFileInfo, ref System.Reflection.MethodBase method, ref int iloffset, ref int native_offset, ref string file, ref int line, ref int column);
            /*0x21b178c*/ StackFrame();
            /*0x21b17dc*/ StackFrame(bool fNeedFileInfo);
            /*0x21b1838*/ StackFrame(int skipFrames);
            /*0x21b1894*/ StackFrame(int skipFrames, bool fNeedFileInfo);
            /*0x21b18f4*/ StackFrame(string fileName, int lineNumber);
            /*0x21b1968*/ StackFrame(string fileName, int lineNumber, int colNumber);
            /*0x21b19e0*/ int GetFileLineNumber();
            /*0x21b19e8*/ int GetFileColumnNumber();
            /*0x21b19f0*/ string GetFileName();
            /*0x21b19f8*/ string GetSecureFileName();
            /*0x21b1acc*/ int GetILOffset();
            /*0x21b1ad4*/ System.Reflection.MethodBase GetMethod();
            /*0x21b1adc*/ int GetNativeOffset();
            /*0x21b1ae4*/ long GetMethodAddress();
            /*0x21b1aec*/ uint GetMethodIndex();
            /*0x21b1af4*/ string GetInternalMethodName();
            /*0x21b1afc*/ string ToString();
        }

        class StackTrace
        {
            static int METHODS_TO_SKIP = 0;
            static string prefix = "  at ";
            static /*0x0*/ bool isAotidSet;
            static /*0x8*/ string aotid;
            /*0x10*/ System.Diagnostics.StackFrame[] frames;
            /*0x18*/ System.Diagnostics.StackTrace[] captured_traces;
            /*0x20*/ bool debug_info;

            static /*0x21b1fbc*/ System.Diagnostics.StackFrame[] get_trace(System.Exception e, int skipFrames, bool fNeedFileInfo);
            static /*0x21b2474*/ string GetAotId();
            static /*0x21b3064*/ void ConvertAsyncStateMachineMethod(ref System.Reflection.MethodBase method, ref System.Type declaringType);
            /*0x21b1d3c*/ StackTrace();
            /*0x21b1f5c*/ StackTrace(bool fNeedFileInfo);
            /*0x21b1f8c*/ StackTrace(int skipFrames);
            /*0x21b0ad8*/ StackTrace(int skipFrames, bool fNeedFileInfo);
            /*0x21b1fc4*/ StackTrace(System.Exception e);
            /*0x21b20c0*/ StackTrace(System.Exception e, bool fNeedFileInfo);
            /*0x21b20cc*/ StackTrace(System.Exception e, int skipFrames);
            /*0x21b1fd0*/ StackTrace(System.Exception e, int skipFrames, bool fNeedFileInfo);
            /*0x21b20d4*/ StackTrace(System.Diagnostics.StackFrame frame);
            /*0x21b217c*/ StackTrace(System.Threading.Thread targetThread, bool needFileInfo);
            /*0x21b21fc*/ StackTrace(System.Diagnostics.StackFrame[] frames);
            /*0x21b1d60*/ void init_frames(int skipFrames, bool fNeedFileInfo);
            /*0x21b2224*/ int get_FrameCount();
            /*0x21b223c*/ System.Diagnostics.StackFrame GetFrame(int index);
            /*0x21b229c*/ System.Diagnostics.StackFrame[] GetFrames();
            /*0x21b253c*/ bool AddFrames(System.Text.StringBuilder sb, bool separator, ref bool isAsync);
            /*0x21b29f4*/ void GetFullNameForStackTrace(System.Text.StringBuilder sb, System.Reflection.MethodBase mi, bool needsNewLine, ref bool skipped, ref bool isAsync);
            /*0x21b34cc*/ string ToString();
            /*0x21b0c38*/ string ToString(System.Diagnostics.StackTrace.TraceFormat traceFormat);

            enum TraceFormat
            {
                Normal = 0,
                TrailingNewLine = 1,
                NoResourceLookup = 2,
            }
        }

        namespace Contracts
        {
            class PureAttribute : System.Attribute
            {
                /*0x21b3628*/ PureAttribute();
            }

            class ContractClassAttribute : System.Attribute
            {
                /*0x10*/ System.Type _typeWithContracts;

                /*0x21b3630*/ ContractClassAttribute(System.Type typeContainingContracts);
                /*0x21b3658*/ System.Type get_TypeContainingContracts();
            }

            class ContractClassForAttribute : System.Attribute
            {
                /*0x10*/ System.Type _typeIAmAContractFor;

                /*0x21b3660*/ ContractClassForAttribute(System.Type typeContractsAreFor);
                /*0x21b3688*/ System.Type get_TypeContractsAreFor();
            }

            class ContractInvariantMethodAttribute : System.Attribute
            {
                /*0x21b3690*/ ContractInvariantMethodAttribute();
            }

            class ContractReferenceAssemblyAttribute : System.Attribute
            {
                /*0x21b3698*/ ContractReferenceAssemblyAttribute();
            }

            class ContractRuntimeIgnoredAttribute : System.Attribute
            {
                /*0x21b36a0*/ ContractRuntimeIgnoredAttribute();
            }

            class ContractVerificationAttribute : System.Attribute
            {
                /*0x10*/ bool _value;

                /*0x21b36a8*/ ContractVerificationAttribute(bool value);
                /*0x21b36d0*/ bool get_Value();
            }

            class ContractPublicPropertyNameAttribute : System.Attribute
            {
                /*0x10*/ string _publicName;

                /*0x21b36d8*/ ContractPublicPropertyNameAttribute(string name);
                /*0x21b3700*/ string get_Name();
            }

            class ContractArgumentValidatorAttribute : System.Attribute
            {
                /*0x21b3708*/ ContractArgumentValidatorAttribute();
            }

            class ContractAbbreviatorAttribute : System.Attribute
            {
                /*0x21b3710*/ ContractAbbreviatorAttribute();
            }

            class ContractOptionAttribute : System.Attribute
            {
                /*0x10*/ string _category;
                /*0x18*/ string _setting;
                /*0x20*/ bool _enabled;
                /*0x28*/ string _value;

                /*0x21b3718*/ ContractOptionAttribute(string category, string setting, bool enabled);
                /*0x21b3754*/ ContractOptionAttribute(string category, string setting, string value);
                /*0x21b3790*/ string get_Category();
                /*0x21b3798*/ string get_Setting();
                /*0x21b37a0*/ bool get_Enabled();
                /*0x21b37a8*/ string get_Value();
            }

            class Contract
            {
                [ThreadStatic] static bool _assertingMustUseRewriter;

                static /*0x21b37b0*/ void Assume(bool condition);
                static /*0x21b3960*/ void Assume(bool condition, string userMessage);
                static /*0x21b3978*/ void Assert(bool condition);
                static /*0x21b3994*/ void Assert(bool condition, string userMessage);
                static /*0x21b39ac*/ void Requires(bool condition);
                static /*0x21b3d18*/ void Requires(bool condition, string userMessage);
                static void Requires<TException>(bool condition);
                static void Requires<TException>(bool condition, string userMessage);
                static /*0x21b3d5c*/ void Ensures(bool condition);
                static /*0x21b3da0*/ void Ensures(bool condition, string userMessage);
                static void EnsuresOnThrow<TException>(bool condition);
                static void EnsuresOnThrow<TException>(bool condition, string userMessage);
                static T Result<T>();
                static T ValueAtReturn<T>(ref T value);
                static T OldValue<T>(T value);
                static /*0x21b3de4*/ void Invariant(bool condition);
                static /*0x21b3e28*/ void Invariant(bool condition, string userMessage);
                static /*0x21b3e6c*/ bool ForAll(int fromInclusive, int toExclusive, System.Predicate<int> predicate);
                static bool ForAll<T>(System.Collections.Generic.IEnumerable<T> collection, System.Predicate<T> predicate);
                static /*0x21b3f54*/ bool Exists(int fromInclusive, int toExclusive, System.Predicate<int> predicate);
                static bool Exists<T>(System.Collections.Generic.IEnumerable<T> collection, System.Predicate<T> predicate);
                static /*0x21b403c*/ void EndContractBlock();
                static /*0x21b37cc*/ void ReportFailure(System.Diagnostics.Contracts.ContractFailureKind failureKind, string userMessage, string conditionText, System.Exception innerException);
                static /*0x21b39f0*/ void AssertMustUseRewriter(System.Diagnostics.Contracts.ContractFailureKind kind, string contractKind);
                static /*0x21b4040*/ void add_ContractFailed(System.EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs> value);
                static /*0x21b4098*/ void remove_ContractFailed(System.EventHandler<System.Diagnostics.Contracts.ContractFailedEventArgs> value);
            }

            enum ContractFailureKind
            {
                Precondition = 0,
                Postcondition = 1,
                PostconditionOnException = 2,
                Invariant = 3,
                Assert = 4,
                Assume = 5,
            }

            class ContractFailedEventArgs : System.EventArgs
            {
                /*0x10*/ System.Diagnostics.Contracts.ContractFailureKind _failureKind;
                /*0x18*/ string _message;
                /*0x20*/ string _condition;
                /*0x28*/ System.Exception _originalException;
                /*0x30*/ bool _handled;
                /*0x31*/ bool _unwind;
                /*0x38*/ System.Exception thrownDuringHandler;

                /*0x21b40f0*/ ContractFailedEventArgs(System.Diagnostics.Contracts.ContractFailureKind failureKind, string message, string condition, System.Exception originalException);
                /*0x21b4178*/ string get_Message();
                /*0x21b4180*/ string get_Condition();
                /*0x21b4188*/ System.Diagnostics.Contracts.ContractFailureKind get_FailureKind();
                /*0x21b4190*/ System.Exception get_OriginalException();
                /*0x21b4198*/ bool get_Handled();
                /*0x21b41a0*/ void SetHandled();
                /*0x21b41ac*/ bool get_Unwind();
                /*0x21b41b4*/ void SetUnwind();
            }

            class ContractException : System.Exception
            {
                /*0x8c*/ System.Diagnostics.Contracts.ContractFailureKind _Kind;
                /*0x90*/ string _UserMessage;
                /*0x98*/ string _Condition;

                /*0x21b41e8*/ ContractException();
                /*0x21b4250*/ ContractException(System.Diagnostics.Contracts.ContractFailureKind kind, string failure, string userMessage, string condition, System.Exception innerException);
                /*0x21b42f4*/ ContractException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x21b41c0*/ System.Diagnostics.Contracts.ContractFailureKind get_Kind();
                /*0x21b41c8*/ string get_Failure();
                /*0x21b41d8*/ string get_UserMessage();
                /*0x21b41e0*/ string get_Condition();
                /*0x21b43f8*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            namespace Internal
            {
                class ContractHelper
                {
                    static /*0x21b4500*/ string RaiseContractFailedEvent(System.Diagnostics.Contracts.ContractFailureKind failureKind, string userMessage, string conditionText, System.Exception innerException);
                    static /*0x21b4580*/ void TriggerFailure(System.Diagnostics.Contracts.ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, System.Exception innerException);
                }
            }
        }

        namespace SymbolStore
        {
            struct SymbolToken
            {
                /*0x10*/ int _token;

                static /*0x21b46a8*/ bool op_Equality(System.Diagnostics.SymbolStore.SymbolToken a, System.Diagnostics.SymbolStore.SymbolToken b);
                static /*0x21b46b4*/ bool op_Inequality(System.Diagnostics.SymbolStore.SymbolToken a, System.Diagnostics.SymbolStore.SymbolToken b);
                /*0x21b4608*/ SymbolToken(int val);
                /*0x21b4610*/ int GetToken();
                /*0x21b4618*/ int GetHashCode();
                /*0x21b4620*/ bool Equals(object obj);
                /*0x21b4698*/ bool Equals(System.Diagnostics.SymbolStore.SymbolToken obj);
            }

            interface ISymbolBinder
            {
                System.Diagnostics.SymbolStore.ISymbolReader GetReader(int importer, string filename, string searchPath);
            }

            interface ISymbolBinder1
            {
                System.Diagnostics.SymbolStore.ISymbolReader GetReader(nint importer, string filename, string searchPath);
            }

            interface ISymbolDocument
            {
                System.Guid get_CheckSumAlgorithmId();
                System.Guid get_DocumentType();
                bool get_HasEmbeddedSource();
                System.Guid get_Language();
                System.Guid get_LanguageVendor();
                int get_SourceLength();
                string get_URL();
                int FindClosestLine(int line);
                byte[] GetCheckSum();
                byte[] GetSourceRange(int startLine, int startColumn, int endLine, int endColumn);
            }

            interface ISymbolDocumentWriter
            {
                void SetCheckSum(System.Guid algorithmId, byte[] checkSum);
                void SetSource(byte[] source);
            }

            interface ISymbolMethod
            {
                System.Diagnostics.SymbolStore.ISymbolScope get_RootScope();
                int get_SequencePointCount();
                System.Diagnostics.SymbolStore.SymbolToken get_Token();
                System.Diagnostics.SymbolStore.ISymbolNamespace GetNamespace();
                int GetOffset(System.Diagnostics.SymbolStore.ISymbolDocument document, int line, int column);
                System.Diagnostics.SymbolStore.ISymbolVariable[] GetParameters();
                int[] GetRanges(System.Diagnostics.SymbolStore.ISymbolDocument document, int line, int column);
                System.Diagnostics.SymbolStore.ISymbolScope GetScope(int offset);
                void GetSequencePoints(int[] offsets, System.Diagnostics.SymbolStore.ISymbolDocument[] documents, int[] lines, int[] columns, int[] endLines, int[] endColumns);
                bool GetSourceStartEnd(System.Diagnostics.SymbolStore.ISymbolDocument[] docs, int[] lines, int[] columns);
            }

            interface ISymbolNamespace
            {
                string get_Name();
                System.Diagnostics.SymbolStore.ISymbolNamespace[] GetNamespaces();
                System.Diagnostics.SymbolStore.ISymbolVariable[] GetVariables();
            }

            interface ISymbolReader
            {
                System.Diagnostics.SymbolStore.SymbolToken get_UserEntryPoint();
                System.Diagnostics.SymbolStore.ISymbolDocument GetDocument(string url, System.Guid language, System.Guid languageVendor, System.Guid documentType);
                System.Diagnostics.SymbolStore.ISymbolDocument[] GetDocuments();
                System.Diagnostics.SymbolStore.ISymbolVariable[] GetGlobalVariables();
                System.Diagnostics.SymbolStore.ISymbolMethod GetMethod(System.Diagnostics.SymbolStore.SymbolToken method);
                System.Diagnostics.SymbolStore.ISymbolMethod GetMethod(System.Diagnostics.SymbolStore.SymbolToken method, int version);
                System.Diagnostics.SymbolStore.ISymbolMethod GetMethodFromDocumentPosition(System.Diagnostics.SymbolStore.ISymbolDocument document, int line, int column);
                System.Diagnostics.SymbolStore.ISymbolNamespace[] GetNamespaces();
                byte[] GetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken parent, string name);
                System.Diagnostics.SymbolStore.ISymbolVariable[] GetVariables(System.Diagnostics.SymbolStore.SymbolToken parent);
            }

            interface ISymbolScope
            {
                int get_EndOffset();
                System.Diagnostics.SymbolStore.ISymbolMethod get_Method();
                System.Diagnostics.SymbolStore.ISymbolScope get_Parent();
                int get_StartOffset();
                System.Diagnostics.SymbolStore.ISymbolScope[] GetChildren();
                System.Diagnostics.SymbolStore.ISymbolVariable[] GetLocals();
                System.Diagnostics.SymbolStore.ISymbolNamespace[] GetNamespaces();
            }

            interface ISymbolVariable
            {
                int get_AddressField1();
                int get_AddressField2();
                int get_AddressField3();
                System.Diagnostics.SymbolStore.SymAddressKind get_AddressKind();
                object get_Attributes();
                int get_EndOffset();
                string get_Name();
                int get_StartOffset();
                byte[] GetSignature();
            }

            interface ISymbolWriter
            {
                void Close();
                void CloseMethod();
                void CloseNamespace();
                void CloseScope(int endOffset);
                System.Diagnostics.SymbolStore.ISymbolDocumentWriter DefineDocument(string url, System.Guid language, System.Guid languageVendor, System.Guid documentType);
                void DefineField(System.Diagnostics.SymbolStore.SymbolToken parent, string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);
                void DefineGlobalVariable(string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);
                void DefineLocalVariable(string name, System.Reflection.FieldAttributes attributes, byte[] signature, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
                void DefineParameter(string name, System.Reflection.ParameterAttributes attributes, int sequence, System.Diagnostics.SymbolStore.SymAddressKind addrKind, int addr1, int addr2, int addr3);
                void DefineSequencePoints(System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int[] offsets, int[] lines, int[] columns, int[] endLines, int[] endColumns);
                void Initialize(nint emitter, string filename, bool fFullBuild);
                void OpenMethod(System.Diagnostics.SymbolStore.SymbolToken method);
                void OpenNamespace(string name);
                int OpenScope(int startOffset);
                void SetMethodSourceRange(System.Diagnostics.SymbolStore.ISymbolDocumentWriter startDoc, int startLine, int startColumn, System.Diagnostics.SymbolStore.ISymbolDocumentWriter endDoc, int endLine, int endColumn);
                void SetScopeRange(int scopeID, int startOffset, int endOffset);
                void SetSymAttribute(System.Diagnostics.SymbolStore.SymbolToken parent, string name, byte[] data);
                void SetUnderlyingWriter(nint underlyingWriter);
                void SetUserEntryPoint(System.Diagnostics.SymbolStore.SymbolToken entryMethod);
                void UsingNamespace(string fullName);
            }

            enum SymAddressKind
            {
                ILOffset = 1,
                NativeRVA = 2,
                NativeRegister = 3,
                NativeRegisterRelative = 4,
                NativeOffset = 5,
                NativeRegisterRegister = 6,
                NativeRegisterStack = 7,
                NativeStackRegister = 8,
                BitField = 9,
                NativeSectionOffset = 10,
            }

            class SymDocumentType
            {
                static /*0x0*/ System.Guid Text;

                /*0x21b46c0*/ SymDocumentType();
            }

            class SymLanguageType
            {
                static /*0x0*/ System.Guid Basic;
                static /*0x10*/ System.Guid C;
                static /*0x20*/ System.Guid Cobol;
                static /*0x30*/ System.Guid CPlusPlus;
                static /*0x40*/ System.Guid CSharp;
                static /*0x50*/ System.Guid ILAssembly;
                static /*0x60*/ System.Guid Java;
                static /*0x70*/ System.Guid JScript;
                static /*0x80*/ System.Guid MCPlusPlus;
                static /*0x90*/ System.Guid Pascal;
                static /*0xa0*/ System.Guid SMC;

                /*0x21b46c8*/ SymLanguageType();
            }

            class SymLanguageVendor
            {
                static /*0x0*/ System.Guid Microsoft;

                /*0x21b46d0*/ SymLanguageVendor();
            }
        }

        namespace Tracing
        {
            enum EventActivityOptions
            {
                None = 0,
                Disable = 2,
                Recursive = 4,
                Detachable = 8,
            }

            class EventSourceException : System.Exception
            {
                /*0x21b46d8*/ EventSourceException();
                /*0x21b4748*/ EventSourceException(string message);
                /*0x21b47b0*/ EventSourceException(string message, System.Exception innerException);
                /*0x21b4820*/ EventSourceException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x21b48a0*/ EventSourceException(System.Exception innerException);
            }

            struct EventSourceOptions
            {
                static byte keywordsSet = 1;
                static byte tagsSet = 2;
                static byte levelSet = 4;
                static byte opcodeSet = 8;
                static byte activityOptionsSet = 16;
                /*0x10*/ System.Diagnostics.Tracing.EventKeywords keywords;
                /*0x18*/ System.Diagnostics.Tracing.EventTags tags;
                /*0x1c*/ System.Diagnostics.Tracing.EventActivityOptions activityOptions;
                /*0x20*/ byte level;
                /*0x21*/ byte opcode;
                /*0x22*/ byte valuesSet;

                /*0x21b4920*/ System.Diagnostics.Tracing.EventLevel get_Level();
                /*0x21b4928*/ void set_Level(System.Diagnostics.Tracing.EventLevel value);
                /*0x21b4990*/ System.Diagnostics.Tracing.EventOpcode get_Opcode();
                /*0x21b4998*/ void set_Opcode(System.Diagnostics.Tracing.EventOpcode value);
                /*0x21b4a00*/ bool get_IsOpcodeSet();
                /*0x21b4a0c*/ System.Diagnostics.Tracing.EventKeywords get_Keywords();
                /*0x21b4a14*/ void set_Keywords(System.Diagnostics.Tracing.EventKeywords value);
                /*0x21b4a28*/ System.Diagnostics.Tracing.EventTags get_Tags();
                /*0x21b4a30*/ void set_Tags(System.Diagnostics.Tracing.EventTags value);
                /*0x21b4a44*/ System.Diagnostics.Tracing.EventActivityOptions get_ActivityOptions();
                /*0x21b4a4c*/ void set_ActivityOptions(System.Diagnostics.Tracing.EventActivityOptions value);
            }

            enum EventTags
            {
                None = 0,
            }

            enum EventLevel
            {
                LogAlways = 0,
                Critical = 1,
                Error = 2,
                Warning = 3,
                Informational = 4,
                Verbose = 5,
            }

            enum EventTask
            {
                None = 0,
            }

            enum EventOpcode
            {
                Info = 0,
                Start = 1,
                Stop = 2,
                DataCollectionStart = 3,
                DataCollectionStop = 4,
                Extension = 5,
                Reply = 6,
                Resume = 7,
                Suspend = 8,
                Send = 9,
                Receive = 240,
            }

            enum EventChannel
            {
                None = 0,
                Admin = 16,
                Operational = 17,
                Analytic = 18,
                Debug = 19,
            }

            enum EventKeywords
            {
                None = 0,
                All = -1,
                MicrosoftTelemetry = 562949953421312,
                WdiContext = 562949953421312,
                WdiDiagnostic = 1125899906842624,
                Sqm = 2251799813685248,
                AuditFailure = 4503599627370496,
                AuditSuccess = 9007199254740992,
                CorrelationHint = 4503599627370496,
                EventLogClassic = 36028797018963968,
            }

            class EventAttribute : System.Attribute
            {
                /*0x10*/ int <EventId>k__BackingField;
                /*0x14*/ System.Diagnostics.Tracing.EventActivityOptions <ActivityOptions>k__BackingField;
                /*0x18*/ System.Diagnostics.Tracing.EventLevel <Level>k__BackingField;
                /*0x20*/ System.Diagnostics.Tracing.EventKeywords <Keywords>k__BackingField;
                /*0x28*/ System.Diagnostics.Tracing.EventOpcode <Opcode>k__BackingField;
                /*0x2c*/ System.Diagnostics.Tracing.EventChannel <Channel>k__BackingField;
                /*0x30*/ string <Message>k__BackingField;
                /*0x38*/ System.Diagnostics.Tracing.EventTask <Task>k__BackingField;
                /*0x3c*/ System.Diagnostics.Tracing.EventTags <Tags>k__BackingField;
                /*0x40*/ byte <Version>k__BackingField;

                /*0x21b4a60*/ EventAttribute(int eventId);
                /*0x21b4a88*/ int get_EventId();
                /*0x21b4a90*/ void set_EventId(int value);
                /*0x21b4a98*/ System.Diagnostics.Tracing.EventActivityOptions get_ActivityOptions();
                /*0x21b4aa0*/ void set_ActivityOptions(System.Diagnostics.Tracing.EventActivityOptions value);
                /*0x21b4aa8*/ System.Diagnostics.Tracing.EventLevel get_Level();
                /*0x21b4ab0*/ void set_Level(System.Diagnostics.Tracing.EventLevel value);
                /*0x21b4ab8*/ System.Diagnostics.Tracing.EventKeywords get_Keywords();
                /*0x21b4ac0*/ void set_Keywords(System.Diagnostics.Tracing.EventKeywords value);
                /*0x21b4ac8*/ System.Diagnostics.Tracing.EventOpcode get_Opcode();
                /*0x21b4ad0*/ void set_Opcode(System.Diagnostics.Tracing.EventOpcode value);
                /*0x21b4ad8*/ System.Diagnostics.Tracing.EventChannel get_Channel();
                /*0x21b4ae0*/ void set_Channel(System.Diagnostics.Tracing.EventChannel value);
                /*0x21b4ae8*/ string get_Message();
                /*0x21b4af0*/ void set_Message(string value);
                /*0x21b4af8*/ System.Diagnostics.Tracing.EventTask get_Task();
                /*0x21b4b00*/ void set_Task(System.Diagnostics.Tracing.EventTask value);
                /*0x21b4b08*/ System.Diagnostics.Tracing.EventTags get_Tags();
                /*0x21b4b10*/ void set_Tags(System.Diagnostics.Tracing.EventTags value);
                /*0x21b4b18*/ byte get_Version();
                /*0x21b4b20*/ void set_Version(byte value);
            }

            enum EventCommand
            {
                Update = 0,
                SendManifest = -1,
                Enable = -2,
                Disable = -3,
            }

            class EventCommandEventArgs : System.EventArgs
            {
                /*0x21b4b28*/ EventCommandEventArgs();
                /*0x21b4b80*/ System.Collections.Generic.IDictionary<string, string> get_Arguments();
                /*0x21b4bc0*/ System.Diagnostics.Tracing.EventCommand get_Command();
                /*0x21b4c00*/ bool DisableEvent(int eventId);
                /*0x21b4c08*/ bool EnableEvent(int eventId);
            }

            class EventCounter : System.Diagnostics.Tracing.DiagnosticCounter
            {
                /*0x21b4c10*/ EventCounter(string name, System.Diagnostics.Tracing.EventSource eventSource);
                /*0x21b4c20*/ void WriteMetric(float value);
                /*0x21b4c24*/ void WriteMetric(double value);
            }

            class EventDataAttribute : System.Attribute
            {
                /*0x21b4ca8*/ EventDataAttribute();
                /*0x21b4c28*/ string get_Name();
                /*0x21b4c68*/ void set_Name(string value);
            }

            class EventFieldAttribute : System.Attribute
            {
                /*0x21b4db0*/ EventFieldAttribute();
                /*0x21b4cb0*/ System.Diagnostics.Tracing.EventFieldFormat get_Format();
                /*0x21b4cf0*/ void set_Format(System.Diagnostics.Tracing.EventFieldFormat value);
                /*0x21b4d30*/ System.Diagnostics.Tracing.EventFieldTags get_Tags();
                /*0x21b4d70*/ void set_Tags(System.Diagnostics.Tracing.EventFieldTags value);
            }

            enum EventFieldFormat
            {
                Boolean = 3,
                Default = 0,
                Hexadecimal = 4,
                HResult = 15,
                Json = 12,
                String = 2,
                Xml = 11,
            }

            enum EventFieldTags
            {
                None = 0,
            }

            class EventIgnoreAttribute : System.Attribute
            {
                /*0x21b4db8*/ EventIgnoreAttribute();
            }

            class EventListener : System.IDisposable
            {
                /*0x10*/ System.EventHandler<System.Diagnostics.Tracing.EventSourceCreatedEventArgs> EventSourceCreated;
                /*0x18*/ System.EventHandler<System.Diagnostics.Tracing.EventWrittenEventArgs> EventWritten;

                static /*0x21b4dc8*/ int EventSourceIndex(System.Diagnostics.Tracing.EventSource eventSource);
                /*0x21b4dc0*/ EventListener();
                /*0x21b4dd0*/ void EnableEvents(System.Diagnostics.Tracing.EventSource eventSource, System.Diagnostics.Tracing.EventLevel level);
                /*0x21b4dd4*/ void EnableEvents(System.Diagnostics.Tracing.EventSource eventSource, System.Diagnostics.Tracing.EventLevel level, System.Diagnostics.Tracing.EventKeywords matchAnyKeyword);
                /*0x21b4dd8*/ void EnableEvents(System.Diagnostics.Tracing.EventSource eventSource, System.Diagnostics.Tracing.EventLevel level, System.Diagnostics.Tracing.EventKeywords matchAnyKeyword, System.Collections.Generic.IDictionary<string, string> arguments);
                /*0x21b4ddc*/ void DisableEvents(System.Diagnostics.Tracing.EventSource eventSource);
                /*0x21b4de0*/ void OnEventSourceCreated(System.Diagnostics.Tracing.EventSource eventSource);
                /*0x21b4de4*/ void OnEventWritten(System.Diagnostics.Tracing.EventWrittenEventArgs eventData);
                /*0x21b4de8*/ void Dispose();
                /*0x21b4dec*/ void add_EventSourceCreated(System.EventHandler<System.Diagnostics.Tracing.EventSourceCreatedEventArgs> value);
                /*0x21b4e9c*/ void remove_EventSourceCreated(System.EventHandler<System.Diagnostics.Tracing.EventSourceCreatedEventArgs> value);
                /*0x21b4f4c*/ void add_EventWritten(System.EventHandler<System.Diagnostics.Tracing.EventWrittenEventArgs> value);
                /*0x21b4ffc*/ void remove_EventWritten(System.EventHandler<System.Diagnostics.Tracing.EventWrittenEventArgs> value);
            }

            enum EventManifestOptions
            {
                AllCultures = 2,
                AllowEventSourceOverride = 8,
                None = 0,
                OnlyIfNeededForRegistration = 4,
                Strict = 1,
            }

            class EventSource : System.IDisposable
            {
                /*0x10*/ string <Name>k__BackingField;
                /*0x18*/ System.Diagnostics.Tracing.EventSourceSettings <Settings>k__BackingField;

                static /*0x21b5290*/ System.Guid get_CurrentThreadActivityId();
                static /*0x21b6380*/ string GenerateManifest(System.Type eventSourceType, string assemblyPathToIncludeInManifest);
                static /*0x21b63c0*/ string GenerateManifest(System.Type eventSourceType, string assemblyPathToIncludeInManifest, System.Diagnostics.Tracing.EventManifestOptions flags);
                static /*0x21b6400*/ System.Guid GetGuid(System.Type eventSourceType);
                static /*0x21b6440*/ string GetName(System.Type eventSourceType);
                static /*0x21b6480*/ System.Collections.Generic.IEnumerable<System.Diagnostics.Tracing.EventSource> GetSources();
                static /*0x21b64c0*/ void SendCommand(System.Diagnostics.Tracing.EventSource eventSource, System.Diagnostics.Tracing.EventCommand command, System.Collections.Generic.IDictionary<string, string> commandArguments);
                static /*0x21b6500*/ void SetCurrentThreadActivityId(System.Guid activityId);
                static /*0x21b6540*/ void SetCurrentThreadActivityId(System.Guid activityId, ref System.Guid oldActivityThatWillContinue);
                /*0x21b50ac*/ EventSource();
                /*0x21b50ec*/ EventSource(bool throwOnEventWriteErrors);
                /*0x21b50f0*/ EventSource(System.Diagnostics.Tracing.EventSourceSettings settings);
                /*0x21b5114*/ EventSource(System.Diagnostics.Tracing.EventSourceSettings settings, string[] traits);
                /*0x21b5138*/ EventSource(string eventSourceName);
                /*0x21b5160*/ EventSource(string eventSourceName, System.Diagnostics.Tracing.EventSourceSettings config);
                /*0x21b5190*/ EventSource(string eventSourceName, System.Diagnostics.Tracing.EventSourceSettings config, string[] traits);
                /*0x21b51c0*/ EventSource(System.Guid eventSourceGuid, string eventSourceName);
                /*0x21b51e8*/ void Finalize();
                /*0x21b5288*/ System.Exception get_ConstructionException();
                /*0x21b52e8*/ System.Guid get_Guid();
                /*0x21b5340*/ string get_Name();
                /*0x21b5348*/ void set_Name(string value);
                /*0x21b5350*/ System.Diagnostics.Tracing.EventSourceSettings get_Settings();
                /*0x21b5358*/ void set_Settings(System.Diagnostics.Tracing.EventSourceSettings value);
                /*0x21b5360*/ bool IsEnabled();
                /*0x21b5368*/ bool IsEnabled(System.Diagnostics.Tracing.EventLevel level, System.Diagnostics.Tracing.EventKeywords keywords);
                /*0x21b5370*/ bool IsEnabled(System.Diagnostics.Tracing.EventLevel level, System.Diagnostics.Tracing.EventKeywords keywords, System.Diagnostics.Tracing.EventChannel channel);
                /*0x21b5378*/ void Dispose();
                /*0x21b53e4*/ string GetTrait(string key);
                /*0x21b53ec*/ void Write(string eventName);
                /*0x21b53f0*/ void Write(string eventName, System.Diagnostics.Tracing.EventSourceOptions options);
                void Write<T>(string eventName, T data);
                void Write<T>(string eventName, System.Diagnostics.Tracing.EventSourceOptions options, T data);
                void Write<T>(string eventName, ref System.Diagnostics.Tracing.EventSourceOptions options, ref T data);
                void Write<T>(string eventName, ref System.Diagnostics.Tracing.EventSourceOptions options, ref System.Guid activityId, ref System.Guid relatedActivityId, ref T data);
                /*0x21b53f4*/ void Dispose(bool disposing);
                /*0x21b53f8*/ void OnEventCommand(System.Diagnostics.Tracing.EventCommandEventArgs command);
                /*0x21b53fc*/ void ReportOutOfBandMessage(string msg, bool flush);
                /*0x21b5400*/ void WriteEvent(int eventId);
                /*0x21b5448*/ void WriteEvent(int eventId, byte[] arg1);
                /*0x21b54d4*/ void WriteEvent(int eventId, int arg1);
                /*0x21b5590*/ void WriteEvent(int eventId, string arg1);
                /*0x21b561c*/ void WriteEvent(int eventId, int arg1, int arg2);
                /*0x21b5720*/ void WriteEvent(int eventId, int arg1, int arg2, int arg3);
                /*0x21b586c*/ void WriteEvent(int eventId, int arg1, string arg2);
                /*0x21b595c*/ void WriteEvent(int eventId, long arg1);
                /*0x21b5a18*/ void WriteEvent(int eventId, long arg1, byte[] arg2);
                /*0x21b5b08*/ void WriteEvent(int eventId, long arg1, long arg2);
                /*0x21b5c0c*/ void WriteEvent(int eventId, long arg1, long arg2, long arg3);
                /*0x21b5d58*/ void WriteEvent(int eventId, long arg1, string arg2);
                /*0x21b5444*/ void WriteEvent(int eventId, object[] args);
                /*0x21b5e48*/ void WriteEvent(int eventId, string arg1, int arg2);
                /*0x21b5f30*/ void WriteEvent(int eventId, string arg1, int arg2, int arg3);
                /*0x21b6060*/ void WriteEvent(int eventId, string arg1, long arg2);
                /*0x21b6148*/ void WriteEvent(int eventId, string arg1, string arg2);
                /*0x21b6208*/ void WriteEvent(int eventId, string arg1, string arg2, string arg3);
                /*0x21b62f4*/ void WriteEventCore(int eventId, int eventDataCount, System.Diagnostics.Tracing.EventSource.EventData* data);
                /*0x21b62f8*/ void WriteEventWithRelatedActivityId(int eventId, System.Guid relatedActivityId, object[] args);
                /*0x21b62fc*/ void WriteEventWithRelatedActivityIdCore(int eventId, System.Guid* relatedActivityId, int eventDataCount, System.Diagnostics.Tracing.EventSource.EventData* data);
                /*0x21b6300*/ void add_EventCommandExecuted(System.EventHandler<System.Diagnostics.Tracing.EventCommandEventArgs> value);
                /*0x21b6340*/ void remove_EventCommandExecuted(System.EventHandler<System.Diagnostics.Tracing.EventCommandEventArgs> value);

                struct EventData
                {
                    /*0x10*/ nint <DataPointer>k__BackingField;
                    /*0x18*/ int <Size>k__BackingField;
                    /*0x1c*/ int <Reserved>k__BackingField;

                    /*0x21b6580*/ void set_DataPointer(nint value);
                    /*0x21b6588*/ void set_Size(int value);
                    /*0x21b6590*/ void set_Reserved(int value);
                }
            }

            class EventSourceAttribute : System.Attribute
            {
                /*0x10*/ string <Guid>k__BackingField;
                /*0x18*/ string <LocalizationResources>k__BackingField;
                /*0x20*/ string <Name>k__BackingField;

                /*0x21b65c8*/ EventSourceAttribute();
                /*0x21b6598*/ string get_Guid();
                /*0x21b65a0*/ void set_Guid(string value);
                /*0x21b65a8*/ string get_LocalizationResources();
                /*0x21b65b0*/ void set_LocalizationResources(string value);
                /*0x21b65b8*/ string get_Name();
                /*0x21b65c0*/ void set_Name(string value);
            }

            class EventSourceCreatedEventArgs : System.EventArgs
            {
                /*0x10*/ System.Diagnostics.Tracing.EventSource <EventSource>k__BackingField;

                /*0x21b65e0*/ EventSourceCreatedEventArgs();
                /*0x21b65d0*/ System.Diagnostics.Tracing.EventSource get_EventSource();
                /*0x21b65d8*/ void set_EventSource(System.Diagnostics.Tracing.EventSource value);
            }

            enum EventSourceSettings
            {
                Default = 0,
                ThrowOnEventWriteErrors = 1,
                EtwManifestEventFormat = 4,
                EtwSelfDescribingEventFormat = 8,
            }

            class EventWrittenEventArgs : System.EventArgs
            {
                /*0x10*/ int <EventId>k__BackingField;
                /*0x18*/ long <OSThreadId>k__BackingField;
                /*0x20*/ System.DateTime <TimeStamp>k__BackingField;
                /*0x28*/ string <EventName>k__BackingField;
                /*0x30*/ System.Diagnostics.Tracing.EventSource <EventSource>k__BackingField;
                /*0x38*/ string <Message>k__BackingField;
                /*0x40*/ System.Collections.ObjectModel.ReadOnlyCollection<object> <Payload>k__BackingField;
                /*0x48*/ System.Collections.ObjectModel.ReadOnlyCollection<string> <PayloadNames>k__BackingField;
                /*0x50*/ System.Guid <RelatedActivityId>k__BackingField;

                /*0x21b6638*/ EventWrittenEventArgs(System.Diagnostics.Tracing.EventSource eventSource);
                /*0x21b67c0*/ EventWrittenEventArgs();
                /*0x21b66a4*/ System.Guid get_ActivityId();
                /*0x21b66f4*/ System.Diagnostics.Tracing.EventChannel get_Channel();
                /*0x21b66fc*/ int get_EventId();
                /*0x21b6704*/ void set_EventId(int value);
                /*0x21b670c*/ long get_OSThreadId();
                /*0x21b6714*/ void set_OSThreadId(long value);
                /*0x21b671c*/ System.DateTime get_TimeStamp();
                /*0x21b6724*/ void set_TimeStamp(System.DateTime value);
                /*0x21b672c*/ string get_EventName();
                /*0x21b6734*/ void set_EventName(string value);
                /*0x21b673c*/ System.Diagnostics.Tracing.EventSource get_EventSource();
                /*0x21b6744*/ void set_EventSource(System.Diagnostics.Tracing.EventSource value);
                /*0x21b674c*/ System.Diagnostics.Tracing.EventKeywords get_Keywords();
                /*0x21b6754*/ System.Diagnostics.Tracing.EventLevel get_Level();
                /*0x21b675c*/ string get_Message();
                /*0x21b6764*/ void set_Message(string value);
                /*0x21b676c*/ System.Diagnostics.Tracing.EventOpcode get_Opcode();
                /*0x21b6774*/ System.Collections.ObjectModel.ReadOnlyCollection<object> get_Payload();
                /*0x21b677c*/ void set_Payload(System.Collections.ObjectModel.ReadOnlyCollection<object> value);
                /*0x21b6784*/ System.Collections.ObjectModel.ReadOnlyCollection<string> get_PayloadNames();
                /*0x21b678c*/ void set_PayloadNames(System.Collections.ObjectModel.ReadOnlyCollection<string> value);
                /*0x21b6794*/ System.Guid get_RelatedActivityId();
                /*0x21b67a0*/ void set_RelatedActivityId(System.Guid value);
                /*0x21b67a8*/ System.Diagnostics.Tracing.EventTags get_Tags();
                /*0x21b67b0*/ System.Diagnostics.Tracing.EventTask get_Task();
                /*0x21b67b8*/ byte get_Version();
            }

            class NonEventAttribute : System.Attribute
            {
                /*0x21b67f8*/ NonEventAttribute();
            }

            class DiagnosticCounter : System.IDisposable
            {
                /*0x10*/ string <DisplayName>k__BackingField;
                /*0x18*/ string <DisplayUnits>k__BackingField;
                /*0x20*/ System.Diagnostics.Tracing.EventSource <EventSource>k__BackingField;
                /*0x28*/ string <Name>k__BackingField;

                /*0x21b4c18*/ DiagnosticCounter(string name, System.Diagnostics.Tracing.EventSource eventSource);
                /*0x21b6800*/ DiagnosticCounter();
                /*0x21b6808*/ string get_DisplayName();
                /*0x21b6810*/ void set_DisplayName(string value);
                /*0x21b6818*/ string get_DisplayUnits();
                /*0x21b6820*/ void set_DisplayUnits(string value);
                /*0x21b6828*/ System.Diagnostics.Tracing.EventSource get_EventSource();
                /*0x21b6830*/ string get_Name();
                /*0x21b6838*/ void AddMetadata(string key, string value);
                /*0x21b683c*/ void Dispose();
            }

            class IncrementingEventCounter : System.Diagnostics.Tracing.DiagnosticCounter
            {
                /*0x30*/ System.TimeSpan <DisplayRateTimeScale>k__BackingField;

                /*0x21b6840*/ IncrementingEventCounter(string name, System.Diagnostics.Tracing.EventSource eventSource);
                /*0x21b6848*/ void Increment(double increment);
                /*0x21b684c*/ System.TimeSpan get_DisplayRateTimeScale();
                /*0x21b6854*/ void set_DisplayRateTimeScale(System.TimeSpan value);
            }

            class IncrementingPollingCounter : System.Diagnostics.Tracing.DiagnosticCounter
            {
                /*0x30*/ System.TimeSpan <DisplayRateTimeScale>k__BackingField;

                /*0x21b685c*/ IncrementingPollingCounter(string name, System.Diagnostics.Tracing.EventSource eventSource, System.Func<double> totalValueProvider);
                /*0x21b6864*/ System.TimeSpan get_DisplayRateTimeScale();
                /*0x21b686c*/ void set_DisplayRateTimeScale(System.TimeSpan value);
            }

            class PollingCounter : System.Diagnostics.Tracing.DiagnosticCounter
            {
                /*0x21b6874*/ PollingCounter(string name, System.Diagnostics.Tracing.EventSource eventSource, System.Func<double> metricProvider);
            }
        }

        namespace CodeAnalysis
        {
            class SuppressMessageAttribute : System.Attribute
            {
                /*0x10*/ string <Category>k__BackingField;
                /*0x18*/ string <CheckId>k__BackingField;
                /*0x20*/ string <Scope>k__BackingField;
                /*0x28*/ string <Target>k__BackingField;
                /*0x30*/ string <MessageId>k__BackingField;
                /*0x38*/ string <Justification>k__BackingField;

                /*0x21b687c*/ SuppressMessageAttribute(string category, string checkId);
                /*0x21b68a8*/ string get_Category();
                /*0x21b68b0*/ string get_CheckId();
                /*0x21b68b8*/ string get_Scope();
                /*0x21b68c0*/ void set_Scope(string value);
                /*0x21b68c8*/ string get_Target();
                /*0x21b68d0*/ void set_Target(string value);
                /*0x21b68d8*/ string get_MessageId();
                /*0x21b68e0*/ void set_MessageId(string value);
                /*0x21b68e8*/ string get_Justification();
                /*0x21b68f0*/ void set_Justification(string value);
            }

            class AllowNullAttribute : System.Attribute
            {
                /*0x21b68f8*/ AllowNullAttribute();
            }

            class DisallowNullAttribute : System.Attribute
            {
                /*0x21b6900*/ DisallowNullAttribute();
            }

            class MaybeNullAttribute : System.Attribute
            {
                /*0x21b6908*/ MaybeNullAttribute();
            }

            class NotNullAttribute : System.Attribute
            {
                /*0x21b6910*/ NotNullAttribute();
            }

            class MaybeNullWhenAttribute : System.Attribute
            {
                /*0x10*/ bool <ReturnValue>k__BackingField;

                /*0x21b6918*/ MaybeNullWhenAttribute(bool returnValue);
                /*0x21b6940*/ bool get_ReturnValue();
            }

            class NotNullWhenAttribute : System.Attribute
            {
                /*0x10*/ bool <ReturnValue>k__BackingField;

                /*0x21b6948*/ NotNullWhenAttribute(bool returnValue);
                /*0x21b6970*/ bool get_ReturnValue();
            }

            class NotNullIfNotNullAttribute : System.Attribute
            {
                /*0x10*/ string <ParameterName>k__BackingField;

                /*0x21b6978*/ NotNullIfNotNullAttribute(string parameterName);
                /*0x21b69a0*/ string get_ParameterName();
            }

            class DoesNotReturnAttribute : System.Attribute
            {
                /*0x21b69a8*/ DoesNotReturnAttribute();
            }

            class DoesNotReturnIfAttribute : System.Attribute
            {
                /*0x10*/ bool <ParameterValue>k__BackingField;

                /*0x21b69b0*/ DoesNotReturnIfAttribute(bool parameterValue);
                /*0x21b69d8*/ bool get_ParameterValue();
            }
        }
    }

    namespace Configuration
    {
        namespace Assemblies
        {
            enum AssemblyHashAlgorithm
            {
                None = 0,
                MD5 = 32771,
                SHA1 = 32772,
                SHA256 = 32780,
                SHA384 = 32781,
                SHA512 = 32782,
            }

            enum AssemblyVersionCompatibility
            {
                SameMachine = 1,
                SameProcess = 2,
                SameDomain = 3,
            }

            struct AssemblyHash : System.ICloneable
            {
                static /*0x0*/ System.Configuration.Assemblies.AssemblyHash Empty;
                /*0x10*/ System.Configuration.Assemblies.AssemblyHashAlgorithm _algorithm;
                /*0x18*/ byte[] _value;

                static /*0x21b6b2c*/ AssemblyHash();
                /*0x21b69f0*/ AssemblyHash(System.Configuration.Assemblies.AssemblyHashAlgorithm algorithm, byte[] value);
                /*0x21b6aa0*/ AssemblyHash(byte[] value);
                /*0x21b69e0*/ System.Configuration.Assemblies.AssemblyHashAlgorithm get_Algorithm();
                /*0x21b69e8*/ void set_Algorithm(System.Configuration.Assemblies.AssemblyHashAlgorithm value);
                /*0x21b6aac*/ object Clone();
                /*0x21b6b1c*/ byte[] GetValue();
                /*0x21b6b24*/ void SetValue(byte[] value);
            }
        }
    }

    namespace Collections
    {
        class Comparer : System.Collections.IComparer, System.Runtime.Serialization.ISerializable
        {
            static /*0x0*/ System.Collections.Comparer Default;
            static /*0x8*/ System.Collections.Comparer DefaultInvariant;
            /*0x10*/ System.Globalization.CompareInfo _compareInfo;

            static /*0x21b7048*/ Comparer();
            /*0x21b6b94*/ Comparer(System.Globalization.CultureInfo culture);
            /*0x21b6c20*/ Comparer(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x21b6d94*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x21b6e38*/ int Compare(object a, object b);
        }

        struct DictionaryEntry
        {
            /*0x10*/ object _key;
            /*0x18*/ object _value;

            /*0x21b710c*/ DictionaryEntry(object key, object value);
            /*0x21b7114*/ object get_Key();
            /*0x21b711c*/ void set_Key(object value);
            /*0x21b7124*/ object get_Value();
            /*0x21b712c*/ void set_Value(object value);
            /*0x21b7134*/ void Deconstruct(ref object key, ref object value);
        }

        class HashHelpers
        {
            static int HashCollisionThreshold = 100;
            static int HashPrime = 101;
            static int MaxPrimeArrayLength = 2146435069;
            static /*0x0*/ int[] primes;
            static /*0x8*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.Serialization.SerializationInfo> s_serializationInfoTable;

            static /*0x21b74ec*/ HashHelpers();
            static /*0x21b7148*/ bool IsPrime(int candidate);
            static /*0x21b71f8*/ int GetPrime(int min);
            static /*0x21b7388*/ int ExpandPrime(int oldSize);
            static /*0x21b740c*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.Serialization.SerializationInfo> get_SerializationInfoTable();
        }

        interface ICollection : System.Collections.IEnumerable
        {
            void CopyTo(System.Array array, int index);
            int get_Count();
            object get_SyncRoot();
            bool get_IsSynchronized();
        }

        interface IComparer
        {
            int Compare(object x, object y);
        }

        interface IDictionary : System.Collections.ICollection, System.Collections.IEnumerable
        {
            object get_Item(object key);
            void set_Item(object key, object value);
            System.Collections.ICollection get_Keys();
            System.Collections.ICollection get_Values();
            bool Contains(object key);
            void Add(object key, object value);
            void Clear();
            bool get_IsReadOnly();
            bool get_IsFixedSize();
            System.Collections.IDictionaryEnumerator GetEnumerator();
            void Remove(object key);
        }

        interface IDictionaryEnumerator : System.Collections.IEnumerator
        {
            object get_Key();
            object get_Value();
            System.Collections.DictionaryEntry get_Entry();
        }

        interface IEnumerable
        {
            System.Collections.IEnumerator GetEnumerator();
        }

        interface IEnumerator
        {
            bool MoveNext();
            object get_Current();
            void Reset();
        }

        interface IEqualityComparer
        {
            bool Equals(object x, object y);
            int GetHashCode(object obj);
        }

        interface IList : System.Collections.ICollection, System.Collections.IEnumerable
        {
            object get_Item(int index);
            void set_Item(int index, object value);
            int Add(object value);
            bool Contains(object value);
            void Clear();
            bool get_IsReadOnly();
            bool get_IsFixedSize();
            int IndexOf(object value);
            void Insert(int index, object value);
            void Remove(object value);
            void RemoveAt(int index);
        }

        interface IStructuralComparable
        {
            int CompareTo(object other, System.Collections.IComparer comparer);
        }

        interface IStructuralEquatable
        {
            bool Equals(object other, System.Collections.IEqualityComparer comparer);
            int GetHashCode(System.Collections.IEqualityComparer comparer);
        }

        class ListDictionaryInternal : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x10*/ System.Collections.ListDictionaryInternal.DictionaryNode head;
            /*0x18*/ int version;
            /*0x1c*/ int count;
            /*0x20*/ object _syncRoot;

            /*0x21b7580*/ ListDictionaryInternal();
            /*0x21b7588*/ object get_Item(object key);
            /*0x21b7640*/ void set_Item(object key, object value);
            /*0x21b7790*/ int get_Count();
            /*0x21b7798*/ System.Collections.ICollection get_Keys();
            /*0x21b7834*/ bool get_IsReadOnly();
            /*0x21b783c*/ bool get_IsFixedSize();
            /*0x21b7844*/ bool get_IsSynchronized();
            /*0x21b784c*/ object get_SyncRoot();
            /*0x21b78c4*/ System.Collections.ICollection get_Values();
            /*0x21b792c*/ void Add(object key, object value);
            /*0x21b7ad0*/ void Clear();
            /*0x21b7ae4*/ bool Contains(object key);
            /*0x21b7b9c*/ void CopyTo(System.Array array, int index);
            /*0x21b7d84*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x21b7e28*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x21b7e88*/ void Remove(object key);

            class NodeEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
            {
                /*0x10*/ System.Collections.ListDictionaryInternal list;
                /*0x18*/ System.Collections.ListDictionaryInternal.DictionaryNode current;
                /*0x20*/ int version;
                /*0x24*/ bool start;

                /*0x21b7de4*/ NodeEnumerator(System.Collections.ListDictionaryInternal list);
                /*0x21b7f88*/ object get_Current();
                /*0x21b7fec*/ System.Collections.DictionaryEntry get_Entry();
                /*0x21b8050*/ object get_Key();
                /*0x21b80b4*/ object get_Value();
                /*0x21b8118*/ bool MoveNext();
                /*0x21b81b8*/ void Reset();
            }

            class NodeKeyValueCollection : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.ListDictionaryInternal list;
                /*0x18*/ bool isKeys;

                /*0x21b7804*/ NodeKeyValueCollection(System.Collections.ListDictionaryInternal list, bool isKeys);
                /*0x21b8238*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
                /*0x21b8404*/ int System.Collections.ICollection.get_Count();
                /*0x21b843c*/ bool System.Collections.ICollection.get_IsSynchronized();
                /*0x21b8444*/ object System.Collections.ICollection.get_SyncRoot();
                /*0x21b845c*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();

                class NodeKeyValueEnumerator : System.Collections.IEnumerator
                {
                    /*0x10*/ System.Collections.ListDictionaryInternal list;
                    /*0x18*/ System.Collections.ListDictionaryInternal.DictionaryNode current;
                    /*0x20*/ int version;
                    /*0x24*/ bool isKeys;
                    /*0x25*/ bool start;

                    /*0x21b84d4*/ NodeKeyValueEnumerator(System.Collections.ListDictionaryInternal list, bool isKeys);
                    /*0x21b8520*/ object get_Current();
                    /*0x21b8598*/ bool MoveNext();
                    /*0x21b8638*/ void Reset();
                }
            }

            class DictionaryNode
            {
                /*0x10*/ object key;
                /*0x18*/ object value;
                /*0x20*/ System.Collections.ListDictionaryInternal.DictionaryNode next;

                /*0x21b7788*/ DictionaryNode();
            }
        }

        class CompatibleComparer : System.Collections.IEqualityComparer
        {
            /*0x10*/ System.Collections.IHashCodeProvider _hcp;
            /*0x18*/ System.Collections.IComparer _comparer;

            /*0x21b86b8*/ CompatibleComparer(System.Collections.IHashCodeProvider hashCodeProvider, System.Collections.IComparer comparer);
            /*0x21b86e4*/ System.Collections.IHashCodeProvider get_HashCodeProvider();
            /*0x21b86ec*/ System.Collections.IComparer get_Comparer();
            /*0x21b86f4*/ bool Equals(object a, object b);
            /*0x21b870c*/ int Compare(object a, object b);
            /*0x21b88d0*/ int GetHashCode(object obj);
        }

        class CaseInsensitiveComparer : System.Collections.IComparer
        {
            static /*0x0*/ System.Collections.CaseInsensitiveComparer s_InvariantCaseInsensitiveComparer;
            /*0x10*/ System.Globalization.CompareInfo _compareInfo;

            static /*0x21b8ae4*/ System.Collections.CaseInsensitiveComparer get_Default();
            static /*0x21b8b70*/ System.Collections.CaseInsensitiveComparer get_DefaultInvariant();
            /*0x21b89dc*/ CaseInsensitiveComparer();
            /*0x21b8a58*/ CaseInsensitiveComparer(System.Globalization.CultureInfo culture);
            /*0x21b8c30*/ int Compare(object a, object b);
        }

        class CaseInsensitiveHashCodeProvider : System.Collections.IHashCodeProvider
        {
            static /*0x0*/ System.Collections.CaseInsensitiveHashCodeProvider s_invariantCaseInsensitiveHashCodeProvider;
            /*0x10*/ System.Globalization.CompareInfo _compareInfo;

            static /*0x21b8e24*/ System.Collections.CaseInsensitiveHashCodeProvider get_Default();
            static /*0x21b8e7c*/ System.Collections.CaseInsensitiveHashCodeProvider get_DefaultInvariant();
            /*0x21b8d1c*/ CaseInsensitiveHashCodeProvider();
            /*0x21b8d98*/ CaseInsensitiveHashCodeProvider(System.Globalization.CultureInfo culture);
            /*0x21b8f2c*/ int GetHashCode(object obj);
        }

        class CollectionBase : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x10*/ System.Collections.ArrayList _list;

            /*0x21b9004*/ CollectionBase();
            /*0x21b9070*/ CollectionBase(int capacity);
            /*0x21b90ec*/ System.Collections.ArrayList get_InnerList();
            /*0x21b90f4*/ System.Collections.IList get_List();
            /*0x21b90f8*/ int get_Capacity();
            /*0x21b911c*/ void set_Capacity(int value);
            /*0x21b9140*/ int get_Count();
            /*0x21b9164*/ void Clear();
            /*0x21b91b0*/ void RemoveAt(int index);
            /*0x21b9388*/ bool System.Collections.IList.get_IsReadOnly();
            /*0x21b93ac*/ bool System.Collections.IList.get_IsFixedSize();
            /*0x21b93d0*/ bool System.Collections.ICollection.get_IsSynchronized();
            /*0x21b93f4*/ object System.Collections.ICollection.get_SyncRoot();
            /*0x21b9418*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
            /*0x21b943c*/ object System.Collections.IList.get_Item(int index);
            /*0x21b94f8*/ void System.Collections.IList.set_Item(int index, object value);
            /*0x21b96e0*/ bool System.Collections.IList.Contains(object value);
            /*0x21b9704*/ int System.Collections.IList.Add(object value);
            /*0x21b9844*/ void System.Collections.IList.Remove(object value);
            /*0x21b99e0*/ int System.Collections.IList.IndexOf(object value);
            /*0x21b9a04*/ void System.Collections.IList.Insert(int index, object value);
            /*0x21b9bb8*/ System.Collections.IEnumerator GetEnumerator();
            /*0x21b9bdc*/ void OnSet(int index, object oldValue, object newValue);
            /*0x21b9be0*/ void OnInsert(int index, object value);
            /*0x21b9be4*/ void OnClear();
            /*0x21b9be8*/ void OnRemove(int index, object value);
            /*0x21b9bec*/ void OnValidate(object value);
            /*0x21b9c44*/ void OnSetComplete(int index, object oldValue, object newValue);
            /*0x21b9c48*/ void OnInsertComplete(int index, object value);
            /*0x21b9c4c*/ void OnClearComplete();
            /*0x21b9c50*/ void OnRemoveComplete(int index, object value);
        }

        class DictionaryBase : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x10*/ System.Collections.Hashtable _hashtable;

            /*0x21ba3bc*/ DictionaryBase();
            /*0x21b9c54*/ System.Collections.Hashtable get_InnerHashtable();
            /*0x21b9cd0*/ System.Collections.IDictionary get_Dictionary();
            /*0x21b9cd4*/ int get_Count();
            /*0x21b9cf0*/ bool System.Collections.IDictionary.get_IsReadOnly();
            /*0x21b9d14*/ bool System.Collections.IDictionary.get_IsFixedSize();
            /*0x21b9d38*/ bool System.Collections.ICollection.get_IsSynchronized();
            /*0x21b9d5c*/ System.Collections.ICollection System.Collections.IDictionary.get_Keys();
            /*0x21b9d80*/ object System.Collections.ICollection.get_SyncRoot();
            /*0x21b9da4*/ System.Collections.ICollection System.Collections.IDictionary.get_Values();
            /*0x21b9dc8*/ void CopyTo(System.Array array, int index);
            /*0x21b9e04*/ object System.Collections.IDictionary.get_Item(object key);
            /*0x21b9e64*/ void System.Collections.IDictionary.set_Item(object key, object value);
            /*0x21ba018*/ bool System.Collections.IDictionary.Contains(object key);
            /*0x21ba044*/ void System.Collections.IDictionary.Add(object key, object value);
            /*0x21ba174*/ void Clear();
            /*0x21ba1c4*/ void System.Collections.IDictionary.Remove(object key);
            /*0x21ba348*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x21ba36c*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x21ba390*/ object OnGet(object key, object currentValue);
            /*0x21ba398*/ void OnSet(object key, object oldValue, object newValue);
            /*0x21ba39c*/ void OnInsert(object key, object value);
            /*0x21ba3a0*/ void OnClear();
            /*0x21ba3a4*/ void OnRemove(object key, object value);
            /*0x21ba3a8*/ void OnValidate(object key, object value);
            /*0x21ba3ac*/ void OnSetComplete(object key, object oldValue, object newValue);
            /*0x21ba3b0*/ void OnInsertComplete(object key, object value);
            /*0x21ba3b4*/ void OnClearComplete();
            /*0x21ba3b8*/ void OnRemoveComplete(object key, object value);
        }

        class KeyValuePairs
        {
            /*0x10*/ object _key;
            /*0x18*/ object _value;

            /*0x21ba3c4*/ KeyValuePairs(object key, object value);
        }

        class Queue : System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            static int _MinimumGrow = 4;
            static int _ShrinkThreshold = 32;
            /*0x10*/ object[] _array;
            /*0x18*/ int _head;
            /*0x1c*/ int _tail;
            /*0x20*/ int _size;
            /*0x24*/ int _growFactor;
            /*0x28*/ int _version;
            /*0x30*/ object _syncRoot;

            static /*0x21baffc*/ System.Collections.Queue Synchronized(System.Collections.Queue queue);
            /*0x21ba3f0*/ Queue();
            /*0x21ba5bc*/ Queue(int capacity);
            /*0x21ba3fc*/ Queue(int capacity, float growFactor);
            /*0x21ba5c4*/ Queue(System.Collections.ICollection col);
            /*0x21ba830*/ int get_Count();
            /*0x21ba838*/ object Clone();
            /*0x21ba91c*/ bool get_IsSynchronized();
            /*0x21ba924*/ object get_SyncRoot();
            /*0x21ba9a0*/ void Clear();
            /*0x21baa10*/ void CopyTo(System.Array array, int index);
            /*0x21bac04*/ void Enqueue(object obj);
            /*0x21badec*/ System.Collections.IEnumerator GetEnumerator();
            /*0x21bae9c*/ object Dequeue();
            /*0x21baf68*/ object Peek();
            /*0x21bb0f8*/ bool Contains(object obj);
            /*0x21bb1ac*/ object GetElement(int i);
            /*0x21bb1ec*/ object[] ToArray();
            /*0x21bad00*/ void SetCapacity(int capacity);
            /*0x21bb304*/ void TrimToSize();

            class SynchronizedQueue : System.Collections.Queue
            {
                /*0x38*/ System.Collections.Queue _q;
                /*0x40*/ object _root;

                /*0x21bb0ac*/ SynchronizedQueue(System.Collections.Queue q);
                /*0x21bb30c*/ bool get_IsSynchronized();
                /*0x21bb314*/ object get_SyncRoot();
                /*0x21bb31c*/ int get_Count();
                /*0x21bb3fc*/ void Clear();
                /*0x21bb4d0*/ object Clone();
                /*0x21bb648*/ bool Contains(object obj);
                /*0x21bb734*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x21bb818*/ void Enqueue(object value);
                /*0x21bb8f4*/ object Dequeue();
                /*0x21bb9d8*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21bbabc*/ object Peek();
                /*0x21bbba0*/ object[] ToArray();
                /*0x21bbc84*/ void TrimToSize();
            }

            class QueueEnumerator : System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.Queue _q;
                /*0x18*/ int _index;
                /*0x1c*/ int _version;
                /*0x20*/ object _currentElement;

                /*0x21bae4c*/ QueueEnumerator(System.Collections.Queue q);
                /*0x21bbd58*/ object Clone();
                /*0x21bbd60*/ bool MoveNext();
                /*0x21bbe28*/ object get_Current();
                /*0x21bbebc*/ void Reset();
            }

            class QueueDebugView
            {
            }
        }

        class ReadOnlyCollectionBase : System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x10*/ System.Collections.ArrayList _list;

            /*0x21bc10c*/ ReadOnlyCollectionBase();
            /*0x21bbf48*/ System.Collections.ArrayList get_InnerList();
            /*0x21bc040*/ int get_Count();
            /*0x21bc064*/ bool System.Collections.ICollection.get_IsSynchronized();
            /*0x21bc088*/ object System.Collections.ICollection.get_SyncRoot();
            /*0x21bc0ac*/ void System.Collections.ICollection.CopyTo(System.Array array, int index);
            /*0x21bc0e8*/ System.Collections.IEnumerator GetEnumerator();
        }

        class SortedList : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            static int _defaultCapacity = 16;
            static int MaxArrayLength = 2146435071;
            /*0x10*/ object[] keys;
            /*0x18*/ object[] values;
            /*0x20*/ int _size;
            /*0x24*/ int version;
            /*0x28*/ System.Collections.IComparer comparer;
            /*0x30*/ System.Collections.SortedList.KeyList keyList;
            /*0x38*/ System.Collections.SortedList.ValueList valueList;
            /*0x40*/ object _syncRoot;

            static /*0x21bdc04*/ System.Collections.SortedList Synchronized(System.Collections.SortedList list);
            /*0x21bc114*/ SortedList();
            /*0x21bc268*/ SortedList(int initialCapacity);
            /*0x21bc3b0*/ SortedList(System.Collections.IComparer comparer);
            /*0x21bc3e4*/ SortedList(System.Collections.IComparer comparer, int capacity);
            /*0x21bc418*/ SortedList(System.Collections.IDictionary d);
            /*0x21bc420*/ SortedList(System.Collections.IDictionary d, System.Collections.IComparer comparer);
            /*0x21bc130*/ void Init();
            /*0x21bc874*/ void Add(object key, object value);
            /*0x21bcad4*/ int get_Capacity();
            /*0x21bcaf0*/ void set_Capacity(int value);
            /*0x21bccd8*/ int get_Count();
            /*0x21bcce0*/ System.Collections.ICollection get_Keys();
            /*0x21bccf0*/ System.Collections.ICollection get_Values();
            /*0x21bcd00*/ bool get_IsReadOnly();
            /*0x21bcd08*/ bool get_IsFixedSize();
            /*0x21bcd10*/ bool get_IsSynchronized();
            /*0x21bcd18*/ object get_SyncRoot();
            /*0x21bcd90*/ void Clear();
            /*0x21bcdd4*/ object Clone();
            /*0x21bce80*/ bool Contains(object key);
            /*0x21bcea4*/ bool ContainsKey(object key);
            /*0x21bcec8*/ bool ContainsValue(object value);
            /*0x21bceec*/ void CopyTo(System.Array array, int arrayIndex);
            /*0x21bd180*/ System.Collections.KeyValuePairs[] ToKeyValuePairsArray();
            /*0x21bd2e8*/ void EnsureCapacity(int min);
            /*0x21bd334*/ object GetByIndex(int index);
            /*0x21bd3f0*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x21bd4c0*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x21bd530*/ object GetKey(int index);
            /*0x21bd5ec*/ System.Collections.IList GetKeyList();
            /*0x21bd684*/ System.Collections.IList GetValueList();
            /*0x21bd71c*/ object get_Item(object key);
            /*0x21bd76c*/ void set_Item(object key, object value);
            /*0x21bd890*/ int IndexOfKey(object key);
            /*0x21bd930*/ int IndexOfValue(object value);
            /*0x21bc9a4*/ void Insert(int index, object key, object value);
            /*0x21bd990*/ void RemoveAt(int index);
            /*0x21bdacc*/ void Remove(object key);
            /*0x21bdb0c*/ void SetByIndex(int index, object value);
            /*0x21bdd04*/ void TrimToSize();

            class SyncSortedList : System.Collections.SortedList
            {
                /*0x48*/ System.Collections.SortedList _list;
                /*0x50*/ object _root;

                /*0x21bdcb4*/ SyncSortedList(System.Collections.SortedList list);
                /*0x21bdd18*/ int get_Count();
                /*0x21bddfc*/ object get_SyncRoot();
                /*0x21bde04*/ bool get_IsReadOnly();
                /*0x21bde28*/ bool get_IsFixedSize();
                /*0x21bde4c*/ bool get_IsSynchronized();
                /*0x21bde54*/ object get_Item(object key);
                /*0x21bdf40*/ void set_Item(object key, object value);
                /*0x21be024*/ void Add(object key, object value);
                /*0x21be108*/ int get_Capacity();
                /*0x21be1ec*/ void Clear();
                /*0x21be2c0*/ object Clone();
                /*0x21be3a4*/ bool Contains(object key);
                /*0x21be490*/ bool ContainsKey(object key);
                /*0x21be57c*/ bool ContainsValue(object key);
                /*0x21be668*/ void CopyTo(System.Array array, int index);
                /*0x21be74c*/ object GetByIndex(int index);
                /*0x21be838*/ System.Collections.IDictionaryEnumerator GetEnumerator();
                /*0x21be91c*/ object GetKey(int index);
                /*0x21bea08*/ System.Collections.IList GetKeyList();
                /*0x21beaec*/ System.Collections.IList GetValueList();
                /*0x21bebd0*/ int IndexOfKey(object key);
                /*0x21bed24*/ int IndexOfValue(object value);
                /*0x21bee10*/ void RemoveAt(int index);
                /*0x21beeec*/ void Remove(object key);
                /*0x21befc8*/ void SetByIndex(int index, object value);
                /*0x21bf0ac*/ System.Collections.KeyValuePairs[] ToKeyValuePairsArray();
                /*0x21bf0d0*/ void TrimToSize();
            }

            class SortedListEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.SortedList _sortedList;
                /*0x18*/ object _key;
                /*0x20*/ object _value;
                /*0x28*/ int _index;
                /*0x2c*/ int _startIndex;
                /*0x30*/ int _endIndex;
                /*0x34*/ int _version;
                /*0x38*/ bool _current;
                /*0x3c*/ int _getObjectRetType;

                /*0x21bd460*/ SortedListEnumerator(System.Collections.SortedList sortedList, int index, int count, int getObjRetType);
                /*0x21bf1a4*/ object Clone();
                /*0x21bf1ac*/ object get_Key();
                /*0x21bf250*/ bool MoveNext();
                /*0x21bf33c*/ System.Collections.DictionaryEntry get_Entry();
                /*0x21bf3fc*/ object get_Current();
                /*0x21bf4e4*/ object get_Value();
                /*0x21bf588*/ void Reset();
            }

            class KeyList : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.SortedList sortedList;

                /*0x21bd65c*/ KeyList(System.Collections.SortedList sortedList);
                /*0x21bf60c*/ int get_Count();
                /*0x21bf628*/ bool get_IsReadOnly();
                /*0x21bf630*/ bool get_IsFixedSize();
                /*0x21bf638*/ bool get_IsSynchronized();
                /*0x21bf65c*/ object get_SyncRoot();
                /*0x21bf680*/ int Add(object key);
                /*0x21bf6d0*/ void Clear();
                /*0x21bf720*/ bool Contains(object key);
                /*0x21bf744*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x21bf814*/ void Insert(int index, object value);
                /*0x21bf864*/ object get_Item(int index);
                /*0x21bf888*/ void set_Item(int index, object value);
                /*0x21bf8d8*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21bf968*/ int IndexOf(object key);
                /*0x21bfa34*/ void Remove(object key);
                /*0x21bfa84*/ void RemoveAt(int index);
            }

            class ValueList : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.SortedList sortedList;

                /*0x21bd6f4*/ ValueList(System.Collections.SortedList sortedList);
                /*0x21bfad4*/ int get_Count();
                /*0x21bfaf0*/ bool get_IsReadOnly();
                /*0x21bfaf8*/ bool get_IsFixedSize();
                /*0x21bfb00*/ bool get_IsSynchronized();
                /*0x21bfb24*/ object get_SyncRoot();
                /*0x21bfb48*/ int Add(object key);
                /*0x21bfb98*/ void Clear();
                /*0x21bfbe8*/ bool Contains(object value);
                /*0x21bfc0c*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x21bfcdc*/ void Insert(int index, object value);
                /*0x21bfd2c*/ object get_Item(int index);
                /*0x21bfd50*/ void set_Item(int index, object value);
                /*0x21bfda0*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21bfe30*/ int IndexOf(object value);
                /*0x21bfea8*/ void Remove(object value);
                /*0x21bfef8*/ void RemoveAt(int index);
            }

            class SortedListDebugView
            {
            }
        }

        class Stack : System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            static int _defaultCapacity = 10;
            /*0x10*/ object[] _array;
            /*0x18*/ int _size;
            /*0x1c*/ int _version;
            /*0x20*/ object _syncRoot;

            static /*0x21c0a2c*/ System.Collections.Stack Synchronized(System.Collections.Stack stack);
            /*0x21bff48*/ Stack();
            /*0x21bffa4*/ Stack(int initialCapacity);
            /*0x21c0070*/ Stack(System.Collections.ICollection col);
            /*0x21c02d8*/ int get_Count();
            /*0x21c02e0*/ bool get_IsSynchronized();
            /*0x21c02e8*/ object get_SyncRoot();
            /*0x21c0360*/ void Clear();
            /*0x21c0390*/ object Clone();
            /*0x21c0420*/ bool Contains(object obj);
            /*0x21c04b0*/ void CopyTo(System.Array array, int index);
            /*0x21c0768*/ System.Collections.IEnumerator GetEnumerator();
            /*0x21c0808*/ object Peek();
            /*0x21c0890*/ object Pop();
            /*0x21c0928*/ void Push(object obj);
            /*0x21c0b1c*/ object[] ToArray();

            class SyncStack : System.Collections.Stack
            {
                /*0x28*/ System.Collections.Stack _s;
                /*0x30*/ object _root;

                /*0x21c0adc*/ SyncStack(System.Collections.Stack stack);
                /*0x21c0c68*/ bool get_IsSynchronized();
                /*0x21c0c70*/ object get_SyncRoot();
                /*0x21c0c78*/ int get_Count();
                /*0x21c0d58*/ bool Contains(object obj);
                /*0x21c0e44*/ object Clone();
                /*0x21c0fc0*/ void Clear();
                /*0x21c1094*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x21c1178*/ void Push(object value);
                /*0x21c1254*/ object Pop();
                /*0x21c1338*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21c141c*/ object Peek();
                /*0x21c1500*/ object[] ToArray();
            }

            class StackEnumerator : System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.Stack _stack;
                /*0x18*/ int _index;
                /*0x1c*/ int _version;
                /*0x20*/ object _currentElement;

                /*0x21c07c8*/ StackEnumerator(System.Collections.Stack stack);
                /*0x21c15e4*/ object Clone();
                /*0x21c15ec*/ bool MoveNext();
                /*0x21c16d0*/ object get_Current();
                /*0x21c1764*/ void Reset();
            }

            class StackDebugView
            {
            }
        }

        class BitArray : System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            static int _ShrinkThreshold = 256;
            static int BitsPerInt32 = 32;
            static int BytesPerInt32 = 4;
            static int BitsPerByte = 8;
            /*0x10*/ int[] m_array;
            /*0x18*/ int m_length;
            /*0x1c*/ int _version;
            /*0x20*/ object _syncRoot;

            static /*0x21c1948*/ int GetArrayLength(int n, int div);
            /*0x21c17e4*/ BitArray(int length);
            /*0x21c17ec*/ BitArray(int length, bool defaultValue);
            /*0x21c1964*/ BitArray(byte[] bytes);
            /*0x21c1c60*/ BitArray(bool[] values);
            /*0x21c1d9c*/ BitArray(int[] values);
            /*0x21c1f14*/ BitArray(System.Collections.BitArray bits);
            /*0x21c2010*/ bool get_Item(int index);
            /*0x21c20f8*/ void set_Item(int index, bool value);
            /*0x21c2014*/ bool Get(int index);
            /*0x21c2100*/ void Set(int index, bool value);
            /*0x21c21fc*/ void SetAll(bool value);
            /*0x21c226c*/ System.Collections.BitArray And(System.Collections.BitArray value);
            /*0x21c2390*/ System.Collections.BitArray Or(System.Collections.BitArray value);
            /*0x21c24b4*/ System.Collections.BitArray Xor(System.Collections.BitArray value);
            /*0x21c25d8*/ System.Collections.BitArray Not();
            /*0x21c264c*/ System.Collections.BitArray RightShift(int count);
            /*0x21c2884*/ System.Collections.BitArray LeftShift(int count);
            /*0x21c2a8c*/ int get_Length();
            /*0x21c2a94*/ void set_Length(int value);
            /*0x21c2c64*/ void CopyTo(System.Array array, int index);
            /*0x21c3188*/ int get_Count();
            /*0x21c3190*/ object get_SyncRoot();
            /*0x21c3208*/ bool get_IsSynchronized();
            /*0x21c3210*/ bool get_IsReadOnly();
            /*0x21c3218*/ object Clone();
            /*0x21c3278*/ System.Collections.IEnumerator GetEnumerator();

            class BitArrayEnumeratorSimple : System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.BitArray bitarray;
                /*0x18*/ int index;
                /*0x1c*/ int version;
                /*0x20*/ bool currentElement;

                /*0x21c32d8*/ BitArrayEnumeratorSimple(System.Collections.BitArray bitarray);
                /*0x21c3318*/ object Clone();
                /*0x21c3320*/ bool MoveNext();
                /*0x21c34cc*/ object get_Current();
                /*0x21c3628*/ void Reset();
            }
        }

        class StructuralComparisons
        {
            static /*0x0*/ System.Collections.IComparer s_StructuralComparer;
            static /*0x8*/ System.Collections.IEqualityComparer s_StructuralEqualityComparer;

            static /*0x21c36a4*/ System.Collections.IComparer get_StructuralComparer();
            static /*0x21c3740*/ System.Collections.IEqualityComparer get_StructuralEqualityComparer();
        }

        class StructuralEqualityComparer : System.Collections.IEqualityComparer
        {
            /*0x21c37d4*/ StructuralEqualityComparer();
            /*0x21c37dc*/ bool Equals(object x, object y);
            /*0x21c38e4*/ int GetHashCode(object obj);
        }

        class StructuralComparer : System.Collections.IComparer
        {
            /*0x21c3738*/ StructuralComparer();
            /*0x21c39d4*/ int Compare(object x, object y);
        }

        class ArrayList : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable, System.ICloneable
        {
            static int _defaultCapacity = 4;
            static int MaxArrayLength = 2146435071;
            /*0x10*/ object[] _items;
            /*0x18*/ int _size;
            /*0x1c*/ int _version;
            /*0x20*/ object _syncRoot;

            static /*0x21c4150*/ System.Collections.ArrayList Adapter(System.Collections.IList list);
            static /*0x21c4830*/ System.Collections.IList FixedSize(System.Collections.IList list);
            static /*0x21c490c*/ System.Collections.ArrayList FixedSize(System.Collections.ArrayList list);
            static /*0x21c53ec*/ System.Collections.IList ReadOnly(System.Collections.IList list);
            static /*0x21c54c8*/ System.Collections.ArrayList ReadOnly(System.Collections.ArrayList list);
            static /*0x21c5828*/ System.Collections.ArrayList Repeat(object value, int count);
            static /*0x21c6000*/ System.Collections.IList Synchronized(System.Collections.IList list);
            static /*0x21c616c*/ System.Collections.ArrayList Synchronized(System.Collections.ArrayList list);
            /*0x21c3af4*/ ArrayList(bool trash);
            /*0x21bbfb0*/ ArrayList();
            /*0x21c3afc*/ ArrayList(int capacity);
            /*0x21c3c40*/ ArrayList(System.Collections.ICollection c);
            /*0x21c3df0*/ int get_Capacity();
            /*0x21c3e0c*/ void set_Capacity(int value);
            /*0x21c3f24*/ int get_Count();
            /*0x21c3f2c*/ bool get_IsFixedSize();
            /*0x21c3f34*/ bool get_IsReadOnly();
            /*0x21c3f3c*/ bool get_IsSynchronized();
            /*0x21c3f44*/ object get_SyncRoot();
            /*0x21c3fbc*/ object get_Item(int index);
            /*0x21c4064*/ void set_Item(int index, object value);
            /*0x21c422c*/ int Add(object value);
            /*0x21c4330*/ void AddRange(System.Collections.ICollection c);
            /*0x21c434c*/ int BinarySearch(int index, int count, object value, System.Collections.IComparer comparer);
            /*0x21c443c*/ int BinarySearch(object value);
            /*0x21c448c*/ int BinarySearch(object value, System.Collections.IComparer comparer);
            /*0x21c44e0*/ void Clear();
            /*0x21c451c*/ object Clone();
            /*0x21c45a4*/ bool Contains(object item);
            /*0x21c4664*/ void CopyTo(System.Array array);
            /*0x21c4678*/ void CopyTo(System.Array array, int arrayIndex);
            /*0x21c4728*/ void CopyTo(int index, System.Array array, int arrayIndex, int count);
            /*0x21c42d4*/ void EnsureCapacity(int min);
            /*0x21c49f0*/ System.Collections.IEnumerator GetEnumerator();
            /*0x21c4b58*/ System.Collections.IEnumerator GetEnumerator(int index, int count);
            /*0x21c4d00*/ int IndexOf(object value);
            /*0x21c4d18*/ int IndexOf(object value, int startIndex);
            /*0x21c4da0*/ int IndexOf(object value, int startIndex, int count);
            /*0x21c4e6c*/ void Insert(int index, object value);
            /*0x21c4fa0*/ void InsertRange(int index, System.Collections.ICollection c);
            /*0x21c5204*/ int LastIndexOf(object value);
            /*0x21c521c*/ int LastIndexOf(object value, int startIndex);
            /*0x21c52ac*/ int LastIndexOf(object value, int startIndex, int count);
            /*0x21c559c*/ void Remove(object obj);
            /*0x21c55dc*/ void RemoveAt(int index);
            /*0x21c56c0*/ void RemoveRange(int index, int count);
            /*0x21c5920*/ void Reverse();
            /*0x21c5958*/ void Reverse(int index, int count);
            /*0x21c5a9c*/ void SetRange(int index, System.Collections.ICollection c);
            /*0x21c5c84*/ System.Collections.ArrayList GetRange(int index, int count);
            /*0x21c5e20*/ void Sort();
            /*0x21c5eb0*/ void Sort(System.Collections.IComparer comparer);
            /*0x21c5efc*/ void Sort(int index, int count, System.Collections.IComparer comparer);
            /*0x21c6264*/ object[] ToArray();
            /*0x21c6334*/ System.Array ToArray(System.Type type);
            /*0x21c6428*/ void TrimToSize();

            class IListWrapper : System.Collections.ArrayList
            {
                /*0x28*/ System.Collections.IList _list;

                /*0x21c4204*/ IListWrapper(System.Collections.IList list);
                /*0x21c643c*/ int get_Capacity();
                /*0x21c64e0*/ void set_Capacity(int value);
                /*0x21c6574*/ int get_Count();
                /*0x21c6618*/ bool get_IsReadOnly();
                /*0x21c66bc*/ bool get_IsFixedSize();
                /*0x21c6760*/ bool get_IsSynchronized();
                /*0x21c6804*/ object get_Item(int index);
                /*0x21c68ac*/ void set_Item(int index, object value);
                /*0x21c6978*/ object get_SyncRoot();
                /*0x21c6a1c*/ int Add(object obj);
                /*0x21c6ad8*/ void AddRange(System.Collections.ICollection c);
                /*0x21c6b20*/ int BinarySearch(int index, int count, object value, System.Collections.IComparer comparer);
                /*0x21c6dd0*/ void Clear();
                /*0x21c6f38*/ object Clone();
                /*0x21c6fa0*/ bool Contains(object obj);
                /*0x21c704c*/ void CopyTo(System.Array array, int index);
                /*0x21c7104*/ void CopyTo(int index, System.Array array, int arrayIndex, int count);
                /*0x21c744c*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21c74ec*/ System.Collections.IEnumerator GetEnumerator(int index, int count);
                /*0x21c77a8*/ int IndexOf(object value);
                /*0x21c7854*/ int IndexOf(object value, int startIndex);
                /*0x21c7928*/ int IndexOf(object value, int startIndex, int count);
                /*0x21c7be4*/ void Insert(int index, object obj);
                /*0x21c7cb0*/ void InsertRange(int index, System.Collections.ICollection c);
                /*0x21c8080*/ int LastIndexOf(object value);
                /*0x21c81b8*/ int LastIndexOf(object value, int startIndex);
                /*0x21c81cc*/ int LastIndexOf(object value, int startIndex, int count);
                /*0x21c8544*/ void Remove(object value);
                /*0x21c8584*/ void RemoveAt(int index);
                /*0x21c8640*/ void RemoveRange(int index, int count);
                /*0x21c8860*/ void Reverse(int index, int count);
                /*0x21c8bd0*/ void SetRange(int index, System.Collections.ICollection c);
                /*0x21c8ff8*/ System.Collections.ArrayList GetRange(int index, int count);
                /*0x21c91b8*/ void Sort(int index, int count, System.Collections.IComparer comparer);
                /*0x21c947c*/ object[] ToArray();
                /*0x21c95d8*/ System.Array ToArray(System.Type type);
                /*0x21c9790*/ void TrimToSize();

                class IListWrapperEnumWrapper : System.Collections.IEnumerator, System.ICloneable
                {
                    /*0x10*/ System.Collections.IEnumerator _en;
                    /*0x18*/ int _remaining;
                    /*0x1c*/ int _initialStartIndex;
                    /*0x20*/ int _initialCount;
                    /*0x24*/ bool _firstCall;

                    /*0x21c76ac*/ IListWrapperEnumWrapper(System.Collections.ArrayList.IListWrapper listWrapper, int startIndex, int count);
                    /*0x21c9794*/ IListWrapperEnumWrapper();
                    /*0x21c979c*/ object Clone();
                    /*0x21c9924*/ bool MoveNext();
                    /*0x21c9a74*/ object get_Current();
                    /*0x21c9b98*/ void Reset();
                }
            }

            class SyncArrayList : System.Collections.ArrayList
            {
                /*0x28*/ System.Collections.ArrayList _list;
                /*0x30*/ object _root;

                /*0x21c621c*/ SyncArrayList(System.Collections.ArrayList list);
                /*0x21c9cc8*/ int get_Capacity();
                /*0x21c9dac*/ void set_Capacity(int value);
                /*0x21c9e88*/ int get_Count();
                /*0x21c9f6c*/ bool get_IsReadOnly();
                /*0x21c9f90*/ bool get_IsFixedSize();
                /*0x21c9fb4*/ bool get_IsSynchronized();
                /*0x21c9fbc*/ object get_Item(int index);
                /*0x21ca0a8*/ void set_Item(int index, object value);
                /*0x21ca18c*/ object get_SyncRoot();
                /*0x21ca194*/ int Add(object value);
                /*0x21ca280*/ void AddRange(System.Collections.ICollection c);
                /*0x21ca35c*/ int BinarySearch(object value);
                /*0x21ca448*/ int BinarySearch(object value, System.Collections.IComparer comparer);
                /*0x21ca53c*/ int BinarySearch(int index, int count, object value, System.Collections.IComparer comparer);
                /*0x21ca648*/ void Clear();
                /*0x21ca71c*/ object Clone();
                /*0x21ca898*/ bool Contains(object item);
                /*0x21ca984*/ void CopyTo(System.Array array);
                /*0x21caa60*/ void CopyTo(System.Array array, int index);
                /*0x21cab44*/ void CopyTo(int index, System.Array array, int arrayIndex, int count);
                /*0x21cac40*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21cad24*/ System.Collections.IEnumerator GetEnumerator(int index, int count);
                /*0x21cae18*/ int IndexOf(object value);
                /*0x21caf04*/ int IndexOf(object value, int startIndex);
                /*0x21caff8*/ int IndexOf(object value, int startIndex, int count);
                /*0x21cb0fc*/ void Insert(int index, object value);
                /*0x21cb1e0*/ void InsertRange(int index, System.Collections.ICollection c);
                /*0x21cb2c4*/ int LastIndexOf(object value);
                /*0x21cb3b0*/ int LastIndexOf(object value, int startIndex);
                /*0x21cb4a4*/ int LastIndexOf(object value, int startIndex, int count);
                /*0x21cb5a8*/ void Remove(object value);
                /*0x21cb684*/ void RemoveAt(int index);
                /*0x21cb760*/ void RemoveRange(int index, int count);
                /*0x21cb844*/ void Reverse(int index, int count);
                /*0x21cb928*/ void SetRange(int index, System.Collections.ICollection c);
                /*0x21cba0c*/ System.Collections.ArrayList GetRange(int index, int count);
                /*0x21cbb00*/ void Sort();
                /*0x21cbbd4*/ void Sort(System.Collections.IComparer comparer);
                /*0x21cbcb0*/ void Sort(int index, int count, System.Collections.IComparer comparer);
                /*0x21cbda4*/ object[] ToArray();
                /*0x21cbe88*/ System.Array ToArray(System.Type type);
                /*0x21cbf74*/ void TrimToSize();
            }

            class SyncIList : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.IList _list;
                /*0x18*/ object _root;

                /*0x21c60b0*/ SyncIList(System.Collections.IList list);
                /*0x21cc048*/ int get_Count();
                /*0x21cc1a0*/ bool get_IsReadOnly();
                /*0x21cc244*/ bool get_IsFixedSize();
                /*0x21cc2e8*/ bool get_IsSynchronized();
                /*0x21cc2f0*/ object get_Item(int index);
                /*0x21cc44c*/ void set_Item(int index, object value);
                /*0x21cc5a4*/ object get_SyncRoot();
                /*0x21cc5ac*/ int Add(object value);
                /*0x21cc70c*/ void Clear();
                /*0x21cc854*/ bool Contains(object item);
                /*0x21cc9b4*/ void CopyTo(System.Array array, int index);
                /*0x21ccb08*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21ccc5c*/ int IndexOf(object value);
                /*0x21ccdbc*/ void Insert(int index, object value);
                /*0x21ccf14*/ void Remove(object value);
                /*0x21cd064*/ void RemoveAt(int index);
            }

            class FixedSizeList : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.IList _list;

                /*0x21c48e4*/ FixedSizeList(System.Collections.IList l);
                /*0x21cd1b4*/ int get_Count();
                /*0x21cd258*/ bool get_IsReadOnly();
                /*0x21cd2fc*/ bool get_IsFixedSize();
                /*0x21cd304*/ bool get_IsSynchronized();
                /*0x21cd3a8*/ object get_Item(int index);
                /*0x21cd450*/ void set_Item(int index, object value);
                /*0x21cd50c*/ object get_SyncRoot();
                /*0x21cd5b0*/ int Add(object obj);
                /*0x21cd600*/ void Clear();
                /*0x21cd650*/ bool Contains(object obj);
                /*0x21cd6fc*/ void CopyTo(System.Array array, int index);
                /*0x21cd7b4*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21cd854*/ int IndexOf(object value);
                /*0x21cd900*/ void Insert(int index, object obj);
                /*0x21cd950*/ void Remove(object value);
                /*0x21cd9a0*/ void RemoveAt(int index);
            }

            class FixedSizeArrayList : System.Collections.ArrayList
            {
                /*0x28*/ System.Collections.ArrayList _list;

                /*0x21c49bc*/ FixedSizeArrayList(System.Collections.ArrayList l);
                /*0x21cd9f0*/ int get_Count();
                /*0x21cda14*/ bool get_IsReadOnly();
                /*0x21cda38*/ bool get_IsFixedSize();
                /*0x21cda40*/ bool get_IsSynchronized();
                /*0x21cda64*/ object get_Item(int index);
                /*0x21cda88*/ void set_Item(int index, object value);
                /*0x21cdac4*/ object get_SyncRoot();
                /*0x21cdae8*/ int Add(object obj);
                /*0x21cdb38*/ void AddRange(System.Collections.ICollection c);
                /*0x21cdb88*/ int BinarySearch(int index, int count, object value, System.Collections.IComparer comparer);
                /*0x21cdbac*/ int get_Capacity();
                /*0x21cdbd0*/ void set_Capacity(int value);
                /*0x21cdc20*/ void Clear();
                /*0x21cdc70*/ object Clone();
                /*0x21cdd5c*/ bool Contains(object obj);
                /*0x21cdd80*/ void CopyTo(System.Array array, int index);
                /*0x21cdda4*/ void CopyTo(int index, System.Array array, int arrayIndex, int count);
                /*0x21cddc8*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21cddec*/ System.Collections.IEnumerator GetEnumerator(int index, int count);
                /*0x21cde10*/ int IndexOf(object value);
                /*0x21cde34*/ int IndexOf(object value, int startIndex);
                /*0x21cde58*/ int IndexOf(object value, int startIndex, int count);
                /*0x21cde7c*/ void Insert(int index, object obj);
                /*0x21cdecc*/ void InsertRange(int index, System.Collections.ICollection c);
                /*0x21cdf1c*/ int LastIndexOf(object value);
                /*0x21cdf40*/ int LastIndexOf(object value, int startIndex);
                /*0x21cdf64*/ int LastIndexOf(object value, int startIndex, int count);
                /*0x21cdf88*/ void Remove(object value);
                /*0x21cdfd8*/ void RemoveAt(int index);
                /*0x21ce028*/ void RemoveRange(int index, int count);
                /*0x21ce078*/ void SetRange(int index, System.Collections.ICollection c);
                /*0x21ce0b4*/ System.Collections.ArrayList GetRange(int index, int count);
                /*0x21ce210*/ void Reverse(int index, int count);
                /*0x21ce24c*/ void Sort(int index, int count, System.Collections.IComparer comparer);
                /*0x21ce288*/ object[] ToArray();
                /*0x21ce2ac*/ System.Array ToArray(System.Type type);
                /*0x21ce2d0*/ void TrimToSize();
            }

            class ReadOnlyList : System.Collections.IList, System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.IList _list;

                /*0x21c54a0*/ ReadOnlyList(System.Collections.IList l);
                /*0x21ce320*/ int get_Count();
                /*0x21ce3c4*/ bool get_IsReadOnly();
                /*0x21ce3cc*/ bool get_IsFixedSize();
                /*0x21ce3d4*/ bool get_IsSynchronized();
                /*0x21ce478*/ object get_Item(int index);
                /*0x21ce520*/ void set_Item(int index, object value);
                /*0x21ce570*/ object get_SyncRoot();
                /*0x21ce614*/ int Add(object obj);
                /*0x21ce664*/ void Clear();
                /*0x21ce6b4*/ bool Contains(object obj);
                /*0x21ce760*/ void CopyTo(System.Array array, int index);
                /*0x21ce818*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21ce8b8*/ int IndexOf(object value);
                /*0x21ce964*/ void Insert(int index, object obj);
                /*0x21ce9b4*/ void Remove(object value);
                /*0x21cea04*/ void RemoveAt(int index);
            }

            class ReadOnlyArrayList : System.Collections.ArrayList
            {
                /*0x28*/ System.Collections.ArrayList _list;

                /*0x21c5578*/ ReadOnlyArrayList(System.Collections.ArrayList l);
                /*0x21cea54*/ int get_Count();
                /*0x21cea78*/ bool get_IsReadOnly();
                /*0x21cea80*/ bool get_IsFixedSize();
                /*0x21cea88*/ bool get_IsSynchronized();
                /*0x21ceaac*/ object get_Item(int index);
                /*0x21cead0*/ void set_Item(int index, object value);
                /*0x21ceb20*/ object get_SyncRoot();
                /*0x21ceb44*/ int Add(object obj);
                /*0x21ceb94*/ void AddRange(System.Collections.ICollection c);
                /*0x21cebe4*/ int BinarySearch(int index, int count, object value, System.Collections.IComparer comparer);
                /*0x21cec08*/ int get_Capacity();
                /*0x21cec2c*/ void set_Capacity(int value);
                /*0x21cec7c*/ void Clear();
                /*0x21ceccc*/ object Clone();
                /*0x21cedb8*/ bool Contains(object obj);
                /*0x21ceddc*/ void CopyTo(System.Array array, int index);
                /*0x21cee00*/ void CopyTo(int index, System.Array array, int arrayIndex, int count);
                /*0x21cee24*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21cee48*/ System.Collections.IEnumerator GetEnumerator(int index, int count);
                /*0x21cee6c*/ int IndexOf(object value);
                /*0x21cee90*/ int IndexOf(object value, int startIndex);
                /*0x21ceeb4*/ int IndexOf(object value, int startIndex, int count);
                /*0x21ceed8*/ void Insert(int index, object obj);
                /*0x21cef28*/ void InsertRange(int index, System.Collections.ICollection c);
                /*0x21cef78*/ int LastIndexOf(object value);
                /*0x21cef9c*/ int LastIndexOf(object value, int startIndex);
                /*0x21cefc0*/ int LastIndexOf(object value, int startIndex, int count);
                /*0x21cefe4*/ void Remove(object value);
                /*0x21cf034*/ void RemoveAt(int index);
                /*0x21cf084*/ void RemoveRange(int index, int count);
                /*0x21cf0d4*/ void SetRange(int index, System.Collections.ICollection c);
                /*0x21cf124*/ System.Collections.ArrayList GetRange(int index, int count);
                /*0x21cf280*/ void Reverse(int index, int count);
                /*0x21cf2d0*/ void Sort(int index, int count, System.Collections.IComparer comparer);
                /*0x21cf320*/ object[] ToArray();
                /*0x21cf344*/ System.Array ToArray(System.Type type);
                /*0x21cf368*/ void TrimToSize();
            }

            class ArrayListEnumerator : System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.ArrayList _list;
                /*0x18*/ int _index;
                /*0x1c*/ int _endIndex;
                /*0x20*/ int _version;
                /*0x28*/ object _currentElement;
                /*0x30*/ int _startIndex;

                /*0x21c4ca4*/ ArrayListEnumerator(System.Collections.ArrayList list, int index, int count);
                /*0x21cf3b8*/ object Clone();
                /*0x21cf3c0*/ bool MoveNext();
                /*0x21cf474*/ object get_Current();
                /*0x21cf510*/ void Reset();
            }

            class Range : System.Collections.ArrayList
            {
                /*0x28*/ System.Collections.ArrayList _baseList;
                /*0x30*/ int _baseIndex;
                /*0x34*/ int _baseSize;
                /*0x38*/ int _baseVersion;

                /*0x21c5dd0*/ Range(System.Collections.ArrayList list, int index, int count);
                /*0x21cf590*/ void InternalUpdateRange();
                /*0x21cf604*/ void InternalUpdateVersion();
                /*0x21cf620*/ int Add(object value);
                /*0x21cf688*/ void AddRange(System.Collections.ICollection c);
                /*0x21cf7d0*/ int BinarySearch(int index, int count, object value, System.Collections.IComparer comparer);
                /*0x21cf91c*/ int get_Capacity();
                /*0x21cf940*/ void set_Capacity(int value);
                /*0x21cf9d4*/ void Clear();
                /*0x21cfa28*/ object Clone();
                /*0x21cfb30*/ bool Contains(object item);
                /*0x21cfc20*/ void CopyTo(System.Array array, int index);
                /*0x21cfdc0*/ void CopyTo(int index, System.Array array, int arrayIndex, int count);
                /*0x21cffac*/ int get_Count();
                /*0x21cffc4*/ bool get_IsReadOnly();
                /*0x21cffe8*/ bool get_IsFixedSize();
                /*0x21d000c*/ bool get_IsSynchronized();
                /*0x21d0030*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21d0048*/ System.Collections.IEnumerator GetEnumerator(int index, int count);
                /*0x21d0168*/ System.Collections.ArrayList GetRange(int index, int count);
                /*0x21d02bc*/ object get_SyncRoot();
                /*0x21d02e0*/ int IndexOf(object value);
                /*0x21d0338*/ int IndexOf(object value, int startIndex);
                /*0x21d0444*/ int IndexOf(object value, int startIndex, int count);
                /*0x21d056c*/ void Insert(int index, object value);
                /*0x21d0648*/ void InsertRange(int index, System.Collections.ICollection c);
                /*0x21d07f8*/ int LastIndexOf(object value);
                /*0x21d0858*/ int LastIndexOf(object value, int startIndex);
                /*0x21d086c*/ int LastIndexOf(object value, int startIndex, int count);
                /*0x21d0984*/ void RemoveAt(int index);
                /*0x21d0a5c*/ void RemoveRange(int index, int count);
                /*0x21d0ba4*/ void Reverse(int index, int count);
                /*0x21d0ce0*/ void SetRange(int index, System.Collections.ICollection c);
                /*0x21d0e50*/ void Sort(int index, int count, System.Collections.IComparer comparer);
                /*0x21d0f9c*/ object get_Item(int index);
                /*0x21d104c*/ void set_Item(int index, object value);
                /*0x21d1120*/ object[] ToArray();
                /*0x21d11fc*/ System.Array ToArray(System.Type type);
                /*0x21d1304*/ void TrimToSize();
            }

            class ArrayListEnumeratorSimple : System.Collections.IEnumerator, System.ICloneable
            {
                static /*0x0*/ object s_dummyObject;
                /*0x10*/ System.Collections.ArrayList _list;
                /*0x18*/ int _index;
                /*0x1c*/ int _version;
                /*0x20*/ object _currentElement;
                /*0x28*/ bool _isArrayList;

                static /*0x21d16d0*/ ArrayListEnumeratorSimple();
                /*0x21c4a50*/ ArrayListEnumeratorSimple(System.Collections.ArrayList list);
                /*0x21d1354*/ object Clone();
                /*0x21d135c*/ bool MoveNext();
                /*0x21d152c*/ object get_Current();
                /*0x21d1600*/ void Reset();
            }

            class ArrayListDebugView
            {
            }
        }

        class Hashtable : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback, System.ICloneable
        {
            static int HashPrime = 101;
            static int InitialSize = 3;
            static string LoadFactorName = "LoadFactor";
            static string VersionName = "Version";
            static string ComparerName = "Comparer";
            static string HashCodeProviderName = "HashCodeProvider";
            static string HashSizeName = "HashSize";
            static string KeysName = "Keys";
            static string ValuesName = "Values";
            static string KeyComparerName = "KeyComparer";
            static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.Serialization.SerializationInfo> s_serializationInfoTable;
            /*0x10*/ System.Collections.Hashtable.bucket[] _buckets;
            /*0x18*/ int _count;
            /*0x1c*/ int _occupancy;
            /*0x20*/ int _loadsize;
            /*0x24*/ float _loadFactor;
            /*0x28*/ int _version;
            /*0x2c*/ bool _isWriterInProgress;
            /*0x30*/ System.Collections.ICollection _keys;
            /*0x38*/ System.Collections.ICollection _values;
            /*0x40*/ System.Collections.IEqualityComparer _keycomparer;
            /*0x48*/ object _syncRoot;

            static /*0x21d1748*/ System.Runtime.CompilerServices.ConditionalWeakTable<object, System.Runtime.Serialization.SerializationInfo> get_SerializationInfoTable();
            static /*0x21d3dc4*/ System.Collections.Hashtable Synchronized(System.Collections.Hashtable table);
            /*0x21d1aec*/ Hashtable(bool trash);
            /*0x21b9cc4*/ Hashtable();
            /*0x21d1da4*/ Hashtable(int capacity);
            /*0x21d1af4*/ Hashtable(int capacity, float loadFactor);
            /*0x21d1dac*/ Hashtable(int capacity, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
            /*0x21d1dd0*/ Hashtable(System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
            /*0x21d1e84*/ Hashtable(System.Collections.IEqualityComparer equalityComparer);
            /*0x21d1eb0*/ Hashtable(int capacity, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
            /*0x21d1eb8*/ Hashtable(int capacity, System.Collections.IEqualityComparer equalityComparer);
            /*0x21d1ee0*/ Hashtable(System.Collections.IDictionary d);
            /*0x21d1eec*/ Hashtable(System.Collections.IDictionary d, float loadFactor);
            /*0x21d2218*/ Hashtable(System.Collections.IDictionary d, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
            /*0x21d2558*/ Hashtable(System.Collections.IDictionary d, System.Collections.IEqualityComparer equalityComparer);
            /*0x21d1de4*/ Hashtable(int capacity, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
            /*0x21d2220*/ Hashtable(System.Collections.IDictionary d, float loadFactor, System.Collections.IHashCodeProvider hcp, System.Collections.IComparer comparer);
            /*0x21d1ef4*/ Hashtable(System.Collections.IDictionary d, float loadFactor, System.Collections.IEqualityComparer equalityComparer);
            /*0x21d2560*/ Hashtable(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x21d17a4*/ System.Collections.IHashCodeProvider get_hcp();
            /*0x21d1854*/ void set_hcp(System.Collections.IHashCodeProvider value);
            /*0x21d1944*/ System.Collections.IComparer get_comparer();
            /*0x21d19f4*/ void set_comparer(System.Collections.IComparer value);
            /*0x21d1ae4*/ System.Collections.IEqualityComparer get_EqualityComparer();
            /*0x21d25c8*/ uint InitHash(object key, int hashsize, ref uint seed, ref uint incr);
            /*0x21d261c*/ void Add(object key, object value);
            /*0x21d29e4*/ void Clear();
            /*0x21d2ab0*/ object Clone();
            /*0x21d2bc4*/ bool Contains(object key);
            /*0x21d2bd4*/ bool ContainsKey(object key);
            /*0x21d2d3c*/ bool ContainsValue(object value);
            /*0x21d2e1c*/ void CopyKeys(System.Array array, int arrayIndex);
            /*0x21d2ec0*/ void CopyEntries(System.Array array, int arrayIndex);
            /*0x21d2fc8*/ void CopyTo(System.Array array, int arrayIndex);
            /*0x21d3178*/ System.Collections.KeyValuePairs[] ToKeyValuePairsArray();
            /*0x21d32c4*/ void CopyValues(System.Array array, int arrayIndex);
            /*0x21d3374*/ object get_Item(object key);
            /*0x21d355c*/ void set_Item(object key, object value);
            /*0x21d3564*/ void expand();
            /*0x21d36f8*/ void rehash();
            /*0x21d2a84*/ void UpdateVersion();
            /*0x21d35d4*/ void rehash(int newsize);
            /*0x21d37c4*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x21d382c*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x21d3894*/ int GetHash(object key);
            /*0x21d395c*/ bool get_IsReadOnly();
            /*0x21d3964*/ bool get_IsFixedSize();
            /*0x21d396c*/ bool get_IsSynchronized();
            /*0x21d3974*/ bool KeyEquals(object item, object key);
            /*0x21d3a7c*/ System.Collections.ICollection get_Keys();
            /*0x21d3aec*/ System.Collections.ICollection get_Values();
            /*0x21d2624*/ void Insert(object key, object nvalue, bool add);
            /*0x21d3714*/ void putEntry(System.Collections.Hashtable.bucket[] newBuckets, object key, object nvalue, int hashcode);
            /*0x21d3b5c*/ void Remove(object key);
            /*0x21d3d44*/ object get_SyncRoot();
            /*0x21d3dbc*/ int get_Count();
            /*0x21d3e78*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            /*0x21d43b4*/ void OnDeserialization(object sender);

            struct bucket
            {
                /*0x10*/ object key;
                /*0x18*/ object val;
                /*0x20*/ int hash_coll;
            }

            class KeyCollection : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.Hashtable _hashtable;

                /*0x21d5c08*/ KeyCollection(System.Collections.Hashtable hashtable);
                /*0x21d5c30*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x21d5dc0*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21d5e80*/ bool get_IsSynchronized();
                /*0x21d5ea4*/ object get_SyncRoot();
                /*0x21d5ec8*/ int get_Count();
            }

            class ValueCollection : System.Collections.ICollection, System.Collections.IEnumerable
            {
                /*0x10*/ System.Collections.Hashtable _hashtable;

                /*0x21d5ee4*/ ValueCollection(System.Collections.Hashtable hashtable);
                /*0x21d5f0c*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x21d609c*/ System.Collections.IEnumerator GetEnumerator();
                /*0x21d6104*/ bool get_IsSynchronized();
                /*0x21d6128*/ object get_SyncRoot();
                /*0x21d614c*/ int get_Count();
            }

            class SyncHashtable : System.Collections.Hashtable, System.Collections.IEnumerable
            {
                /*0x50*/ System.Collections.Hashtable _table;

                /*0x21d6168*/ SyncHashtable(System.Collections.Hashtable table);
                /*0x21d6194*/ SyncHashtable(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x21d61dc*/ void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                /*0x21d621c*/ int get_Count();
                /*0x21d6240*/ bool get_IsReadOnly();
                /*0x21d6264*/ bool get_IsFixedSize();
                /*0x21d6288*/ bool get_IsSynchronized();
                /*0x21d6290*/ object get_Item(object key);
                /*0x21d62b4*/ void set_Item(object key, object value);
                /*0x21d63b4*/ object get_SyncRoot();
                /*0x21d63d8*/ void Add(object key, object value);
                /*0x21d64d8*/ void Clear();
                /*0x21d65c8*/ bool Contains(object key);
                /*0x21d65ec*/ bool ContainsKey(object key);
                /*0x21d667c*/ bool ContainsValue(object key);
                /*0x21d6784*/ void CopyTo(System.Array array, int arrayIndex);
                /*0x21d6884*/ object Clone();
                /*0x21d69ec*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                /*0x21d6a10*/ System.Collections.IDictionaryEnumerator GetEnumerator();
                /*0x21d6a34*/ System.Collections.ICollection get_Keys();
                /*0x21d6b34*/ System.Collections.ICollection get_Values();
                /*0x21d6c34*/ void Remove(object key);
                /*0x21d6d2c*/ void OnDeserialization(object sender);
                /*0x21d6d30*/ System.Collections.KeyValuePairs[] ToKeyValuePairsArray();
            }

            class HashtableEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator, System.ICloneable
            {
                /*0x10*/ System.Collections.Hashtable _hashtable;
                /*0x18*/ int _bucket;
                /*0x1c*/ int _version;
                /*0x20*/ bool _current;
                /*0x24*/ int _getObjectRetType;
                /*0x28*/ object _currentKey;
                /*0x30*/ object _currentValue;

                /*0x21d5e28*/ HashtableEnumerator(System.Collections.Hashtable hashtable, int getObjRetType);
                /*0x21d6d54*/ object Clone();
                /*0x21d6d5c*/ object get_Key();
                /*0x21d6dc0*/ bool MoveNext();
                /*0x21d6ef4*/ System.Collections.DictionaryEntry get_Entry();
                /*0x21d6f74*/ object get_Current();
                /*0x21d705c*/ object get_Value();
                /*0x21d70c0*/ void Reset();
            }

            class HashtableDebugView
            {
            }
        }

        interface IHashCodeProvider
        {
            int GetHashCode(object obj);
        }

        class EmptyReadOnlyDictionaryInternal : System.Collections.IDictionary, System.Collections.ICollection, System.Collections.IEnumerable
        {
            /*0x21d7164*/ EmptyReadOnlyDictionaryInternal();
            /*0x21d716c*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
            /*0x21d71d0*/ void CopyTo(System.Array array, int index);
            /*0x21d7368*/ int get_Count();
            /*0x21d7370*/ object get_SyncRoot();
            /*0x21d7374*/ bool get_IsSynchronized();
            /*0x21d737c*/ object get_Item(object key);
            /*0x21d73f8*/ void set_Item(object key, object value);
            /*0x21d7594*/ System.Collections.ICollection get_Keys();
            /*0x21d75ec*/ System.Collections.ICollection get_Values();
            /*0x21d7644*/ bool Contains(object key);
            /*0x21d764c*/ void Add(object key, object value);
            /*0x21d77e8*/ void Clear();
            /*0x21d7848*/ bool get_IsReadOnly();
            /*0x21d7850*/ bool get_IsFixedSize();
            /*0x21d7858*/ System.Collections.IDictionaryEnumerator GetEnumerator();
            /*0x21d78b4*/ void Remove(object key);

            class NodeEnumerator : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
            {
                /*0x21d71c8*/ NodeEnumerator();
                /*0x21d7914*/ bool MoveNext();
                /*0x21d791c*/ object get_Current();
                /*0x21d797c*/ void Reset();
                /*0x21d7980*/ object get_Key();
                /*0x21d79e0*/ object get_Value();
                /*0x21d7a40*/ System.Collections.DictionaryEntry get_Entry();
            }
        }

        namespace Concurrent
        {
            class ConcurrentQueue<T> : System.Collections.Concurrent.IProducerConsumerCollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<T>
            {
                static int InitialSegmentLength = 32;
                static int MaxSegmentLength = 1048576;
                /*0x0*/ object _crossSegmentLock;
                /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> _tail;
                /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> _head;

                static int GetCount(System.Collections.Concurrent.ConcurrentQueue.Segment<T> s, int head, int tail);
                static long GetCount(System.Collections.Concurrent.ConcurrentQueue.Segment<T> head, int headHead, System.Collections.Concurrent.ConcurrentQueue.Segment<T> tail, int tailTail);
                ConcurrentQueue();
                ConcurrentQueue(System.Collections.Generic.IEnumerable<T> collection);
                void InitializeFromCollection(System.Collections.Generic.IEnumerable<T> collection);
                void System.Collections.ICollection.CopyTo(System.Array array, int index);
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
                bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(ref T item);
                bool get_IsEmpty();
                T[] ToArray();
                int get_Count();
                void CopyTo(T[] array, int index);
                System.Collections.Generic.IEnumerator<T> GetEnumerator();
                void SnapForObservation(ref System.Collections.Concurrent.ConcurrentQueue.Segment<T> head, ref int headHead, ref System.Collections.Concurrent.ConcurrentQueue.Segment<T> tail, ref int tailTail);
                T GetItemWhenAvailable(System.Collections.Concurrent.ConcurrentQueue.Segment<T> segment, int i);
                System.Collections.Generic.IEnumerator<T> Enumerate(System.Collections.Concurrent.ConcurrentQueue.Segment<T> head, int headHead, System.Collections.Concurrent.ConcurrentQueue.Segment<T> tail, int tailTail);
                void Enqueue(T item);
                void EnqueueSlow(T item);
                bool TryDequeue(ref T result);
                bool TryDequeueSlow(ref T item);
                bool TryPeek(ref T result);
                bool TryPeek(ref T result, bool resultUsed);
                void Clear();

                class Segment<T>
                {
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment.Slot<T> _slots;
                    /*0x0*/ int _slotsMask;
                    /*0x0*/ System.Collections.Concurrent.PaddedHeadAndTail _headAndTail;
                    /*0x0*/ bool _preservedForObservation;
                    /*0x0*/ bool _frozenForEnqueues;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> _nextSegment;

                    static int RoundUpToPowerOf2(int i);
                    Segment(int boundedLength);
                    int get_Capacity();
                    int get_FreezeOffset();
                    void EnsureFrozenForEnqueues();
                    bool TryDequeue(ref T item);
                    bool TryPeek(ref T result, bool resultUsed);
                    bool TryEnqueue(T item);

                    struct Slot<T>
                    {
                        /*0x0*/ T Item;
                        /*0x0*/ int SequenceNumber;
                    }
                }

                class <Enumerate>d__28<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ int <>1__state;
                    /*0x0*/ T <>2__current;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> head;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> tail;
                    /*0x0*/ int tailTail;
                    /*0x0*/ int headHead;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue<T> <>4__this;
                    /*0x0*/ int <headTail>5__2;
                    /*0x0*/ int <i>5__3;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentQueue.Segment<T> <s>5__4;
                    /*0x0*/ int <i>5__5;

                    <Enumerate>d__28(int <>1__state);
                    void System.IDisposable.Dispose();
                    bool MoveNext();
                    T System.Collections.Generic.IEnumerator<T>.get_Current();
                    void System.Collections.IEnumerator.Reset();
                    object System.Collections.IEnumerator.get_Current();
                }
            }

            struct PaddedHeadAndTail
            {
                /*0x90*/ int Head;
                /*0x110*/ int Tail;
            }

            class CDSCollectionETWBCLProvider : System.Diagnostics.Tracing.EventSource
            {
                static System.Diagnostics.Tracing.EventKeywords ALL_KEYWORDS = -1;
                static int CONCURRENTSTACK_FASTPUSHFAILED_ID = 1;
                static int CONCURRENTSTACK_FASTPOPFAILED_ID = 2;
                static int CONCURRENTDICTIONARY_ACQUIRINGALLLOCKS_ID = 3;
                static int CONCURRENTBAG_TRYTAKESTEALS_ID = 4;
                static int CONCURRENTBAG_TRYPEEKSTEALS_ID = 5;
                static /*0x0*/ System.Collections.Concurrent.CDSCollectionETWBCLProvider Log;

                static /*0x21d7bfc*/ CDSCollectionETWBCLProvider();
                /*0x21d7aa0*/ CDSCollectionETWBCLProvider();
                /*0x21d7aa8*/ void ConcurrentStack_FastPushFailed(int spinCount);
                /*0x21d7af4*/ void ConcurrentStack_FastPopFailed(int spinCount);
                /*0x21d7b40*/ void ConcurrentDictionary_AcquiringAllLocks(int numOfBuckets);
                /*0x21d7b8c*/ void ConcurrentBag_TryTakeSteals();
                /*0x21d7bc4*/ void ConcurrentBag_TryPeekSteals();
            }

            class ConcurrentDictionary<TKey, TValue> : System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.IDictionary, System.Collections.ICollection, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>
            {
                static int DefaultCapacity = 31;
                static int MaxLockNumber = 1024;
                static /*0x0*/ bool s_isValueWriteAtomic;
                /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Tables<TKey, TValue> _tables;
                /*0x0*/ System.Collections.Generic.IEqualityComparer<TKey> _comparer;
                /*0x0*/ bool _growLockArray;
                /*0x0*/ int _budget;
                /*0x0*/ System.Collections.Generic.KeyValuePair<TKey, TValue> _serializationArray;
                /*0x0*/ int _serializationConcurrencyLevel;
                /*0x0*/ int _serializationCapacity;

                static ConcurrentDictionary();
                static bool IsValueWriteAtomic();
                static void ThrowKeyNotFoundException(object key);
                static void ThrowKeyNullException();
                static int GetBucket(int hashcode, int bucketCount);
                static void GetBucketAndLockNo(int hashcode, ref int bucketNo, ref int lockNo, int bucketCount, int lockCount);
                static int get_DefaultConcurrencyLevel();
                ConcurrentDictionary();
                ConcurrentDictionary(int concurrencyLevel, int capacity);
                ConcurrentDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> collection);
                ConcurrentDictionary(System.Collections.Generic.IEqualityComparer<TKey> comparer);
                ConcurrentDictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> collection, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                ConcurrentDictionary(int concurrencyLevel, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> collection, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                ConcurrentDictionary(int concurrencyLevel, int capacity, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                ConcurrentDictionary(int concurrencyLevel, int capacity, bool growLockArray, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                void InitializeFromCollection(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> collection);
                bool TryAdd(TKey key, TValue value);
                bool ContainsKey(TKey key);
                bool TryRemove(TKey key, ref TValue value);
                bool TryRemoveInternal(TKey key, ref TValue value, bool matchValue, TValue oldValue);
                bool TryGetValue(TKey key, ref TValue value);
                bool TryGetValueInternal(TKey key, int hashcode, ref TValue value);
                bool TryUpdate(TKey key, TValue newValue, TValue comparisonValue);
                bool TryUpdateInternal(TKey key, int hashcode, TValue newValue, TValue comparisonValue);
                void Clear();
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int index);
                System.Collections.Generic.KeyValuePair<TKey, TValue> ToArray();
                void CopyToPairs(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int index);
                void CopyToEntries(System.Collections.DictionaryEntry[] array, int index);
                void CopyToObjects(object[] array, int index);
                System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator();
                bool TryAddInternal(TKey key, int hashcode, TValue value, bool updateIfExists, bool acquireLock, ref TValue resultingValue);
                TValue get_Item(TKey key);
                void set_Item(TKey key, TValue value);
                int get_Count();
                int GetCountInternal();
                TValue GetOrAdd(TKey key, System.Func<TKey, TValue> valueFactory);
                TValue GetOrAdd<TArg>(TKey key, System.Func<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
                TValue GetOrAdd(TKey key, TValue value);
                TValue AddOrUpdate<TArg>(TKey key, System.Func<TKey, TArg, TValue> addValueFactory, System.Func<TKey, TValue, TArg, TValue> updateValueFactory, TArg factoryArgument);
                TValue AddOrUpdate(TKey key, System.Func<TKey, TValue> addValueFactory, System.Func<TKey, TValue, TValue> updateValueFactory);
                TValue AddOrUpdate(TKey key, TValue addValue, System.Func<TKey, TValue, TValue> updateValueFactory);
                bool get_IsEmpty();
                void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
                bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
                System.Collections.Generic.ICollection<TKey> get_Keys();
                System.Collections.Generic.IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
                System.Collections.Generic.ICollection<TValue> get_Values();
                System.Collections.Generic.IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                void System.Collections.IDictionary.Add(object key, object value);
                bool System.Collections.IDictionary.Contains(object key);
                System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
                bool System.Collections.IDictionary.get_IsFixedSize();
                bool System.Collections.IDictionary.get_IsReadOnly();
                System.Collections.ICollection System.Collections.IDictionary.get_Keys();
                void System.Collections.IDictionary.Remove(object key);
                System.Collections.ICollection System.Collections.IDictionary.get_Values();
                object System.Collections.IDictionary.get_Item(object key);
                void System.Collections.IDictionary.set_Item(object key, object value);
                void System.Collections.ICollection.CopyTo(System.Array array, int index);
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                void GrowTable(System.Collections.Concurrent.ConcurrentDictionary.Tables<TKey, TValue> tables);
                void AcquireAllLocks(ref int locksAcquired);
                void AcquireLocks(int fromInclusive, int toExclusive, ref int locksAcquired);
                void ReleaseLocks(int fromInclusive, int toExclusive);
                System.Collections.ObjectModel.ReadOnlyCollection<TKey> GetKeys();
                System.Collections.ObjectModel.ReadOnlyCollection<TValue> GetValues();
                void OnSerializing(System.Runtime.Serialization.StreamingContext context);
                void OnSerialized(System.Runtime.Serialization.StreamingContext context);
                void OnDeserialized(System.Runtime.Serialization.StreamingContext context);

                class Tables<TKey, TValue>
                {
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> _buckets;
                    /*0x0*/ object[] _locks;
                    /*0x0*/ int[] _countPerLock;

                    Tables(System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> buckets, object[] locks, int[] countPerLock);
                }

                class Node<TKey, TValue>
                {
                    /*0x0*/ TKey _key;
                    /*0x0*/ TValue _value;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> _next;
                    /*0x0*/ int _hashcode;

                    Node(TKey key, TValue value, int hashcode, System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> next);
                }

                class DictionaryEnumerator<TKey, TValue> : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> _enumerator;

                    DictionaryEnumerator(System.Collections.Concurrent.ConcurrentDictionary<TKey, TValue> dictionary);
                    System.Collections.DictionaryEntry get_Entry();
                    object get_Key();
                    object get_Value();
                    object get_Current();
                    bool MoveNext();
                    void Reset();
                }

                class <GetEnumerator>d__35<TKey, TValue> : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ int <>1__state;
                    /*0x0*/ System.Collections.Generic.KeyValuePair<TKey, TValue> <>2__current;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary<TKey, TValue> <>4__this;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> <buckets>5__2;
                    /*0x0*/ int <i>5__3;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentDictionary.Node<TKey, TValue> <current>5__4;

                    <GetEnumerator>d__35(int <>1__state);
                    void System.IDisposable.Dispose();
                    bool MoveNext();
                    System.Collections.Generic.KeyValuePair<TKey, TValue> System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_Current();
                    void System.Collections.IEnumerator.Reset();
                    object System.Collections.IEnumerator.get_Current();
                }
            }

            class IDictionaryDebugView<K, V>
            {
                /*0x0*/ System.Collections.Generic.IDictionary<K, V> _dictionary;

                IDictionaryDebugView(System.Collections.Generic.IDictionary<K, V> dictionary);
                System.Collections.Generic.KeyValuePair<K, V> get_Items();
            }

            class ConcurrentStack<T> : System.Collections.Concurrent.IProducerConsumerCollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<T>
            {
                static int BACKOFF_MAX_YIELDS = 8;
                /*0x0*/ System.Collections.Concurrent.ConcurrentStack.Node<T> _head;

                static void ValidatePushPopRangeInput(T[] items, int startIndex, int count);
                static void CopyRemovedItems(System.Collections.Concurrent.ConcurrentStack.Node<T> head, T[] collection, int startIndex, int nodesCount);
                ConcurrentStack();
                ConcurrentStack(System.Collections.Generic.IEnumerable<T> collection);
                void InitializeFromCollection(System.Collections.Generic.IEnumerable<T> collection);
                bool get_IsEmpty();
                int get_Count();
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                void Clear();
                void System.Collections.ICollection.CopyTo(System.Array array, int index);
                void CopyTo(T[] array, int index);
                void Push(T item);
                void PushRange(T[] items);
                void PushRange(T[] items, int startIndex, int count);
                void PushCore(System.Collections.Concurrent.ConcurrentStack.Node<T> head, System.Collections.Concurrent.ConcurrentStack.Node<T> tail);
                bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
                bool TryPeek(ref T result);
                bool TryPop(ref T result);
                int TryPopRange(T[] items);
                int TryPopRange(T[] items, int startIndex, int count);
                bool TryPopCore(ref T result);
                int TryPopCore(int count, ref System.Collections.Concurrent.ConcurrentStack.Node<T> poppedHead);
                bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(ref T item);
                T[] ToArray();
                System.Collections.Generic.List<T> ToList();
                System.Collections.Generic.List<T> ToList(System.Collections.Concurrent.ConcurrentStack.Node<T> curr);
                System.Collections.Generic.IEnumerator<T> GetEnumerator();
                System.Collections.Generic.IEnumerator<T> GetEnumerator(System.Collections.Concurrent.ConcurrentStack.Node<T> head);
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();

                class Node<T>
                {
                    /*0x0*/ T _value;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentStack.Node<T> _next;

                    Node(T value);
                }

                class <GetEnumerator>d__35<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ int <>1__state;
                    /*0x0*/ T <>2__current;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentStack.Node<T> head;
                    /*0x0*/ System.Collections.Concurrent.ConcurrentStack.Node<T> <current>5__2;

                    <GetEnumerator>d__35(int <>1__state);
                    void System.IDisposable.Dispose();
                    bool MoveNext();
                    T System.Collections.Generic.IEnumerator<T>.get_Current();
                    void System.Collections.IEnumerator.Reset();
                    object System.Collections.IEnumerator.get_Current();
                }
            }

            interface IProducerConsumerCollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.ICollection
            {
                void CopyTo(T[] array, int index);
                bool TryAdd(T item);
                bool TryTake(ref T item);
                T[] ToArray();
            }

            class IProducerConsumerCollectionDebugView<T>
            {
                /*0x0*/ System.Collections.Concurrent.IProducerConsumerCollection<T> _collection;

                IProducerConsumerCollectionDebugView(System.Collections.Concurrent.IProducerConsumerCollection<T> collection);
                T[] get_Items();
            }

            class OrderablePartitioner<TSource> : System.Collections.Concurrent.Partitioner<TSource>
            {
                /*0x0*/ bool <KeysOrderedInEachPartition>k__BackingField;
                /*0x0*/ bool <KeysOrderedAcrossPartitions>k__BackingField;
                /*0x0*/ bool <KeysNormalized>k__BackingField;

                OrderablePartitioner(bool keysOrderedInEachPartition, bool keysOrderedAcrossPartitions, bool keysNormalized);
                System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>>> GetOrderablePartitions(int partitionCount);
                System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> GetOrderableDynamicPartitions();
                bool get_KeysOrderedInEachPartition();
                void set_KeysOrderedInEachPartition(bool value);
                bool get_KeysOrderedAcrossPartitions();
                void set_KeysOrderedAcrossPartitions(bool value);
                bool get_KeysNormalized();
                void set_KeysNormalized(bool value);
                System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<TSource>> GetPartitions(int partitionCount);
                System.Collections.Generic.IEnumerable<TSource> GetDynamicPartitions();

                class EnumerableDropIndices<TSource> : System.Collections.Generic.IEnumerable<TSource>, System.Collections.IEnumerable, System.IDisposable
                {
                    /*0x0*/ System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> _source;

                    EnumerableDropIndices(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> source);
                    System.Collections.Generic.IEnumerator<TSource> GetEnumerator();
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    void Dispose();
                }

                class EnumeratorDropIndices<TSource> : System.Collections.Generic.IEnumerator<TSource>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>> _source;

                    EnumeratorDropIndices(System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>> source);
                    bool MoveNext();
                    TSource get_Current();
                    object System.Collections.IEnumerator.get_Current();
                    void Dispose();
                    void Reset();
                }
            }

            class Partitioner<TSource>
            {
                Partitioner();
                System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<TSource>> GetPartitions(int partitionCount);
                bool get_SupportsDynamicPartitions();
                System.Collections.Generic.IEnumerable<TSource> GetDynamicPartitions();
            }

            enum EnumerablePartitionerOptions
            {
                None = 0,
                NoBuffering = 1,
            }

            class Partitioner
            {
                static int DEFAULT_BYTES_PER_UNIT = 128;
                static int DEFAULT_BYTES_PER_CHUNK = 512;

                static System.Collections.Concurrent.OrderablePartitioner<TSource> Create<TSource>(System.Collections.Generic.IList<TSource> list, bool loadBalance);
                static System.Collections.Concurrent.OrderablePartitioner<TSource> Create<TSource>(TSource[] array, bool loadBalance);
                static System.Collections.Concurrent.OrderablePartitioner<TSource> Create<TSource>(System.Collections.Generic.IEnumerable<TSource> source);
                static System.Collections.Concurrent.OrderablePartitioner<TSource> Create<TSource>(System.Collections.Generic.IEnumerable<TSource> source, System.Collections.Concurrent.EnumerablePartitionerOptions partitionerOptions);
                static /*0x21d7c60*/ System.Collections.Concurrent.OrderablePartitioner<System.Tuple<long, long>> Create(long fromInclusive, long toExclusive);
                static /*0x21d7de4*/ System.Collections.Concurrent.OrderablePartitioner<System.Tuple<long, long>> Create(long fromInclusive, long toExclusive, long rangeSize);
                static /*0x21d7d54*/ System.Collections.Generic.IEnumerable<System.Tuple<long, long>> CreateRanges(long fromInclusive, long toExclusive, long rangeSize);
                static /*0x21d7f00*/ System.Collections.Concurrent.OrderablePartitioner<System.Tuple<int, int>> Create(int fromInclusive, int toExclusive);
                static /*0x21d8080*/ System.Collections.Concurrent.OrderablePartitioner<System.Tuple<int, int>> Create(int fromInclusive, int toExclusive, int rangeSize);
                static /*0x21d7ff0*/ System.Collections.Generic.IEnumerable<System.Tuple<int, int>> CreateRanges(int fromInclusive, int toExclusive, int rangeSize);
                static int GetDefaultChunkSize<TSource>();

                class DynamicPartitionEnumerator_Abstract<TSource, TSourceReader> : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>>, System.IDisposable, System.Collections.IEnumerator
                {
                    static /*0x0*/ int s_defaultMaxChunkSize;
                    /*0x0*/ TSourceReader _sharedReader;
                    /*0x0*/ System.Collections.Concurrent.Partitioner.SharedInt _currentChunkSize;
                    /*0x0*/ System.Collections.Concurrent.Partitioner.SharedInt _localOffset;
                    /*0x0*/ int _doublingCountdown;
                    /*0x0*/ int _maxChunkSize;
                    /*0x0*/ System.Collections.Concurrent.Partitioner.SharedLong _sharedIndex;

                    static DynamicPartitionEnumerator_Abstract();
                    DynamicPartitionEnumerator_Abstract(TSourceReader sharedReader, System.Collections.Concurrent.Partitioner.SharedLong sharedIndex);
                    DynamicPartitionEnumerator_Abstract(TSourceReader sharedReader, System.Collections.Concurrent.Partitioner.SharedLong sharedIndex, bool useSingleChunking);
                    bool GrabNextChunk(int requestedChunkSize);
                    bool get_HasNoElementsLeft();
                    System.Collections.Generic.KeyValuePair<long, TSource> get_Current();
                    void Dispose();
                    void Reset();
                    object System.Collections.IEnumerator.get_Current();
                    bool MoveNext();
                }

                class DynamicPartitionerForIEnumerable<TSource> : System.Collections.Concurrent.OrderablePartitioner<TSource>
                {
                    /*0x0*/ System.Collections.Generic.IEnumerable<TSource> _source;
                    /*0x0*/ bool _useSingleChunking;

                    DynamicPartitionerForIEnumerable(System.Collections.Generic.IEnumerable<TSource> source, System.Collections.Concurrent.EnumerablePartitionerOptions partitionerOptions);
                    System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>>> GetOrderablePartitions(int partitionCount);
                    System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> GetOrderableDynamicPartitions();
                    bool get_SupportsDynamicPartitions();

                    class InternalPartitionEnumerable<TSource> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>>, System.Collections.IEnumerable, System.IDisposable
                    {
                        /*0x0*/ System.Collections.Generic.IEnumerator<TSource> _sharedReader;
                        /*0x0*/ System.Collections.Concurrent.Partitioner.SharedLong _sharedIndex;
                        /*0x0*/ System.Collections.Generic.KeyValuePair<long, TSource> _fillBuffer;
                        /*0x0*/ int _fillBufferSize;
                        /*0x0*/ int _fillBufferCurrentPosition;
                        /*0x0*/ int _activeCopiers;
                        /*0x0*/ System.Collections.Concurrent.Partitioner.SharedBool _hasNoElementsLeft;
                        /*0x0*/ System.Collections.Concurrent.Partitioner.SharedBool _sourceDepleted;
                        /*0x0*/ object _sharedLock;
                        /*0x0*/ bool _disposed;
                        /*0x0*/ System.Collections.Concurrent.Partitioner.SharedInt _activePartitionCount;
                        /*0x0*/ bool _useSingleChunking;

                        InternalPartitionEnumerable(System.Collections.Generic.IEnumerator<TSource> sharedReader, bool useSingleChunking, bool isStaticPartitioning);
                        System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>> GetEnumerator();
                        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                        void TryCopyFromFillBuffer(System.Collections.Generic.KeyValuePair<long, TSource> destArray, int requestedChunkSize, ref int actualNumElementsGrabbed);
                        bool GrabChunk(System.Collections.Generic.KeyValuePair<long, TSource> destArray, int requestedChunkSize, ref int actualNumElementsGrabbed);
                        bool GrabChunk_Single(System.Collections.Generic.KeyValuePair<long, TSource> destArray, int requestedChunkSize, ref int actualNumElementsGrabbed);
                        bool GrabChunk_Buffered(System.Collections.Generic.KeyValuePair<long, TSource> destArray, int requestedChunkSize, ref int actualNumElementsGrabbed);
                        void Dispose();
                    }

                    class InternalPartitionEnumerator<TSource> : System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract<TSource, System.Collections.Generic.IEnumerator<TSource>>
                    {
                        /*0x0*/ System.Collections.Generic.KeyValuePair<long, TSource> _localList;
                        /*0x0*/ System.Collections.Concurrent.Partitioner.SharedBool _hasNoElementsLeft;
                        /*0x0*/ System.Collections.Concurrent.Partitioner.SharedInt _activePartitionCount;
                        /*0x0*/ System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable.InternalPartitionEnumerable<TSource> _enumerable;

                        InternalPartitionEnumerator(System.Collections.Generic.IEnumerator<TSource> sharedReader, System.Collections.Concurrent.Partitioner.SharedLong sharedIndex, System.Collections.Concurrent.Partitioner.SharedBool hasNoElementsLeft, System.Collections.Concurrent.Partitioner.SharedInt activePartitionCount, System.Collections.Concurrent.Partitioner.DynamicPartitionerForIEnumerable.InternalPartitionEnumerable<TSource> enumerable, bool useSingleChunking);
                        bool GrabNextChunk(int requestedChunkSize);
                        bool get_HasNoElementsLeft();
                        System.Collections.Generic.KeyValuePair<long, TSource> get_Current();
                        void Dispose();
                    }
                }

                class DynamicPartitionerForIndexRange_Abstract<TSource, TCollection> : System.Collections.Concurrent.OrderablePartitioner<TSource>
                {
                    /*0x0*/ TCollection _data;

                    DynamicPartitionerForIndexRange_Abstract(TCollection data);
                    System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> GetOrderableDynamicPartitions_Factory(TCollection data);
                    System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>>> GetOrderablePartitions(int partitionCount);
                    System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> GetOrderableDynamicPartitions();
                    bool get_SupportsDynamicPartitions();
                }

                class DynamicPartitionEnumeratorForIndexRange_Abstract<TSource, TSourceReader> : System.Collections.Concurrent.Partitioner.DynamicPartitionEnumerator_Abstract<TSource, TSourceReader>
                {
                    /*0x0*/ int _startIndex;

                    DynamicPartitionEnumeratorForIndexRange_Abstract(TSourceReader sharedReader, System.Collections.Concurrent.Partitioner.SharedLong sharedIndex);
                    int get_SourceCount();
                    bool GrabNextChunk(int requestedChunkSize);
                    bool get_HasNoElementsLeft();
                    void Dispose();
                }

                class DynamicPartitionerForIList<TSource> : System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract<TSource, System.Collections.Generic.IList<TSource>>
                {
                    DynamicPartitionerForIList(System.Collections.Generic.IList<TSource> source);
                    System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> GetOrderableDynamicPartitions_Factory(System.Collections.Generic.IList<TSource> _data);

                    class InternalPartitionEnumerable<TSource> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>>, System.Collections.IEnumerable
                    {
                        /*0x0*/ System.Collections.Generic.IList<TSource> _sharedReader;
                        /*0x0*/ System.Collections.Concurrent.Partitioner.SharedLong _sharedIndex;

                        InternalPartitionEnumerable(System.Collections.Generic.IList<TSource> sharedReader);
                        System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>> GetEnumerator();
                        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    }

                    class InternalPartitionEnumerator<TSource> : System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract<TSource, System.Collections.Generic.IList<TSource>>
                    {
                        InternalPartitionEnumerator(System.Collections.Generic.IList<TSource> sharedReader, System.Collections.Concurrent.Partitioner.SharedLong sharedIndex);
                        int get_SourceCount();
                        System.Collections.Generic.KeyValuePair<long, TSource> get_Current();
                    }
                }

                class DynamicPartitionerForArray<TSource> : System.Collections.Concurrent.Partitioner.DynamicPartitionerForIndexRange_Abstract<TSource, TSource[]>
                {
                    DynamicPartitionerForArray(TSource[] source);
                    System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>> GetOrderableDynamicPartitions_Factory(TSource[] _data);

                    class InternalPartitionEnumerable<TSource> : System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<long, TSource>>, System.Collections.IEnumerable
                    {
                        /*0x0*/ TSource[] _sharedReader;
                        /*0x0*/ System.Collections.Concurrent.Partitioner.SharedLong _sharedIndex;

                        InternalPartitionEnumerable(TSource[] sharedReader);
                        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                        System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>> GetEnumerator();
                    }

                    class InternalPartitionEnumerator<TSource> : System.Collections.Concurrent.Partitioner.DynamicPartitionEnumeratorForIndexRange_Abstract<TSource, TSource[]>
                    {
                        InternalPartitionEnumerator(TSource[] sharedReader, System.Collections.Concurrent.Partitioner.SharedLong sharedIndex);
                        int get_SourceCount();
                        System.Collections.Generic.KeyValuePair<long, TSource> get_Current();
                    }
                }

                class StaticIndexRangePartitioner<TSource, TCollection> : System.Collections.Concurrent.OrderablePartitioner<TSource>
                {
                    StaticIndexRangePartitioner();
                    int get_SourceCount();
                    System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>> CreatePartition(int startIndex, int endIndex);
                    System.Collections.Generic.IList<System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>>> GetOrderablePartitions(int partitionCount);
                }

                class StaticIndexRangePartition<TSource> : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ int _startIndex;
                    /*0x0*/ int _endIndex;
                    /*0x0*/ int _offset;

                    StaticIndexRangePartition(int startIndex, int endIndex);
                    System.Collections.Generic.KeyValuePair<long, TSource> get_Current();
                    void Dispose();
                    void Reset();
                    bool MoveNext();
                    object System.Collections.IEnumerator.get_Current();
                }

                class StaticIndexRangePartitionerForIList<TSource> : System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner<TSource, System.Collections.Generic.IList<TSource>>
                {
                    /*0x0*/ System.Collections.Generic.IList<TSource> _list;

                    StaticIndexRangePartitionerForIList(System.Collections.Generic.IList<TSource> list);
                    int get_SourceCount();
                    System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>> CreatePartition(int startIndex, int endIndex);
                }

                class StaticIndexRangePartitionForIList<TSource> : System.Collections.Concurrent.Partitioner.StaticIndexRangePartition<TSource>
                {
                    /*0x0*/ System.Collections.Generic.IList<TSource> _list;

                    StaticIndexRangePartitionForIList(System.Collections.Generic.IList<TSource> list, int startIndex, int endIndex);
                    System.Collections.Generic.KeyValuePair<long, TSource> get_Current();
                }

                class StaticIndexRangePartitionerForArray<TSource> : System.Collections.Concurrent.Partitioner.StaticIndexRangePartitioner<TSource, TSource[]>
                {
                    /*0x0*/ TSource[] _array;

                    StaticIndexRangePartitionerForArray(TSource[] array);
                    int get_SourceCount();
                    System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<long, TSource>> CreatePartition(int startIndex, int endIndex);
                }

                class StaticIndexRangePartitionForArray<TSource> : System.Collections.Concurrent.Partitioner.StaticIndexRangePartition<TSource>
                {
                    /*0x0*/ TSource[] _array;

                    StaticIndexRangePartitionForArray(TSource[] array, int startIndex, int endIndex);
                    System.Collections.Generic.KeyValuePair<long, TSource> get_Current();
                }

                class SharedInt
                {
                    /*0x10*/ int Value;

                    /*0x21d819c*/ SharedInt(int value);
                }

                class SharedBool
                {
                    /*0x10*/ bool Value;

                    /*0x21d81c8*/ SharedBool(bool value);
                }

                class SharedLong
                {
                    /*0x10*/ long Value;

                    /*0x21d81f4*/ SharedLong(long value);
                }

                class <CreateRanges>d__6 : System.Collections.Generic.IEnumerable<System.Tuple<long, long>>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Tuple<long, long>>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Tuple<long, long> <>2__current;
                    /*0x20*/ int <>l__initialThreadId;
                    /*0x28*/ long fromInclusive;
                    /*0x30*/ long <>3__fromInclusive;
                    /*0x38*/ long rangeSize;
                    /*0x40*/ long <>3__rangeSize;
                    /*0x48*/ long toExclusive;
                    /*0x50*/ long <>3__toExclusive;
                    /*0x58*/ bool <shouldQuit>5__2;
                    /*0x60*/ long <i>5__3;

                    /*0x21d7ecc*/ <CreateRanges>d__6(int <>1__state);
                    /*0x21d821c*/ void System.IDisposable.Dispose();
                    /*0x21d8220*/ bool MoveNext();
                    /*0x21d83d8*/ System.Tuple<long, long> System.Collections.Generic.IEnumerator<System.Tuple<System.Int64,System.Int64>>.get_Current();
                    /*0x21d83e0*/ void System.Collections.IEnumerator.Reset();
                    /*0x21d8420*/ object System.Collections.IEnumerator.get_Current();
                    /*0x21d8428*/ System.Collections.Generic.IEnumerator<System.Tuple<long, long>> System.Collections.Generic.IEnumerable<System.Tuple<System.Int64,System.Int64>>.GetEnumerator();
                    /*0x21d84dc*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                }

                class <CreateRanges>d__9 : System.Collections.Generic.IEnumerable<System.Tuple<int, int>>, System.Collections.IEnumerable, System.Collections.Generic.IEnumerator<System.Tuple<int, int>>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x10*/ int <>1__state;
                    /*0x18*/ System.Tuple<int, int> <>2__current;
                    /*0x20*/ int <>l__initialThreadId;
                    /*0x24*/ int fromInclusive;
                    /*0x28*/ int <>3__fromInclusive;
                    /*0x2c*/ int rangeSize;
                    /*0x30*/ int <>3__rangeSize;
                    /*0x34*/ int toExclusive;
                    /*0x38*/ int <>3__toExclusive;
                    /*0x3c*/ bool <shouldQuit>5__2;
                    /*0x40*/ int <i>5__3;

                    /*0x21d8168*/ <CreateRanges>d__9(int <>1__state);
                    /*0x21d84e0*/ void System.IDisposable.Dispose();
                    /*0x21d84e4*/ bool MoveNext();
                    /*0x21d867c*/ System.Tuple<int, int> System.Collections.Generic.IEnumerator<System.Tuple<System.Int32,System.Int32>>.get_Current();
                    /*0x21d8684*/ void System.Collections.IEnumerator.Reset();
                    /*0x21d86c4*/ object System.Collections.IEnumerator.get_Current();
                    /*0x21d86cc*/ System.Collections.Generic.IEnumerator<System.Tuple<int, int>> System.Collections.Generic.IEnumerable<System.Tuple<System.Int32,System.Int32>>.GetEnumerator();
                    /*0x21d8780*/ System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                }
            }
        }

        namespace ObjectModel
        {
            class Collection<T> : System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.IList, System.Collections.ICollection, System.Collections.Generic.IReadOnlyList<T>, System.Collections.Generic.IReadOnlyCollection<T>
            {
                /*0x0*/ System.Collections.Generic.IList<T> items;

                static bool IsCompatibleObject(object value);
                Collection();
                Collection(System.Collections.Generic.IList<T> list);
                int get_Count();
                System.Collections.Generic.IList<T> get_Items();
                T get_Item(int index);
                void set_Item(int index, T value);
                void Add(T item);
                void Clear();
                void CopyTo(T[] array, int index);
                bool Contains(T item);
                System.Collections.Generic.IEnumerator<T> GetEnumerator();
                int IndexOf(T item);
                void Insert(int index, T item);
                bool Remove(T item);
                void RemoveAt(int index);
                void ClearItems();
                void InsertItem(int index, T item);
                void RemoveItem(int index);
                void SetItem(int index, T item);
                bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                void System.Collections.ICollection.CopyTo(System.Array array, int index);
                object System.Collections.IList.get_Item(int index);
                void System.Collections.IList.set_Item(int index, object value);
                bool System.Collections.IList.get_IsReadOnly();
                bool System.Collections.IList.get_IsFixedSize();
                int System.Collections.IList.Add(object value);
                bool System.Collections.IList.Contains(object value);
                int System.Collections.IList.IndexOf(object value);
                void System.Collections.IList.Insert(int index, object value);
                void System.Collections.IList.Remove(object value);
            }

            class ReadOnlyCollection<T> : System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.IList, System.Collections.ICollection, System.Collections.Generic.IReadOnlyList<T>, System.Collections.Generic.IReadOnlyCollection<T>
            {
                /*0x0*/ System.Collections.Generic.IList<T> list;
                /*0x0*/ object _syncRoot;

                static bool IsCompatibleObject(object value);
                ReadOnlyCollection(System.Collections.Generic.IList<T> list);
                int get_Count();
                T get_Item(int index);
                bool Contains(T value);
                void CopyTo(T[] array, int index);
                System.Collections.Generic.IEnumerator<T> GetEnumerator();
                int IndexOf(T value);
                System.Collections.Generic.IList<T> get_Items();
                bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
                T System.Collections.Generic.IList<T>.get_Item(int index);
                void System.Collections.Generic.IList<T>.set_Item(int index, T value);
                void System.Collections.Generic.ICollection<T>.Add(T value);
                void System.Collections.Generic.ICollection<T>.Clear();
                void System.Collections.Generic.IList<T>.Insert(int index, T value);
                bool System.Collections.Generic.ICollection<T>.Remove(T value);
                void System.Collections.Generic.IList<T>.RemoveAt(int index);
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                void System.Collections.ICollection.CopyTo(System.Array array, int index);
                bool System.Collections.IList.get_IsFixedSize();
                bool System.Collections.IList.get_IsReadOnly();
                object System.Collections.IList.get_Item(int index);
                void System.Collections.IList.set_Item(int index, object value);
                int System.Collections.IList.Add(object value);
                void System.Collections.IList.Clear();
                bool System.Collections.IList.Contains(object value);
                int System.Collections.IList.IndexOf(object value);
                void System.Collections.IList.Insert(int index, object value);
                void System.Collections.IList.Remove(object value);
                void System.Collections.IList.RemoveAt(int index);
            }

            class KeyedCollection<TKey, TItem> : System.Collections.ObjectModel.Collection<TItem>
            {
                static int defaultThreshold = 0;
                /*0x0*/ System.Collections.Generic.IEqualityComparer<TKey> comparer;
                /*0x0*/ System.Collections.Generic.Dictionary<TKey, TItem> dict;
                /*0x0*/ int keyCount;
                /*0x0*/ int threshold;

                KeyedCollection();
                KeyedCollection(System.Collections.Generic.IEqualityComparer<TKey> comparer);
                KeyedCollection(System.Collections.Generic.IEqualityComparer<TKey> comparer, int dictionaryCreationThreshold);
                System.Collections.Generic.List<TItem> get_Items();
                System.Collections.Generic.IEqualityComparer<TKey> get_Comparer();
                TItem get_Item(TKey key);
                bool Contains(TKey key);
                bool TryGetValue(TKey key, ref TItem item);
                bool ContainsItem(TItem item);
                bool Remove(TKey key);
                System.Collections.Generic.IDictionary<TKey, TItem> get_Dictionary();
                void ChangeItemKey(TItem item, TKey newKey);
                void ClearItems();
                TKey GetKeyForItem(TItem item);
                void InsertItem(int index, TItem item);
                void RemoveItem(int index);
                void SetItem(int index, TItem item);
                void AddKey(TKey key, TItem item);
                void CreateDictionary();
                void RemoveKey(TKey key);
            }

            class ReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.IDictionary, System.Collections.ICollection, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>
            {
                /*0x0*/ System.Collections.Generic.IDictionary<TKey, TValue> m_dictionary;
                /*0x0*/ object _syncRoot;
                /*0x0*/ System.Collections.ObjectModel.ReadOnlyDictionary.KeyCollection<TKey, TValue> _keys;
                /*0x0*/ System.Collections.ObjectModel.ReadOnlyDictionary.ValueCollection<TKey, TValue> _values;

                static bool IsCompatibleKey(object key);
                ReadOnlyDictionary(System.Collections.Generic.IDictionary<TKey, TValue> dictionary);
                System.Collections.Generic.IDictionary<TKey, TValue> get_Dictionary();
                System.Collections.ObjectModel.ReadOnlyDictionary.KeyCollection<TKey, TValue> get_Keys();
                System.Collections.ObjectModel.ReadOnlyDictionary.ValueCollection<TKey, TValue> get_Values();
                bool ContainsKey(TKey key);
                System.Collections.Generic.ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
                bool TryGetValue(TKey key, ref TValue value);
                System.Collections.Generic.ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
                TValue get_Item(TKey key);
                void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
                bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
                TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
                void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
                int get_Count();
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> item);
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int arrayIndex);
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> item);
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> item);
                System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> GetEnumerator();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                void System.Collections.IDictionary.Add(object key, object value);
                void System.Collections.IDictionary.Clear();
                bool System.Collections.IDictionary.Contains(object key);
                System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
                bool System.Collections.IDictionary.get_IsFixedSize();
                bool System.Collections.IDictionary.get_IsReadOnly();
                System.Collections.ICollection System.Collections.IDictionary.get_Keys();
                void System.Collections.IDictionary.Remove(object key);
                System.Collections.ICollection System.Collections.IDictionary.get_Values();
                object System.Collections.IDictionary.get_Item(object key);
                void System.Collections.IDictionary.set_Item(object key, object value);
                void System.Collections.ICollection.CopyTo(System.Array array, int index);
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                System.Collections.Generic.IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
                System.Collections.Generic.IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();

                struct DictionaryEnumerator<TKey, TValue> : System.Collections.IDictionaryEnumerator, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.IDictionary<TKey, TValue> _dictionary;
                    /*0x0*/ System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> _enumerator;

                    DictionaryEnumerator(System.Collections.Generic.IDictionary<TKey, TValue> dictionary);
                    System.Collections.DictionaryEntry get_Entry();
                    object get_Key();
                    object get_Value();
                    object get_Current();
                    bool MoveNext();
                    void Reset();
                }

                class KeyCollection<TKey, TValue> : System.Collections.Generic.ICollection<TKey>, System.Collections.Generic.IEnumerable<TKey>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<TKey>
                {
                    /*0x0*/ System.Collections.Generic.ICollection<TKey> _collection;
                    /*0x0*/ object _syncRoot;

                    KeyCollection(System.Collections.Generic.ICollection<TKey> collection);
                    KeyCollection();
                    void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
                    void System.Collections.Generic.ICollection<TKey>.Clear();
                    bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item);
                    void CopyTo(TKey[] array, int arrayIndex);
                    int get_Count();
                    bool System.Collections.Generic.ICollection<TKey>.get_IsReadOnly();
                    bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
                    System.Collections.Generic.IEnumerator<TKey> GetEnumerator();
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    void System.Collections.ICollection.CopyTo(System.Array array, int index);
                    bool System.Collections.ICollection.get_IsSynchronized();
                    object System.Collections.ICollection.get_SyncRoot();
                }

                class ValueCollection<TKey, TValue> : System.Collections.Generic.ICollection<TValue>, System.Collections.Generic.IEnumerable<TValue>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<TValue>
                {
                    /*0x0*/ System.Collections.Generic.ICollection<TValue> _collection;
                    /*0x0*/ object _syncRoot;

                    ValueCollection(System.Collections.Generic.ICollection<TValue> collection);
                    ValueCollection();
                    void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
                    void System.Collections.Generic.ICollection<TValue>.Clear();
                    bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item);
                    void CopyTo(TValue[] array, int arrayIndex);
                    int get_Count();
                    bool System.Collections.Generic.ICollection<TValue>.get_IsReadOnly();
                    bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
                    System.Collections.Generic.IEnumerator<TValue> GetEnumerator();
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    void System.Collections.ICollection.CopyTo(System.Array array, int index);
                    bool System.Collections.ICollection.get_IsSynchronized();
                    object System.Collections.ICollection.get_SyncRoot();
                }
            }

            class ReadOnlyDictionaryHelpers
            {
                static void CopyToNonGenericICollectionHelper<T>(System.Collections.Generic.ICollection<T> collection, System.Array array, int index);
            }
        }

        namespace Generic
        {
            enum InsertionBehavior
            {
                None = 0,
                OverwriteExisting = 1,
                ThrowOnExisting = 2,
            }

            class Dictionary<TKey, TValue> : System.Collections.Generic.IDictionary<TKey, TValue>, System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable, System.Collections.IDictionary, System.Collections.ICollection, System.Collections.Generic.IReadOnlyDictionary<TKey, TValue>, System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Runtime.Serialization.ISerializable, System.Runtime.Serialization.IDeserializationCallback
            {
                static string VersionName = "Version";
                static string HashSizeName = "HashSize";
                static string KeyValuePairsName = "KeyValuePairs";
                static string ComparerName = "Comparer";
                /*0x0*/ int[] _buckets;
                /*0x0*/ System.Collections.Generic.Dictionary.Entry<TKey, TValue> _entries;
                /*0x0*/ int _count;
                /*0x0*/ int _freeList;
                /*0x0*/ int _freeCount;
                /*0x0*/ int _version;
                /*0x0*/ System.Collections.Generic.IEqualityComparer<TKey> _comparer;
                /*0x0*/ System.Collections.Generic.Dictionary.KeyCollection<TKey, TValue> _keys;
                /*0x0*/ System.Collections.Generic.Dictionary.ValueCollection<TKey, TValue> _values;
                /*0x0*/ object _syncRoot;

                static bool IsCompatibleKey(object key);
                Dictionary();
                Dictionary(int capacity);
                Dictionary(System.Collections.Generic.IEqualityComparer<TKey> comparer);
                Dictionary(int capacity, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                Dictionary(System.Collections.Generic.IDictionary<TKey, TValue> dictionary);
                Dictionary(System.Collections.Generic.IDictionary<TKey, TValue> dictionary, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                Dictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> collection);
                Dictionary(System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>> collection, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                Dictionary(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                System.Collections.Generic.IEqualityComparer<TKey> get_Comparer();
                int get_Count();
                System.Collections.Generic.Dictionary.KeyCollection<TKey, TValue> get_Keys();
                System.Collections.Generic.ICollection<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
                System.Collections.Generic.IEnumerable<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
                System.Collections.Generic.Dictionary.ValueCollection<TKey, TValue> get_Values();
                System.Collections.Generic.ICollection<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
                System.Collections.Generic.IEnumerable<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
                TValue get_Item(TKey key);
                void set_Item(TKey key, TValue value);
                void Add(TKey key, TValue value);
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(System.Collections.Generic.KeyValuePair<TKey, TValue> keyValuePair);
                void Clear();
                bool ContainsKey(TKey key);
                bool ContainsValue(TValue value);
                void CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int index);
                System.Collections.Generic.Dictionary.Enumerator<TKey, TValue> GetEnumerator();
                System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                int FindEntry(TKey key);
                int Initialize(int capacity);
                bool TryInsert(TKey key, TValue value, System.Collections.Generic.InsertionBehavior behavior);
                void OnDeserialization(object sender);
                void Resize();
                void Resize(int newSize, bool forceNewHashCodes);
                bool Remove(TKey key);
                bool Remove(TKey key, ref TValue value);
                bool TryGetValue(TKey key, ref TValue value);
                bool TryAdd(TKey key, TValue value);
                bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
                void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(System.Collections.Generic.KeyValuePair<TKey, TValue> array, int index);
                void System.Collections.ICollection.CopyTo(System.Array array, int index);
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                int EnsureCapacity(int capacity);
                void TrimExcess();
                void TrimExcess(int capacity);
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                bool System.Collections.IDictionary.get_IsFixedSize();
                bool System.Collections.IDictionary.get_IsReadOnly();
                System.Collections.ICollection System.Collections.IDictionary.get_Keys();
                System.Collections.ICollection System.Collections.IDictionary.get_Values();
                object System.Collections.IDictionary.get_Item(object key);
                void System.Collections.IDictionary.set_Item(object key, object value);
                void System.Collections.IDictionary.Add(object key, object value);
                bool System.Collections.IDictionary.Contains(object key);
                System.Collections.IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
                void System.Collections.IDictionary.Remove(object key);

                struct Entry<TKey, TValue>
                {
                    /*0x0*/ int hashCode;
                    /*0x0*/ int next;
                    /*0x0*/ TKey key;
                    /*0x0*/ TValue value;
                }

                struct Enumerator<TKey, TValue> : System.Collections.Generic.IEnumerator<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.IDisposable, System.Collections.IEnumerator, System.Collections.IDictionaryEnumerator
                {
                    static int DictEntry = 1;
                    static int KeyValuePair = 2;
                    /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;
                    /*0x0*/ int _version;
                    /*0x0*/ int _index;
                    /*0x0*/ System.Collections.Generic.KeyValuePair<TKey, TValue> _current;
                    /*0x0*/ int _getEnumeratorRetType;

                    Enumerator(System.Collections.Generic.Dictionary<TKey, TValue> dictionary, int getEnumeratorRetType);
                    bool MoveNext();
                    System.Collections.Generic.KeyValuePair<TKey, TValue> get_Current();
                    void Dispose();
                    object System.Collections.IEnumerator.get_Current();
                    void System.Collections.IEnumerator.Reset();
                    System.Collections.DictionaryEntry System.Collections.IDictionaryEnumerator.get_Entry();
                    object System.Collections.IDictionaryEnumerator.get_Key();
                    object System.Collections.IDictionaryEnumerator.get_Value();
                }

                class KeyCollection<TKey, TValue> : System.Collections.Generic.ICollection<TKey>, System.Collections.Generic.IEnumerable<TKey>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<TKey>
                {
                    /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;

                    KeyCollection(System.Collections.Generic.Dictionary<TKey, TValue> dictionary);
                    System.Collections.Generic.Dictionary.KeyCollection.Enumerator<TKey, TValue> GetEnumerator();
                    void CopyTo(TKey[] array, int index);
                    int get_Count();
                    bool System.Collections.Generic.ICollection<TKey>.get_IsReadOnly();
                    void System.Collections.Generic.ICollection<TKey>.Add(TKey item);
                    void System.Collections.Generic.ICollection<TKey>.Clear();
                    bool System.Collections.Generic.ICollection<TKey>.Contains(TKey item);
                    bool System.Collections.Generic.ICollection<TKey>.Remove(TKey item);
                    System.Collections.Generic.IEnumerator<TKey> System.Collections.Generic.IEnumerable<TKey>.GetEnumerator();
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    void System.Collections.ICollection.CopyTo(System.Array array, int index);
                    bool System.Collections.ICollection.get_IsSynchronized();
                    object System.Collections.ICollection.get_SyncRoot();

                    struct Enumerator<TKey, TValue> : System.Collections.Generic.IEnumerator<TKey>, System.IDisposable, System.Collections.IEnumerator
                    {
                        /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;
                        /*0x0*/ int _index;
                        /*0x0*/ int _version;
                        /*0x0*/ TKey _currentKey;

                        Enumerator(System.Collections.Generic.Dictionary<TKey, TValue> dictionary);
                        void Dispose();
                        bool MoveNext();
                        TKey get_Current();
                        object System.Collections.IEnumerator.get_Current();
                        void System.Collections.IEnumerator.Reset();
                    }
                }

                class ValueCollection<TKey, TValue> : System.Collections.Generic.ICollection<TValue>, System.Collections.Generic.IEnumerable<TValue>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<TValue>
                {
                    /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;

                    ValueCollection(System.Collections.Generic.Dictionary<TKey, TValue> dictionary);
                    System.Collections.Generic.Dictionary.ValueCollection.Enumerator<TKey, TValue> GetEnumerator();
                    void CopyTo(TValue[] array, int index);
                    int get_Count();
                    bool System.Collections.Generic.ICollection<TValue>.get_IsReadOnly();
                    void System.Collections.Generic.ICollection<TValue>.Add(TValue item);
                    bool System.Collections.Generic.ICollection<TValue>.Remove(TValue item);
                    void System.Collections.Generic.ICollection<TValue>.Clear();
                    bool System.Collections.Generic.ICollection<TValue>.Contains(TValue item);
                    System.Collections.Generic.IEnumerator<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator();
                    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                    void System.Collections.ICollection.CopyTo(System.Array array, int index);
                    bool System.Collections.ICollection.get_IsSynchronized();
                    object System.Collections.ICollection.get_SyncRoot();

                    struct Enumerator<TKey, TValue> : System.Collections.Generic.IEnumerator<TValue>, System.IDisposable, System.Collections.IEnumerator
                    {
                        /*0x0*/ System.Collections.Generic.Dictionary<TKey, TValue> _dictionary;
                        /*0x0*/ int _index;
                        /*0x0*/ int _version;
                        /*0x0*/ TValue _currentValue;

                        Enumerator(System.Collections.Generic.Dictionary<TKey, TValue> dictionary);
                        void Dispose();
                        bool MoveNext();
                        TValue get_Current();
                        object System.Collections.IEnumerator.get_Current();
                        void System.Collections.IEnumerator.Reset();
                    }
                }
            }

            interface IAsyncEnumerable<T>
            {
                System.Collections.Generic.IAsyncEnumerator<T> GetAsyncEnumerator(System.Threading.CancellationToken cancellationToken);
            }

            interface IAsyncEnumerator<T> : System.IAsyncDisposable
            {
                System.Threading.Tasks.ValueTask<bool> MoveNextAsync();
                T get_Current();
            }

            interface ICollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                int get_Count();
                bool get_IsReadOnly();
                void Add(T item);
                void Clear();
                bool Contains(T item);
                void CopyTo(T[] array, int arrayIndex);
                bool Remove(T item);
            }

            class ICollectionDebugView<T>
            {
                /*0x0*/ System.Collections.Generic.ICollection<T> _collection;

                ICollectionDebugView(System.Collections.Generic.ICollection<T> collection);
                T[] get_Items();
            }

            interface IComparer<T>
            {
                int Compare(T x, T y);
            }

            interface IDictionary<TKey, TValue> : System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
            {
                TValue get_Item(TKey key);
                void set_Item(TKey key, TValue value);
                System.Collections.Generic.ICollection<TKey> get_Keys();
                System.Collections.Generic.ICollection<TValue> get_Values();
                bool ContainsKey(TKey key);
                void Add(TKey key, TValue value);
                bool Remove(TKey key);
                bool TryGetValue(TKey key, ref TValue value);
            }

            class IDictionaryDebugView<K, V>
            {
                /*0x0*/ System.Collections.Generic.IDictionary<K, V> _dict;

                IDictionaryDebugView(System.Collections.Generic.IDictionary<K, V> dictionary);
                System.Collections.Generic.KeyValuePair<K, V> get_Items();
            }

            class DictionaryKeyCollectionDebugView<TKey, TValue>
            {
                /*0x0*/ System.Collections.Generic.ICollection<TKey> _collection;

                DictionaryKeyCollectionDebugView(System.Collections.Generic.ICollection<TKey> collection);
                TKey[] get_Items();
            }

            class DictionaryValueCollectionDebugView<TKey, TValue>
            {
                /*0x0*/ System.Collections.Generic.ICollection<TValue> _collection;

                DictionaryValueCollectionDebugView(System.Collections.Generic.ICollection<TValue> collection);
                TValue[] get_Items();
            }

            interface IEnumerable<T> : System.Collections.IEnumerable
            {
                System.Collections.Generic.IEnumerator<T> GetEnumerator();
            }

            interface IEnumerator<T> : System.IDisposable, System.Collections.IEnumerator
            {
                T get_Current();
            }

            interface IEqualityComparer<T>
            {
                bool Equals(T x, T y);
                int GetHashCode(T obj);
            }

            interface IList<T> : System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                T get_Item(int index);
                void set_Item(int index, T value);
                int IndexOf(T item);
                void Insert(int index, T item);
                void RemoveAt(int index);
            }

            interface IReadOnlyCollection<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                int get_Count();
            }

            interface IReadOnlyDictionary<TKey, TValue> : System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey, TValue>>, System.Collections.IEnumerable
            {
                bool ContainsKey(TKey key);
                bool TryGetValue(TKey key, ref TValue value);
                TValue get_Item(TKey key);
                System.Collections.Generic.IEnumerable<TKey> get_Keys();
                System.Collections.Generic.IEnumerable<TValue> get_Values();
            }

            interface IReadOnlyList<T> : System.Collections.Generic.IReadOnlyCollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                T get_Item(int index);
            }

            class KeyNotFoundException : System.SystemException
            {
                /*0x21d8784*/ KeyNotFoundException();
                /*0x21d87e0*/ KeyNotFoundException(string message);
                /*0x21d8804*/ KeyNotFoundException(string message, System.Exception innerException);
                /*0x21d8828*/ KeyNotFoundException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class KeyValuePair
            {
                static System.Collections.Generic.KeyValuePair<TKey, TValue> Create<TKey, TValue>(TKey key, TValue value);
                static /*0x21d8830*/ string PairToString(object key, object value);
            }

            struct KeyValuePair<TKey, TValue>
            {
                /*0x0*/ TKey key;
                /*0x0*/ TValue value;

                KeyValuePair(TKey key, TValue value);
                TKey get_Key();
                TValue get_Value();
                string ToString();
                void Deconstruct(ref TKey key, ref TValue value);
            }

            class List<T> : System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.IList, System.Collections.ICollection, System.Collections.Generic.IReadOnlyList<T>, System.Collections.Generic.IReadOnlyCollection<T>
            {
                static int DefaultCapacity = 4;
                static /*0x0*/ T[] s_emptyArray;
                /*0x0*/ T[] _items;
                /*0x0*/ int _size;
                /*0x0*/ int _version;
                /*0x0*/ object _syncRoot;

                static List();
                static bool IsCompatibleObject(object value);
                List();
                List(int capacity);
                List(System.Collections.Generic.IEnumerable<T> collection);
                int get_Capacity();
                void set_Capacity(int value);
                int get_Count();
                bool System.Collections.IList.get_IsFixedSize();
                bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
                bool System.Collections.IList.get_IsReadOnly();
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                T get_Item(int index);
                void set_Item(int index, T value);
                object System.Collections.IList.get_Item(int index);
                void System.Collections.IList.set_Item(int index, object value);
                void Add(T item);
                void AddWithResize(T item);
                int System.Collections.IList.Add(object item);
                void AddRange(System.Collections.Generic.IEnumerable<T> collection);
                System.Collections.ObjectModel.ReadOnlyCollection<T> AsReadOnly();
                int BinarySearch(int index, int count, T item, System.Collections.Generic.IComparer<T> comparer);
                int BinarySearch(T item);
                int BinarySearch(T item, System.Collections.Generic.IComparer<T> comparer);
                void Clear();
                bool Contains(T item);
                bool System.Collections.IList.Contains(object item);
                System.Collections.Generic.List<TOutput> ConvertAll<TOutput>(System.Converter<T, TOutput> converter);
                void CopyTo(T[] array);
                void System.Collections.ICollection.CopyTo(System.Array array, int arrayIndex);
                void CopyTo(int index, T[] array, int arrayIndex, int count);
                void CopyTo(T[] array, int arrayIndex);
                void EnsureCapacity(int min);
                bool Exists(System.Predicate<T> match);
                T Find(System.Predicate<T> match);
                System.Collections.Generic.List<T> FindAll(System.Predicate<T> match);
                int FindIndex(System.Predicate<T> match);
                int FindIndex(int startIndex, System.Predicate<T> match);
                int FindIndex(int startIndex, int count, System.Predicate<T> match);
                T FindLast(System.Predicate<T> match);
                int FindLastIndex(System.Predicate<T> match);
                int FindLastIndex(int startIndex, System.Predicate<T> match);
                int FindLastIndex(int startIndex, int count, System.Predicate<T> match);
                void ForEach(System.Action<T> action);
                System.Collections.Generic.List.Enumerator<T> GetEnumerator();
                System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                System.Collections.Generic.List<T> GetRange(int index, int count);
                int IndexOf(T item);
                int System.Collections.IList.IndexOf(object item);
                int IndexOf(T item, int index);
                int IndexOf(T item, int index, int count);
                void Insert(int index, T item);
                void System.Collections.IList.Insert(int index, object item);
                void InsertRange(int index, System.Collections.Generic.IEnumerable<T> collection);
                int LastIndexOf(T item);
                int LastIndexOf(T item, int index);
                int LastIndexOf(T item, int index, int count);
                bool Remove(T item);
                void System.Collections.IList.Remove(object item);
                int RemoveAll(System.Predicate<T> match);
                void RemoveAt(int index);
                void RemoveRange(int index, int count);
                void Reverse();
                void Reverse(int index, int count);
                void Sort();
                void Sort(System.Collections.Generic.IComparer<T> comparer);
                void Sort(int index, int count, System.Collections.Generic.IComparer<T> comparer);
                void Sort(System.Comparison<T> comparison);
                T[] ToArray();
                void TrimExcess();
                bool TrueForAll(System.Predicate<T> match);
                void AddEnumerable(System.Collections.Generic.IEnumerable<T> enumerable);

                struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.List<T> _list;
                    /*0x0*/ int _index;
                    /*0x0*/ int _version;
                    /*0x0*/ T _current;

                    Enumerator(System.Collections.Generic.List<T> list);
                    void Dispose();
                    bool MoveNext();
                    bool MoveNextRare();
                    T get_Current();
                    object System.Collections.IEnumerator.get_Current();
                    void System.Collections.IEnumerator.Reset();
                }
            }

            struct ValueListBuilder<T>
            {
                /*0x0*/ System.Span<T> _span;
                /*0x0*/ T[] _arrayFromPool;
                /*0x0*/ int _pos;

                ValueListBuilder(System.Span<T> initialSpan);
                int get_Length();
                ref T get_Item(int index);
                void Append(T item);
                System.ReadOnlySpan<T> AsSpan();
                void Dispose();
                void Grow();
            }

            struct ArrayBuilder<T>
            {
                static int DefaultCapacity = 4;
                static int MaxCoreClrArrayLength = 2146435071;
                /*0x0*/ T[] _array;
                /*0x0*/ int _count;

                ArrayBuilder(int capacity);
                int get_Capacity();
                int get_Count();
                T get_Item(int index);
                void set_Item(int index, T value);
                void Add(T item);
                T First();
                T Last();
                T[] ToArray();
                void UncheckedAdd(T item);
                void EnsureCapacity(int minimum);
            }

            class EnumerableHelpers
            {
                static void Copy<T>(System.Collections.Generic.IEnumerable<T> source, T[] array, int arrayIndex, int count);
                static void IterativeCopy<T>(System.Collections.Generic.IEnumerable<T> source, T[] array, int arrayIndex, int count);
                static T[] ToArray<T>(System.Collections.Generic.IEnumerable<T> source);
                static T[] ToArray<T>(System.Collections.Generic.IEnumerable<T> source, ref int length);
            }

            struct CopyPosition
            {
                /*0x10*/ int <Row>k__BackingField;
                /*0x14*/ int <Column>k__BackingField;

                static /*0x21d88f8*/ System.Collections.Generic.CopyPosition get_Start();
                /*0x21d88f0*/ CopyPosition(int row, int column);
                /*0x21d8900*/ int get_Row();
                /*0x21d8908*/ int get_Column();
                /*0x21d8910*/ System.Collections.Generic.CopyPosition Normalize(int endColumn);
                /*0x21d8940*/ string get_DebuggerDisplay();
            }

            struct LargeArrayBuilder<T>
            {
                static int StartingCapacity = 4;
                static int ResizeLimit = 8;
                /*0x0*/ int _maxCapacity;
                /*0x0*/ T[] _first;
                /*0x0*/ System.Collections.Generic.ArrayBuilder<T[]> _buffers;
                /*0x0*/ T[] _current;
                /*0x0*/ int _index;
                /*0x0*/ int _count;

                static int <CopyTo>g__CopyToCore|17_0(T[] sourceBuffer, int sourceIndex, ref System.Collections.Generic.LargeArrayBuilder.<>c__DisplayClass17_0<T> );
                LargeArrayBuilder(bool initialize);
                LargeArrayBuilder(int maxCapacity);
                int get_Count();
                void Add(T item);
                void AddWithBufferAllocation(T item);
                void AddRange(System.Collections.Generic.IEnumerable<T> items);
                void AddWithBufferAllocation(T item, ref T[] destination, ref int index);
                void CopyTo(T[] array, int arrayIndex, int count);
                System.Collections.Generic.CopyPosition CopyTo(System.Collections.Generic.CopyPosition position, T[] array, int arrayIndex, int count);
                T[] GetBuffer(int index);
                void SlowAdd(T item);
                T[] ToArray();
                bool TryMove(ref T[] array);
                void AllocateBuffer();

                struct <>c__DisplayClass17_0<T>
                {
                    /*0x0*/ int count;
                    /*0x0*/ T[] array;
                    /*0x0*/ int arrayIndex;
                }
            }

            class LowLevelDictionary<TKey, TValue>
            {
                static int DefaultSize = 17;
                /*0x0*/ System.Collections.Generic.LowLevelDictionary.Entry<TKey, TValue> _buckets;
                /*0x0*/ int _numEntries;
                /*0x0*/ int _version;
                /*0x0*/ System.Collections.Generic.IEqualityComparer<TKey> _comparer;

                LowLevelDictionary();
                LowLevelDictionary(int capacity);
                LowLevelDictionary(System.Collections.Generic.IEqualityComparer<TKey> comparer);
                LowLevelDictionary(int capacity, System.Collections.Generic.IEqualityComparer<TKey> comparer);
                int get_Count();
                TValue get_Item(TKey key);
                void set_Item(TKey key, TValue value);
                bool TryGetValue(TKey key, ref TValue value);
                void Add(TKey key, TValue value);
                void Clear(int capacity);
                bool Remove(TKey key);
                System.Collections.Generic.LowLevelDictionary.Entry<TKey, TValue> Find(TKey key);
                System.Collections.Generic.LowLevelDictionary.Entry<TKey, TValue> UncheckedAdd(TKey key, TValue value);
                void ExpandBuckets();
                int GetBucket(TKey key, int numBuckets);

                class Entry<TKey, TValue>
                {
                    /*0x0*/ TKey _key;
                    /*0x0*/ TValue _value;
                    /*0x0*/ System.Collections.Generic.LowLevelDictionary.Entry<TKey, TValue> _next;

                    Entry();
                }

                class DefaultComparer`1<TKey, TValue, T> : System.Collections.Generic.IEqualityComparer<T>
                {
                    DefaultComparer`1();
                    bool Equals(T x, T y);
                    int GetHashCode(T obj);
                }
            }

            class ReferenceEqualityComparer<T> : System.Collections.Generic.IEqualityComparer<T>
            {
                static /*0x0*/ System.Collections.Generic.ReferenceEqualityComparer<T> Instance;

                static ReferenceEqualityComparer();
                ReferenceEqualityComparer();
                bool Equals(T x, T y);
                int GetHashCode(T obj);
            }

            class CollectionExtensions
            {
                static TValue GetValueOrDefault<TKey, TValue>(System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary, TKey key);
                static TValue GetValueOrDefault<TKey, TValue>(System.Collections.Generic.IReadOnlyDictionary<TKey, TValue> dictionary, TKey key, TValue defaultValue);
                static bool TryAdd<TKey, TValue>(System.Collections.Generic.IDictionary<TKey, TValue> dictionary, TKey key, TValue value);
                static bool Remove<TKey, TValue>(System.Collections.Generic.IDictionary<TKey, TValue> dictionary, TKey key, ref TValue value);
            }

            class Queue<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<T>
            {
                static int MinimumGrow = 4;
                static int GrowFactor = 200;
                /*0x0*/ T[] _array;
                /*0x0*/ int _head;
                /*0x0*/ int _tail;
                /*0x0*/ int _size;
                /*0x0*/ int _version;
                /*0x0*/ object _syncRoot;

                Queue();
                Queue(int capacity);
                Queue(System.Collections.Generic.IEnumerable<T> collection);
                int get_Count();
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                void Clear();
                void CopyTo(T[] array, int arrayIndex);
                void System.Collections.ICollection.CopyTo(System.Array array, int index);
                void Enqueue(T item);
                System.Collections.Generic.Queue.Enumerator<T> GetEnumerator();
                System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                T Dequeue();
                bool TryDequeue(ref T result);
                T Peek();
                bool TryPeek(ref T result);
                bool Contains(T item);
                T[] ToArray();
                void SetCapacity(int capacity);
                void MoveNext(ref int index);
                void ThrowForEmptyQueue();
                void TrimExcess();

                struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.Queue<T> _q;
                    /*0x0*/ int _version;
                    /*0x0*/ int _index;
                    /*0x0*/ T _currentElement;

                    Enumerator(System.Collections.Generic.Queue<T> q);
                    void Dispose();
                    bool MoveNext();
                    T get_Current();
                    void ThrowEnumerationNotStartedOrEnded();
                    object System.Collections.IEnumerator.get_Current();
                    void System.Collections.IEnumerator.Reset();
                }
            }

            class QueueDebugView<T>
            {
                /*0x0*/ System.Collections.Generic.Queue<T> _queue;

                QueueDebugView(System.Collections.Generic.Queue<T> queue);
                T[] get_Items();
            }

            class Stack<T> : System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable, System.Collections.ICollection, System.Collections.Generic.IReadOnlyCollection<T>
            {
                static int DefaultCapacity = 4;
                /*0x0*/ T[] _array;
                /*0x0*/ int _size;
                /*0x0*/ int _version;
                /*0x0*/ object _syncRoot;

                Stack();
                Stack(int capacity);
                Stack(System.Collections.Generic.IEnumerable<T> collection);
                int get_Count();
                bool System.Collections.ICollection.get_IsSynchronized();
                object System.Collections.ICollection.get_SyncRoot();
                void Clear();
                bool Contains(T item);
                void CopyTo(T[] array, int arrayIndex);
                void System.Collections.ICollection.CopyTo(System.Array array, int arrayIndex);
                System.Collections.Generic.Stack.Enumerator<T> GetEnumerator();
                System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();
                void TrimExcess();
                T Peek();
                bool TryPeek(ref T result);
                T Pop();
                bool TryPop(ref T result);
                void Push(T item);
                void PushWithResize(T item);
                T[] ToArray();
                void ThrowForEmptyStack();

                struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.Stack<T> _stack;
                    /*0x0*/ int _version;
                    /*0x0*/ int _index;
                    /*0x0*/ T _currentElement;

                    Enumerator(System.Collections.Generic.Stack<T> stack);
                    void Dispose();
                    bool MoveNext();
                    T get_Current();
                    void ThrowEnumerationNotStartedOrEnded();
                    object System.Collections.IEnumerator.get_Current();
                    void System.Collections.IEnumerator.Reset();
                }
            }

            class StackDebugView<T>
            {
                /*0x0*/ System.Collections.Generic.Stack<T> _stack;

                StackDebugView(System.Collections.Generic.Stack<T> stack);
                T[] get_Items();
            }

            class CollectionDebugView<T>
            {
                /*0x0*/ System.Collections.Generic.ICollection<T> _collection;

                CollectionDebugView(System.Collections.Generic.ICollection<T> collection);
                T[] get_Items();
            }

            class DictionaryDebugView<K, V>
            {
                /*0x0*/ System.Collections.Generic.IDictionary<K, V> _dict;

                DictionaryDebugView(System.Collections.Generic.IDictionary<K, V> dictionary);
                System.Collections.Generic.KeyValuePair<K, V> get_Items();
            }

            class LowLevelList<T>
            {
                static int _defaultCapacity = 4;
                static /*0x0*/ T[] s_emptyArray;
                /*0x0*/ T[] _items;
                /*0x0*/ int _size;
                /*0x0*/ int _version;

                static LowLevelList();
                LowLevelList();
                LowLevelList(int capacity);
                LowLevelList(System.Collections.Generic.IEnumerable<T> collection);
                int get_Capacity();
                void set_Capacity(int value);
                int get_Count();
                T get_Item(int index);
                void set_Item(int index, T value);
                void Add(T item);
                void EnsureCapacity(int min);
                void AddRange(System.Collections.Generic.IEnumerable<T> collection);
                void Clear();
                bool Contains(T item);
                void CopyTo(int index, T[] array, int arrayIndex, int count);
                void CopyTo(T[] array, int arrayIndex);
                int IndexOf(T item);
                int IndexOf(T item, int index);
                void Insert(int index, T item);
                void InsertRange(int index, System.Collections.Generic.IEnumerable<T> collection);
                bool Remove(T item);
                int RemoveAll(System.Predicate<T> match);
                void RemoveAt(int index);
                T[] ToArray();
            }

            class LowLevelListWithIList<T> : System.Collections.Generic.LowLevelList<T>, System.Collections.Generic.IList<T>, System.Collections.Generic.ICollection<T>, System.Collections.Generic.IEnumerable<T>, System.Collections.IEnumerable
            {
                LowLevelListWithIList();
                LowLevelListWithIList(int capacity);
                LowLevelListWithIList(System.Collections.Generic.IEnumerable<T> collection);
                bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
                System.Collections.Generic.IEnumerator<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
                System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator();

                struct Enumerator<T> : System.Collections.Generic.IEnumerator<T>, System.IDisposable, System.Collections.IEnumerator
                {
                    /*0x0*/ System.Collections.Generic.LowLevelListWithIList<T> _list;
                    /*0x0*/ int _index;
                    /*0x0*/ int _version;
                    /*0x0*/ T _current;

                    Enumerator(System.Collections.Generic.LowLevelListWithIList<T> list);
                    void Dispose();
                    bool MoveNext();
                    bool MoveNextRare();
                    T get_Current();
                    object System.Collections.IEnumerator.get_Current();
                    void System.Collections.IEnumerator.Reset();
                }
            }

            class IntrospectiveSortUtilities
            {
                static int IntrosortSizeThreshold = 16;

                static /*0x21d89e0*/ int FloorLog2PlusOne(int n);
                static /*0x21d8a14*/ void ThrowOrIgnoreBadComparer(object comparer);
            }

            class ArraySortHelper<T>
            {
                static /*0x0*/ System.Collections.Generic.ArraySortHelper<T> s_defaultArraySortHelper;

                static ArraySortHelper();
                static void Sort(T[] keys, int index, int length, System.Comparison<T> comparer);
                static int InternalBinarySearch(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer);
                static void SwapIfGreater(T[] keys, System.Comparison<T> comparer, int a, int b);
                static void Swap(T[] a, int i, int j);
                static void IntrospectiveSort(T[] keys, int left, int length, System.Comparison<T> comparer);
                static void IntroSort(T[] keys, int lo, int hi, int depthLimit, System.Comparison<T> comparer);
                static int PickPivotAndPartition(T[] keys, int lo, int hi, System.Comparison<T> comparer);
                static void Heapsort(T[] keys, int lo, int hi, System.Comparison<T> comparer);
                static void DownHeap(T[] keys, int i, int n, int lo, System.Comparison<T> comparer);
                static void InsertionSort(T[] keys, int lo, int hi, System.Comparison<T> comparer);
                static System.Collections.Generic.ArraySortHelper<T> get_Default();
                ArraySortHelper();
                void Sort(T[] keys, int index, int length, System.Collections.Generic.IComparer<T> comparer);
                int BinarySearch(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer);
            }

            class GenericArraySortHelper<T>
            {
                static int BinarySearch(T[] array, int index, int length, T value);
                static void SwapIfGreaterWithItems(T[] keys, int a, int b);
                static void Swap(T[] a, int i, int j);
                static void IntrospectiveSort(T[] keys, int left, int length);
                static void IntroSort(T[] keys, int lo, int hi, int depthLimit);
                static int PickPivotAndPartition(T[] keys, int lo, int hi);
                static void Heapsort(T[] keys, int lo, int hi);
                static void DownHeap(T[] keys, int i, int n, int lo);
                static void InsertionSort(T[] keys, int lo, int hi);
                GenericArraySortHelper();
                void Sort(T[] keys, int index, int length, System.Collections.Generic.IComparer<T> comparer);
                int BinarySearch(T[] array, int index, int length, T value, System.Collections.Generic.IComparer<T> comparer);
            }

            class ArraySortHelper<TKey, TValue>
            {
                static /*0x0*/ System.Collections.Generic.ArraySortHelper<TKey, TValue> s_defaultArraySortHelper;

                static ArraySortHelper();
                static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, System.Collections.Generic.IComparer<TKey> comparer, int a, int b);
                static void Swap(TKey[] keys, TValue[] values, int i, int j);
                static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length, System.Collections.Generic.IComparer<TKey> comparer);
                static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit, System.Collections.Generic.IComparer<TKey> comparer);
                static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi, System.Collections.Generic.IComparer<TKey> comparer);
                static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi, System.Collections.Generic.IComparer<TKey> comparer);
                static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo, System.Collections.Generic.IComparer<TKey> comparer);
                static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi, System.Collections.Generic.IComparer<TKey> comparer);
                static System.Collections.Generic.ArraySortHelper<TKey, TValue> get_Default();
                ArraySortHelper();
                void Sort(TKey[] keys, TValue[] values, int index, int length, System.Collections.Generic.IComparer<TKey> comparer);
            }

            class GenericArraySortHelper<TKey, TValue>
            {
                static void SwapIfGreaterWithItems(TKey[] keys, TValue[] values, int a, int b);
                static void Swap(TKey[] keys, TValue[] values, int i, int j);
                static void IntrospectiveSort(TKey[] keys, TValue[] values, int left, int length);
                static void IntroSort(TKey[] keys, TValue[] values, int lo, int hi, int depthLimit);
                static int PickPivotAndPartition(TKey[] keys, TValue[] values, int lo, int hi);
                static void Heapsort(TKey[] keys, TValue[] values, int lo, int hi);
                static void DownHeap(TKey[] keys, TValue[] values, int i, int n, int lo);
                static void InsertionSort(TKey[] keys, TValue[] values, int lo, int hi);
                GenericArraySortHelper();
                void Sort(TKey[] keys, TValue[] values, int index, int length, System.Collections.Generic.IComparer<TKey> comparer);
            }

            class Comparer<T> : System.Collections.IComparer, System.Collections.Generic.IComparer<T>
            {
                static /*0x0*/ System.Collections.Generic.Comparer<T> defaultComparer;

                static System.Collections.Generic.Comparer<T> get_Default();
                static System.Collections.Generic.Comparer<T> Create(System.Comparison<T> comparison);
                static System.Collections.Generic.Comparer<T> CreateComparer();
                Comparer();
                int Compare(T x, T y);
                int System.Collections.IComparer.Compare(object x, object y);
            }

            class GenericComparer<T> : System.Collections.Generic.Comparer<T>
            {
                GenericComparer();
                int Compare(T x, T y);
                bool Equals(object obj);
                int GetHashCode();
            }

            class NullableComparer<T> : System.Collections.Generic.Comparer<System.Nullable<T>>
            {
                NullableComparer();
                int Compare(System.Nullable<T> x, System.Nullable<T> y);
                bool Equals(object obj);
                int GetHashCode();
            }

            class ObjectComparer<T> : System.Collections.Generic.Comparer<T>
            {
                ObjectComparer();
                int Compare(T x, T y);
                bool Equals(object obj);
                int GetHashCode();
            }

            class ComparisonComparer<T> : System.Collections.Generic.Comparer<T>
            {
                /*0x0*/ System.Comparison<T> _comparison;

                ComparisonComparer(System.Comparison<T> comparison);
                int Compare(T x, T y);
            }

            class EqualityComparer<T> : System.Collections.IEqualityComparer, System.Collections.Generic.IEqualityComparer<T>
            {
                static /*0x0*/ System.Collections.Generic.EqualityComparer<T> defaultComparer;

                static System.Collections.Generic.EqualityComparer<T> get_Default();
                static System.Collections.Generic.EqualityComparer<T> CreateComparer();
                EqualityComparer();
                bool Equals(T x, T y);
                int GetHashCode(T obj);
                int IndexOf(T[] array, T value, int startIndex, int count);
                int LastIndexOf(T[] array, T value, int startIndex, int count);
                int System.Collections.IEqualityComparer.GetHashCode(object obj);
                bool System.Collections.IEqualityComparer.Equals(object x, object y);
            }

            class GenericEqualityComparer<T> : System.Collections.Generic.EqualityComparer<T>
            {
                GenericEqualityComparer();
                bool Equals(T x, T y);
                int GetHashCode(T obj);
                int IndexOf(T[] array, T value, int startIndex, int count);
                int LastIndexOf(T[] array, T value, int startIndex, int count);
                bool Equals(object obj);
                int GetHashCode();
            }

            class NullableEqualityComparer<T> : System.Collections.Generic.EqualityComparer<System.Nullable<T>>
            {
                NullableEqualityComparer();
                bool Equals(System.Nullable<T> x, System.Nullable<T> y);
                int GetHashCode(System.Nullable<T> obj);
                int IndexOf(System.Nullable<T> array, System.Nullable<T> value, int startIndex, int count);
                int LastIndexOf(System.Nullable<T> array, System.Nullable<T> value, int startIndex, int count);
                bool Equals(object obj);
                int GetHashCode();
            }

            class ObjectEqualityComparer<T> : System.Collections.Generic.EqualityComparer<T>
            {
                ObjectEqualityComparer();
                bool Equals(T x, T y);
                int GetHashCode(T obj);
                int IndexOf(T[] array, T value, int startIndex, int count);
                int LastIndexOf(T[] array, T value, int startIndex, int count);
                bool Equals(object obj);
                int GetHashCode();
            }

            class ByteEqualityComparer : System.Collections.Generic.EqualityComparer<byte>
            {
                /*0x21d8d44*/ ByteEqualityComparer();
                /*0x21d8a7c*/ bool Equals(byte x, byte y);
                /*0x21d8a8c*/ int GetHashCode(byte b);
                /*0x21d8aa8*/ int IndexOf(byte[] array, byte value, int startIndex, int count);
                /*0x21d8c3c*/ int LastIndexOf(byte[] array, byte value, int startIndex, int count);
                /*0x21d8c94*/ bool Equals(object obj);
                /*0x21d8d0c*/ int GetHashCode();
            }

            class EnumEqualityComparer<T> : System.Collections.Generic.EqualityComparer<T>, System.Runtime.Serialization.ISerializable
            {
                EnumEqualityComparer();
                EnumEqualityComparer(System.Runtime.Serialization.SerializationInfo information, System.Runtime.Serialization.StreamingContext context);
                bool Equals(T x, T y);
                int GetHashCode(T obj);
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
                bool Equals(object obj);
                int GetHashCode();
            }

            class SByteEnumEqualityComparer<T> : System.Collections.Generic.EnumEqualityComparer<T>, System.Runtime.Serialization.ISerializable
            {
                SByteEnumEqualityComparer();
                SByteEnumEqualityComparer(System.Runtime.Serialization.SerializationInfo information, System.Runtime.Serialization.StreamingContext context);
                int GetHashCode(T obj);
            }

            class ShortEnumEqualityComparer<T> : System.Collections.Generic.EnumEqualityComparer<T>, System.Runtime.Serialization.ISerializable
            {
                ShortEnumEqualityComparer();
                ShortEnumEqualityComparer(System.Runtime.Serialization.SerializationInfo information, System.Runtime.Serialization.StreamingContext context);
                int GetHashCode(T obj);
            }

            class LongEnumEqualityComparer<T> : System.Collections.Generic.EqualityComparer<T>, System.Runtime.Serialization.ISerializable
            {
                LongEnumEqualityComparer();
                LongEnumEqualityComparer(System.Runtime.Serialization.SerializationInfo information, System.Runtime.Serialization.StreamingContext context);
                bool Equals(T x, T y);
                int GetHashCode(T obj);
                bool Equals(object obj);
                int GetHashCode();
                void GetObjectData(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);
            }

            class InternalStringComparer : System.Collections.Generic.EqualityComparer<string>
            {
                /*0x21d8e48*/ InternalStringComparer();
                /*0x21d8d8c*/ int GetHashCode(string obj);
                /*0x21d8dac*/ bool Equals(string x, string y);
                /*0x21d8ddc*/ int IndexOf(string[] array, string value, int startIndex, int count);
            }
        }
    }

    namespace Buffers
    {
        class SpanAction<T, TArg> : System.MulticastDelegate
        {
            SpanAction(object object, nint method);
            void Invoke(System.Span<T> span, TArg arg);
            System.IAsyncResult BeginInvoke(System.Span<T> span, TArg arg, System.AsyncCallback callback, object object);
            void EndInvoke(System.IAsyncResult result);
        }

        class ReadOnlySpanAction<T, TArg> : System.MulticastDelegate
        {
            ReadOnlySpanAction(object object, nint method);
            void Invoke(System.ReadOnlySpan<T> span, TArg arg);
            System.IAsyncResult BeginInvoke(System.ReadOnlySpan<T> span, TArg arg, System.AsyncCallback callback, object object);
            void EndInvoke(System.IAsyncResult result);
        }

        class ArrayPool<T>
        {
            static /*0x0*/ System.Buffers.ArrayPool<T> <Shared>k__BackingField;

            static ArrayPool();
            static System.Buffers.ArrayPool<T> get_Shared();
            static System.Buffers.ArrayPool<T> Create();
            static System.Buffers.ArrayPool<T> Create(int maxArrayLength, int maxArraysPerBucket);
            ArrayPool();
            T[] Rent(int minimumLength);
            void Return(T[] array, bool clearArray);
        }

        class ArrayPoolEventSource : System.Diagnostics.Tracing.EventSource
        {
            static /*0x0*/ System.Buffers.ArrayPoolEventSource Log;

            static /*0x21d91bc*/ ArrayPoolEventSource();
            /*0x21d8e90*/ ArrayPoolEventSource();
            /*0x21d8f3c*/ void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
            /*0x21d904c*/ void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, System.Buffers.ArrayPoolEventSource.BufferAllocatedReason reason);
            /*0x21d9178*/ void BufferReturned(int bufferId, int bufferSize, int poolId);
            /*0x21d9190*/ void BufferTrimmed(int bufferId, int bufferSize, int poolId);
            /*0x21d91a8*/ void BufferTrimPoll(int milliseconds, int pressure);

            enum BufferAllocatedReason
            {
                Pooled = 0,
                OverMaximumSize = 1,
                PoolExhausted = 2,
            }
        }

        class ConfigurableArrayPool<T> : System.Buffers.ArrayPool<T>
        {
            static int DefaultMaxArrayLength = 1048576;
            static int DefaultMaxNumberOfArraysPerBucket = 50;
            /*0x0*/ System.Buffers.ConfigurableArrayPool.Bucket<T> _buckets;

            ConfigurableArrayPool();
            ConfigurableArrayPool(int maxArrayLength, int maxArraysPerBucket);
            int get_Id();
            T[] Rent(int minimumLength);
            void Return(T[] array, bool clearArray);

            class Bucket<T>
            {
                /*0x0*/ int _bufferLength;
                /*0x0*/ T[][] _buffers;
                /*0x0*/ int _poolId;
                /*0x0*/ System.Threading.SpinLock _lock;
                /*0x0*/ int _index;

                Bucket(int bufferLength, int numberOfBuffers, int poolId);
                int get_Id();
                T[] Rent();
                void Return(T[] array);
            }
        }

        interface IMemoryOwner<T> : System.IDisposable
        {
            System.Memory<T> get_Memory();
        }

        interface IPinnable
        {
            System.Buffers.MemoryHandle Pin(int elementIndex);
            void Unpin();
        }

        struct MemoryHandle : System.IDisposable
        {
            /*0x10*/ void* _pointer;
            /*0x18*/ System.Runtime.InteropServices.GCHandle _handle;
            /*0x20*/ System.Buffers.IPinnable _pinnable;

            /*0x21d921c*/ MemoryHandle(void* pointer, System.Runtime.InteropServices.GCHandle handle, System.Buffers.IPinnable pinnable);
            /*0x21d9228*/ void* get_Pointer();
            /*0x21d9230*/ void Dispose();
        }

        class MemoryManager<T> : System.Buffers.IMemoryOwner<T>, System.IDisposable, System.Buffers.IPinnable
        {
            MemoryManager();
            System.Memory<T> get_Memory();
            System.Span<T> GetSpan();
            System.Buffers.MemoryHandle Pin(int elementIndex);
            void Unpin();
            System.Memory<T> CreateMemory(int length);
            System.Memory<T> CreateMemory(int start, int length);
            bool TryGetArray(ref System.ArraySegment<T> segment);
            void System.IDisposable.Dispose();
            void Dispose(bool disposing);
        }

        class TlsOverPerCoreLockedStacksArrayPool<T> : System.Buffers.ArrayPool<T>
        {
            static int NumBuckets = 17;
            static int MaxPerCorePerArraySizeStacks = 64;
            static int MaxBuffersPerArraySizePerCore = 8;
            static /*0x0*/ bool s_trimBuffers;
            static /*0x0*/ System.Runtime.CompilerServices.ConditionalWeakTable<T[][], object> s_allTlsBuckets;
            [ThreadStatic] static T[][] t_tlsBuckets;
            /*0x0*/ int[] _bucketArraySizes;
            /*0x0*/ System.Buffers.TlsOverPerCoreLockedStacksArrayPool.PerCoreLockedStacks<T> _buckets;
            /*0x0*/ int _callbackCreated;

            static TlsOverPerCoreLockedStacksArrayPool();
            static bool Gen2GcCallbackFunc(object target);
            static System.Buffers.TlsOverPerCoreLockedStacksArrayPool.MemoryPressure<T> GetMemoryPressure();
            static bool GetTrimBuffers();
            TlsOverPerCoreLockedStacksArrayPool();
            System.Buffers.TlsOverPerCoreLockedStacksArrayPool.PerCoreLockedStacks<T> CreatePerCoreLockedStacks(int bucketIndex);
            int get_Id();
            T[] Rent(int minimumLength);
            void Return(T[] array, bool clearArray);
            bool Trim();

            enum MemoryPressure<T>
            {
                Low = 0,
                Medium = 1,
                High = 2,
            }

            class PerCoreLockedStacks<T>
            {
                /*0x0*/ System.Buffers.TlsOverPerCoreLockedStacksArrayPool.LockedStack<T> _perCoreStacks;

                PerCoreLockedStacks();
                void TryPush(T[] array);
                T[] TryPop();
                bool Trim(uint tickCount, int id, System.Buffers.TlsOverPerCoreLockedStacksArrayPool.MemoryPressure<T> pressure, int[] bucketSizes);
            }

            class LockedStack<T>
            {
                /*0x0*/ T[][] _arrays;
                /*0x0*/ int _count;
                /*0x0*/ uint _firstStackItemMS;

                LockedStack();
                bool TryPush(T[] array);
                T[] TryPop();
                void Trim(uint tickCount, int id, System.Buffers.TlsOverPerCoreLockedStacksArrayPool.MemoryPressure<T> pressure, int bucketSize);
            }
        }

        class Utilities
        {
            static /*0x21d92fc*/ int SelectBucketIndex(int bufferSize);
            static /*0x21d9378*/ int GetMaxSizeForBucket(int binIndex);
        }

        class ArrayMemoryPool<T> : System.Buffers.MemoryPool<T>
        {
            static int s_maxBufferSize = 2147483647;

            ArrayMemoryPool();
            int get_MaxBufferSize();
            System.Buffers.IMemoryOwner<T> Rent(int minimumBufferSize);
            void Dispose(bool disposing);

            class ArrayMemoryPoolBuffer<T> : System.Buffers.IMemoryOwner<T>, System.IDisposable
            {
                /*0x0*/ T[] _array;

                ArrayMemoryPoolBuffer(int size);
                System.Memory<T> get_Memory();
                void Dispose();
            }
        }

        class BuffersExtensions
        {
            static System.Nullable<System.SequencePosition> PositionOf<T>(ref System.Buffers.ReadOnlySequence<T> source, T value);
            static System.Nullable<System.SequencePosition> PositionOfMultiSegment<T>(ref System.Buffers.ReadOnlySequence<T> source, T value);
            static void CopyTo<T>(ref System.Buffers.ReadOnlySequence<T> source, System.Span<T> destination);
            static void CopyToMultiSegment<T>(ref System.Buffers.ReadOnlySequence<T> sequence, System.Span<T> destination);
            static T[] ToArray<T>(ref System.Buffers.ReadOnlySequence<T> sequence);
            static void Write<T>(System.Buffers.IBufferWriter<T> writer, System.ReadOnlySpan<T> value);
            static void WriteMultiSegment<T>(System.Buffers.IBufferWriter<T> writer, ref System.ReadOnlySpan<T> source, System.Span<T> destination);
        }

        interface IBufferWriter<T>
        {
            void Advance(int count);
            System.Memory<T> GetMemory(int sizeHint);
            System.Span<T> GetSpan(int sizeHint);
        }

        class MemoryPool<T> : System.IDisposable
        {
            static /*0x0*/ System.Buffers.MemoryPool<T> s_shared;

            static MemoryPool();
            static System.Buffers.MemoryPool<T> get_Shared();
            MemoryPool();
            System.Buffers.IMemoryOwner<T> Rent(int minBufferSize);
            int get_MaxBufferSize();
            void Dispose();
            void Dispose(bool disposing);
        }

        enum OperationStatus
        {
            Done = 0,
            DestinationTooSmall = 1,
            NeedMoreData = 2,
            InvalidData = 3,
        }

        struct ReadOnlySequence<T>
        {
            static /*0x0*/ System.Buffers.ReadOnlySequence<T> Empty;
            /*0x0*/ object _startObject;
            /*0x0*/ object _endObject;
            /*0x0*/ int _startInteger;
            /*0x0*/ int _endInteger;

            static ReadOnlySequence();
            static System.SequencePosition SeekMultiSegment(System.Buffers.ReadOnlySequenceSegment<T> currentSegment, object endObject, int endIndex, long offset, System.ExceptionArgument argument);
            static System.SequencePosition GetEndPosition(System.Buffers.ReadOnlySequenceSegment<T> startSegment, object startObject, int startIndex, object endObject, int endIndex, long length);
            static int GetIndex(ref System.SequencePosition position);
            static int GetIndex(int Integer);
            static bool InRange(uint value, uint start, uint end);
            static bool InRange(ulong value, ulong start, ulong end);
            static System.ReadOnlySpan<T> GetFirstSpanSlow(object startObject, int startIndex, int endIndex, bool hasMultipleSegments);
            ReadOnlySequence(object startSegment, int startIndexAndFlags, object endSegment, int endIndexAndFlags);
            ReadOnlySequence(System.Buffers.ReadOnlySequenceSegment<T> startSegment, int startIndex, System.Buffers.ReadOnlySequenceSegment<T> endSegment, int endIndex);
            ReadOnlySequence(T[] array);
            ReadOnlySequence(T[] array, int start, int length);
            ReadOnlySequence(System.ReadOnlyMemory<T> memory);
            long get_Length();
            bool get_IsEmpty();
            bool get_IsSingleSegment();
            System.ReadOnlyMemory<T> get_First();
            System.ReadOnlySpan<T> get_FirstSpan();
            System.SequencePosition get_Start();
            System.SequencePosition get_End();
            System.Buffers.ReadOnlySequence<T> Slice(long start, long length);
            System.Buffers.ReadOnlySequence<T> Slice(long start, System.SequencePosition end);
            System.Buffers.ReadOnlySequence<T> Slice(System.SequencePosition start, long length);
            System.Buffers.ReadOnlySequence<T> Slice(int start, int length);
            System.Buffers.ReadOnlySequence<T> Slice(int start, System.SequencePosition end);
            System.Buffers.ReadOnlySequence<T> Slice(System.SequencePosition start, int length);
            System.Buffers.ReadOnlySequence<T> Slice(System.SequencePosition start, System.SequencePosition end);
            System.Buffers.ReadOnlySequence<T> Slice(System.SequencePosition start);
            System.Buffers.ReadOnlySequence<T> Slice(long start);
            string ToString();
            System.Buffers.ReadOnlySequence.Enumerator<T> GetEnumerator();
            System.SequencePosition GetPosition(long offset);
            System.SequencePosition GetPosition(long offset, System.SequencePosition origin);
            bool TryGet(ref System.SequencePosition position, ref System.ReadOnlyMemory<T> memory, bool advance);
            bool TryGetBuffer(ref System.SequencePosition position, ref System.ReadOnlyMemory<T> memory, ref System.SequencePosition next);
            System.ReadOnlyMemory<T> GetFirstBuffer();
            System.ReadOnlyMemory<T> GetFirstBufferSlow(object startObject, bool isMultiSegment);
            System.ReadOnlySpan<T> GetFirstSpan();
            System.ReadOnlySpan<T> GetFirstSpanSlow(object startObject, bool isMultiSegment);
            System.SequencePosition Seek(long offset, System.ExceptionArgument exceptionArgument);
            System.SequencePosition Seek(ref System.SequencePosition start, long offset);
            void BoundsCheck(ref System.SequencePosition position, bool positionIsNotNull);
            void BoundsCheck(uint sliceStartIndex, object sliceStartObject, uint sliceEndIndex, object sliceEndObject);
            System.Buffers.ReadOnlySequence.SequenceType<T> GetSequenceType();
            System.Buffers.ReadOnlySequence<T> SliceImpl(ref System.SequencePosition start, ref System.SequencePosition end);
            System.Buffers.ReadOnlySequence<T> SliceImpl(ref System.SequencePosition start);
            long GetLength();
            bool TryGetReadOnlySequenceSegment(ref System.Buffers.ReadOnlySequenceSegment<T> startSegment, ref int startIndex, ref System.Buffers.ReadOnlySequenceSegment<T> endSegment, ref int endIndex);
            bool TryGetArray(ref System.ArraySegment<T> segment);
            bool TryGetString(ref string text, ref int start, ref int length);
            void GetFirstSpan(ref System.ReadOnlySpan<T> first, ref System.SequencePosition next);

            struct Enumerator<T>
            {
                /*0x0*/ System.Buffers.ReadOnlySequence<T> _sequence;
                /*0x0*/ System.SequencePosition _next;
                /*0x0*/ System.ReadOnlyMemory<T> _currentMemory;

                Enumerator(ref System.Buffers.ReadOnlySequence<T> sequence);
                System.ReadOnlyMemory<T> get_Current();
                bool MoveNext();
            }

            enum SequenceType<T>
            {
                MultiSegment = 0,
                Array = 1,
                MemoryManager = 2,
                String = 3,
                Empty = 4,
            }

            class <>c<T>
            {
                static /*0x0*/ System.Buffers.ReadOnlySequence.<>c<T> <>9;
                static /*0x0*/ System.Buffers.SpanAction<char, System.Buffers.ReadOnlySequence<char>> <>9__33_0;

                static <>c();
                <>c();
                void <ToString>b__33_0(System.Span<char> span, System.Buffers.ReadOnlySequence<char> sequence);
            }
        }

        class ReadOnlySequence
        {
            static int FlagBitMask = -2147483648;
            static int IndexBitMask = 2147483647;
            static int SegmentStartMask = 0;
            static int SegmentEndMask = 0;
            static int ArrayStartMask = 0;
            static int ArrayEndMask = -2147483648;
            static int MemoryManagerStartMask = -2147483648;
            static int MemoryManagerEndMask = 0;
            static int StringStartMask = -2147483648;
            static int StringEndMask = -2147483648;

            static /*0x21d9384*/ int SegmentToSequenceStart(int startIndex);
            static /*0x21d9388*/ int SegmentToSequenceEnd(int endIndex);
            static /*0x21d938c*/ int ArrayToSequenceStart(int startIndex);
            static /*0x21d9390*/ int ArrayToSequenceEnd(int endIndex);
            static /*0x21d9398*/ int MemoryManagerToSequenceStart(int startIndex);
            static /*0x21d93a0*/ int MemoryManagerToSequenceEnd(int endIndex);
            static /*0x21d93a4*/ int StringToSequenceStart(int startIndex);
            static /*0x21d93ac*/ int StringToSequenceEnd(int endIndex);
        }

        class ReadOnlySequenceDebugView<T>
        {
            /*0x0*/ T[] _array;
            /*0x0*/ System.Buffers.ReadOnlySequenceDebugView.ReadOnlySequenceDebugViewSegments<T> _segments;

            ReadOnlySequenceDebugView(System.Buffers.ReadOnlySequence<T> sequence);
            System.Buffers.ReadOnlySequenceDebugView.ReadOnlySequenceDebugViewSegments<T> get_BufferSegments();
            T[] get_Items();

            struct ReadOnlySequenceDebugViewSegments<T>
            {
                /*0x0*/ System.ReadOnlyMemory<T> <Segments>k__BackingField;

                void set_Segments(System.ReadOnlyMemory<T> value);
            }
        }

        class ReadOnlySequenceSegment<T>
        {
            /*0x0*/ System.ReadOnlyMemory<T> <Memory>k__BackingField;
            /*0x0*/ System.Buffers.ReadOnlySequenceSegment<T> <Next>k__BackingField;
            /*0x0*/ long <RunningIndex>k__BackingField;

            ReadOnlySequenceSegment();
            System.ReadOnlyMemory<T> get_Memory();
            void set_Memory(System.ReadOnlyMemory<T> value);
            System.Buffers.ReadOnlySequenceSegment<T> get_Next();
            void set_Next(System.Buffers.ReadOnlySequenceSegment<T> value);
            long get_RunningIndex();
            void set_RunningIndex(long value);
        }

        struct StandardFormat : System.IEquatable<System.Buffers.StandardFormat>
        {
            static byte NoPrecision = 255;
            static byte MaxPrecision = 99;
            static int FormatStringLength = 3;
            /*0x10*/ byte _format;
            /*0x11*/ byte _precision;

            static /*0x21d9450*/ System.Buffers.StandardFormat op_Implicit(char symbol);
            static /*0x21d947c*/ System.Buffers.StandardFormat Parse(System.ReadOnlySpan<char> format);
            static /*0x21d9620*/ System.Buffers.StandardFormat Parse(string format);
            static /*0x21d9680*/ bool TryParse(System.ReadOnlySpan<char> format, ref System.Buffers.StandardFormat result);
            static /*0x21d949c*/ bool ParseHelper(System.ReadOnlySpan<char> format, ref System.Buffers.StandardFormat standardFormat, bool throws);
            static /*0x21d9968*/ bool op_Equality(System.Buffers.StandardFormat left, System.Buffers.StandardFormat right);
            static /*0x21d998c*/ bool op_Inequality(System.Buffers.StandardFormat left, System.Buffers.StandardFormat right);
            /*0x21d93f4*/ StandardFormat(char symbol, byte precision);
            /*0x21d93b4*/ char get_Symbol();
            /*0x21d93bc*/ byte get_Precision();
            /*0x21d93c4*/ bool get_HasPrecision();
            /*0x21d93d4*/ bool get_IsDefault();
            /*0x21d9688*/ bool Equals(object obj);
            /*0x21d9734*/ int GetHashCode();
            /*0x21d970c*/ bool Equals(System.Buffers.StandardFormat other);
            /*0x21d9768*/ string ToString();
            /*0x21d9870*/ int Format(System.Span<char> destination);
        }

        class ArrayBufferWriter<T> : System.Buffers.IBufferWriter<T>
        {
            static int DefaultInitialBufferSize = 256;
            /*0x0*/ T[] _buffer;
            /*0x0*/ int _index;

            static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
            ArrayBufferWriter();
            ArrayBufferWriter(int initialCapacity);
            System.ReadOnlyMemory<T> get_WrittenMemory();
            System.ReadOnlySpan<T> get_WrittenSpan();
            int get_WrittenCount();
            int get_Capacity();
            int get_FreeCapacity();
            void Clear();
            void Advance(int count);
            System.Memory<T> GetMemory(int sizeHint);
            System.Span<T> GetSpan(int sizeHint);
            void CheckAndResizeBuffer(int sizeHint);
        }

        struct SequenceReader<T>
        {
            /*0x0*/ System.SequencePosition _currentPosition;
            /*0x0*/ System.SequencePosition _nextPosition;
            /*0x0*/ bool _moreData;
            /*0x0*/ long _length;
            /*0x0*/ System.Buffers.ReadOnlySequence<T> <Sequence>k__BackingField;
            /*0x0*/ System.ReadOnlySpan<T> <CurrentSpan>k__BackingField;
            /*0x0*/ int <CurrentSpanIndex>k__BackingField;
            /*0x0*/ long <Consumed>k__BackingField;

            SequenceReader(System.Buffers.ReadOnlySequence<T> sequence);
            bool TryReadTo(ref System.ReadOnlySpan<T> span, T delimiter, bool advancePastDelimiter);
            bool TryReadToSlow(ref System.ReadOnlySpan<T> span, T delimiter, bool advancePastDelimiter);
            bool TryReadTo(ref System.ReadOnlySpan<T> span, T delimiter, T delimiterEscape, bool advancePastDelimiter);
            bool TryReadToSlow(ref System.ReadOnlySpan<T> span, T delimiter, T delimiterEscape, int index, bool advancePastDelimiter);
            bool TryReadToSlow(ref System.Buffers.ReadOnlySequence<T> sequence, T delimiter, T delimiterEscape, int index, bool advancePastDelimiter);
            bool TryReadTo(ref System.Buffers.ReadOnlySequence<T> sequence, T delimiter, bool advancePastDelimiter);
            bool TryReadToInternal(ref System.Buffers.ReadOnlySequence<T> sequence, T delimiter, bool advancePastDelimiter, int skip);
            bool TryReadTo(ref System.Buffers.ReadOnlySequence<T> sequence, T delimiter, T delimiterEscape, bool advancePastDelimiter);
            bool TryReadToAny(ref System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> delimiters, bool advancePastDelimiter);
            bool TryReadToAnySlow(ref System.ReadOnlySpan<T> span, System.ReadOnlySpan<T> delimiters, bool advancePastDelimiter);
            bool TryReadToAny(ref System.Buffers.ReadOnlySequence<T> sequence, System.ReadOnlySpan<T> delimiters, bool advancePastDelimiter);
            bool TryReadToAnyInternal(ref System.Buffers.ReadOnlySequence<T> sequence, System.ReadOnlySpan<T> delimiters, bool advancePastDelimiter, int skip);
            bool TryReadTo(ref System.Buffers.ReadOnlySequence<T> sequence, System.ReadOnlySpan<T> delimiter, bool advancePastDelimiter);
            bool TryAdvanceTo(T delimiter, bool advancePastDelimiter);
            bool TryAdvanceToAny(System.ReadOnlySpan<T> delimiters, bool advancePastDelimiter);
            long AdvancePast(T value);
            long AdvancePastAny(System.ReadOnlySpan<T> values);
            long AdvancePastAny(T value0, T value1, T value2, T value3);
            long AdvancePastAny(T value0, T value1, T value2);
            long AdvancePastAny(T value0, T value1);
            bool IsNext(T next, bool advancePast);
            bool IsNext(System.ReadOnlySpan<T> next, bool advancePast);
            bool IsNextSlow(System.ReadOnlySpan<T> next, bool advancePast);
            bool get_End();
            System.Buffers.ReadOnlySequence<T> get_Sequence();
            System.SequencePosition get_Position();
            System.ReadOnlySpan<T> get_CurrentSpan();
            void set_CurrentSpan(System.ReadOnlySpan<T> value);
            int get_CurrentSpanIndex();
            void set_CurrentSpanIndex(int value);
            System.ReadOnlySpan<T> get_UnreadSpan();
            long get_Consumed();
            void set_Consumed(long value);
            long get_Remaining();
            long get_Length();
            bool TryPeek(ref T value);
            bool TryRead(ref T value);
            void Rewind(long count);
            void RetreatToPreviousSpan(long consumed);
            void ResetReader();
            void GetNextSpan();
            void Advance(long count);
            void AdvanceCurrentSpan(long count);
            void AdvanceWithinSpan(long count);
            void AdvanceToNextSpan(long count);
            bool TryCopyTo(System.Span<T> destination);
            bool TryCopyMultisegment(System.Span<T> destination);
        }

        class SequenceReaderExtensions
        {
            static bool TryRead<T>(ref System.Buffers.SequenceReader<byte> reader, ref T value);
            static bool TryReadMultisegment<T>(ref System.Buffers.SequenceReader<byte> reader, ref T value);
            static /*0x21d99b0*/ bool TryReadLittleEndian(ref System.Buffers.SequenceReader<byte> reader, ref short value);
            static /*0x21d9ad0*/ bool TryReadBigEndian(ref System.Buffers.SequenceReader<byte> reader, ref short value);
            static /*0x21d9a54*/ bool TryReadReverseEndianness(ref System.Buffers.SequenceReader<byte> reader, ref short value);
            static /*0x21d9b74*/ bool TryReadLittleEndian(ref System.Buffers.SequenceReader<byte> reader, ref int value);
            static /*0x21d9c90*/ bool TryReadBigEndian(ref System.Buffers.SequenceReader<byte> reader, ref int value);
            static /*0x21d9c18*/ bool TryReadReverseEndianness(ref System.Buffers.SequenceReader<byte> reader, ref int value);
            static /*0x21d9d34*/ bool TryReadLittleEndian(ref System.Buffers.SequenceReader<byte> reader, ref long value);
            static /*0x21d9e58*/ bool TryReadBigEndian(ref System.Buffers.SequenceReader<byte> reader, ref long value);
            static /*0x21d9dd8*/ bool TryReadReverseEndianness(ref System.Buffers.SequenceReader<byte> reader, ref long value);
        }

        namespace Binary
        {
            class BinaryPrimitives
            {
                static /*0x21d9efc*/ sbyte ReverseEndianness(sbyte value);
                static /*0x21d9f00*/ short ReverseEndianness(short value);
                static /*0x21d9f0c*/ int ReverseEndianness(int value);
                static /*0x21d9f14*/ long ReverseEndianness(long value);
                static /*0x21d9f28*/ byte ReverseEndianness(byte value);
                static /*0x21d9f2c*/ ushort ReverseEndianness(ushort value);
                static /*0x21d9f38*/ uint ReverseEndianness(uint value);
                static /*0x21d9f40*/ ulong ReverseEndianness(ulong value);
                static /*0x21d9f54*/ short ReadInt16BigEndian(System.ReadOnlySpan<byte> source);
                static /*0x21da038*/ int ReadInt32BigEndian(System.ReadOnlySpan<byte> source);
                static /*0x21da11c*/ long ReadInt64BigEndian(System.ReadOnlySpan<byte> source);
                static /*0x21da20c*/ ushort ReadUInt16BigEndian(System.ReadOnlySpan<byte> source);
                static /*0x21da2f0*/ uint ReadUInt32BigEndian(System.ReadOnlySpan<byte> source);
                static /*0x21da3d4*/ ulong ReadUInt64BigEndian(System.ReadOnlySpan<byte> source);
                static /*0x21da4c4*/ bool TryReadInt16BigEndian(System.ReadOnlySpan<byte> source, ref short value);
                static /*0x21da5d4*/ bool TryReadInt32BigEndian(System.ReadOnlySpan<byte> source, ref int value);
                static /*0x21da6e0*/ bool TryReadInt64BigEndian(System.ReadOnlySpan<byte> source, ref long value);
                static /*0x21da7f4*/ bool TryReadUInt16BigEndian(System.ReadOnlySpan<byte> source, ref ushort value);
                static /*0x21da904*/ bool TryReadUInt32BigEndian(System.ReadOnlySpan<byte> source, ref uint value);
                static /*0x21daa10*/ bool TryReadUInt64BigEndian(System.ReadOnlySpan<byte> source, ref ulong value);
                static /*0x21dab24*/ short ReadInt16LittleEndian(System.ReadOnlySpan<byte> source);
                static /*0x21dac08*/ int ReadInt32LittleEndian(System.ReadOnlySpan<byte> source);
                static /*0x21dacec*/ long ReadInt64LittleEndian(System.ReadOnlySpan<byte> source);
                static /*0x21daddc*/ ushort ReadUInt16LittleEndian(System.ReadOnlySpan<byte> source);
                static /*0x21daec0*/ uint ReadUInt32LittleEndian(System.ReadOnlySpan<byte> source);
                static /*0x21dafa4*/ ulong ReadUInt64LittleEndian(System.ReadOnlySpan<byte> source);
                static /*0x21db094*/ bool TryReadInt16LittleEndian(System.ReadOnlySpan<byte> source, ref short value);
                static /*0x21db194*/ bool TryReadInt32LittleEndian(System.ReadOnlySpan<byte> source, ref int value);
                static /*0x21db290*/ bool TryReadInt64LittleEndian(System.ReadOnlySpan<byte> source, ref long value);
                static /*0x21db394*/ bool TryReadUInt16LittleEndian(System.ReadOnlySpan<byte> source, ref ushort value);
                static /*0x21db494*/ bool TryReadUInt32LittleEndian(System.ReadOnlySpan<byte> source, ref uint value);
                static /*0x21db590*/ bool TryReadUInt64LittleEndian(System.ReadOnlySpan<byte> source, ref ulong value);
                static /*0x21db694*/ void WriteInt16BigEndian(System.Span<byte> destination, short value);
                static /*0x21db784*/ void WriteInt32BigEndian(System.Span<byte> destination, int value);
                static /*0x21db870*/ void WriteInt64BigEndian(System.Span<byte> destination, long value);
                static /*0x21db964*/ void WriteUInt16BigEndian(System.Span<byte> destination, ushort value);
                static /*0x21dba54*/ void WriteUInt32BigEndian(System.Span<byte> destination, uint value);
                static /*0x21dbb40*/ void WriteUInt64BigEndian(System.Span<byte> destination, ulong value);
                static /*0x21dbc34*/ bool TryWriteInt16BigEndian(System.Span<byte> destination, short value);
                static /*0x21dbd24*/ bool TryWriteInt32BigEndian(System.Span<byte> destination, int value);
                static /*0x21dbe10*/ bool TryWriteInt64BigEndian(System.Span<byte> destination, long value);
                static /*0x21dbf04*/ bool TryWriteUInt16BigEndian(System.Span<byte> destination, ushort value);
                static /*0x21dbff4*/ bool TryWriteUInt32BigEndian(System.Span<byte> destination, uint value);
                static /*0x21dc0e0*/ bool TryWriteUInt64BigEndian(System.Span<byte> destination, ulong value);
                static /*0x21dc1d4*/ void WriteInt16LittleEndian(System.Span<byte> destination, short value);
                static /*0x21dc2c4*/ void WriteInt32LittleEndian(System.Span<byte> destination, int value);
                static /*0x21dc3b0*/ void WriteInt64LittleEndian(System.Span<byte> destination, long value);
                static /*0x21dc4a4*/ void WriteUInt16LittleEndian(System.Span<byte> destination, ushort value);
                static /*0x21dc594*/ void WriteUInt32LittleEndian(System.Span<byte> destination, uint value);
                static /*0x21dc680*/ void WriteUInt64LittleEndian(System.Span<byte> destination, ulong value);
                static /*0x21dc774*/ bool TryWriteInt16LittleEndian(System.Span<byte> destination, short value);
                static /*0x21dc864*/ bool TryWriteInt32LittleEndian(System.Span<byte> destination, int value);
                static /*0x21dc950*/ bool TryWriteInt64LittleEndian(System.Span<byte> destination, long value);
                static /*0x21dca44*/ bool TryWriteUInt16LittleEndian(System.Span<byte> destination, ushort value);
                static /*0x21dcb34*/ bool TryWriteUInt32LittleEndian(System.Span<byte> destination, uint value);
                static /*0x21dcc20*/ bool TryWriteUInt64LittleEndian(System.Span<byte> destination, ulong value);
            }
        }

        namespace Text
        {
            class FormattingHelpers
            {
                static string HexTableLower = "0123456789abcdef";
                static string HexTableUpper = "0123456789ABCDEF";

                static /*0x21dcd14*/ int CountDigits(ulong value);
                static /*0x21dcdd0*/ int CountDigits(uint value);
                static /*0x21dce3c*/ int CountHexDigits(ulong value);
                static /*0x21dce84*/ char GetSymbolOrDefault(ref System.Buffers.StandardFormat format, char defaultSymbol);
                static /*0x21dcea4*/ void FillWithAsciiZeros(System.Span<byte> buffer);
                static /*0x21dcefc*/ void WriteHexByte(byte value, System.Span<byte> buffer, int startingIndex, System.Buffers.Text.FormattingHelpers.HexCasing casing);
                static /*0x21dcf58*/ void WriteDigits(ulong value, System.Span<byte> buffer);
                static /*0x21dd004*/ void WriteDigitsWithGroupSeparator(ulong value, System.Span<byte> buffer);
                static /*0x21dd0dc*/ void WriteDigits(uint value, System.Span<byte> buffer);
                static /*0x21dd188*/ void WriteFourDecimalDigits(uint value, System.Span<byte> buffer, int startingIndex);
                static /*0x21dd228*/ void WriteTwoDecimalDigits(uint value, System.Span<byte> buffer, int startingIndex);
                static /*0x21dd274*/ ulong DivMod(ulong numerator, ulong denominator, ref ulong modulo);
                static /*0x21dd288*/ uint DivMod(uint numerator, uint denominator, ref uint modulo);
                static /*0x21dd29c*/ int CountDecimalTrailingZeros(uint value, ref uint valueWithoutTrailingZeros);

                enum HexCasing
                {
                    Uppercase = 0,
                    Lowercase = 8224,
                }
            }

            class Base64
            {
                static byte EncodingPad = 61;
                static int MaximumEncodeLength = 1610612733;
                static /*0x0*/ sbyte[] s_decodingMap;
                static /*0x8*/ byte[] s_encodingMap;

                static /*0x21de014*/ Base64();
                static /*0x21dd2dc*/ System.Buffers.OperationStatus DecodeFromUtf8(System.ReadOnlySpan<byte> utf8, System.Span<byte> bytes, ref int bytesConsumed, ref int bytesWritten, bool isFinalBlock);
                static /*0x21dd6a0*/ int GetMaxDecodedFromUtf8Length(int length);
                static /*0x21dd6cc*/ System.Buffers.OperationStatus DecodeFromUtf8InPlace(System.Span<byte> buffer, ref int bytesWritten);
                static /*0x21dd950*/ int Decode(ref byte encodedBytes, ref sbyte decodingMap);
                static /*0x21dd984*/ void WriteThreeLowOrderBytes(ref byte destination, int value);
                static /*0x21dd99c*/ System.Buffers.OperationStatus EncodeToUtf8(System.ReadOnlySpan<byte> bytes, System.Span<byte> utf8, ref int bytesConsumed, ref int bytesWritten, bool isFinalBlock);
                static /*0x21ddcb0*/ int GetMaxEncodedToUtf8Length(int length);
                static /*0x21ddcfc*/ System.Buffers.OperationStatus EncodeToUtf8InPlace(System.Span<byte> buffer, int dataLength, ref int bytesWritten);
                static /*0x21ddf64*/ int Encode(ref byte threeBytes, ref byte encodingMap);
                static /*0x21ddfac*/ int EncodeAndPadOne(ref byte twoBytes, ref byte encodingMap);
                static /*0x21ddfec*/ int EncodeAndPadTwo(ref byte oneByte, ref byte encodingMap);
            }

            class Utf8Constants
            {
                static byte Colon = 58;
                static byte Comma = 44;
                static byte Minus = 45;
                static byte Period = 46;
                static byte Plus = 43;
                static byte Slash = 47;
                static byte Space = 32;
                static byte Hyphen = 45;
                static byte Separator = 44;
                static int GroupSize = 3;
                static int DateTimeMaxUtcOffsetHours = 14;
                static int DateTimeNumFractionDigits = 7;
                static int MaxDateTimeFraction = 9999999;
                static ulong BillionMaxUIntValue = 4294967295000000000;
                static uint Billion = 1000000000;
                static /*0x0*/ System.TimeSpan s_nullUtcOffset;

                static /*0x21de100*/ Utf8Constants();
            }

            class Utf8Formatter
            {
                static byte TimeMarker = 84;
                static byte UtcMarker = 90;
                static byte GMT1 = 71;
                static byte GMT2 = 77;
                static byte GMT3 = 84;
                static byte GMT1Lowercase = 103;
                static byte GMT2Lowercase = 109;
                static byte GMT3Lowercase = 116;
                static byte OpenBrace = 123;
                static byte CloseBrace = 125;
                static byte OpenParen = 40;
                static byte CloseParen = 41;
                static byte Dash = 45;
                static /*0x0*/ uint[] DayAbbreviations;
                static /*0x8*/ uint[] DayAbbreviationsLowercase;
                static /*0x10*/ uint[] MonthAbbreviations;
                static /*0x18*/ uint[] MonthAbbreviationsLowercase;

                static /*0x21e8cb8*/ Utf8Formatter();
                static /*0x21de178*/ bool TryFormat(bool value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21de4d8*/ bool TryFormatDateTimeG(System.DateTime value, System.TimeSpan offset, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21de844*/ bool TryFormatDateTimeL(System.DateTime value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21deac0*/ bool TryFormatDateTimeO(System.DateTime value, System.TimeSpan offset, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21def40*/ bool TryFormatDateTimeR(System.DateTime value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21df1bc*/ bool TryFormat(System.DateTimeOffset value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21df3d8*/ bool TryFormat(System.DateTime value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21df5b4*/ bool TryFormatDecimalE(ref System.Buffers.Text.NumberBuffer number, System.Span<byte> destination, ref int bytesWritten, byte precision, byte exponentSymbol);
                static /*0x21df808*/ bool TryFormatDecimalF(ref System.Buffers.Text.NumberBuffer number, System.Span<byte> destination, ref int bytesWritten, byte precision);
                static /*0x21dfaa4*/ bool TryFormatDecimalG(ref System.Buffers.Text.NumberBuffer number, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21dfcd0*/ bool TryFormat(decimal value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21dffdc*/ bool TryFormat(double value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e0080*/ bool TryFormat(float value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static bool TryFormatFloatingPoint<T>(T value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e0124*/ bool TryFormat(System.Guid value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e06cc*/ bool TryFormatInt64D(long value, byte precision, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e0a0c*/ bool TryFormatInt64Default(long value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e1c5c*/ bool TryFormatInt32Default(int value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e1fe0*/ bool TryFormatInt32MultipleDigits(int value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e22f0*/ bool TryFormatInt64MultipleDigits(long value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e1470*/ bool TryFormatInt64MoreThanNegativeBillionMaxUInt(long value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e1988*/ bool TryFormatInt64LessThanNegativeBillionMaxUInt(long value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e26a8*/ bool TryFormatInt64N(long value, byte precision, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e2a48*/ bool TryFormatInt64(long value, ulong mask, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e0760*/ bool TryFormatUInt64D(ulong value, byte precision, System.Span<byte> destination, bool insertNegationSign, ref int bytesWritten);
                static /*0x21e36b0*/ bool TryFormatUInt64Default(ulong value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e3ae0*/ bool TryFormatUInt32Default(uint value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e3cec*/ bool TryFormatUInt32SingleDigit(uint value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e3d54*/ bool TryFormatUInt32MultipleDigits(uint value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e3ed4*/ bool TryFormatUInt64SingleDigit(ulong value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e3f3c*/ bool TryFormatUInt64MultipleDigits(ulong value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e1234*/ bool TryFormatUInt64LessThanBillionMaxUInt(ulong value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e16e0*/ bool TryFormatUInt64MoreThanBillionMaxUInt(ulong value, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e273c*/ bool TryFormatUInt64N(ulong value, byte precision, System.Span<byte> destination, bool insertNegationSign, ref int bytesWritten);
                static /*0x21e3544*/ bool TryFormatUInt64X(ulong value, byte precision, bool useLower, System.Span<byte> destination, ref int bytesWritten);
                static /*0x21e4110*/ bool TryFormatUInt64(ulong value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e4760*/ bool TryFormat(byte value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e4c70*/ bool TryFormat(sbyte value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e552c*/ bool TryFormat(ushort value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e5a90*/ bool TryFormat(short value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e63f4*/ bool TryFormat(uint value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e69fc*/ bool TryFormat(int value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e73f0*/ bool TryFormat(ulong value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e7a70*/ bool TryFormat(long value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);
                static /*0x21e8598*/ bool TryFormat(System.TimeSpan value, System.Span<byte> destination, ref int bytesWritten, System.Buffers.StandardFormat format);

                struct DecomposedGuid
                {
                    /*0x10*/ System.Guid Guid;
                    /*0x10*/ byte Byte00;
                    /*0x11*/ byte Byte01;
                    /*0x12*/ byte Byte02;
                    /*0x13*/ byte Byte03;
                    /*0x14*/ byte Byte04;
                    /*0x15*/ byte Byte05;
                    /*0x16*/ byte Byte06;
                    /*0x17*/ byte Byte07;
                    /*0x18*/ byte Byte08;
                    /*0x19*/ byte Byte09;
                    /*0x1a*/ byte Byte10;
                    /*0x1b*/ byte Byte11;
                    /*0x1c*/ byte Byte12;
                    /*0x1d*/ byte Byte13;
                    /*0x1e*/ byte Byte14;
                    /*0x1f*/ byte Byte15;
                }
            }

            class ParserHelpers
            {
                static int ByteOverflowLength = 3;
                static int ByteOverflowLengthHex = 2;
                static int UInt16OverflowLength = 5;
                static int UInt16OverflowLengthHex = 4;
                static int UInt32OverflowLength = 10;
                static int UInt32OverflowLengthHex = 8;
                static int UInt64OverflowLength = 20;
                static int UInt64OverflowLengthHex = 16;
                static int SByteOverflowLength = 3;
                static int SByteOverflowLengthHex = 2;
                static int Int16OverflowLength = 5;
                static int Int16OverflowLengthHex = 4;
                static int Int32OverflowLength = 10;
                static int Int32OverflowLengthHex = 8;
                static int Int64OverflowLength = 19;
                static int Int64OverflowLengthHex = 16;
                static /*0x0*/ byte[] s_hexLookup;

                static /*0x21e8e18*/ ParserHelpers();
                static /*0x21e8e08*/ bool IsDigit(int i);
            }

            class Utf8Parser
            {
                static uint FlipCase = 32;
                static uint NoFlipCase = 0;
                static /*0x0*/ int[] s_daysToMonth365;
                static /*0x8*/ int[] s_daysToMonth366;

                static /*0x21ef92c*/ Utf8Parser();
                static /*0x21e8eac*/ bool TryParse(System.ReadOnlySpan<byte> source, ref bool value, ref int bytesConsumed, char standardFormat);
                static /*0x21e9020*/ bool TryParseDateTimeOffsetDefault(System.ReadOnlySpan<byte> source, ref System.DateTimeOffset value, ref int bytesConsumed);
                static /*0x21e91f4*/ bool TryParseDateTimeG(System.ReadOnlySpan<byte> source, ref System.DateTime value, ref System.DateTimeOffset valueAsOffset, ref int bytesConsumed);
                static /*0x21e9444*/ bool TryCreateDateTimeOffset(System.DateTime dateTime, bool offsetNegative, int offsetHours, int offsetMinutes, ref System.DateTimeOffset value);
                static /*0x21e96c4*/ bool TryCreateDateTimeOffset(int year, int month, int day, int hour, int minute, int second, int fraction, bool offsetNegative, int offsetHours, int offsetMinutes, ref System.DateTimeOffset value);
                static /*0x21e9564*/ bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(int year, int month, int day, int hour, int minute, int second, int fraction, ref System.DateTimeOffset value);
                static /*0x21e97d8*/ bool TryCreateDateTime(int year, int month, int day, int hour, int minute, int second, int fraction, System.DateTimeKind kind, ref System.DateTime value);
                static /*0x21e99fc*/ bool TryParseDateTimeOffsetO(System.ReadOnlySpan<byte> source, ref System.DateTimeOffset value, ref int bytesConsumed, ref System.DateTimeKind kind);
                static /*0x21e9e30*/ bool TryParseDateTimeOffsetR(System.ReadOnlySpan<byte> source, uint caseFlipXorMask, ref System.DateTimeOffset dateTimeOffset, ref int bytesConsumed);
                static /*0x21ea304*/ bool TryParse(System.ReadOnlySpan<byte> source, ref System.DateTime value, ref int bytesConsumed, char standardFormat);
                static /*0x21ea4f8*/ bool TryParse(System.ReadOnlySpan<byte> source, ref System.DateTimeOffset value, ref int bytesConsumed, char standardFormat);
                static /*0x21ea690*/ bool TryParse(System.ReadOnlySpan<byte> source, ref decimal value, ref int bytesConsumed, char standardFormat);
                static /*0x21ead9c*/ bool TryParse(System.ReadOnlySpan<byte> source, ref float value, ref int bytesConsumed, char standardFormat);
                static /*0x21eb0bc*/ bool TryParse(System.ReadOnlySpan<byte> source, ref double value, ref int bytesConsumed, char standardFormat);
                static /*0x21eaefc*/ bool TryParseNormalAsFloatingPoint(System.ReadOnlySpan<byte> source, ref double value, ref int bytesConsumed, char standardFormat);
                static bool TryParseAsSpecialFloatingPoint<T>(System.ReadOnlySpan<byte> source, T positiveInfinity, T negativeInfinity, T nan, ref T value, ref int bytesConsumed);
                static /*0x21eb1b0*/ bool TryParse(System.ReadOnlySpan<byte> source, ref System.Guid value, ref int bytesConsumed, char standardFormat);
                static /*0x21eb6a4*/ bool TryParseGuidN(System.ReadOnlySpan<byte> text, ref System.Guid value, ref int bytesConsumed);
                static /*0x21eb320*/ bool TryParseGuidCore(System.ReadOnlySpan<byte> source, bool ends, char begin, char end, ref System.Guid value, ref int bytesConsumed);
                static /*0x21ebe40*/ bool TryParseSByteD(System.ReadOnlySpan<byte> source, ref sbyte value, ref int bytesConsumed);
                static /*0x21ec054*/ bool TryParseInt16D(System.ReadOnlySpan<byte> source, ref short value, ref int bytesConsumed);
                static /*0x21ec2d0*/ bool TryParseInt32D(System.ReadOnlySpan<byte> source, ref int value, ref int bytesConsumed);
                static /*0x21ec660*/ bool TryParseInt64D(System.ReadOnlySpan<byte> source, ref long value, ref int bytesConsumed);
                static /*0x21ec844*/ bool TryParseSByteN(System.ReadOnlySpan<byte> source, ref sbyte value, ref int bytesConsumed);
                static /*0x21eca20*/ bool TryParseInt16N(System.ReadOnlySpan<byte> source, ref short value, ref int bytesConsumed);
                static /*0x21ecbfc*/ bool TryParseInt32N(System.ReadOnlySpan<byte> source, ref int value, ref int bytesConsumed);
                static /*0x21ecdf4*/ bool TryParseInt64N(System.ReadOnlySpan<byte> source, ref long value, ref int bytesConsumed);
                static /*0x21ecff8*/ bool TryParse(System.ReadOnlySpan<byte> source, ref sbyte value, ref int bytesConsumed, char standardFormat);
                static /*0x21ed304*/ bool TryParse(System.ReadOnlySpan<byte> source, ref short value, ref int bytesConsumed, char standardFormat);
                static /*0x21ed4a0*/ bool TryParse(System.ReadOnlySpan<byte> source, ref int value, ref int bytesConsumed, char standardFormat);
                static /*0x21ed63c*/ bool TryParse(System.ReadOnlySpan<byte> source, ref long value, ref int bytesConsumed, char standardFormat);
                static /*0x21ed7d8*/ bool TryParseByteD(System.ReadOnlySpan<byte> source, ref byte value, ref int bytesConsumed);
                static /*0x21ed978*/ bool TryParseUInt16D(System.ReadOnlySpan<byte> source, ref ushort value, ref int bytesConsumed);
                static /*0x21edb80*/ bool TryParseUInt32D(System.ReadOnlySpan<byte> source, ref uint value, ref int bytesConsumed);
                static /*0x21edeac*/ bool TryParseUInt64D(System.ReadOnlySpan<byte> source, ref ulong value, ref int bytesConsumed);
                static /*0x21ee000*/ bool TryParseByteN(System.ReadOnlySpan<byte> source, ref byte value, ref int bytesConsumed);
                static /*0x21ee194*/ bool TryParseUInt16N(System.ReadOnlySpan<byte> source, ref ushort value, ref int bytesConsumed);
                static /*0x21ee328*/ bool TryParseUInt32N(System.ReadOnlySpan<byte> source, ref uint value, ref int bytesConsumed);
                static /*0x21ee4e8*/ bool TryParseUInt64N(System.ReadOnlySpan<byte> source, ref ulong value, ref int bytesConsumed);
                static /*0x21ed194*/ bool TryParseByteX(System.ReadOnlySpan<byte> source, ref byte value, ref int bytesConsumed);
                static /*0x21ebb1c*/ bool TryParseUInt16X(System.ReadOnlySpan<byte> source, ref ushort value, ref int bytesConsumed);
                static /*0x21eb988*/ bool TryParseUInt32X(System.ReadOnlySpan<byte> source, ref uint value, ref int bytesConsumed);
                static /*0x21ebcac*/ bool TryParseUInt64X(System.ReadOnlySpan<byte> source, ref ulong value, ref int bytesConsumed);
                static /*0x21ee6a8*/ bool TryParse(System.ReadOnlySpan<byte> source, ref byte value, ref int bytesConsumed, char standardFormat);
                static /*0x21ee840*/ bool TryParse(System.ReadOnlySpan<byte> source, ref ushort value, ref int bytesConsumed, char standardFormat);
                static /*0x21ee9d8*/ bool TryParse(System.ReadOnlySpan<byte> source, ref uint value, ref int bytesConsumed, char standardFormat);
                static /*0x21eeb70*/ bool TryParse(System.ReadOnlySpan<byte> source, ref ulong value, ref int bytesConsumed, char standardFormat);
                static /*0x21ea85c*/ bool TryParseNumber(System.ReadOnlySpan<byte> source, ref System.Buffers.Text.NumberBuffer number, ref int bytesConsumed, System.Buffers.Text.Utf8Parser.ParseNumberOptions options, ref bool textUsedExponentNotation);
                static /*0x21eed08*/ bool TryParseTimeSpanBigG(System.ReadOnlySpan<byte> source, ref System.TimeSpan value, ref int bytesConsumed);
                static /*0x21ef2b8*/ bool TryParseTimeSpanC(System.ReadOnlySpan<byte> source, ref System.TimeSpan value, ref int bytesConsumed);
                static /*0x21ef564*/ bool TryParseTimeSpanLittleG(System.ReadOnlySpan<byte> source, ref System.TimeSpan value, ref int bytesConsumed);
                static /*0x21ef7d0*/ bool TryParse(System.ReadOnlySpan<byte> source, ref System.TimeSpan value, ref int bytesConsumed, char standardFormat);
                static /*0x21ef0cc*/ bool TryParseTimeSpanFraction(System.ReadOnlySpan<byte> source, ref uint value, ref int bytesConsumed);
                static /*0x21ef1fc*/ bool TryCreateTimeSpan(bool isNegative, uint days, uint hours, uint minutes, uint seconds, uint fraction, ref System.TimeSpan timeSpan);

                enum ParseNumberOptions
                {
                    AllowExponent = 1,
                }

                enum ComponentParseResult
                {
                    NoMoreData = 0,
                    Colon = 1,
                    Period = 2,
                    ParseFailure = 3,
                }

                struct TimeSpanSplitter
                {
                    /*0x10*/ uint V1;
                    /*0x14*/ uint V2;
                    /*0x18*/ uint V3;
                    /*0x1c*/ uint V4;
                    /*0x20*/ uint V5;
                    /*0x24*/ bool IsNegative;
                    /*0x28*/ uint Separators;

                    static /*0x21efc94*/ System.Buffers.Text.Utf8Parser.ComponentParseResult ParseComponent(System.ReadOnlySpan<byte> source, bool neverParseAsFraction, ref int srcIndex, ref uint value);
                    /*0x21ef9fc*/ bool TrySplitTimeSpan(System.ReadOnlySpan<byte> source, bool periodUsedToSeparateDay, ref int bytesConsumed);
                }
            }

            class Number
            {
                static int DECIMAL_PRECISION = 29;
                static /*0x0*/ ulong[] s_rgval64Power10;
                static /*0x8*/ sbyte[] s_rgexp64Power10;
                static /*0x10*/ ulong[] s_rgval64Power10By16;
                static /*0x18*/ short[] s_rgexp64Power10By16;

                static /*0x21f0b44*/ Number();
                static /*0x21efe44*/ bool NumberBufferToDouble(ref System.Buffers.Text.NumberBuffer number, ref double value);
                static /*0x21f045c*/ bool NumberBufferToDecimal(ref System.Buffers.Text.NumberBuffer number, ref decimal value);
                static /*0x21f0660*/ void DecimalToNumber(decimal value, ref System.Buffers.Text.NumberBuffer number);
                static /*0x21f0870*/ uint DigitsToInt(System.ReadOnlySpan<byte> digits, int count);
                static /*0x21f0938*/ ulong Mul32x32To64(uint a, uint b);
                static /*0x21f0940*/ ulong Mul64Lossy(ulong a, ulong b, ref int pexp);
                static /*0x21f09d8*/ int abs(int value);
                static /*0x21eff14*/ double NumberToDouble(ref System.Buffers.Text.NumberBuffer number);
                static /*0x21f0a34*/ void RoundNumber(ref System.Buffers.Text.NumberBuffer number, int pos);
            }

            struct NumberBuffer
            {
                static int BufferSize = 51;
                /*0x10*/ int Scale;
                /*0x14*/ bool IsNegative;
                /*0x15*/ byte _b0;
                /*0x16*/ byte _b1;
                /*0x17*/ byte _b2;
                /*0x18*/ byte _b3;
                /*0x19*/ byte _b4;
                /*0x1a*/ byte _b5;
                /*0x1b*/ byte _b6;
                /*0x1c*/ byte _b7;
                /*0x1d*/ byte _b8;
                /*0x1e*/ byte _b9;
                /*0x1f*/ byte _b10;
                /*0x20*/ byte _b11;
                /*0x21*/ byte _b12;
                /*0x22*/ byte _b13;
                /*0x23*/ byte _b14;
                /*0x24*/ byte _b15;
                /*0x25*/ byte _b16;
                /*0x26*/ byte _b17;
                /*0x27*/ byte _b18;
                /*0x28*/ byte _b19;
                /*0x29*/ byte _b20;
                /*0x2a*/ byte _b21;
                /*0x2b*/ byte _b22;
                /*0x2c*/ byte _b23;
                /*0x2d*/ byte _b24;
                /*0x2e*/ byte _b25;
                /*0x2f*/ byte _b26;
                /*0x30*/ byte _b27;
                /*0x31*/ byte _b28;
                /*0x32*/ byte _b29;
                /*0x33*/ byte _b30;
                /*0x34*/ byte _b31;
                /*0x35*/ byte _b32;
                /*0x36*/ byte _b33;
                /*0x37*/ byte _b34;
                /*0x38*/ byte _b35;
                /*0x39*/ byte _b36;
                /*0x3a*/ byte _b37;
                /*0x3b*/ byte _b38;
                /*0x3c*/ byte _b39;
                /*0x3d*/ byte _b40;
                /*0x3e*/ byte _b41;
                /*0x3f*/ byte _b42;
                /*0x40*/ byte _b43;
                /*0x41*/ byte _b44;
                /*0x42*/ byte _b45;
                /*0x43*/ byte _b46;
                /*0x44*/ byte _b47;
                /*0x45*/ byte _b48;
                /*0x46*/ byte _b49;
                /*0x47*/ byte _b50;

                /*0x21f080c*/ System.Span<byte> get_Digits();
                /*0x21f0658*/ byte* get_UnsafeDigits();
                /*0x21f09e4*/ int get_NumDigits();
                /*0x21f0cc4*/ void CheckConsistency();
                /*0x21f0cc8*/ string ToString();
            }
        }
    }
}

class <PrivateImplementationDetails>
{
    static /*0x0*/ <PrivateImplementationDetails> 001D686DB504E20C792EAA07FE09224A45FF328E24A80072D04D16ABC5C2B5D2;
    static /*0x40*/ <PrivateImplementationDetails> 021022D5891F99B3B525763EB77BAEC69B107268F560721F5060FCDBD4D5AAE8;
    static /*0xea*/ <PrivateImplementationDetails> 042957A0DB5FF2D38A343AC5AE5F8635B88F10C32EB87A238B1DFB4756468476;
    static /*0xf6*/ <PrivateImplementationDetails> 06B65E85E7DE323D68D88C332DBDA9DB89C27652506CE5B4EA2C86A5BBBEABE9;
    static /*0x27e*/ <PrivateImplementationDetails> 07FA6E88C946B2528C09C16C2FB8E9CDA49AFFAFC601774C437FD9F2DF3ECE01;
    static /*0x2b6*/ <PrivateImplementationDetails> 0C496C9AE05419BD25256D0EF4F31AFD291119F14B8BD683BF1774F91E08659D;
    static /*0x30a*/ <PrivateImplementationDetails> 0E499E7743BCDFF289B85890E4DFDD635594DB16246DC094C3C19556B6C1262C;
    static /*0x352*/ <PrivateImplementationDetails> 0F9E3C7E66CDEF5C44FA29E65CA676C480F7A2A4A067F70107FDC292C68D38B0;
    static /*0x35e*/ <PrivateImplementationDetails> 1199C3B39A2FA058EFF5B3829616AE81EE2B59A51D89C107A5FA4B6FEF95DD16;
    static /*0x3aa*/ <PrivateImplementationDetails> 125CF2084D7EEC18DC9795BE4BAA221655C0EABAB89E90A74FB0370378A60293;
    static /*0x62a*/ <PrivateImplementationDetails> 12D518BA10F3DD1A331E65FBD4C330930C0A0BD9F50F37BE0BDF596E964B9A78;
    static /*0xe5e*/ <PrivateImplementationDetails> 1537CF074FEBB1EDD62F5C35E2A77A575ED00CD6C5D8F479EFA4302E2F757688;
    static /*0xe76*/ <PrivateImplementationDetails> 195ABC1ABB69B6BD65F20ACAFA79EED2D330BF513E25C830F24B8A78D8703446;
    static /*0xef6*/ <PrivateImplementationDetails> 1A07BC77B9912D8D87E9B28E0167F53A9B09BB017B35A35F3913989C9440A60B;
    static /*0xf00*/ <PrivateImplementationDetails> 1A52279427700E21F7E68A077A8F17857A850718317B7228442260DBA2AF68F0;
    static /*0x104a*/ <PrivateImplementationDetails> 1B9CC34A0CF8DBCC350E200673FAC4124DDAD581F1FC2C16FF9A1C0154691687;
    static /*0x15f4*/ <PrivateImplementationDetails> 1C4B3A80ED7AEC83916479BCE280E1258D5785D07F0EA22A5E27592ACCAE692B;
    static /*0x175c*/ <PrivateImplementationDetails> 1E398465A9EE43BEF177E8E00D8C5348363E726339A46C767812C81310C00CB2;
    static /*0x1774*/ <PrivateImplementationDetails> 1F38DEB3F70291588D06D3830D0D4241CE0570C9F4EE8B00F606C4753EB016E2;
    static /*0x179e*/ <PrivateImplementationDetails> 20CD2802EDA4ADAD1D749ABFE753256D8754EB845C973830A5556ECCAF1ADD6E;
    static /*0x17ba*/ <PrivateImplementationDetails> 21244F82B210125632917591768F6BF22EB6861F80C6C25A25BD26DFB580EA7B;
    static /*0x18ba*/ <PrivateImplementationDetails> 215E3E0B11A214B3198654E87B3D953AC8FB1ABC7045AF841A7C4892624BDE49;
    static /*0x18c4*/ <PrivateImplementationDetails> 2403FBEA85D0741C5727760E97EF16C9BF23294F21C0F1265A4BAF7F22202A64;
    static /*0x18d0*/ <PrivateImplementationDetails> 24CB9F17C8326D8BB8EC908716519DF7F265AE825F0DD13BB04E03A90B07D90E;
    static /*0x18e0*/ <PrivateImplementationDetails> 25308BAB47481701F1E861B1EA4F2409E73ABB14E9579C26DF4ABE440A0DCF0A;
    static /*0x192c*/ <PrivateImplementationDetails> 25E3E48132FBDBE9B7C0C6C54D7C10A5DE12A105AA3E5DE2A0DC808BF245B7A5;
    static /*0x2568*/ <PrivateImplementationDetails> 2AC9A6746ACA543AF8DFF39894CFE8173AFBA21EB01C6FAE33D52947222855EF;
    static /*0x256b*/ <PrivateImplementationDetails> 2CCF4119215BDAD102DA7AD5B57E0E6CA19CC8FF5524856FC58907E824213E1F;
    static /*0x25b3*/ <PrivateImplementationDetails> 31B56A7232040CADEA08E3A0A4AE95187D35A3278C4E84C774569CB0D48BBA5E;
    static /*0x2b53*/ <PrivateImplementationDetails> 3444EB31231B2CCC1B05C7A44EBD1B2A009C1D9977A99B453F52E2F81DD6C32F;
    static /*0x2b9b*/ <PrivateImplementationDetails> 3C847C0018C758197C8564174888A84F5621BA50DBB59D1EBA7FF28C73D279A1;
    static /*0x402b*/ <PrivateImplementationDetails> 3D95E4501B1964D7FCE16E3F5682A038752B462357D87343880B1E819F6163FE;
    static /*0x403b*/ <PrivateImplementationDetails> 3F1431B31172B4BE5418BDA2F4063F512F2F7A7CFDCE81A60B131792B5F7F694;
    static /*0x406b*/ <PrivateImplementationDetails> 3F62692E2AD5078353EC4471A13421A61EE493294CF59DC66626A6EF9CCCD2C4;
    static /*0x40b3*/ <PrivateImplementationDetails> 40EC13C575237954625B718CA2B291A90543D086FE5E3258F158FDDD3A9067CC;
    static /*0x410b*/ <PrivateImplementationDetails> 425CE249C852AD06731DB313704890E29BD6FBF1FFB08F99948EB9ACF9053017;
    static /*0x49bb*/ <PrivateImplementationDetails> 42E1421FC2A5A6A33E964D7EB9603EB101818D858DDA09B2BC9B5A888C1C351C;
    static /*0x49c7*/ <PrivateImplementationDetails> 44D066BAE9848B4A4B2C31F1854666526A32D0588635569423BDA1DA303C97DF;
    static /*0x49cd*/ <PrivateImplementationDetails> 4623CA5867960AA898AA1F65E720CD5ECD3552542E0C6F6FB65B21D14DD1CBC2;
    static /*0x4a45*/ <PrivateImplementationDetails> 4800FBFC4566EB02D1727A4B1C949CCBC7535C216A0766564C199308631B5DD6;
    static /*0x4a75*/ <PrivateImplementationDetails> 493402F3E4397B2945B16273E795816C0BDF80F76F42FCAA75F3DF2E215ABC1B;
    static /*0x5a75*/ <PrivateImplementationDetails> 494C32E1A18F6E8AD8ED5FAB0A5AF07F801BE7AF3C936942B020918CE2953046;
    static /*0x5b23*/ <PrivateImplementationDetails> 4E0B9E024FA510B6F03C92D95BB204E78CDC6E3FD2EC8D35787B7BC76F0655A0;
    static /*0x6471*/ <PrivateImplementationDetails> 501E4F476B5C5D742AB5526561490A19EF5F752BEC30E7C5B172D05897A98932;
    static /*0x6491*/ <PrivateImplementationDetails> 508085E0DDEEA9CE48BFAE98CEC779F8D06301AE973555D37680D08190CAFA70;
    static /*0x64bd*/ <PrivateImplementationDetails> 510FDFA4743E58DD45DCDD7CB4F8509BF6294CC1D1D4958CA30A9E7604973006;
    static /*0x6505*/ <PrivateImplementationDetails> 5292FD0A8E62FCCBE41F34EFE7575D097990A66FE23B3507971C5BF272A4362E;
    static /*0x652f*/ <PrivateImplementationDetails> 533B8C444F951E83EFF7305E3807B66CE0005DE0A2D0A44873C130895A3BE6AA;
    static /*0x6543*/ <PrivateImplementationDetails> 543172FF9822CE5240DF89FF3AD8C7FD9824F97D0EED9B1432E60345FBBDE9A9;
    static /*0x6577*/ <PrivateImplementationDetails> 55D0BF716B334D123E0088CFB3F8E2FEA17AF5025BB527F95EEB09BA978EA329;
    static /*0x6677*/ <PrivateImplementationDetails> 56073E3CC3FC817690CC306D0DB7EA63EBCB0801359567CA44CA3D3B9BF63854;
    static /*0x90a7*/ <PrivateImplementationDetails> 5857EE4CE98BFABBD62B385C1098507DD0052FF3951043AAD6A1DABD495F18AA;
    static /*0x90db*/ <PrivateImplementationDetails> 5DF6E0E2761359D30A8275058E299FCC0381534545F55CF43E41983F5D4C9456;
    static /*0x90fb*/ <PrivateImplementationDetails> 5EC4E50DA95A113769D73E5F7F8221A876185CEE6498ABB16FBB9F0563C15BBF;
    static /*0x9143*/ <PrivateImplementationDetails> 61D639BE11384EE21CDE2B40357F4F9D80A106C97C592D18A9F4CAA442CA5D31;
    static /*0x91a1*/ <PrivateImplementationDetails> 62E6F13B53D67FDD780E20D89A6E8EE503B197AC16AC3F1D2571C147FDD324C9;
    static /*0x92a1*/ <PrivateImplementationDetails> 64A0AD5A7BF0B569FABE66AF3006423DA81FF79CD282E8D781CD013B1FD7D5CE;
    static /*0x92bd*/ <PrivateImplementationDetails> 668BB69E184E0C32DC3BC488001C506C87EE5A95C7E7B6B87D24C3A6DC779956;
    static /*0x9abd*/ <PrivateImplementationDetails> 6708B572BDBE5D5E79701DBB9744AF74B50FED7608218F2D7BF1B5D87E5A53ED;
    static /*0x9aed*/ <PrivateImplementationDetails> 67856A16DB0550FDAB4D1A9B208B0C155C4679CA116BF867B74ED2A0AA4D2955;
    static /*0x9d75*/ <PrivateImplementationDetails> 692DE452EE427272A5F6154F04360D24165B56693B08F60D93127DEDC12D1DDE;
    static /*0xa29d*/ <PrivateImplementationDetails> 6DABE7D1BCE5A165B668653474D7F5F3680A7FBC30EA3F3FC3FEB1790BD659B5;
    static /*0xa2ef*/ <PrivateImplementationDetails> 6DC92D3617F0357376502FBA4CDD465B5423818DABE8B2CA1A06E1351F2F1C85;
    static /*0xa337*/ <PrivateImplementationDetails> 70871E7CEBC5FB665C6CDA09BCB582780757E8F266C78289B5A1553B02AA3D82;
    static /*0xa377*/ <PrivateImplementationDetails> 71F7F6B226CBC11C8B26D506869FAE022928427389882579DB316F36FF34A096;
    static /*0xa44b*/ <PrivateImplementationDetails> 71F993C1E0FB950AAACBC0B9A2B0975B213EF14C8AA693F413336D46E9EAB8E9;
    static /*0xa47b*/ <PrivateImplementationDetails> 739592F1F51C1B5B4053CDFD26932FE506C041EC6B08A39DCE012EADDA72ADA7;
    static /*0xa49b*/ <PrivateImplementationDetails> 73F5D95C401726B2C92EC96A696BA15F0E5A5C6DD9AC6BEB3736A81772A11531;
    static /*0xac9b*/ <PrivateImplementationDetails> 74BCD6ED20AF2231F2BB1CDE814C5F4FF48E54BAC46029EEF90DDF4A208E2B20;
    static /*0xadbb*/ <PrivateImplementationDetails> 74EF7306E7452D6859B6463CE496B8DF30925F69E1B2969E1F3F34BBC9C6AF04;
    static /*0xaebb*/ <PrivateImplementationDetails> 7543B37FA53FDE2C84F07FD39F368555966AA1C0EB2F2FD26B294D79966E290E;
    static /*0xaefb*/ <PrivateImplementationDetails> 765BD07ED3CB498A599FFB48B31E077C45B4C2C37CD1547CEA27E60655CF21B6;
    static /*0xb1f4*/ <PrivateImplementationDetails> 78AD7906208AA1E531D0C1100062DE3D252210B1E4214061294A0BB7C94762B8;
    static /*0xb26c*/ <PrivateImplementationDetails> 7BEC6AD454781FDCD8D475B3418629CBABB3BF9CA66FA80009D608A1A60D0696;
    static /*0xb82c*/ <PrivateImplementationDetails> 7F777906B0704EB248888E491577584D5BEBE71B375BD595A06444390B471915;
    static /*0xb874*/ <PrivateImplementationDetails> 801494072CDD59E61F9AA9345A80D045378705DFDCE94902C22EAEAE049BE780;
    static /*0xb974*/ <PrivateImplementationDetails> 805796429D6E812E01657F32029A8103B7C27B5203C2EFC9C0001E3EBAD7F24C;
    static /*0xb990*/ long 819B40F8CF7DC49B4275955A17C10239F1BBBB3BF96E26E25ED844B96B645D7F;
    static /*0xb998*/ <PrivateImplementationDetails> 8259E3EBA4D41CA02AE5322BBD280034A9C9860D9CD0D2038139FC9EBE6B6C77;
    static /*0xb9e0*/ long 82B100804CE219CD73E155C7C6457FCF04EA539DE5B19F4736E800098714EB21;
    static /*0xb9e8*/ <PrivateImplementationDetails> 83F180C4F05CDA92C6CE1FB81ECB9031C503C1906040707C412F2BC7CB609F2A;
    static /*0xba00*/ <PrivateImplementationDetails> 861FD05B0EAD3D0AA9418B140CC37846BBC5F195214D90CEF42919D1E36EED10;
    static /*0xba48*/ <PrivateImplementationDetails> 86BDA34D2165AC08F2DE4918B302E44205CDEA674FCA7F2C7F56D4F12D8B0C73;
    static /*0xbe30*/ long 8BFD94DEAAC0F168DC8B50A00AC120A113B550B68FEF344F807D503D1A6E5DED;
    static /*0xbe38*/ <PrivateImplementationDetails> 8C7DD76CF6FAC1893ED057E9FC91B995F9379B69E0796CAB7DE38ADAE3D2C568;
    static /*0xbe68*/ <PrivateImplementationDetails> 8CCE27079B32C13BB310169A6AD26AE419CDC98B7E2EFD3CC9997257F4BC1DEF;
    static /*0xc4e9*/ <PrivateImplementationDetails> 9086502742CE7F0595B57A4E5B32901FF4CF97959B92F7E91A435E4765AC1115;
    static /*0xdc29*/ <PrivateImplementationDetails> 9287D942CCFE5B2A54D81BDDC56BD89F2DC6C4C8B31507E6284F8D25D1009367;
    static /*0xdc41*/ <PrivateImplementationDetails> 933598639CBAA1DE502F80D2FD1DB78F13C8D7BB64A5FDC1BC73AC0B5CE4F5CA;
    static /*0xdce1*/ <PrivateImplementationDetails> 93B42898102ACB2421875C45676880B8A07390D8DF0E1EE85C5D1AA26964B0C6;
    static /*0xde31*/ <PrivateImplementationDetails> 93F28AF88A06482BE13F8D0354B6A7676DDAED573EA3938C50F6E53E6D6BB0B6;
    static /*0xde65*/ <PrivateImplementationDetails> 95BDE712712F10D07813AE3DEEA40D1F38E3FCF1A92CC435F17A326CC22242EB;
    static /*0xdf13*/ <PrivateImplementationDetails> 964889A5283FD0A3DFC8AE256721E6F67B8212FD6841AB1C821DE3134DE79B07;
    static /*0xe019*/ <PrivateImplementationDetails> 96E3FDE919EC36694EFBEC22FEF80F84EE640CC5E46CED07C3E65AC04607C7D6;
    static /*0xe028*/ <PrivateImplementationDetails> 9960C7FC60CDD325C8A2A00995BE7064EAC3F6295C6A5C4E797D2281846131E4;
    static /*0xe04c*/ <PrivateImplementationDetails> 99E66DACA3EFF94776AF1258E0E5B2F4DF2900E4EA32351B0DF37A87F2426B1F;
    static /*0xe078*/ <PrivateImplementationDetails> A252A93D042C5E2453990C2829A425C6DD749CCDCDF13DB58C11BBC78E8D3CE9;
    static /*0xe0c0*/ <PrivateImplementationDetails> A2DFDF9C2CED8BB1C0B9B06064345ACC9C22DFE5FEC9976FF061F0994451519B;
    static /*0xe138*/ <PrivateImplementationDetails> A2EC7CB9B0FE89F9A9BEA547D773225AFE6E4535DF28325A0D6CD7A5E2D20376;
    static /*0xe184*/ <PrivateImplementationDetails> A30E1152CFB528AE968FAC58E83BBEB3611BFDE2E6CF60B4FA9535A7D0A9B8EA;
    static /*0xe1cc*/ <PrivateImplementationDetails> A516EECB41051151F0183A8B0B6F6693C43F7D9E1815F85CAAAB18E00A5269A2;
    static /*0xe1f4*/ <PrivateImplementationDetails> AAF4528994DD7C464F43C131F6CD44DF41ACC18462C95877252FFC7EAC0164EF;
    static /*0xe23c*/ <PrivateImplementationDetails> AB0B9733AAEC4A2806711E41E36D3D0923BAF116156F33445DC2AA58DA5DF877;
    static /*0xe95c*/ <PrivateImplementationDetails> AE4D29CF65CDB056FD3752F023E1C7B9E470FA189E45CAB74EB9AB81AD18BBD8;
    static /*0x1302c*/ <PrivateImplementationDetails> B215DD70A77190680641703C6DF73729B4583E285AF8B51ACF9086655FB2D0F3;
    static /*0x1402c*/ <PrivateImplementationDetails> B21802DE889E5F4F5344C8E0D366F59B68F886F88EFE45EA5CE01534A3F5C0E5;
    static /*0x14060*/ <PrivateImplementationDetails> B55F94CD2F415D0279D7A1AF2265C4D9A90CE47F8C900D5D09AD088796210838;
    static /*0x148e0*/ <PrivateImplementationDetails> BABD01C34E7E65E57E4C431281E782B4101CE0644A8090AD6E501F1C6CF2C9DF;
    static /*0x14904*/ <PrivateImplementationDetails> BB425A9B43E10C921902A25D07A4317DEFF9F606A788672E1B21633C143407F0;
    static /*0x14914*/ <PrivateImplementationDetails> C250CAD28060A4EB63B4C4A643DDA196CCD35FD2FC67FB749ADF4BAC6D62E1A0;
    static /*0x14938*/ <PrivateImplementationDetails> C2D8E5EED6CBEBD8625FC18F81486A7733C04F9B0129FFBE974C68B90308B4F2;
    static /*0x14a38*/ <PrivateImplementationDetails> C5733A1245383FBF067B4A9BDB41E3FB8E3A6BDEF37B3D5418F389422875783F;
    static /*0x14a80*/ <PrivateImplementationDetails> C8EC70AC5A448C3A45CF1DFCC1375BE4E80DC6793E97D5E89BD97A0DC232B2E3;
    static /*0x14e80*/ <PrivateImplementationDetails> C95D810E738DB5F591EE691CE884EED2F110D9F82B1F7A8BE6ED257FDF4CDBEB;
    static /*0x14e90*/ <PrivateImplementationDetails> C9830DF6956357ACE51CE1F82298578B36EB45A0CFDB8AEC5B9FDA7DB17E8063;
    static /*0x14f12*/ <PrivateImplementationDetails> CAF8A46B3A07E26F84FE849B57A877051A0D06194B1C057985446B64BCC6E016;
    static /*0x14f5a*/ <PrivateImplementationDetails> CAFFFC9D15E4037EE8FBDB1A45DFE456F0936BDC7310F1882EAF14B706A76658;
    static /*0x14f7e*/ <PrivateImplementationDetails> CE11D6DEAFFC6D6EF6030E30E7444C933E6261F32AA737064EF0446C219ECE22;
    static /*0x15f7e*/ <PrivateImplementationDetails> D1A99909A2923269BB67E72C1AED693F74961BDA58360FCC133007740CEBF5F1;
    static /*0x15fc6*/ <PrivateImplementationDetails> D3B16F8D71CB719B941527D5A1ADA7ED83F4EB967FEE117DDA2FE4021E1D283F;
    static /*0x15fcc*/ <PrivateImplementationDetails> D503954AE2C3616EA32CEB0D66F5B2E119D03CE722773E5D7E1A8BC8F1803631;
    static /*0x16014*/ <PrivateImplementationDetails> D6691EE5A533DE7E0859066942261B24D0C836D7EE016D2251377BFEE40FEA15;
    static /*0x160c0*/ <PrivateImplementationDetails> D870074914025E855AA5985A2D6778F1E277036BF9C9F03DEC61F3C496FEC35C;
    static /*0x168c0*/ <PrivateImplementationDetails> D896D464C3726A21162F271ACB711464AD07EA9C9CE78E0297FD0DE934471FA6;
    static /*0x168cc*/ <PrivateImplementationDetails> D8A29F3D197FBB54CF9F4B105AFBA6B1257ADF6449F0184F843380AAAA24639C;
    static /*0x16914*/ <PrivateImplementationDetails> DCDCF594464B904F763D4CE53B1DBE08A47E551AE86FD5D61F63FD0C3313FDC3;
    static /*0x1695c*/ <PrivateImplementationDetails> DCE88EE5233B9D0FD0D7A6222C82BC3AEE83B15E9992F939B17AB40530DB555C;
    static /*0x1728a*/ <PrivateImplementationDetails> DD471F12FFA94CC557A02A91C2CBB95F551AB28C8BBF297B2F953B8886BCCF6D;
    static /*0x17322*/ <PrivateImplementationDetails> DF29A050CD2EBD9DFDC783DB1CC74D3D716DAEC1630A337EE31B9E2E03D34D2D;
    static /*0x1736a*/ <PrivateImplementationDetails> E148B2057CF0C1595155635E761FB66AAE634C40D8FABC4CE79A2DB8886525D4;
    static /*0x1836a*/ <PrivateImplementationDetails> E2C673A3A737B04369A63F1FB1A30F6E742B066E2CCCD9B1838793CBB5590598;
    static /*0x18390*/ <PrivateImplementationDetails> E32C465157D21F39B3DBF186A98FB02185C63B0260B47247A7A5FDF2B061EAA8;
    static /*0x1839c*/ <PrivateImplementationDetails> E5F4F6214036DF103321A8A0CE30C2EF935694B4199D52BC538E7EF3F045CB92;
    static /*0x183b4*/ <PrivateImplementationDetails> E768EDCAE10BAB68BB5DF102FDBB8CF4F31B9D60159B44DA3F33ABC36388308B;
    static /*0x183f4*/ <PrivateImplementationDetails> E8588351183F6F6A7DAD54DC28357628F3C4D4B358AB92A18AE7D08B0D9B0092;
    static /*0x187ee*/ <PrivateImplementationDetails> EBE07C3718876777F609CD22058F4C3A6CCCC695F5BDE90998DC1E12E0CBE63D;
    static /*0x187fa*/ <PrivateImplementationDetails> EC85ED774A75308D011FEF4A32204FB9725776189F565C95E968E241738E89D4;
    static /*0x18812*/ <PrivateImplementationDetails> EE415D5C3ECC6C8C19F71BCD4E03847F5A15931374A7F5BF88C24B722F04B8FE;
    static /*0x18832*/ <PrivateImplementationDetails> EE7220B15E73A8A78DAD09E95C9B9FC2A52404B7F56051A11B1B5DCFA9E22966;
    static /*0x18838*/ <PrivateImplementationDetails> EF39C5A882F9477B2A250BA257247825CEB07FC53C3C984385F2C2E5F8222431;
    static /*0x18938*/ <PrivateImplementationDetails> EF82B163CA8252A793A6E73F57775D843C9A21F65586926EB11893FA8BB603E9;
    static /*0x18948*/ <PrivateImplementationDetails> F0CF66F9B123DCEBB39C38C5D8E4821D4E94DB593889C506BCA0827036F1B7EB;
    static /*0x18a38*/ <PrivateImplementationDetails> F1945CD6C19E56B3C1C78943EF5EC18116907A4CA1EFC40A57D48AB1DB7ADFC5;
    static /*0x18a3b*/ <PrivateImplementationDetails> F19B89DC2C99490D8E4D92B7FC5B5E48BB37E76012F4DA195023267C1C7FDD6A;
    static /*0x196bb*/ <PrivateImplementationDetails> F2830F044682E33B39018B5912634835B641562914E192CA66C654F5E4492FA8;
    static /*0x197bb*/ <PrivateImplementationDetails> F427E43884EE0547E625C240E1BA0A2960151D2B44C46F20B9B98FE66FB3C6F2;
    static /*0x19819*/ <PrivateImplementationDetails> F4BD8144313C3B67E191C6F3CD8B00540FF1809837C5BCA5C2FDA0D518681563;
    static /*0x19861*/ <PrivateImplementationDetails> F7D2AD02ED768134B31339AB059D864789E0A60090CC368B3881EB0631BBAF93;
    static /*0x19c61*/ <PrivateImplementationDetails> F7D381AF73D85950E0B064CF1AA8F14938A1F38084B46CE36AAEFE81BEF739F3;
    static /*0x19d35*/ <PrivateImplementationDetails> FADB218011E7702BB9575D0C32A685DA10B5C72EB809BD9A955DB1C76E4D8315;
    static /*0x19d69*/ <PrivateImplementationDetails> FB2089AF82E09593374B65EC2440779FDCF5DD6DA07D26E57AF6790667B937CD;
    static /*0x1a221*/ <PrivateImplementationDetails> FC405235E052D3DED17776A6B4C52CF9EFAE85050127AA6C45B5BA95F87ACCFD;
    static /*0x1a251*/ <PrivateImplementationDetails> FC5B0FD4492EC7BC85845E312A7A1469DF87CA5BCA5B5B9E0B3030E6E11E48E6;
    static /*0x1a285*/ <PrivateImplementationDetails> FD68700E95459C5E7A49C5830F8BD0A9BA4BD171252663D8066B09E7768C5C5D;
    static /*0x1a375*/ <PrivateImplementationDetails> FEC387BA57A54BB6066E4CA8A4F9C0FF9C36B9CBD6600C3683F6FB1BDB5077EB;

    static /*0x21f0e48*/ uint ComputeStringHash(string s);

    struct __StaticArrayInitTypeSize=3
    {
    }

    struct __StaticArrayInitTypeSize=6
    {
    }

    struct __StaticArrayInitTypeSize=10
    {
    }

    struct __StaticArrayInitTypeSize=12
    {
    }

    struct __StaticArrayInitTypeSize=15
    {
    }

    struct __StaticArrayInitTypeSize=16
    {
    }

    struct __StaticArrayInitTypeSize=20
    {
    }

    struct __StaticArrayInitTypeSize=24
    {
    }

    struct __StaticArrayInitTypeSize=28
    {
    }

    struct __StaticArrayInitTypeSize=32
    {
    }

    struct __StaticArrayInitTypeSize=36
    {
    }

    struct __StaticArrayInitTypeSize=38
    {
    }

    struct __StaticArrayInitTypeSize=40
    {
    }

    struct __StaticArrayInitTypeSize=42
    {
    }

    struct __StaticArrayInitTypeSize=44
    {
    }

    struct __StaticArrayInitTypeSize=48
    {
    }

    struct __StaticArrayInitTypeSize=52
    {
    }

    struct __StaticArrayInitTypeSize=56
    {
    }

    struct __StaticArrayInitTypeSize=64
    {
    }

    struct __StaticArrayInitTypeSize=72
    {
    }

    struct __StaticArrayInitTypeSize=76
    {
    }

    struct __StaticArrayInitTypeSize=82
    {
    }

    struct __StaticArrayInitTypeSize=84
    {
    }

    struct __StaticArrayInitTypeSize=88
    {
    }

    struct __StaticArrayInitTypeSize=94
    {
    }

    struct __StaticArrayInitTypeSize=120
    {
    }

    struct __StaticArrayInitTypeSize=128
    {
    }

    struct __StaticArrayInitTypeSize=130
    {
    }

    struct __StaticArrayInitTypeSize=152
    {
    }

    struct __StaticArrayInitTypeSize=160
    {
    }

    struct __StaticArrayInitTypeSize=170
    {
    }

    struct __StaticArrayInitTypeSize=172
    {
    }

    struct __StaticArrayInitTypeSize=174
    {
    }

    struct __StaticArrayInitTypeSize=212
    {
    }

    struct __StaticArrayInitTypeSize=240
    {
    }

    struct __StaticArrayInitTypeSize=256
    {
    }

    struct __StaticArrayInitTypeSize=262
    {
    }

    struct __StaticArrayInitTypeSize=288
    {
    }

    struct __StaticArrayInitTypeSize=330
    {
    }

    struct __StaticArrayInitTypeSize=336
    {
    }

    struct __StaticArrayInitTypeSize=360
    {
    }

    struct __StaticArrayInitTypeSize=392
    {
    }

    struct __StaticArrayInitTypeSize=640
    {
    }

    struct __StaticArrayInitTypeSize=648
    {
    }

    struct __StaticArrayInitTypeSize=761
    {
    }

    struct __StaticArrayInitTypeSize=998
    {
    }

    struct __StaticArrayInitTypeSize=1018
    {
    }

    struct __StaticArrayInitTypeSize=1024
    {
    }

    struct __StaticArrayInitTypeSize=1208
    {
    }

    struct __StaticArrayInitTypeSize=1320
    {
    }

    struct __StaticArrayInitTypeSize=1440
    {
    }

    struct __StaticArrayInitTypeSize=1450
    {
    }

    struct __StaticArrayInitTypeSize=1472
    {
    }

    struct __StaticArrayInitTypeSize=1665
    {
    }

    struct __StaticArrayInitTypeSize=1824
    {
    }

    struct __StaticArrayInitTypeSize=2048
    {
    }

    struct __StaticArrayInitTypeSize=2100
    {
    }

    struct __StaticArrayInitTypeSize=2176
    {
    }

    struct __StaticArrayInitTypeSize=2224
    {
    }

    struct __StaticArrayInitTypeSize=2350
    {
    }

    struct __StaticArrayInitTypeSize=2382
    {
    }

    struct __StaticArrayInitTypeSize=3132
    {
    }

    struct __StaticArrayInitTypeSize=3200
    {
    }

    struct __StaticArrayInitTypeSize=4096
    {
    }

    struct __StaticArrayInitTypeSize=5264
    {
    }

    struct __StaticArrayInitTypeSize=5952
    {
    }

    struct __StaticArrayInitTypeSize=10800
    {
    }

    struct __StaticArrayInitTypeSize=18128
    {
    }
}

namespace System
{
    namespace Runtime
    {
        namespace InteropServices
        {
            interface UCOMITypeInfo
            {
                void AddressOfMember(int memid, System.Runtime.InteropServices.INVOKEKIND invKind, ref nint ppv);
                void CreateInstance(object pUnkOuter, ref System.Guid riid, ref object ppvObj);
                void GetContainingTypeLib(ref System.Runtime.InteropServices.UCOMITypeLib ppTLB, ref int pIndex);
                void GetDllEntry(int memid, System.Runtime.InteropServices.INVOKEKIND invKind, ref string pBstrDllName, ref string pBstrName, ref short pwOrdinal);
                void GetDocumentation(int index, ref string strName, ref string strDocString, ref int dwHelpContext, ref string strHelpFile);
                void GetFuncDesc(int index, ref nint ppFuncDesc);
                void GetIDsOfNames(string[] rgszNames, int cNames, int[] pMemId);
                void GetImplTypeFlags(int index, ref int pImplTypeFlags);
                void GetMops(int memid, ref string pBstrMops);
                void GetNames(int memid, string[] rgBstrNames, int cMaxNames, ref int pcNames);
                void GetRefTypeInfo(int hRef, ref System.Runtime.InteropServices.UCOMITypeInfo ppTI);
                void GetRefTypeOfImplType(int index, ref int href);
                void GetTypeAttr(ref nint ppTypeAttr);
                void GetTypeComp(ref System.Runtime.InteropServices.UCOMITypeComp ppTComp);
                void GetVarDesc(int index, ref nint ppVarDesc);
                void Invoke(object pvInstance, int memid, short wFlags, ref System.Runtime.InteropServices.DISPPARAMS pDispParams, ref object pVarResult, ref System.Runtime.InteropServices.EXCEPINFO pExcepInfo, ref int puArgErr);
                void ReleaseFuncDesc(nint pFuncDesc);
                void ReleaseTypeAttr(nint pTypeAttr);
                void ReleaseVarDesc(nint pVarDesc);
            }

            interface UCOMITypeLib
            {
                void FindName(string szNameBuf, int lHashVal, System.Runtime.InteropServices.UCOMITypeInfo[] ppTInfo, int[] rgMemId, ref short pcFound);
                void GetDocumentation(int index, ref string strName, ref string strDocString, ref int dwHelpContext, ref string strHelpFile);
                void GetLibAttr(ref nint ppTLibAttr);
                void GetTypeComp(ref System.Runtime.InteropServices.UCOMITypeComp ppTComp);
                void GetTypeInfo(int index, ref System.Runtime.InteropServices.UCOMITypeInfo ppTI);
                int GetTypeInfoCount();
                void GetTypeInfoOfGuid(ref System.Guid guid, ref System.Runtime.InteropServices.UCOMITypeInfo ppTInfo);
                void GetTypeInfoType(int index, ref System.Runtime.InteropServices.TYPEKIND pTKind);
                bool IsName(string szNameBuf, int lHashVal);
                void ReleaseTLibAttr(nint pTLibAttr);
            }

            interface UCOMITypeComp
            {
                void Bind(string szName, int lHashVal, short wFlags, ref System.Runtime.InteropServices.UCOMITypeInfo ppTInfo, ref System.Runtime.InteropServices.DESCKIND pDescKind, ref System.Runtime.InteropServices.BINDPTR pBindPtr);
                void BindType(string szName, int lHashVal, ref System.Runtime.InteropServices.UCOMITypeInfo ppTInfo, ref System.Runtime.InteropServices.UCOMITypeComp ppTComp);
            }

            interface _AssemblyBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _ConstructorBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _CustomAttributeBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _EnumBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _EventBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _FieldBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _ILGenerator
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _LocalBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _MethodBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _ModuleBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _ParameterBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _PropertyBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }

            interface _TypeBuilder
            {
                void GetIDsOfNames(ref System.Guid riid, nint rgszNames, uint cNames, uint lcid, nint rgDispId);
                void GetTypeInfo(uint iTInfo, uint lcid, nint ppTInfo);
                void GetTypeInfoCount(ref uint pcTInfo);
                void Invoke(uint dispIdMember, ref System.Guid riid, uint lcid, short wFlags, nint pDispParams, nint pVarResult, nint pExcepInfo, nint puArgErr);
            }
        }
    }

    namespace Security
    {
        class ReadOnlyPermissionSet : System.Security.PermissionSet
        {
            /*0x21f0ec4*/ ReadOnlyPermissionSet(System.Security.SecurityElement permissionSetXml);
            /*0x21f0efc*/ System.Security.IPermission AddPermissionImpl(System.Security.IPermission perm);
            /*0x21f0f34*/ System.Collections.IEnumerator GetEnumeratorImpl();
            /*0x21f0f6c*/ System.Security.IPermission GetPermissionImpl(System.Type permClass);
            /*0x21f0fa4*/ System.Security.IPermission RemovePermissionImpl(System.Type permClass);
            /*0x21f0fdc*/ System.Security.IPermission SetPermissionImpl(System.Security.IPermission perm);
        }
    }

    namespace Runtime
    {
        namespace InteropServices
        {
            interface ITypeLibConverter
            {
                object ConvertAssemblyToTypeLib(System.Reflection.Assembly assembly, string typeLibName, System.Runtime.InteropServices.TypeLibExporterFlags flags, System.Runtime.InteropServices.ITypeLibExporterNotifySink notifySink);
                System.Reflection.Emit.AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, System.Runtime.InteropServices.ITypeLibImporterNotifySink notifySink, byte[] publicKey, System.Reflection.StrongNameKeyPair keyPair, bool unsafeInterfaces);
                System.Reflection.Emit.AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, System.Runtime.InteropServices.TypeLibImporterFlags flags, System.Runtime.InteropServices.ITypeLibImporterNotifySink notifySink, byte[] publicKey, System.Reflection.StrongNameKeyPair keyPair, string asmNamespace, System.Version asmVersion);
                bool GetPrimaryInteropAssembly(System.Guid g, int major, int minor, int lcid, ref string asmName, ref string asmCodeBase);
            }

            enum TypeLibExporterFlags
            {
                CallerResolvedReferences = 2,
                ExportAs32Bit = 16,
                ExportAs64Bit = 32,
                None = 0,
                OldNames = 4,
                OnlyReferenceRegistered = 1,
            }

            interface ITypeLibExporterNotifySink
            {
                void ReportEvent(System.Runtime.InteropServices.ExporterEventKind eventKind, int eventCode, string eventMsg);
                object ResolveRef(System.Reflection.Assembly assembly);
            }

            interface ITypeLibImporterNotifySink
            {
                void ReportEvent(System.Runtime.InteropServices.ImporterEventKind eventKind, int eventCode, string eventMsg);
                System.Reflection.Assembly ResolveRef(object typeLib);
            }

            enum TypeLibImporterFlags
            {
                ImportAsAgnostic = 2048,
                ImportAsArm = 16384,
                ImportAsItanium = 1024,
                ImportAsX64 = 512,
                ImportAsX86 = 256,
                NoDefineVersionResource = 8192,
                None = 0,
                PreventClassMembers = 16,
                PrimaryInteropAssembly = 1,
                ReflectionOnlyLoading = 4096,
                SafeArrayAsSystemArray = 4,
                SerializableValueClasses = 32,
                TransformDispRetVals = 8,
                UnsafeInterfaces = 2,
            }

            interface ITypeLibExporterNameProvider
            {
                string[] GetNames();
            }

            class RegistrationServices : System.Runtime.InteropServices.IRegistrationServices
            {
                /*0x21f1014*/ RegistrationServices();
                /*0x21f104c*/ System.Guid GetManagedCategoryGuid();
                /*0x21f1084*/ string GetProgIdForType(System.Type type);
                /*0x21f10bc*/ System.Type[] GetRegistrableTypesInAssembly(System.Reflection.Assembly assembly);
                /*0x21f10f4*/ bool RegisterAssembly(System.Reflection.Assembly assembly, System.Runtime.InteropServices.AssemblyRegistrationFlags flags);
                /*0x21f112c*/ void RegisterTypeForComClients(System.Type type, ref System.Guid g);
                /*0x21f1164*/ int RegisterTypeForComClients(System.Type type, System.Runtime.InteropServices.RegistrationClassContext classContext, System.Runtime.InteropServices.RegistrationConnectionType flags);
                /*0x21f119c*/ bool TypeRepresentsComType(System.Type type);
                /*0x21f11d4*/ bool TypeRequiresRegistration(System.Type type);
                /*0x21f120c*/ bool UnregisterAssembly(System.Reflection.Assembly assembly);
                /*0x21f1244*/ void UnregisterTypeForComClients(int cookie);
            }

            class TypeLibConverter : System.Runtime.InteropServices.ITypeLibConverter
            {
                /*0x21f127c*/ TypeLibConverter();
                /*0x21f12b4*/ object ConvertAssemblyToTypeLib(System.Reflection.Assembly assembly, string strTypeLibName, System.Runtime.InteropServices.TypeLibExporterFlags flags, System.Runtime.InteropServices.ITypeLibExporterNotifySink notifySink);
                /*0x21f12ec*/ System.Reflection.Emit.AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, int flags, System.Runtime.InteropServices.ITypeLibImporterNotifySink notifySink, byte[] publicKey, System.Reflection.StrongNameKeyPair keyPair, bool unsafeInterfaces);
                /*0x21f1324*/ System.Reflection.Emit.AssemblyBuilder ConvertTypeLibToAssembly(object typeLib, string asmFileName, System.Runtime.InteropServices.TypeLibImporterFlags flags, System.Runtime.InteropServices.ITypeLibImporterNotifySink notifySink, byte[] publicKey, System.Reflection.StrongNameKeyPair keyPair, string asmNamespace, System.Version asmVersion);
                /*0x21f135c*/ bool GetPrimaryInteropAssembly(System.Guid g, int major, int minor, int lcid, ref string asmName, ref string asmCodeBase);
            }

            interface UCOMIBindCtx
            {
                void EnumObjectParam(ref System.Runtime.InteropServices.UCOMIEnumString ppenum);
                void GetBindOptions(ref System.Runtime.InteropServices.BIND_OPTS pbindopts);
                void GetObjectParam(string pszKey, ref object ppunk);
                void GetRunningObjectTable(ref System.Runtime.InteropServices.UCOMIRunningObjectTable pprot);
                void RegisterObjectBound(object punk);
                void RegisterObjectParam(string pszKey, object punk);
                void ReleaseBoundObjects();
                void RevokeObjectBound(object punk);
                void RevokeObjectParam(string pszKey);
                void SetBindOptions(ref System.Runtime.InteropServices.BIND_OPTS pbindopts);
            }

            interface UCOMIEnumString
            {
                void Clone(ref System.Runtime.InteropServices.UCOMIEnumString ppenum);
                int Next(int celt, string[] rgelt, ref int pceltFetched);
                int Reset();
                int Skip(int celt);
            }

            interface UCOMIRunningObjectTable
            {
                void EnumRunning(ref System.Runtime.InteropServices.UCOMIEnumMoniker ppenumMoniker);
                void GetObject(System.Runtime.InteropServices.UCOMIMoniker pmkObjectName, ref object ppunkObject);
                void GetTimeOfLastChange(System.Runtime.InteropServices.UCOMIMoniker pmkObjectName, ref System.Runtime.InteropServices.FILETIME pfiletime);
                void IsRunning(System.Runtime.InteropServices.UCOMIMoniker pmkObjectName);
                void NoteChangeTime(int dwRegister, ref System.Runtime.InteropServices.FILETIME pfiletime);
                void Register(int grfFlags, object punkObject, System.Runtime.InteropServices.UCOMIMoniker pmkObjectName, ref int pdwRegister);
                void Revoke(int dwRegister);
            }

            interface UCOMIEnumMoniker
            {
                void Clone(ref System.Runtime.InteropServices.UCOMIEnumMoniker ppenum);
                int Next(int celt, System.Runtime.InteropServices.UCOMIMoniker[] rgelt, ref int pceltFetched);
                int Reset();
                int Skip(int celt);
            }

            interface UCOMIMoniker
            {
                void BindToObject(System.Runtime.InteropServices.UCOMIBindCtx pbc, System.Runtime.InteropServices.UCOMIMoniker pmkToLeft, ref System.Guid riidResult, ref object ppvResult);
                void BindToStorage(System.Runtime.InteropServices.UCOMIBindCtx pbc, System.Runtime.InteropServices.UCOMIMoniker pmkToLeft, ref System.Guid riid, ref object ppvObj);
                void CommonPrefixWith(System.Runtime.InteropServices.UCOMIMoniker pmkOther, ref System.Runtime.InteropServices.UCOMIMoniker ppmkPrefix);
                void ComposeWith(System.Runtime.InteropServices.UCOMIMoniker pmkRight, bool fOnlyIfNotGeneric, ref System.Runtime.InteropServices.UCOMIMoniker ppmkComposite);
                void Enum(bool fForward, ref System.Runtime.InteropServices.UCOMIEnumMoniker ppenumMoniker);
                void GetClassID(ref System.Guid pClassID);
                void GetDisplayName(System.Runtime.InteropServices.UCOMIBindCtx pbc, System.Runtime.InteropServices.UCOMIMoniker pmkToLeft, ref string ppszDisplayName);
                void GetSizeMax(ref long pcbSize);
                void GetTimeOfLastChange(System.Runtime.InteropServices.UCOMIBindCtx pbc, System.Runtime.InteropServices.UCOMIMoniker pmkToLeft, ref System.Runtime.InteropServices.FILETIME pFileTime);
                void Hash(ref int pdwHash);
                void Inverse(ref System.Runtime.InteropServices.UCOMIMoniker ppmk);
                int IsDirty();
                void IsEqual(System.Runtime.InteropServices.UCOMIMoniker pmkOtherMoniker);
                void IsRunning(System.Runtime.InteropServices.UCOMIBindCtx pbc, System.Runtime.InteropServices.UCOMIMoniker pmkToLeft, System.Runtime.InteropServices.UCOMIMoniker pmkNewlyRunning);
                void IsSystemMoniker(ref int pdwMksys);
                void Load(System.Runtime.InteropServices.UCOMIStream pStm);
                void ParseDisplayName(System.Runtime.InteropServices.UCOMIBindCtx pbc, System.Runtime.InteropServices.UCOMIMoniker pmkToLeft, string pszDisplayName, ref int pchEaten, ref System.Runtime.InteropServices.UCOMIMoniker ppmkOut);
                void Reduce(System.Runtime.InteropServices.UCOMIBindCtx pbc, int dwReduceHowFar, ref System.Runtime.InteropServices.UCOMIMoniker ppmkToLeft, ref System.Runtime.InteropServices.UCOMIMoniker ppmkReduced);
                void RelativePathTo(System.Runtime.InteropServices.UCOMIMoniker pmkOther, ref System.Runtime.InteropServices.UCOMIMoniker ppmkRelPath);
                void Save(System.Runtime.InteropServices.UCOMIStream pStm, bool fClearDirty);
            }

            interface UCOMIStream
            {
                void Clone(ref System.Runtime.InteropServices.UCOMIStream ppstm);
                void Commit(int grfCommitFlags);
                void CopyTo(System.Runtime.InteropServices.UCOMIStream pstm, long cb, nint pcbRead, nint pcbWritten);
                void LockRegion(long libOffset, long cb, int dwLockType);
                void Read(byte[] pv, int cb, nint pcbRead);
                void Revert();
                void Seek(long dlibMove, int dwOrigin, nint plibNewPosition);
                void SetSize(long libNewSize);
                void Stat(ref System.Runtime.InteropServices.STATSTG pstatstg, int grfStatFlag);
                void UnlockRegion(long libOffset, long cb, int dwLockType);
                void Write(byte[] pv, int cb, nint pcbWritten);
            }

            interface UCOMIConnectionPoint
            {
                void Advise(object pUnkSink, ref int pdwCookie);
                void EnumConnections(ref System.Runtime.InteropServices.UCOMIEnumConnections ppEnum);
                void GetConnectionInterface(ref System.Guid pIID);
                void GetConnectionPointContainer(ref System.Runtime.InteropServices.UCOMIConnectionPointContainer ppCPC);
                void Unadvise(int dwCookie);
            }

            interface UCOMIEnumConnections
            {
                void Clone(ref System.Runtime.InteropServices.UCOMIEnumConnections ppenum);
                int Next(int celt, System.Runtime.InteropServices.CONNECTDATA[] rgelt, ref int pceltFetched);
                void Reset();
                int Skip(int celt);
            }

            interface UCOMIConnectionPointContainer
            {
                void EnumConnectionPoints(ref System.Runtime.InteropServices.UCOMIEnumConnectionPoints ppEnum);
                void FindConnectionPoint(ref System.Guid riid, ref System.Runtime.InteropServices.UCOMIConnectionPoint ppCP);
            }

            interface UCOMIEnumConnectionPoints
            {
                void Clone(ref System.Runtime.InteropServices.UCOMIEnumConnectionPoints ppenum);
                int Next(int celt, System.Runtime.InteropServices.UCOMIConnectionPoint[] rgelt, ref int pceltFetched);
                int Reset();
                int Skip(int celt);
            }

            interface UCOMIEnumVARIANT
            {
                void Clone(int ppenum);
                int Next(int celt, int rgvar, int pceltFetched);
                int Reset();
                int Skip(int celt);
            }

            interface UCOMIPersistFile
            {
                void GetClassID(ref System.Guid pClassID);
                void GetCurFile(ref string ppszFileName);
                int IsDirty();
                void Load(string pszFileName, int dwMode);
                void Save(string pszFileName, bool fRemember);
                void SaveCompleted(string pszFileName);
            }
        }

        namespace DesignerServices
        {
            class WindowsRuntimeDesignerContext
            {
                static /*0x21f1474*/ void InitializeSharedContext(System.Collections.Generic.IEnumerable<string> paths);
                static /*0x21f14ac*/ void SetIterationContext(System.Runtime.DesignerServices.WindowsRuntimeDesignerContext context);
                /*0x21f1394*/ WindowsRuntimeDesignerContext(System.Collections.Generic.IEnumerable<string> paths, string name);
                /*0x21f13cc*/ string get_Name();
                /*0x21f1404*/ System.Reflection.Assembly GetAssembly(string assemblyName);
                /*0x21f143c*/ System.Type GetType(string typeName);
            }
        }
    }
}

namespace Unity
{
    class ThrowStub : System.ObjectDisposedException
    {
        static /*0x21f14e4*/ void ThrowNotSupportedException();
    }
}
